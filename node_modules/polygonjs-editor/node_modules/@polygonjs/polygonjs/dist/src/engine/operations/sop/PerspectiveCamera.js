"use strict";
import { BaseSopOperation } from "./_Base";
import { MathUtils, Vector3 } from "three";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { CameraNodeType } from "../../poly/NodeContext";
import { PERSPECTIVE_CAMERA_DEFAULT, registerPerspectiveCamera } from "../../../core/camera/CorePerspectiveCamera";
import { CameraAttribute, CORE_CAMERA_DEFAULT, PerspectiveCameraAttribute } from "../../../core/camera/CoreCamera";
import { isBooleanTrue } from "../../../core/Type";
import { CameraHelper } from "../../../core/helpers/CameraHelper";
import { ThreejsCoreObject } from "../../../core/geometry/modules/three/ThreejsCoreObject";
import { CoreSceneObjectsFactory, GeneratorName } from "../../../core/CoreSceneObjectsFactory";
const _PerspectiveCameraSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraNodeType.PERSPECTIVE;
  }
  cook(inputCoreGroups, params) {
    const camera = _PerspectiveCameraSopOperation.createCamera(params, this._node);
    camera.name = params.name || CameraNodeType.PERSPECTIVE;
    camera.position.copy(params.position);
    camera.rotation.set(
      MathUtils.degToRad(params.rotation.x),
      MathUtils.degToRad(params.rotation.y),
      MathUtils.degToRad(params.rotation.z)
    );
    camera.updateWorldMatrix(false, false);
    camera.updateProjectionMatrix();
    camera.matrixAutoUpdate = params.matrixAutoUpdate;
    _PerspectiveCameraSopOperation.setCameraAttributes(camera, params);
    const pbrUpdateFunc = CoreSceneObjectsFactory.generator(GeneratorName.PERSPECTIVE_CAMERA_UPDATE);
    pbrUpdateFunc({
      camera,
      params: {
        apertureBlades: params.apertureBlades,
        fStop: params.fStop,
        focusDistance: params.focusDistance,
        apertureRotation: params.apertureRotation,
        anamorphicRatio: params.anamorphicRatio
      }
    });
    const objects = [camera];
    if (isBooleanTrue(params.showHelper)) {
      const helper = new CameraHelper(camera);
      helper.update();
      camera.add(helper);
    }
    return this.createCoreGroupFromObjects(objects);
  }
  static createCamera(params, nodeGenerator) {
    const camera = CoreSceneObjectsFactory.generator(GeneratorName.PERSPECTIVE_CAMERA)({
      fov: params.fov,
      aspect: 1,
      near: params.near,
      far: params.far
    });
    if (nodeGenerator) {
      ThreejsCoreObject.addAttribute(camera, CameraAttribute.NODE_ID, nodeGenerator.graphNodeId());
    }
    return camera;
  }
  static setCameraAttributes(camera, options) {
    ThreejsCoreObject.addAttribute(camera, PerspectiveCameraAttribute.FOV, options.fov);
  }
};
export let PerspectiveCameraSopOperation = _PerspectiveCameraSopOperation;
PerspectiveCameraSopOperation.DEFAULT_PARAMS = {
  fov: PERSPECTIVE_CAMERA_DEFAULT.fov,
  near: CORE_CAMERA_DEFAULT.near,
  far: CORE_CAMERA_DEFAULT.far,
  position: new Vector3(0, 0, 0),
  rotation: new Vector3(0, 0, 0),
  showHelper: false,
  matrixAutoUpdate: true,
  name: CameraNodeType.PERSPECTIVE,
  // PBR
  apertureBlades: 6,
  fStop: 0.6,
  focusDistance: 10,
  apertureRotation: 0,
  anamorphicRatio: 1
};
PerspectiveCameraSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
PerspectiveCameraSopOperation.onRegister = registerPerspectiveCamera;
