"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { NetworkChildNodeType } from "../../poly/NodeContext";
class SubnetInputSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param sets which input of the parent subnet node is used */
    this.input = ParamConfig.INTEGER(0, {
      range: [0, 3],
      rangeLocked: [true, true],
      callback: (node) => {
        SubnetInputSopNode.PARAM_CALLBACK_reset(node);
      }
    });
  }
}
const ParamsConfig = new SubnetInputSopParamsConfig();
export class SubnetInputSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return NetworkChildNodeType.INPUT;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
    this.lifecycle.onAfterAdded(() => {
      this._setParentInputDependency();
    });
  }
  async cook() {
    const inputIndex = this.pv.input;
    const parent = this.parent();
    if (!parent) {
      this.states.error.set(`subnet input has no parent`);
      return this.cookController.endCook();
    }
    if (!parent.io.inputs.hasInput(inputIndex)) {
      this.states.error.set(`parent has no input ${inputIndex}`);
      return this.cookController.endCook();
    }
    const container = await parent.containerController.requestInputContainer(inputIndex);
    if (!container) {
      this.states.error.set(`input invalid ${inputIndex}`);
      return this.cookController.endCook();
    }
    const coreGroup = container.coreContent();
    if (!coreGroup) {
      this.states.error.set(`input invalid ${inputIndex}`);
      return this.cookController.endCook();
    }
    this.setCoreGroup(coreGroup);
  }
  static PARAM_CALLBACK_reset(node) {
    node._setParentInputDependency();
  }
  _setParentInputDependency() {
    if (this._currentParentInputGraphNode) {
      this.removeGraphInput(this._currentParentInputGraphNode);
    }
    const parent = this.parent();
    if (parent) {
      this._currentParentInputGraphNode = parent.io.inputs.inputGraphNode(this.pv.input);
      this.addGraphInput(this._currentParentInputGraphNode);
    }
  }
}
