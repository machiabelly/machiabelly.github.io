"use strict";
import { BaseSopOperation } from "./_Base";
import { Vector3, Box3 } from "three";
import { CoreTransform } from "../../../core/Transform";
import { RoundedBoxGeometry } from "three/examples/jsm/geometries/RoundedBoxGeometry";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
const tmpBox = new Box3();
const tmpSize = new Vector3();
const tmpCenter = new Vector3();
export class RoundedBoxSopOperation extends BaseSopOperation {
  constructor() {
    super(...arguments);
    this._coreTransform = new CoreTransform();
  }
  static type() {
    return "roundedBox";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const geometry = coreGroup ? this._cookWithInput(coreGroup, params) : this._cookWithoutInput(params);
    return this.createCoreGroupFromGeometry(geometry);
  }
  _cookWithoutInput(params) {
    const { sizes, size } = params;
    const geometry = new RoundedBoxGeometry(
      sizes.x * size,
      sizes.y * size,
      sizes.z * size,
      params.divisions,
      params.bevel
    );
    geometry.translate(params.center.x, params.center.y, params.center.z);
    geometry.computeVertexNormals();
    return geometry;
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const geometry = new RoundedBoxGeometry(tmpSize.x, tmpSize.y, tmpSize.z, params.divisions, params.bevel);
    const matrix = this._coreTransform.translationMatrix(tmpCenter);
    geometry.applyMatrix4(matrix);
    return geometry;
  }
}
RoundedBoxSopOperation.DEFAULT_PARAMS = {
  size: 1,
  sizes: new Vector3(1, 1, 1),
  divisions: 2,
  bevel: 0.1,
  center: new Vector3(0, 0, 0)
};
RoundedBoxSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
