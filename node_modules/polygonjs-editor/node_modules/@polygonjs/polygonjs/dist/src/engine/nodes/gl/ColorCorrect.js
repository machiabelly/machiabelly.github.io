"use strict";
import { TypedGlNode } from "./_Base";
import { GlConnectionPointType, GlConnectionPoint } from "../utils/io/connections/Gl";
import { ThreeToGl } from "../../../core/ThreeToGl";
import ColorGlslLib from "./gl/color.glsl";
export var ColorCorrectType = /* @__PURE__ */ ((ColorCorrectType2) => {
  ColorCorrectType2["LINEAR"] = "Linear";
  ColorCorrectType2["SRGB"] = "sRGB";
  return ColorCorrectType2;
})(ColorCorrectType || {});
const TYPES = ["Linear" /* LINEAR */, "sRGB" /* SRGB */];
import { ParamConfig, NodeParamsConfig } from "../utils/params/ParamsConfig";
import { FunctionGLDefinition } from "./utils/GLDefinition";
class ColorCorrectParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.color = ParamConfig.VECTOR4([1, 1, 1, 1]);
    this.from = ParamConfig.INTEGER(TYPES.indexOf("Linear" /* LINEAR */), {
      menu: {
        entries: TYPES.map((type, i) => {
          return { name: type, value: i };
        })
      }
    });
    this.to = ParamConfig.INTEGER(TYPES.indexOf("sRGB" /* SRGB */), {
      menu: {
        entries: TYPES.map((type, i) => {
          return { name: type, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new ColorCorrectParamsConfig();
const _ColorCorrectGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "colorCorrect";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["to", "from"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_ColorCorrectGlNode.OUTPUT_NAME, GlConnectionPointType.VEC4)
    ]);
  }
  colorSpaces() {
    return {
      from: TYPES[this.pv.from],
      to: TYPES[this.pv.to]
    };
  }
  setLines(shaders_collection_controller) {
    const { from, to } = this.colorSpaces();
    const out = this.glVarName(_ColorCorrectGlNode.OUTPUT_NAME);
    const arg_in = ThreeToGl.any(this.variableForInput(_ColorCorrectGlNode.INPUT_NAME));
    const body_lines = [];
    if (from != to) {
      const method_name = `${from}To${to}`;
      const args = [];
      args.push(arg_in);
      body_lines.push(`vec4 ${out} = ${method_name}(${args.join(", ")})`);
    } else {
      body_lines.push(`vec4 ${out} = ${arg_in}`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
    shaders_collection_controller.addDefinitions(this, [new FunctionGLDefinition(this, ColorGlslLib)]);
  }
};
export let ColorCorrectGlNode = _ColorCorrectGlNode;
ColorCorrectGlNode.INPUT_NAME = "color";
ColorCorrectGlNode.OUTPUT_NAME = "out";
