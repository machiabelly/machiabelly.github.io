"use strict";
import { TRIGGER_CONNECTION_NAME, TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import {
  JsConnectionPoint,
  JsConnectionPointType,
  JS_CONNECTION_POINT_IN_NODE_DEF,
  PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES
} from "../utils/io/connections/Js";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { inputObject3D } from "./_BaseObject3D";
import { WatchedValueJsDefinition } from "./utils/JsDefinition";
import { Poly } from "../../Poly";
import { nodeMethodName } from "./code/assemblers/actor/ActorAssemblerUtils";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
var OnObjectAttributeUpdateInputName = /* @__PURE__ */ ((OnObjectAttributeUpdateInputName2) => {
  OnObjectAttributeUpdateInputName2["attribName"] = "attribName";
  return OnObjectAttributeUpdateInputName2;
})(OnObjectAttributeUpdateInputName || {});
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
class OnObjectAttributeUpdateJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param type */
    this.type = ParamConfig.INTEGER(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new OnObjectAttributeUpdateJsParamsConfig();
const _OnObjectAttributeUpdateJsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.ON_OBJECT_ATTRIBUTE_UPDATE;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["type"]);
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),
      new JsConnectionPoint(
        "attribName" /* attribName */,
        JsConnectionPointType.STRING,
        CONNECTION_OPTIONS
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_output_name_function(
      (index) => [
        TRIGGER_CONNECTION_NAME,
        _OnObjectAttributeUpdateJsNode.OUTPUT_NEW_VAL,
        _OnObjectAttributeUpdateJsNode.OUTPUT_PREV_VAL
      ][index]
    );
    this.io.connection_points.set_expected_output_types_function(() => [
      JsConnectionPointType.TRIGGER,
      ...this._currentConnectionType()
    ]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} actor node type not valid`);
    }
    const connectionType = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];
    if (connectionType == null) {
      console.warn(`${this.type()} actor node type not valid`);
    }
    return [connectionType, connectionType];
  }
  setAttribType(type) {
    this.p.type.set(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(type));
  }
  attribType() {
    return PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];
  }
  setAttribName(attribName) {
    this.params.get("attribName" /* attribName */).set(attribName);
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(linesController) {
    const type = this.attribType();
    const object3D = inputObject3D(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const usedOutputNames = this.io.outputs.used_output_names();
    const _val = (propertyName, functionName, type2) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, linesController);
      const varName = this.jsVarName(propertyName);
      const variable = createVariable(type2);
      if (variable) {
        linesController.addVariable(this, variable);
      }
      linesController.addBodyOrComputed(this, [
        {
          dataType: type2,
          varName,
          value: func.asString(object3D, attribName, `'${type2}'`)
        }
      ]);
    };
    _val(_OnObjectAttributeUpdateJsNode.OUTPUT_NEW_VAL, "getObjectAttributeAutoDefault", type);
    _val(_OnObjectAttributeUpdateJsNode.OUTPUT_PREV_VAL, "getObjectAttributePrevious", type);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const type = this.attribType();
    const object3D = inputObject3D(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const getObjectAttributeRef = Poly.namedFunctionsRegister.getFunction(
      "getObjectAttributeRef",
      this,
      linesController
    );
    linesController.addDefinitions(this, [
      new WatchedValueJsDefinition(
        this,
        linesController,
        type,
        getObjectAttributeRef.asString(object3D, attribName, `'${type}'`),
        `this.${nodeMethodName(this)}()`,
        {
          deep: true
        }
      )
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: false
    });
  }
};
export let OnObjectAttributeUpdateJsNode = _OnObjectAttributeUpdateJsNode;
OnObjectAttributeUpdateJsNode.OUTPUT_NEW_VAL = "newValue";
OnObjectAttributeUpdateJsNode.OUTPUT_PREV_VAL = "previousValue";
