"use strict";
import { TypedAnimNode } from "./_Base";
import { AnimCopyStamp } from "./utils/CopyStamp";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TimelineBuilder } from "../../../core/animation/TimelineBuilder";
import { AnimType } from "../../poly/registers/nodes/types/Anim";
class CopyAnimParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.count = ParamConfig.INTEGER(1, {
      range: [1, 20],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new CopyAnimParamsConfig();
export class CopyAnimNode extends TypedAnimNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return AnimType.COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  async cook(input_contents) {
    const builder = new TimelineBuilder();
    for (let i = 0; i < this.pv.count; i++) {
      this.stampNode().setGlobalIndex(i);
      const container = await this.containerController.requestInputContainer(0);
      if (container) {
        const stamped_builder = container.coreContentCloned();
        if (stamped_builder) {
          builder.addTimelineBuilder(stamped_builder);
        }
      }
    }
    this.setTimelineBuilder(builder);
  }
  //
  //
  // STAMP
  //
  //
  stampValue(attrib_name) {
    return this.stampNode().value(attrib_name);
  }
  stampNode() {
    return this._stampNode = this._stampNode || this._createStampNode();
  }
  _createStampNode() {
    const stampNode = new AnimCopyStamp(this.scene());
    stampNode.setForbiddenTriggerNodes(this);
    return stampNode;
  }
}
