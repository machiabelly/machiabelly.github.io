"use strict";
import { GODRAYS_RESOLUTION_SCALE } from "./GodRaysConstant";
import {
  Vector3,
  BasicDepthPacking,
  PointLight,
  Plane,
  DirectionalLight,
  Frustum,
  Matrix4
} from "three";
import { Pass } from "postprocessing";
import { GodraysMaterial } from "./GodRaysMaterial";
export class GodraysIllumPass extends Pass {
  constructor(props, params) {
    super("GodraysPass");
    this.params = params;
    this.shadowMapSet = false;
    this.lightWorldPos = new Vector3();
    this.props = props;
    this.lastParams = params;
    this.material = new GodraysMaterial(this.props);
    this.updateUniforms(this.props, this.params);
    this.fullscreenMaterial = this.material;
  }
  setSize(width, height) {
    this.material.uniforms.resolution.value.set(
      Math.ceil(width * GODRAYS_RESOLUTION_SCALE),
      Math.ceil(height * GODRAYS_RESOLUTION_SCALE)
    );
  }
  render(renderer, _inputBuffer, outputBuffer, _deltaTime, _stencilTest) {
    var _a;
    if (!this.shadowMapSet && ((_a = this.props.light.shadow.map) == null ? void 0 : _a.texture)) {
      this.updateUniforms(this.props, this.lastParams);
      this.shadowMapSet = true;
    }
    this._updateLightPosition(this.props);
    renderer.setRenderTarget(outputBuffer);
    renderer.render(this.scene, this.camera);
  }
  setDepthTexture(depthTexture, depthPacking) {
    this.material.uniforms.sceneDepth.value = depthTexture;
    if (depthPacking && depthPacking !== BasicDepthPacking) {
      throw new Error("Only BasicDepthPacking is supported");
    }
  }
  _updateLightPosition({ light, camera }) {
    light.getWorldPosition(this.lightWorldPos);
  }
  updateUniforms({ light, camera }, params) {
    var _a, _b, _c, _d, _e, _f;
    const shadow = light.shadow;
    if (!shadow) {
      throw new Error("Light used for godrays must have shadow");
    }
    const shadowMap = (_b = (_a = shadow.map) == null ? void 0 : _a.texture) != null ? _b : null;
    const mapSize = (_d = (_c = shadow.map) == null ? void 0 : _c.height) != null ? _d : 1;
    const uniforms = this.material.uniforms;
    uniforms.density.value = params.density;
    uniforms.maxDensity.value = params.maxDensity;
    uniforms.lightPos.value = this.lightWorldPos;
    uniforms.cameraPos.value = camera.position;
    uniforms.lightCameraProjectionMatrix.value = light.shadow.camera.projectionMatrix;
    uniforms.lightCameraMatrixWorldInverse.value = light.shadow.camera.matrixWorldInverse;
    uniforms.cameraProjectionMatrixInv.value = camera.projectionMatrixInverse;
    uniforms.cameraMatrixWorld.value = camera.matrixWorld;
    uniforms.shadowMap.value = shadowMap;
    uniforms.mapSize.value = mapSize;
    uniforms.lightCameraNear.value = (_e = shadow == null ? void 0 : shadow.camera.near) != null ? _e : 0.1;
    uniforms.lightCameraFar.value = (_f = shadow == null ? void 0 : shadow.camera.far) != null ? _f : 1e3;
    uniforms.density.value = params.density;
    uniforms.maxDensity.value = params.maxDensity;
    uniforms.distanceAttenuation.value = params.distanceAttenuation;
    if (light instanceof PointLight || light.isPointLight) {
      const planes = [];
      const directions = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1)
      ];
      for (const direction of directions) {
        planes.push(
          new Plane().setFromNormalAndCoplanarPoint(
            direction,
            light.position.clone().add(direction.clone().multiplyScalar(uniforms.lightCameraFar.value))
          )
        );
      }
      uniforms.fNormals.value = planes.map((x) => x.normal.clone());
      uniforms.fConstants.value = planes.map((x) => x.constant);
    } else if (light instanceof DirectionalLight || light.isDirectionalLight) {
      const frustum = new Frustum();
      frustum.setFromProjectionMatrix(
        new Matrix4().multiplyMatrices(
          light.shadow.camera.projectionMatrix,
          light.shadow.camera.matrixWorldInverse
        )
      );
      uniforms.fNormals.value = frustum.planes.map((x) => x.normal.clone().multiplyScalar(-1));
      uniforms.fConstants.value = frustum.planes.map((x) => x.constant * -1);
    }
  }
}
