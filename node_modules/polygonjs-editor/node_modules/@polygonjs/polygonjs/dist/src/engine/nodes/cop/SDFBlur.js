"use strict";
import { CopType } from "./../../poly/registers/nodes/types/Cop";
import { Vector3 } from "three";
import { TypedCopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { addSDFMetadataToContainer, readSDFMetadataFromContainer } from "../../../core/loader/geometry/SDF";
class SDFBlurCopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param resolution */
    this.resolution = ParamConfig.VECTOR3([-1, -1, -1], {
      cook: false,
      editable: false,
      separatorBefore: true
    });
    /** @param boundMin */
    this.boundMin = ParamConfig.VECTOR3([-1, -1, -1], {
      cook: false,
      editable: false
    });
    /** @param boundMax */
    this.boundMax = ParamConfig.VECTOR3([1, 1, 1], {
      cook: false,
      editable: false
    });
  }
}
const ParamsConfig = new SDFBlurCopParamsConfig();
export class SDFBlurCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return CopType.SDF_BLUR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  async cook(inputContents) {
    var _a;
    const texture = inputContents[0];
    const textureData = (_a = texture.source) == null ? void 0 : _a.data;
    if (!textureData) {
      this.states.error.set("the input must be a 3D texture");
      return;
    }
    const dataContainer = readSDFMetadataFromContainer(texture);
    if (!dataContainer) {
      this.states.error.set("the input must contain a dataContainer");
      return;
    }
    const boundMin = new Vector3(dataContainer.boundMinx, dataContainer.boundMiny, dataContainer.boundMinz);
    const boundMax = new Vector3(dataContainer.boundMaxx, dataContainer.boundMaxy, dataContainer.boundMaxz);
    const resolution = new Vector3(dataContainer.resolutionx, dataContainer.resolutiony, dataContainer.resolutionz);
    const resx = resolution.x;
    const resy = resolution.y;
    const resz = resolution.z;
    const d = textureData.data;
    let i = 0;
    const zMap = /* @__PURE__ */ new Map();
    for (let z = 0; z < resz; z++) {
      const yMap2 = /* @__PURE__ */ new Map();
      zMap.set(z, yMap2);
      for (let y = 0; y < resy; y++) {
        const xMap2 = /* @__PURE__ */ new Map();
        yMap2.set(y, xMap2);
        for (let x = 0; x < resx; x++) {
          xMap2.set(x, d[i]);
          i++;
        }
      }
    }
    let yMap = /* @__PURE__ */ new Map();
    let yMap_xp = /* @__PURE__ */ new Map();
    let yMap_xm = /* @__PURE__ */ new Map();
    let xMap = /* @__PURE__ */ new Map();
    let xMap_yp = /* @__PURE__ */ new Map();
    let xMap_ym = /* @__PURE__ */ new Map();
    let xMap_zp = /* @__PURE__ */ new Map();
    let xMap_zp_yp = /* @__PURE__ */ new Map();
    let xMap_zp_ym = /* @__PURE__ */ new Map();
    let xMap_zm = /* @__PURE__ */ new Map();
    let xMap_zm_yp = /* @__PURE__ */ new Map();
    let xMap_zm_ym = /* @__PURE__ */ new Map();
    i = 0;
    for (let z = 0; z < resz; z++) {
      const zInRange = z > 0 && z < resz - 1;
      if (zInRange) {
        yMap = zMap.get(z);
        yMap_xp = zMap.get(z + 1);
        yMap_xm = zMap.get(z - 1);
      }
      for (let y = 0; y < resy; y++) {
        const yInRange = zInRange && y > 0 && y < resy - 1;
        if (yInRange) {
          xMap = yMap.get(y);
          xMap_yp = yMap.get(y + 1);
          xMap_ym = yMap.get(y - 1);
          xMap_zp = yMap_xp.get(y);
          xMap_zp_yp = yMap_xp.get(y + 1);
          xMap_zp_ym = yMap_xp.get(y - 1);
          xMap_zm = yMap_xm.get(y);
          xMap_zm_yp = yMap_xm.get(y + 1);
          xMap_zm_ym = yMap_xm.get(y - 1);
        }
        for (let x = 0; x < resx; x++) {
          const xInRange = yInRange && x > 0 && x < resx - 1;
          if (xInRange) {
            const v = xMap.get(x) + xMap.get(x - 1) + xMap.get(x + 1);
            const v_yp = xMap_yp.get(x) + xMap_yp.get(x - 1) + xMap_yp.get(x + 1);
            const v_ym = xMap_ym.get(x) + xMap_ym.get(x - 1) + xMap_ym.get(x + 1);
            const v_xp1 = xMap_zp.get(x) + xMap_zp.get(x - 1) + xMap_zp.get(x + 1);
            const v_xp_yp = xMap_zp_yp.get(x) + xMap_zp_yp.get(x - 1) + xMap_zp_yp.get(x + 1);
            const v_xp_ym = xMap_zp_ym.get(x) + xMap_zp_ym.get(x - 1) + xMap_zp_ym.get(x + 1);
            const v_xm = xMap_zm.get(x) + xMap_zm.get(x - 1) + xMap_zm.get(x + 1);
            const v_xm_yp = xMap_zm_yp.get(x) + xMap_zm_yp.get(x - 1) + xMap_zm_yp.get(x + 1);
            const v_xm_ym = xMap_zm_ym.get(x) + xMap_zm_ym.get(x - 1) + xMap_zm_ym.get(x + 1);
            const total = v + v_yp + v_ym + v_xp1 + v_xp_yp + v_xp_ym + v_xm + v_xm_yp + v_xm_ym;
            d[i] = total / 27;
          }
          i++;
        }
      }
    }
    addSDFMetadataToContainer(texture, {
      boundMin,
      boundMax,
      resolution
    });
    this.p.boundMin.set(boundMin);
    this.p.boundMax.set(boundMax);
    this.p.resolution.set(resolution);
    this.setTexture(texture);
  }
}
