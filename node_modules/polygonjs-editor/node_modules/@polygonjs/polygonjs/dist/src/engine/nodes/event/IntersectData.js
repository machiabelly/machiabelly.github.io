"use strict";
import { TypedEventNode } from "./_Base";
import { AttribType, ATTRIBUTE_TYPES, AttribTypeMenuEntries } from "../../../core/geometry/Constant";
import { EventConnectionPoint, EventConnectionPointType } from "../utils/io/connections/Event";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CoreType } from "../../../core/Type";
import { TypeAssert } from "../../poly/Assert";
import { resolveIntersectGeometryAttribute } from "../../../core/geometry/intersect/CoreIntersect";
import { coreObjectClassFactory } from "../../../core/geometry/CoreObjectFactory";
export var TargetType = /* @__PURE__ */ ((TargetType2) => {
  TargetType2["SCENE_GRAPH"] = "scene graph";
  TargetType2["NODE"] = "node";
  return TargetType2;
})(TargetType || {});
export const TARGET_TYPES = ["scene graph" /* SCENE_GRAPH */, "node" /* NODE */];
class IntersectDataParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param geometry vertex attribute to read */
    this.attributeName = ParamConfig.STRING("id", {
      cook: false
    });
    /** @param type of attribute */
    this.attributeType = ParamConfig.INTEGER(ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), {
      menu: {
        entries: AttribTypeMenuEntries
      }
    });
    /** @param attribute value for float */
    this.attributeValue1 = ParamConfig.FLOAT(0, {
      cook: false,
      visibleIf: {
        attributeType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC)
      }
    });
    /** @param attribute value that attributeValue1 is set to when no object is intersected */
    this.resetValue1 = ParamConfig.FLOAT(-1, {
      cook: false,
      visibleIf: {
        attributeType: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC)
      }
    });
    /** @param attribute value for string */
    this.attributeValues = ParamConfig.STRING("", {
      visibleIf: {
        attributeType: ATTRIBUTE_TYPES.indexOf(AttribType.STRING)
      }
    });
    /** @param attribute value that attributeValues is set to when no object is intersected */
    this.resetValues = ParamConfig.STRING("", {
      visibleIf: {
        attributeType: ATTRIBUTE_TYPES.indexOf(AttribType.STRING)
      }
    });
  }
}
const ParamsConfig = new IntersectDataParamsConfig();
const _IntersectDataEventNode = class extends TypedEventNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "intersectData";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new EventConnectionPoint(
        _IntersectDataEventNode.INPUT_HIT,
        EventConnectionPointType.BASE,
        this._processHit.bind(this)
      ),
      new EventConnectionPoint(
        _IntersectDataEventNode.INPUT_MISS,
        EventConnectionPointType.BASE,
        this._processMiss.bind(this)
      )
    ]);
  }
  _processHit(context) {
    var _a;
    const intersect = (_a = context.value) == null ? void 0 : _a.intersect;
    if (!intersect) {
      return;
    }
    this._resolveIntersectAttribute(intersect);
  }
  _processMiss(context) {
    const attribType = ATTRIBUTE_TYPES[this.pv.attributeType];
    switch (attribType) {
      case AttribType.NUMERIC: {
        this.p.attributeValue1.set(this.pv.resetValue1);
        return;
      }
      case AttribType.STRING: {
        this.p.attributeValues.set(this.pv.resetValues);
        return;
      }
    }
    TypeAssert.unreachable(attribType);
  }
  _resolveIntersectAttribute(intersection) {
    const attribType = ATTRIBUTE_TYPES[this.pv.attributeType];
    let attribValue = _IntersectDataEventNode.resolveObjectAttribute(
      intersection,
      this.pv.attributeName
    );
    if (attribValue == null) {
      attribValue = resolveIntersectGeometryAttribute(intersection, this.pv.attributeName, attribType);
    }
    if (attribValue != null) {
      switch (attribType) {
        case AttribType.NUMERIC: {
          this.p.attributeValue1.set(attribValue);
          return;
        }
        case AttribType.STRING: {
          if (CoreType.isString(attribValue)) {
            this.p.attributeValues.set(attribValue);
          }
          return;
        }
      }
      TypeAssert.unreachable(attribType);
    }
  }
  static resolveObjectAttribute(intersection, attribName) {
    const value = coreObjectClassFactory(intersection.object).attribValue(intersection.object, attribName);
    if (value == null) {
      return;
    }
    if (CoreType.isNumber(value) || CoreType.isString(value)) {
      return value;
    }
    if (CoreType.isArray(value)) {
      return value[0];
    }
    if (CoreType.isVector(value)) {
      return value.x;
    }
  }
};
export let IntersectDataEventNode = _IntersectDataEventNode;
IntersectDataEventNode.INPUT_HIT = "hit";
IntersectDataEventNode.INPUT_MISS = "miss";
