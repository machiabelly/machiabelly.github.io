"use strict";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CoreType, isBooleanTrue } from "../../../core/Type";
import { GlConnectionPointType, GL_CONNECTION_POINT_TYPES_FOR_CONSTANT } from "../utils/io/connections/Gl";
import { GlType } from "../../poly/registers/nodes/types/Gl";
function typedVisibleOptions(type, otherParamVal = {}) {
  const val = GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf(type);
  return { visibleIf: { type: val, ...otherParamVal } };
}
class ConstantGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.type = ParamConfig.INTEGER(GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf(GlConnectionPointType.FLOAT), {
      menu: {
        entries: GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    this.bool = ParamConfig.BOOLEAN(0, typedVisibleOptions(GlConnectionPointType.BOOL));
    this.int = ParamConfig.INTEGER(0, typedVisibleOptions(GlConnectionPointType.INT));
    this.float = ParamConfig.FLOAT(0, typedVisibleOptions(GlConnectionPointType.FLOAT));
    this.vec2 = ParamConfig.VECTOR2([0, 0], typedVisibleOptions(GlConnectionPointType.VEC2));
    this.vec3 = ParamConfig.VECTOR3([0, 0, 0], typedVisibleOptions(GlConnectionPointType.VEC3, { asColor: false }));
    this.color = ParamConfig.COLOR([0, 0, 0], typedVisibleOptions(GlConnectionPointType.VEC3, { asColor: true }));
    this.vec4 = ParamConfig.VECTOR4([0, 0, 0, 0], typedVisibleOptions(GlConnectionPointType.VEC4));
    /** @param when using vec3, use toggle on it should be a color */
    this.asColor = ParamConfig.BOOLEAN(0, typedVisibleOptions(GlConnectionPointType.VEC3));
  }
}
const ParamsConfig = new ConstantGlParamsConfig();
const _ConstantGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return GlType.CONSTANT;
  }
  initializeNode() {
    this.io.connection_points.set_output_name_function((index) => _ConstantGlNode.OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [this._currentConnectionType()]);
  }
  setLines(shaders_collection_controller) {
    const param = this.currentParam();
    if (!param) {
      console.warn(`no param found for constant node for type '${this.pv.type}'`);
      return;
    }
    const value = this.currentValue();
    if (value == null) {
      console.warn(`no value found for constant node for type '${this.pv.type}'`);
      return;
    }
    const connection_type = this._currentConnectionType();
    const var_value = this._currentVarName();
    const body_line = `${connection_type} ${var_value} = ${value}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn("constant gl node type is null", this.path());
    }
    const connectionType = GL_CONNECTION_POINT_TYPES_FOR_CONSTANT[this.pv.type] || GlConnectionPointType.FLOAT;
    if (connectionType == null) {
      console.warn(`constant gl node type if not valid (${this.pv.type})`, this.path());
    }
    return connectionType;
  }
  currentParam() {
    const type = GL_CONNECTION_POINT_TYPES_FOR_CONSTANT[this.pv.type];
    switch (type) {
      case GlConnectionPointType.BOOL: {
        return this.p.bool;
      }
      case GlConnectionPointType.INT: {
        return this.p.int;
      }
      case GlConnectionPointType.FLOAT: {
        return this.p.float;
      }
      case GlConnectionPointType.VEC2: {
        return this.p.vec2;
      }
      case GlConnectionPointType.VEC3: {
        if (isBooleanTrue(this.pv.asColor)) {
          return this.p.color;
        } else {
          return this.p.vec3;
        }
      }
      case GlConnectionPointType.VEC4: {
        return this.p.vec4;
      }
    }
    return this.p.bool;
  }
  _currentVarName() {
    return this.glVarName(_ConstantGlNode.OUTPUT_NAME);
  }
  currentValue() {
    const param = this.currentParam();
    if (param) {
      let value = ThreeToGl.any(param.value);
      if (param.name() == this.p.int.name() && CoreType.isNumber(param.value)) {
        value = ThreeToGl.integer(param.value);
      }
      return value;
    }
  }
  setGlType(type) {
    this.p.type.set(GL_CONNECTION_POINT_TYPES_FOR_CONSTANT.indexOf(type));
  }
};
export let ConstantGlNode = _ConstantGlNode;
ConstantGlNode.OUTPUT_NAME = "val";
