"use strict";
import { TypedJsNode } from "./_Base";
import { ParamConfig, NodeParamsConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType, JsConnectionPointTypeFromArrayTypeMap } from "../utils/io/connections/Js";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
import { componentsForType } from "../../functions/_VectorUtils";
const ALLOWED_TYPES = [
  JsConnectionPointType.BOOLEAN,
  JsConnectionPointType.INT,
  JsConnectionPointType.COLOR,
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.STRING,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
export var JsCompareTestName = /* @__PURE__ */ ((JsCompareTestName2) => {
  JsCompareTestName2["EQUAL"] = "Equal";
  JsCompareTestName2["LESS_THAN"] = "Less Than";
  JsCompareTestName2["GREATER_THAN"] = "Greater Than";
  JsCompareTestName2["LESS_THAN_OR_EQUAL"] = "Less Than Or Equal";
  JsCompareTestName2["GREATER_THAN_OR_EQUAL"] = "Greater Than Or Equal";
  JsCompareTestName2["NOT_EQUAL"] = "Not Equal";
  return JsCompareTestName2;
})(JsCompareTestName || {});
var JsCompareTestOperation = /* @__PURE__ */ ((JsCompareTestOperation2) => {
  JsCompareTestOperation2["EQUAL"] = "==";
  JsCompareTestOperation2["LESS_THAN"] = "<";
  JsCompareTestOperation2["GREATER_THAN"] = ">";
  JsCompareTestOperation2["LESS_THAN_OR_EQUAL"] = "<=";
  JsCompareTestOperation2["GREATER_THAN_OR_EQUAL"] = ">=";
  JsCompareTestOperation2["NOT_EQUAL"] = "!=";
  return JsCompareTestOperation2;
})(JsCompareTestOperation || {});
const TEST_NAMES = [
  "Equal" /* EQUAL */,
  "Less Than" /* LESS_THAN */,
  "Greater Than" /* GREATER_THAN */,
  "Less Than Or Equal" /* LESS_THAN_OR_EQUAL */,
  "Greater Than Or Equal" /* GREATER_THAN_OR_EQUAL */,
  "Not Equal" /* NOT_EQUAL */
];
const TEST_OPERATIONS_FLOAT = [
  "==" /* EQUAL */,
  "<" /* LESS_THAN */,
  ">" /* GREATER_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "!=" /* NOT_EQUAL */
];
function singleElementComparison(value0, value1, operation) {
  return `${value0} ${operation} ${value1}`;
}
const OUTPUT_NAME = "val";
var CompareInputName = /* @__PURE__ */ ((CompareInputName2) => {
  CompareInputName2["VALUE0"] = "value0";
  CompareInputName2["VALUE1"] = "value1";
  return CompareInputName2;
})(CompareInputName || {});
class CompareJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.test = ParamConfig.INTEGER(1, {
      menu: {
        entries: TEST_NAMES.map((name, i) => {
          const operator = TEST_OPERATIONS_FLOAT[i];
          const label = `${operator.padEnd(2, " ")} (${name})`;
          return { name: label, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new CompareJsParamsConfig();
export class CompareJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "compare";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["test"]);
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  setTestName(test) {
    this.p.test.set(TEST_NAMES.indexOf(test));
  }
  testName() {
    return TEST_NAMES[this.pv.test];
  }
  operator() {
    return TEST_OPERATIONS_FLOAT[this.pv.test];
  }
  _expectedInputName(index) {
    return ["value0" /* VALUE0 */, "value1" /* VALUE1 */][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || JsConnectionPointType.FLOAT;
    const boundType = JsConnectionPointTypeFromArrayTypeMap[type];
    return [type, boundType];
  }
  _expectedOutputTypes() {
    return [JsConnectionPointType.BOOLEAN];
  }
  _expectedOutputName(index) {
    return OUTPUT_NAME;
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = createVariable(inputType);
    if (variable) {
      shadersCollectionController.addVariable(this, variable);
    }
    const operation = this.operator();
    const value0 = this.variableForInput(shadersCollectionController, "value0" /* VALUE0 */);
    const value1 = this.variableForInput(shadersCollectionController, "value1" /* VALUE1 */);
    const components = componentsForType(inputType);
    const mainFunction = components != null && components.length > 0 ? components.map((c) => singleElementComparison(`${value0}.${c}`, `${value1}.${c}`, operation)).join(" && ") : singleElementComparison(value0, value1, operation);
    shadersCollectionController.addBodyOrComputed(this, [{ dataType: inputType, varName, value: mainFunction }]);
  }
}
