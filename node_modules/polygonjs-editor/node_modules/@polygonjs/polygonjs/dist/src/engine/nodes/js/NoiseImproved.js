"use strict";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { ParamlessTypedJsNode } from "./_Base";
import { Poly } from "../../Poly";
var NoiseImprovedJsNodeInputName = /* @__PURE__ */ ((NoiseImprovedJsNodeInputName2) => {
  NoiseImprovedJsNodeInputName2["POSITION"] = "position";
  NoiseImprovedJsNodeInputName2["AMP"] = "amp";
  NoiseImprovedJsNodeInputName2["FREQ"] = "freq";
  NoiseImprovedJsNodeInputName2["OFFSET"] = "offset";
  NoiseImprovedJsNodeInputName2["OCTAVES"] = "octaves";
  NoiseImprovedJsNodeInputName2["AMP_MULT"] = "ampMult";
  NoiseImprovedJsNodeInputName2["FREQ_MULT"] = "freqMult";
  return NoiseImprovedJsNodeInputName2;
})(NoiseImprovedJsNodeInputName || {});
const DefaultValues = {
  ["position" /* POSITION */]: 0,
  ["amp" /* AMP */]: 1,
  ["freq" /* FREQ */]: 1,
  ["offset" /* OFFSET */]: 0,
  ["octaves" /* OCTAVES */]: 3,
  ["ampMult" /* AMP_MULT */]: 0.5,
  ["freqMult" /* FREQ_MULT */]: 2
};
const OUTPUT_NAME = "noise";
const ALLOWED_INPUT_TYPES = [JsConnectionPointType.VECTOR3];
function functionNameByType(type) {
  switch (type) {
    case JsConnectionPointType.VECTOR3: {
      return "noiseImprovedVector3";
    }
  }
}
export class NoiseImprovedJsNode extends ParamlessTypedJsNode {
  static type() {
    return "noiseImproved";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _firstType() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : JsConnectionPointType.VECTOR3;
    return type;
  }
  _expectedInputTypes() {
    const type = this._firstType();
    return [
      type,
      JsConnectionPointType.FLOAT,
      type,
      type,
      JsConnectionPointType.INT,
      JsConnectionPointType.FLOAT,
      JsConnectionPointType.FLOAT
    ];
  }
  _expectedOutputTypes() {
    const type = JsConnectionPointType.FLOAT;
    return [type];
  }
  _expectedInputName(index) {
    return [
      "position" /* POSITION */,
      "amp" /* AMP */,
      "freq" /* FREQ */,
      "offset" /* OFFSET */,
      "octaves" /* OCTAVES */,
      "ampMult" /* AMP_MULT */,
      "freqMult" /* FREQ_MULT */
    ][index];
  }
  _expectedOutputName(index) {
    return OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  setLines(shadersCollectionController) {
    const position = this.variableForInput(shadersCollectionController, "position" /* POSITION */);
    const amp = this.variableForInput(shadersCollectionController, "amp" /* AMP */);
    const freq = this.variableForInput(shadersCollectionController, "freq" /* FREQ */);
    const offset = this.variableForInput(shadersCollectionController, "offset" /* OFFSET */);
    const octaves = this.variableForInput(shadersCollectionController, "octaves" /* OCTAVES */);
    const ampMult = this.variableForInput(shadersCollectionController, "ampMult" /* AMP_MULT */);
    const freqMult = this.variableForInput(shadersCollectionController, "freqMult" /* FREQ_MULT */);
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const functionName = functionNameByType(inputType);
    if (functionName) {
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        {
          dataType: inputType,
          varName,
          value: func.asString(position, amp, freq, offset, octaves, ampMult, freqMult)
        }
      ]);
      return;
    }
  }
}
