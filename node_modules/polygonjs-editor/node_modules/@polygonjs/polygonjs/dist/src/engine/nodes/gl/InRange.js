"use strict";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { TypedGlNode } from "./_Base";
class InRangeGlParamsConfig extends NodeParamsConfig {
  // input = ParamConfig.FLOAT(0.5);
  // min = ParamConfig.FLOAT(0);
  // max = ParamConfig.FLOAT(1);
}
const ParamsConfig = new InRangeGlParamsConfig();
const _InRangeGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "inRange";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(
      (i) => [_InRangeGlNode.INPUT, _InRangeGlNode.INPUT_MIN, _InRangeGlNode.INPUT_MAX][i]
    );
    this.io.connection_points.set_output_name_function(() => _InRangeGlNode.OUTPUT);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [GlConnectionPointType.BOOL]);
  }
  _expected_input_types() {
    const type = GlConnectionPointType.FLOAT;
    return [type, type, type];
  }
  setLines(shadersCollectionController) {
    const glOutType = GlConnectionPointType.BOOL;
    const input = ThreeToGl.float(this.variableForInput(_InRangeGlNode.INPUT));
    const inputMin = ThreeToGl.float(this.variableForInput(_InRangeGlNode.INPUT_MIN));
    const inputMax = ThreeToGl.float(this.variableForInput(_InRangeGlNode.INPUT_MAX));
    const out = this.glVarName(this.io.connection_points.output_name(0));
    const bodyLine = `${glOutType} ${out} = ${input} > ${inputMin} && ${input} < ${inputMax}`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
  }
};
export let InRangeGlNode = _InRangeGlNode;
InRangeGlNode.OUTPUT = "out";
InRangeGlNode.INPUT = "input";
InRangeGlNode.INPUT_MIN = "min";
InRangeGlNode.INPUT_MAX = "max";
