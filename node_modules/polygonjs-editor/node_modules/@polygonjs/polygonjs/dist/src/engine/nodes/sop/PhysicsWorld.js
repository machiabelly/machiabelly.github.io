"use strict";
import { Group } from "three";
import {
  initCorePhysicsWorld,
  physicsWorldNodeIdFromObject,
  PHYSICS_GRAVITY_DEFAULT
} from "./../../../core/physics/PhysicsWorld";
import { TypedActorSopNode } from "./_BaseActor";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { NodeContext } from "../../poly/NodeContext";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { createOrFindPhysicsWorld } from "../../../core/physics/PhysicsWorld";
import { updatePhysicsDebugObject } from "../../../core/physics/PhysicsDebug";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { CoreType } from "../../../core/Type";
import { Poly } from "../../Poly";
import { ThreejsCoreObject } from "../../../core/geometry/modules/three/ThreejsCoreObject";
import { PhysicsIdAttribute } from "../../../core/physics/PhysicsAttribute";
import { CorePhysics } from "../../../core/physics/CorePhysics";
import { setJointDataListForWorldObject } from "../../../core/physics/PhysicsJoint";
class PhysicsWorldSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param gravity */
    this.gravity = ParamConfig.VECTOR3(PHYSICS_GRAVITY_DEFAULT);
  }
  /** @param display debug information */
  // debug = ParamConfig.BOOLEAN(0);
  /** @param actor node */
  // node = ParamConfig.NODE_PATH('', {
  // 	visibleIf: {useThisNode: 0},
  // 	// nodeSelection: {
  // 	// 	// context: NodeContext.ACTOR,
  // 	// },
  // 	dependentOnFoundNode: false,
  // });
}
const ParamsConfig = new PhysicsWorldSopParamsConfig();
export class PhysicsWorldSopNode extends TypedActorSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.PHYSICS_WORLD;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.ALWAYS);
  }
  async cook(inputCoreGroups) {
    this.compilationController.compileIfRequired();
    await CorePhysics();
    const coreGroup = inputCoreGroups[0];
    const worldObject = new Group();
    worldObject.name = this.name();
    worldObject.matrixAutoUpdate = false;
    Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler(worldObject, this);
    ThreejsCoreObject.addAttribute(worldObject, PhysicsIdAttribute.WORLD, this.graphNodeId());
    const inputObjects = coreGroup.threejsObjects();
    for (const inputObject of inputObjects) {
      worldObject.add(inputObject);
    }
    setJointDataListForWorldObject(this.scene(), worldObject);
    const actorNode = this._findActorNode();
    this.scene().actorsManager.assignActorBuilder(worldObject, actorNode);
    this.setObject(worldObject);
  }
  updateObjectOnAdd(object) {
    const worldNodeId = ThreejsCoreObject.attribValue(object, PhysicsIdAttribute.WORLD);
    if (worldNodeId != null) {
      if (worldNodeId != this.graphNodeId()) {
        return;
      }
      const worldObject = object;
      createOrFindPhysicsWorld(this, worldObject, this.pv.gravity).then(({ world, PhysicsLib }) => {
        var _a;
        initCorePhysicsWorld(PhysicsLib, worldObject, this.scene());
        const sibblings = (_a = worldObject.parent) == null ? void 0 : _a.children.filter((sibbling) => sibbling.uuid != worldObject.uuid);
        if (!sibblings) {
          return;
        }
        const debugObject = sibblings.find(
          (sibbling) => ThreejsCoreObject.attribValue(sibbling, PhysicsIdAttribute.DEBUG_WORLD) == worldNodeId
          //this.graphNodeId()
        );
        if (debugObject) {
          updatePhysicsDebugObject(debugObject);
        }
      });
    }
  }
  _findActorNode() {
    return this;
  }
  //
  // CHILDREN
  //
  // protected override _childrenControllerContext = NodeContext.JS;
  // override createNode<S extends keyof JsNodeChildrenMap>(
  // 	node_class: S,
  // 	options?: NodeCreateOptions
  // ): JsNodeChildrenMap[S];
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K;
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K {
  // 	return super.createNode(node_class, options) as K;
  // }
  // override children() {
  // 	return super.children() as BaseJsNodeType[];
  // }
  // override nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {
  // 	return super.nodesByType(type) as JsNodeChildrenMap[K][];
  // }
  // override childrenAllowed() {
  // 	return true;
  // }
}
export function getPhysicsWorldNodeFromWorldObject(worldObject, scene) {
  const nodeId = physicsWorldNodeIdFromObject(worldObject);
  if (nodeId == null) {
    return;
  }
  const graphNode = scene.graph.nodeFromId(nodeId);
  if (!graphNode) {
    return;
  }
  const node = CoreType.isFunction(graphNode.context) ? graphNode : null;
  if (!node) {
    return;
  }
  if (node.context() != NodeContext.SOP) {
    return;
  }
  if (node.type() != SopType.PHYSICS_WORLD) {
    return;
  }
  return node;
}
