/**
 * the node to rull them all
 *
 * @remarks
 *
 * The root node is unique in the scene. it is the higest parent, just above the [obj](/docs/nodes/obj) nodes.
 *
 * It allows you to control the following scene properties:
 *
 * - the scene background (which can be nothing, a plain color, or a texture)
 * - which camera is used when exporting the scene
 * - the fog
 * - an environment map which would override every material's environment map
 * - a material which would override every other material
 * - the display of an audio icon in the viewer, which is useful when using sound in your scene, and allowing users to turn it on/off
 *
 */
import { TypedBaseManagerNode } from './_Base';
import { BaseObjNodeType } from '../obj/_Base';
import { NodeContext } from '../../poly/NodeContext';
import { ObjNodeChildrenMap } from '../../poly/registers/nodes/Obj';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
import { HierarchyObjNode } from '../obj/utils/HierarchyController';
import { Constructor, valueof } from '../../../types/GlobalTypes';
import { Scene } from 'three';
import { RootAudioController } from './utils/Scene/Audio';
import { SceneAutoUpdateController } from './utils/Scene/AutoUpdate';
import { SceneBackgroundController } from './utils/Scene/Background';
import { SceneEnvController } from './utils/Scene/Env';
import { SceneFogController } from './utils/Scene/Fog';
import { RootLoadProgressController } from './utils/Scene/LoadProgress';
import { SceneMaterialOverrideController } from './utils/Scene/MaterialOverride';
import { RootMainCameraController } from './utils/Scene/RootMainCamera';
import { NodeCreateOptions } from '../utils/hierarchy/ChildrenController';
export declare const ROOT_NODE_NAME = "RootNode";
declare const ObjectsManagerParamsConfig_base: {
    new (...args: any[]): {
        nodesMask: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
        printNodes: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BUTTON>;
    };
} & {
    new (...args: any[]): {
        displayAudioIcon: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        audioIconColor: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.COLOR>;
        audioIconStyle: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    };
} & {
    new (...args: any[]): {
        useOverrideMaterial: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        overrideMaterial: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.NODE_PATH>;
    };
} & {
    new (...args: any[]): {
        useEnvironment: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        environment: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.NODE_PATH>;
    };
} & {
    new (...args: any[]): {
        useFog: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        fogType: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        fogColor: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.COLOR>;
        fogNear: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
        fogFar: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
        fogDensity: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
    };
} & {
    new (...args: any[]): {
        mainCameraPath: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
    };
} & {
    new (...args: any[]): {
        backgroundMode: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        bgColor: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.COLOR>;
        bgTexture: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.NODE_PATH>;
        bgBlur: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
        bgIntensity: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
    };
} & {
    new (...args: any[]): {
        autoUpdate: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
    };
} & typeof NodeParamsConfig;
declare class ObjectsManagerParamsConfig extends ObjectsManagerParamsConfig_base {
}
export declare class RootManagerNode extends TypedBaseManagerNode<ObjectsManagerParamsConfig> {
    paramsConfig: ObjectsManagerParamsConfig;
    static type(): string;
    protected _object: Scene;
    private _queuedNodesById;
    readonly audioController: RootAudioController;
    readonly sceneAutoUpdateController: SceneAutoUpdateController;
    readonly sceneBackgroundController: SceneBackgroundController;
    readonly sceneEnvController: SceneEnvController;
    readonly sceneFogController: SceneFogController;
    readonly loadProgress: RootLoadProgressController;
    readonly sceneMaterialOverrideController: SceneMaterialOverrideController;
    readonly mainCameraController: RootMainCameraController;
    cook(): void;
    protected _childrenControllerContext: NodeContext;
    initializeNode(): void;
    private _createScene;
    get object(): Scene;
    createNode<S extends keyof ObjNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): ObjNodeChildrenMap[S];
    createNode<K extends valueof<ObjNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
    children(): BaseObjNodeType[];
    nodesByType<K extends keyof ObjNodeChildrenMap>(type: K): ObjNodeChildrenMap[K][];
    private _updateScene;
    private _addToQueue;
    processQueue(): void;
    private _updateObject;
    getParentForNode(node: BaseObjNodeType): Scene | import("three").Group<import("three").Object3DEventMap> | null;
    private _addToScene;
    private _removeFromScene;
    areChildrenCooking(): boolean;
    addToParentTransform(node: HierarchyObjNode): void;
    removeFromParentTransform(node: HierarchyObjNode): void;
    private _onChildAdd;
    private _onChildRemove;
}
export {};
