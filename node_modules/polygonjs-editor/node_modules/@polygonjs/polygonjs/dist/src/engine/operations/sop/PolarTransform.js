"use strict";
import { BaseSopOperation } from "./_Base";
import { Vector3, Matrix4 } from "three";
import { TypeAssert } from "../../../engine/poly/Assert";
import { TransformTargetType, TRANSFORM_TARGET_TYPES } from "../../../core/Transform";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { CorePolarTransform } from "../../../core/PolarTransform";
export class PolarTransformSopOperation extends BaseSopOperation {
  constructor() {
    super(...arguments);
    this._fullMatrix = new Matrix4();
  }
  static type() {
    return "polarTransform";
  }
  cook(inputCoreGroups, params) {
    const objects = inputCoreGroups[0].threejsObjects();
    CorePolarTransform.matrix(params, this._fullMatrix);
    this._applyTransform(objects, params, this._fullMatrix);
    return inputCoreGroups[0];
  }
  _applyTransform(objects, params, matrix) {
    const mode = TRANSFORM_TARGET_TYPES[params.applyOn];
    switch (mode) {
      case TransformTargetType.GEOMETRY: {
        return this._applyMatrixToGeometries(objects, matrix);
      }
      case TransformTargetType.OBJECT: {
        return this._applyMatrixToObjects(objects, matrix);
      }
    }
    TypeAssert.unreachable(mode);
  }
  _applyMatrixToGeometries(objects, matrix) {
    for (let object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        geometry.applyMatrix4(matrix);
      }
    }
  }
  _applyMatrixToObjects(objects, matrix) {
    for (let object of objects) {
      CorePolarTransform.applyMatrixToObject(object, matrix);
    }
  }
}
PolarTransformSopOperation.DEFAULT_PARAMS = {
  applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT),
  center: new Vector3(0, 0, 0),
  longitude: 0,
  latitude: 0,
  depth: 1
};
PolarTransformSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
