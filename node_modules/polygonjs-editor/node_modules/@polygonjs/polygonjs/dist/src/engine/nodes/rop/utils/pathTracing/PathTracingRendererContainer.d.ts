import { Material, Object3D, Vector2, WebGLCapabilities, WebGLMultipleRenderTargets, WebGLRenderer, WebGLRenderTarget, Object3DEventMap } from 'three';
import { Scene, Camera, MeshBasicMaterial } from 'three';
import { FullScreenQuad } from 'three/examples/jsm/postprocessing/Pass';
import { AbstractRenderer } from '../../../../viewers/Common';
import { PathTracingRenderer, PhysicalCamera, DenoiseMaterial } from '../../../../../core/render/PBR/three-gpu-pathtracer';
import type { PathTracingRendererRopNode } from '../../PathTracingRenderer';
interface UpdateOptions {
    resolutionScale: number;
    displayDebug: boolean;
    bounces: number;
    transmissiveBounces: number;
    stableNoise: boolean;
    filterGlossyFactor: number;
    backgroundBlur: number;
    environmentIntensity: number;
    tiles: Vector2;
    multipleImportanceSampling: boolean;
    denoise: boolean;
    denoiseSigma: number;
    denoiseThreshold: number;
    denoiseKSigma: number;
    maxSamplesCount: number;
    samplesPerAnimationFrame: number;
    f: Vector2;
    useWorker: boolean;
}
interface PathtracingRendererContainerOptions {
    node: PathTracingRendererRopNode;
    webGLRenderer: WebGLRenderer;
    pathTracingRenderer: PathTracingRenderer;
    fsQuad: FullScreenQuad;
    fsQuadMat: MeshBasicMaterial;
    denoiseQuad: FullScreenQuad;
    denoiseMat: DenoiseMaterial;
}
export declare class PathTracingRendererContainer implements AbstractRenderer {
    displayDebug: boolean;
    backgroundBlur: number;
    maxSamplesCount: number;
    samplesPerAnimationFrame: number;
    frameRange: Vector2;
    resolutionScale: number;
    private _useWorker;
    domElement: HTMLCanvasElement;
    private _generated;
    private _generating;
    readonly isPathTracingRendererContainer = true;
    private _denoiseActive;
    readonly node: PathTracingRendererRopNode;
    readonly webGLRenderer: WebGLRenderer;
    readonly pathTracingRenderer: PathTracingRenderer;
    readonly fsQuad: FullScreenQuad;
    readonly fsQuadMat: MeshBasicMaterial;
    readonly denoiseQuad: FullScreenQuad;
    readonly denoiseMat: DenoiseMaterial;
    constructor(options: PathtracingRendererContainerOptions);
    private _multipleImportanceSampling;
    update(options: UpdateOptions): void;
    render(scene: Scene, camera: PhysicalCamera): void;
    pbrRenderAllowed(): boolean;
    markAsNotGenerated(): void;
    renderRealtime(scene: Scene, camera: PhysicalCamera): void;
    private _preRender;
    private _postRender;
    samplesCount(): number;
    getPixelRatio(): number;
    compile(scene: Object3D<Object3DEventMap>, camera: Camera, targetScene: Scene | null | undefined): Set<Material>;
    dispose(): void;
    setSize(w: number, h: number, setStyle: boolean): void;
    setRenderTarget(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets | null, activeCubeFace?: number | undefined, activeMipmapLevel?: number | undefined): void;
    readRenderTargetPixels(renderTarget: WebGLRenderTarget | WebGLMultipleRenderTargets, x: number, y: number, width: number, height: number, buffer: Float32Array, activeCubeFaceIndex?: number | undefined): void;
    get capabilities(): WebGLCapabilities;
    private _generator;
    private _workerGenerator;
    private _generateRequired;
    generate(scene: Scene): Promise<void>;
    reset(): void;
    private _previousCameraProjectionMatrix;
    private _previousCameraWorldMatrix;
    private _resetIfCameraUpdated;
}
export {};
