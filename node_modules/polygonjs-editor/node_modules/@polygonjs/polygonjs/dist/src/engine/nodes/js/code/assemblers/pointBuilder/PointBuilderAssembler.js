"use strict";
import { Vector3 } from "three";
import { JsAssemblerBasePointBuilder } from "./_BasePointBuilderAssembler";
import { JsShaderConfig } from "../../configs/ShaderConfig";
import { VariableConfig } from "../../configs/VariableConfig";
import { JsConnectionPointType, JsConnectionPoint } from "../../../../utils/io/connections/Js";
import { PointBuilderAssemblerConstant, PointVariable } from "./PointBuilderAssemblerCommon";
import { JsFunctionName } from "../../../../utils/shaders/ShaderName";
import { AttributeJsNodeInput } from "../../../Attribute";
export class JsAssemblerPointBuilder extends JsAssemblerBasePointBuilder {
  _evaluatorName() {
    return "CustomPointBuilderEvaluator";
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(PointVariable.POSITION, JsConnectionPointType.VECTOR3),
      new JsConnectionPoint(PointVariable.NORMAL, JsConnectionPointType.VECTOR3)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(PointVariable.POSITION, JsConnectionPointType.VECTOR3),
      new JsConnectionPoint(PointVariable.NORMAL, JsConnectionPointType.VECTOR3),
      new JsConnectionPoint(PointVariable.PTNUM, JsConnectionPointType.INT),
      new JsConnectionPoint(PointVariable.OBJNUM, JsConnectionPointType.INT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new JsShaderConfig(
        JsFunctionName.MAIN,
        [
          PointVariable.POSITION,
          PointVariable.NORMAL,
          // attribute
          AttributeJsNodeInput.EXPORT
        ],
        []
      )
    ];
  }
  create_variable_configs() {
    return [
      new VariableConfig(PointVariable.POSITION, {
        prefix: "return "
      }),
      new VariableConfig(PointVariable.NORMAL, {
        prefix: "return "
      })
    ];
  }
  //
  //
  // NODE LINES
  //
  //
  setNodeLinesOutput(outputNode, linesController) {
    const inputNames = this.inputNamesForShaderName(outputNode, linesController.currentShaderName());
    const bodyLines = [];
    if (inputNames) {
      for (const inputName of inputNames) {
        const input = outputNode.io.inputs.named_input(inputName);
        if (input) {
          const varName = outputNode.variableForInput(linesController, inputName);
          switch (inputName) {
            case PointVariable.POSITION: {
              bodyLines.push(`${PointBuilderAssemblerConstant.POSITION}.copy(${varName})`);
              break;
            }
            case PointVariable.NORMAL: {
              bodyLines.push(`${PointBuilderAssemblerConstant.NORMAL}.copy(${varName})`);
              bodyLines.push(`${PointBuilderAssemblerConstant.NORMALS_UPDATED} = true`);
              break;
            }
          }
        }
      }
    }
    linesController._addBodyLines(outputNode, bodyLines);
  }
  setNodeLinesGlobals(globalsNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case PointVariable.POSITION:
        case PointVariable.NORMAL: {
          linesController.addVariable(globalsNode, new Vector3(), varName);
          bodyLines.push(`${varName}.copy(${PointBuilderAssemblerConstant.POINT_CONTAINER}.${outputName})`);
          break;
        }
        case PointVariable.OBJNUM:
        case PointVariable.PTNUM: {
          bodyLines.push(`${varName}= ${PointBuilderAssemblerConstant.POINT_CONTAINER}.${outputName}`);
        }
      }
    }
    linesController._addBodyLines(globalsNode, bodyLines);
  }
}
