"use strict";
import { GlobalsBaseController } from "./_Base";
import { AttributeGlNode } from "../../Attribute";
import { VaryingGLDefinition, AttributeGLDefinition } from "../../utils/GLDefinition";
import { MapUtils } from "../../../../../core/MapUtils";
import { ShaderName } from "../../../utils/shaders/ShaderName";
import { GlobalsOutput } from "../assemblers/materials/common/GlobalOutput";
import { GlobalsBaseControllerType } from "./Common";
const VARIABLE_CONFIG_DEFAULT_BY_NAME = {
  position: "vec3( position )"
};
const _GlobalsGeometryHandler = class extends GlobalsBaseController {
  type() {
    return GlobalsBaseControllerType.GEOMETRY;
  }
  handleGlobalsNode(globals_node, output_name, shaders_collection_controller) {
    const connection_point = globals_node.io.outputs.namedOutputConnectionPointsByName(output_name);
    if (!connection_point) {
      return;
    }
    const glType = connection_point.type();
    this.handleGlobalVar(globals_node, output_name, glType, shaders_collection_controller);
  }
  handleGlobalVar(globals_node, output_name, glType, shaders_collection_controller) {
    var _a, _b;
    const var_name = globals_node.glVarName(output_name);
    const definition = new VaryingGLDefinition(globals_node, glType, var_name);
    shaders_collection_controller.addDefinitions(globals_node, [definition]);
    const assembler = (_b = (_a = globals_node.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler;
    if (!assembler) {
      return;
    }
    const shader_config = assembler.shader_config(shaders_collection_controller.currentShaderName());
    if (!shader_config) {
      return;
    }
    const dependencies = shader_config.dependencies();
    const body_lines = [];
    const worldPositionLine = `${var_name} = modelMatrix * vec4( position, 1.0 )`;
    const worldNormalLine = `${var_name} = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal )`;
    switch (output_name) {
      case GlobalsOutput.WORLD_POSITION: {
        body_lines.push(worldPositionLine);
        break;
      }
      case GlobalsOutput.WORLD_NORMAL: {
        body_lines.push(worldNormalLine);
        break;
      }
      default: {
        body_lines.push(`${var_name} = ${glType}(${output_name})`);
      }
    }
    for (const dependency of dependencies) {
      shaders_collection_controller.addDefinitions(globals_node, [definition], dependency);
      shaders_collection_controller.addBodyLines(globals_node, body_lines, dependency);
    }
    if (dependencies.length == 0) {
      shaders_collection_controller.addBodyLines(globals_node, body_lines);
    }
  }
  static variable_config_default(variable_name) {
    return VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];
  }
  variable_config_default(variable_name) {
    return _GlobalsGeometryHandler.variable_config_default(variable_name);
  }
  // variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{
  // 	return null
  // }
  readAttribute(node, gl_type, attrib_name, shaders_collection_controller) {
    return _GlobalsGeometryHandler.readAttribute(node, gl_type, attrib_name, shaders_collection_controller);
  }
  static readAttribute(node, gl_type, attrib_name, shaders_collection_controller) {
    var _a, _b;
    if (_GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {
      shaders_collection_controller.addDefinitions(
        node,
        [new AttributeGLDefinition(node, gl_type, attrib_name)],
        ShaderName.VERTEX
      );
    } else {
    }
    const shader_name = shaders_collection_controller.currentShaderName();
    switch (shader_name) {
      case ShaderName.VERTEX: {
        return attrib_name;
      }
      case ShaderName.FRAGMENT: {
        if (!(node instanceof AttributeGlNode)) {
          return;
        }
        const attribNode = node;
        const var_name = attribNode.varyingName();
        const varying_definition = new VaryingGLDefinition(node, gl_type, var_name);
        const definitions_by_shader_name = /* @__PURE__ */ new Map();
        definitions_by_shader_name.set(ShaderName.FRAGMENT, []);
        const body_lines_by_shader_name = /* @__PURE__ */ new Map();
        body_lines_by_shader_name.set(ShaderName.FRAGMENT, []);
        MapUtils.pushOnArrayAtEntry(definitions_by_shader_name, shader_name, varying_definition);
        const set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;
        const shader_config = (_b = (_a = node.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler.shader_config(shader_name);
        if (shader_config) {
          const dependencies = shader_config.dependencies();
          for (const dependency of dependencies) {
            MapUtils.pushOnArrayAtEntry(definitions_by_shader_name, dependency, varying_definition);
            MapUtils.pushOnArrayAtEntry(body_lines_by_shader_name, dependency, set_varying_body_line);
          }
          definitions_by_shader_name.forEach((definitions, shader_name2) => {
            shaders_collection_controller.addDefinitions(node, definitions, shader_name2);
          });
          body_lines_by_shader_name.forEach((body_lines, shader_name2) => {
            shaders_collection_controller.addBodyLines(node, body_lines, shader_name2);
          });
        }
        return var_name;
      }
    }
  }
  handle_attribute_node(node, gl_type, attrib_name, shaders_collection_controller) {
    return _GlobalsGeometryHandler.readAttribute(node, gl_type, attrib_name, shaders_collection_controller);
  }
};
export let GlobalsGeometryHandler = _GlobalsGeometryHandler;
GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES = [
  "position",
  "color",
  "normal",
  "uv",
  "uv2",
  "morphTarget0",
  "morphTarget1",
  "morphTarget2",
  "morphTarget3",
  "skinIndex",
  "skinWeight"
];
GlobalsGeometryHandler.IF_RULE = {
  uv: "defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )"
};
