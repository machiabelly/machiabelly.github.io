"use strict";
import { CSGSopNode } from "./_BaseCSG";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { step } from "../../../core/geometry/modules/csg/CsgConstant";
import { primitives, maths } from "@jscad/modeling";
const { torus } = primitives;
class CSGTorusSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param inner radius */
    this.innerRadius = ParamConfig.FLOAT(0.25, {
      range: [2 * maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
    /** @param outer radius */
    this.outerRadius = ParamConfig.FLOAT(1, {
      range: [2 * maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
    /** @param inner segments */
    this.innerSegments = ParamConfig.INTEGER(12, {
      range: [3, 32],
      rangeLocked: [true, false]
    });
    /** @param outer segments */
    this.outerSegments = ParamConfig.INTEGER(32, {
      range: [3, 32],
      rangeLocked: [true, false]
    });
    /** @param inner rotation */
    this.innerRotation = ParamConfig.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [false, false]
    });
    /** @param open */
    this.open = ParamConfig.BOOLEAN(0);
    /** @param start angle */
    this.startAngle = ParamConfig.FLOAT(0, {
      range: [0, 2 * Math.PI],
      rangeLocked: [false, false],
      step,
      visibleIf: { open: 1 }
    });
    /** @param outer rotation */
    this.outerRotation = ParamConfig.FLOAT("2 * $PI", {
      range: [0, 2 * Math.PI],
      rangeLocked: [false, false],
      step,
      visibleIf: { open: 1 }
    });
  }
}
const ParamsConfig = new CSGTorusSopParamsConfig();
export class CSGTorusSopNode extends CSGSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CSG_TORUS;
  }
  cook(inputCoreGroups) {
    try {
      const {
        innerRadius,
        outerRadius,
        innerSegments,
        outerSegments,
        innerRotation,
        open,
        outerRotation,
        startAngle
      } = this.pv;
      const innerRadius2 = Math.min(innerRadius, outerRadius - 1 * maths.constants.EPS);
      const geo = torus({
        innerRadius: innerRadius2,
        outerRadius,
        innerSegments,
        outerSegments,
        innerRotation,
        outerRotation: open ? outerRotation : 2 * Math.PI,
        startAngle: open ? startAngle : 0
      });
      this.setCSGGeometry(geo);
    } catch (err) {
      const message = err instanceof Error ? err.message : "failed to create geometry";
      this.states.error.set(message);
      this.setCSGObjects([]);
    }
  }
}
