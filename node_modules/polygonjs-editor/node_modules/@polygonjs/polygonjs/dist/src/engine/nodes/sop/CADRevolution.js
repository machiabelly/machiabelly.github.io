"use strict";
import { CADSopNode } from "./_BaseCAD";
import { step } from "../../../core/geometry/modules/cad/CadConstant";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CoreCadType } from "../../../core/geometry/modules/cad/CadCoreType";
import { CadGeometryType, cadGeometryTypeFromShape } from "../../../core/geometry/modules/cad/CadCommon";
import { CadObject } from "../../../core/geometry/modules/cad/CadObject";
import {
  cadAxis
} from "../../../core/geometry/modules/cad/CadMath";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { curveDataFromEdge } from "../../../core/geometry/modules/cad/toObject3D/CadEdge";
import { traverseEdges } from "../../../core/geometry/modules/cad/CadTraverse";
import { CadLoaderSync } from "../../../core/geometry/modules/cad/CadLoaderSync";
class CADRevolutionSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param axis */
    this.axis = ParamConfig.VECTOR3([0, 1, 0]);
    /** @param closed */
    this.closed = ParamConfig.BOOLEAN(true);
    /** @param thetaMin */
    // thetaMin = ParamConfig.FLOAT(0, {
    // 	range: [0, 2 * Math.PI],
    // 	rangeLocked: [false, false],
    // 	step,
    // 	visibleIf: {closed: false},
    // });
    /** @param thetaMax */
    // thetaMax = ParamConfig.FLOAT(`2*$PI`, {
    // 	range: [0, 2 * Math.PI],
    // 	rangeLocked: [false, false],
    // 	step,
    // 	visibleIf: {closed: false},
    // });
    /** @param phi */
    this.phi = ParamConfig.FLOAT(`2*$PI`, {
      range: [0, 2 * Math.PI],
      rangeLocked: [true, true],
      step,
      visibleIf: { closed: false }
    });
  }
}
const ParamsConfig = new CADRevolutionSopParamsConfig();
export class CADRevolutionSopNode extends CADSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CAD_REVOLUTION;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(inputCoreGroups) {
    const oc = CadLoaderSync.oc();
    const coreGroup0 = inputCoreGroups[0];
    const newObjects = [];
    const axis = cadAxis(this.pv.axis);
    const createRevolution = (edge) => {
      const handle = curveDataFromEdge(oc, edge).curveHandle;
      const api = new oc.BRepPrimAPI_MakeRevolution_6(axis, handle, this.pv.phi);
      const newShape = api.Shape();
      api.delete();
      const type = cadGeometryTypeFromShape(oc, newShape);
      if (type) {
        newObjects.push(new CadObject(newShape, type));
      } else {
        console.log("no type", newShape);
      }
    };
    const inputObjects = coreGroup0.cadObjects();
    if (inputObjects) {
      for (const inputObject of inputObjects) {
        const type = inputObject.type;
        switch (type) {
          case CadGeometryType.CURVE_2D: {
          }
          case CadGeometryType.EDGE: {
            if (CoreCadType.isEdge(inputObject)) {
              createRevolution(inputObject.cadGeometry());
            }
            break;
          }
          case CadGeometryType.WIRE: {
            if (CoreCadType.isWire(inputObject)) {
              traverseEdges(oc, inputObject.cadGeometry(), (edge) => {
                createRevolution(edge);
              });
            }
            break;
          }
        }
      }
    }
    this.setCADObjects(newObjects);
  }
}
