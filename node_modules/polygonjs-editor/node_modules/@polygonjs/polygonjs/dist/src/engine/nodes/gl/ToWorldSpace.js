"use strict";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../../src/core/ThreeToGl";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPoint, GlConnectionPointType } from "../utils/io/connections/Gl";
var Interpretation = /* @__PURE__ */ ((Interpretation2) => {
  Interpretation2["POSITION"] = "position";
  Interpretation2["DIR_VEC"] = "direction vector";
  return Interpretation2;
})(Interpretation || {});
const INTERPRETATIONS = ["position" /* POSITION */, "direction vector" /* DIR_VEC */];
const OUTPUT_NAME = "out";
class ToWorldSpaceGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.vec = ParamConfig.VECTOR3([0, 0, 0]);
    this.interpretation = ParamConfig.INTEGER(0, {
      menu: {
        entries: INTERPRETATIONS.map((name, value) => {
          return { name, value };
        })
      }
    });
  }
}
const ParamsConfig = new ToWorldSpaceGlParamsConfig();
export class ToWorldSpaceGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "toWorldSpace";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["interpretation"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(OUTPUT_NAME, GlConnectionPointType.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const vec = ThreeToGl.vector3(this.variableForInputParam(this.p.vec));
    const out = this.glVarName(OUTPUT_NAME);
    const interpretation = INTERPRETATIONS[this.pv.interpretation];
    switch (interpretation) {
      case "position" /* POSITION */: {
        body_lines.push(`vec3 ${out} = (modelMatrix * vec4( ${vec}, 1.0 )).xyz`);
        break;
      }
      case "direction vector" /* DIR_VEC */: {
        body_lines.push(
          `vec3 ${out} = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * ${vec} )`
        );
        break;
      }
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}
