import { Camera, Scene } from 'three';
import { TypedViewer, TypedViewerOptions, BaseViewerMountOptions } from './_Base';
import { AvailableRenderConfig } from '../../core/camera/CoreCameraRendererController';
import type { EffectComposer } from 'postprocessing';
import { AbstractRenderer } from './Common';
declare global {
    interface HTMLCanvasElement {
        onwebglcontextlost: () => void;
        onwebglcontextrestored: () => void;
    }
}
export interface ThreejsViewerOptions<C extends Camera> extends TypedViewerOptions<C> {
}
export interface ThreejsViewerSetupData<C extends Camera> {
    renderer: AbstractRenderer;
    renderScene: Scene;
    camera: C;
}
interface SetAutoRenderOptions {
    cancelAnimate?: boolean;
}
/**
 *
 *
 * threejs viewers are created by the [PerspectiveCamera](/docs/nodes/obj/perspectivecamera) and [OrthographicCamera](/docs/nodes/obj/orthographiccamera) object nodes. They inherit from [TypedViewer](/docs/api/TypedViewer).
 *
 */
export declare class ThreejsViewer<C extends Camera> extends TypedViewer<C> {
    protected _requestAnimationFrameId: number | undefined;
    private _webXRConfig;
    private _markerTrackingConfig;
    private _rendererConfig;
    private _cssRendererConfig;
    private _codeConfig;
    private _FPSConfig;
    private _effectComposer;
    protected _errorMessage: string | undefined;
    private _resizeObserver;
    static _canvasIdPrefix(): string;
    constructor(options: ThreejsViewerOptions<C>);
    rendererConfig(): AvailableRenderConfig | undefined;
    protected _setupFunctions(options: ThreejsViewerOptions<C>): ThreejsViewerSetupData<C> | void;
    /**
     * mounts the viewer onto an element
     *
     *
     */
    mount(element: HTMLElement, options?: BaseViewerMountOptions): void;
    _build(): void;
    /**
     * disposes the viewer
     *
     *
     */
    dispose(): void;
    private _setEvents;
    private _initDisplay;
    /**
     * setAutoRender to false will stop the rendering. This can be useful if you know that nothing has changed in the scene, or if the renderer is currently not visible.
     *
     *
     */
    setAutoRender(state?: boolean, options?: SetAutoRenderOptions): void;
    isXR(): boolean;
    private _startAnimate;
    private _cancelAnimate;
    protected _animateWebBound: () => void;
    protected _animateWeb(): void;
    private _animateWebXR;
    private _accumulatedDelta;
    protected __animateCommon__(): void;
    private _cancelAnimateCommon;
    protected _tick(delta: number): void;
    /**
     * returns the current renderer
     *
     *
     */
    renderer(): AbstractRenderer | undefined;
    effectComposer(): EffectComposer | undefined;
    preCompile(): void;
    markAsReady(): void;
    private _onResizeBound;
    onResize(): void;
    updateSize(): boolean;
    private _updateRendererSize;
    private _listenToWindowResize;
    private _unlistenToWindowResize;
    private _createResizeObserver;
    private _disposeResizeObserver;
}
export {};
