"use strict";
import { TypedSubnetJsNode, TypedSubnetJsParamsConfigMixin } from "./Subnet";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { JsType } from "../../poly/registers/nodes/types/Js";
export var ForLoopJsInputName = /* @__PURE__ */ ((ForLoopJsInputName2) => {
  ForLoopJsInputName2["START"] = "start";
  ForLoopJsInputName2["MAX"] = "max";
  ForLoopJsInputName2["STEP"] = "step";
  ForLoopJsInputName2["I"] = "i";
  return ForLoopJsInputName2;
})(ForLoopJsInputName || {});
const DEFAULT_VALUES = {
  ["start" /* START */]: 0,
  ["max" /* MAX */]: 10,
  ["step" /* STEP */]: 1
};
const FOR_LOOP_INPUT_NAMES = [
  "start" /* START */,
  "max" /* MAX */,
  "step" /* STEP */,
  "i" /* I */
];
class ForLoopJsParamsConfig extends TypedSubnetJsParamsConfigMixin(NodeParamsConfig) {
  constructor() {
    super(...arguments);
    this.start = ParamConfig.FLOAT(0);
    this.max = ParamConfig.FLOAT(10, {
      range: [0, 100],
      rangeLocked: [false, false]
    });
    this.step = ParamConfig.FLOAT(1);
  }
}
const ParamsConfig = new ForLoopJsParamsConfig();
export class ForLoopJsNode extends TypedSubnetJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.FOR_LOOP;
  }
  paramDefaultValue(name) {
    return DEFAULT_VALUES[name];
  }
  _expectedInputTypes() {
    const type = JsConnectionPointType.INT;
    const forLoopInputTypes = [type, type, type];
    return forLoopInputTypes.concat(super._expectedInputTypes());
  }
  _expectedInputName(index) {
    if (index <= 2) {
      return FOR_LOOP_INPUT_NAMES[index];
    } else {
      return super._expectedInputName(index - 3);
    }
  }
  childExpectedInputConnectionPointTypes() {
    const type = JsConnectionPointType.INT;
    const forLoopInputTypes = [type, type, type, type];
    return forLoopInputTypes.concat(super._expectedInputTypes());
  }
  childExpectedInputConnectionPointName(index) {
    if (index <= 3) {
      return FOR_LOOP_INPUT_NAMES[index];
    } else {
      return super._expectedInputName(index - 4);
    }
  }
  inputNameForSubnetInput(index) {
    return this.childExpectedInputConnectionPointName(index);
  }
  //
  //
  // set_lines
  //
  //
  setLinesBlockStart(linesController) {
    const start = this.jsVarName("start" /* START */);
    const max = this.jsVarName("max" /* MAX */);
    const step = this.jsVarName("step" /* STEP */);
    const i = this.jsVarName("i" /* I */);
    const bodyLine = `for( ${i} = ${start}; ${i} < ${max}; ${i}+= ${step}){`;
    linesController._addBodyLines(this, [bodyLine]);
  }
  setSubnetInputLines(linesController, childNode) {
    const outputTypes = childNode.expectedOutputTypes();
    let i = 0;
    for (const _ of outputTypes) {
      const inputName = this.inputNameForSubnetInput(i);
      const inputValue = this.jsVarName(inputName);
      const varName = childNode.jsVarName(inputName);
      linesController._addBodyLines(childNode, [`${varName}=${inputValue}`]);
      i++;
    }
  }
  // override setSubnetInputLines(linesController: JsLinesCollectionController, childNode: SubnetInputJsNode) {
  // 	const start = this.variableForInputParam(linesController, this.p.start);
  // 	const max = this.variableForInputParam(linesController, this.p.max);
  // 	const step = this.variableForInputParam(linesController, this.p.step);
  // 	const body_lines: string[] = [];
  // 	// i
  // 	const iterator_name = this.jsVarName(ForLoopInput.I);
  // 	const i = childNode.jsVarName(ForLoopInput.I);
  // 	body_lines.push(`	const ${i} = ${iterator_name}`);
  // 	// start
  // 	const startVar = childNode.jsVarName(ForLoopInput.START);
  // 	body_lines.push(`	const ${startVar} = ${start}`);
  // 	// end
  // 	const maxVar = childNode.jsVarName(ForLoopInput.MAX);
  // 	body_lines.push(`	const ${maxVar} = ${max}`);
  // 	// step
  // 	const stepVar = childNode.jsVarName(ForLoopInput.STEP);
  // 	body_lines.push(`	const ${stepVar} = ${step}`);
  // 	const connections = this.io.connections.inputConnections();
  // 	if (connections) {
  // 		for (const connection of connections) {
  // 			if (connection) {
  // 				if (connection.inputIndex() >= OFFSET) {
  // 					const connection_point = connection.destConnectionPoint();
  // 					if (connection_point) {
  // 						const in_value = this.jsVarName(connection_point.name());
  // 						const gl_type = connection_point.type();
  // 						const out = childNode.jsVarName(connection_point.name());
  // 						const body_line = `	${gl_type} ${out} = ${in_value}`;
  // 						body_lines.push(body_line);
  // 					}
  // 				}
  // 			}
  // 		}
  // 	}
  // 	linesController._addBodyLines(childNode, body_lines);
  // }
}
