"use strict";
import { ObjectType } from "./../../../core/geometry/Constant";
import { TypedSopNode } from "./_Base";
import { Vector3 } from "three";
import { ConeGeometry } from "three";
import { rotateGeometry } from "../../../core/Transform";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { BaseSopOperation } from "../../operations/sop/_Base";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT_UP = new Vector3(0, 1, 0);
class ConeSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param cone radius */
    this.radius = ParamConfig.FLOAT(1, { range: [0, 1] });
    /** @param cone height */
    this.height = ParamConfig.FLOAT(1, { range: [0, 1] });
    /** @param radial segments count */
    this.segmentsRadial = ParamConfig.INTEGER(12, { range: [3, 20], rangeLocked: [true, false] });
    /** @param height segments count */
    this.segmentsHeight = ParamConfig.INTEGER(1, { range: [1, 20], rangeLocked: [true, false] });
    /** @param adds a cap */
    this.cap = ParamConfig.BOOLEAN(1);
    /** @param theta start */
    this.thetaStart = ParamConfig.FLOAT(1, { range: [0, Math.PI * 2] });
    /** @param start length */
    this.thetaLength = ParamConfig.FLOAT("2*$PI", { range: [0, Math.PI * 2] });
    /** @param center */
    this.center = ParamConfig.VECTOR3([0, 0, 0]);
    /** @param direction */
    this.direction = ParamConfig.VECTOR3([0, 1, 0]);
  }
  // should point up to match RBD expectation
}
const ParamsConfig = new ConeSopParamsConfig();
export class ConeSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CONE;
  }
  cook() {
    const geometry = new ConeGeometry(
      this.pv.radius,
      this.pv.height,
      this.pv.segmentsRadial,
      this.pv.segmentsHeight,
      !isBooleanTrue(this.pv.cap),
      this.pv.thetaStart,
      this.pv.thetaLength
    );
    rotateGeometry(geometry, DEFAULT_UP, this.pv.direction);
    geometry.translate(this.pv.center.x, this.pv.center.y, this.pv.center.z);
    const object = BaseSopOperation.createObject(geometry, ObjectType.MESH);
    object.name = this.name();
    this.setObject(object);
  }
}
