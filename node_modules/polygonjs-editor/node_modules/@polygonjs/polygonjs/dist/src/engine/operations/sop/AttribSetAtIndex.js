"use strict";
import { BaseSopOperation } from "./_Base";
import { Vector2, Vector3, Vector4 } from "three";
import { ATTRIBUTE_CLASSES, AttribClass, AttribType, ATTRIBUTE_TYPES } from "../../../core/geometry/Constant";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { TypeAssert } from "../../../engine/poly/Assert";
import { CoreAttribute } from "../../../core/geometry/Attribute";
import { corePointClassFactory } from "../../../core/geometry/CoreObjectFactory";
import { pointsFromObject } from "../../../core/geometry/entities/point/CorePointUtils";
const _points = [];
const _AttribSetAtIndexSopOperation = class extends BaseSopOperation {
  static type() {
    return "attribSetAtIndex";
  }
  cook(inputCoreGroups, params) {
    var _a;
    const coreGroup = inputCoreGroups[0];
    const attribName = params.name;
    if (attribName && attribName.trim() != "") {
      this._addAttribute(ATTRIBUTE_CLASSES[params.class], coreGroup, params);
    } else {
      (_a = this.states) == null ? void 0 : _a.error.set("attribute name is not valid");
    }
    return coreGroup;
  }
  _addAttribute(attribClass, coreGroup, params) {
    var _a, _b;
    const attribType = ATTRIBUTE_TYPES[params.type];
    switch (attribClass) {
      case AttribClass.POINT:
        this._addPointAttribute(attribType, coreGroup, params);
        return;
      case AttribClass.VERTEX:
        (_a = this.states) == null ? void 0 : _a.error.set("vertex not supported yet");
        return;
      case AttribClass.PRIMITIVE:
        (_b = this.states) == null ? void 0 : _b.error.set("primitive not supported yet");
        return;
      case AttribClass.OBJECT:
        this._addObjectAttribute(attribType, coreGroup, params);
        return;
      case AttribClass.CORE_GROUP:
        this._addCoreGroupAttribute(attribType, coreGroup, params);
        return;
    }
    TypeAssert.unreachable(attribClass);
  }
  _addPointAttribute(attribType, coreGroup, params) {
    const objects = coreGroup.allObjects();
    switch (attribType) {
      case AttribType.NUMERIC: {
        for (let object of objects) {
          this._addNumericAttributeToPoints(object, params);
        }
        return;
      }
      case AttribType.STRING: {
        for (let object of objects) {
          this._addStringAttributeToPoints(object, params);
        }
        return;
      }
    }
    TypeAssert.unreachable(attribType);
  }
  _addObjectAttribute(attribType, coreGroup, params) {
    const allCoreObjects = coreGroup.allCoreObjects();
    const attribName = params.name;
    const defaultValue = _AttribSetAtIndexSopOperation.defaultAttribValue(params);
    if (defaultValue != null) {
      for (let coreObject2 of allCoreObjects) {
        if (!coreObject2.hasAttribute(attribName)) {
          coreObject2.setAttribValue(attribName, defaultValue);
        }
      }
    }
    const coreObject = allCoreObjects[params.index];
    if (!coreObject) {
      return;
    }
    switch (attribType) {
      case AttribType.NUMERIC:
        this._addNumericAttributeToObject(coreObject, params);
        return;
      case AttribType.STRING:
        this._addStringAttributeToObject(coreObject, params);
        return;
    }
    TypeAssert.unreachable(attribType);
  }
  _addCoreGroupAttribute(attribType, coreGroup, params) {
    switch (attribType) {
      case AttribType.NUMERIC:
        this._addNumericAttributeToCoreGroup(coreGroup, params);
        return;
      case AttribType.STRING:
        this._addStringAttributeToCoreGroup(coreGroup, params);
        return;
    }
    TypeAssert.unreachable(attribType);
  }
  _addNumericAttributeToPoints(object, params) {
    const corePointClass = corePointClassFactory(object);
    const attribName = CoreAttribute.remapName(params.name);
    if (!corePointClass.hasAttribute(object, attribName)) {
      corePointClass.addNumericAttribute(object, attribName, params.size, 0);
    }
    const attrib = corePointClass.attribute(object, attribName);
    const array = attrib.array;
    const { index, size } = params;
    switch (size) {
      case 1: {
        if (index < array.length) {
          array[index] = params.value1;
          attrib.needsUpdate = true;
        }
        break;
      }
      case 2: {
        const i2 = index * 2;
        if (i2 < array.length) {
          params.value2.toArray(array, i2);
          attrib.needsUpdate = true;
        }
        break;
      }
      case 3: {
        const i3 = index * 3;
        if (i3 < array.length) {
          params.value3.toArray(array, i3);
          attrib.needsUpdate = true;
        }
        break;
      }
      case 4: {
        const i4 = index * 4;
        if (i4 < array.length) {
          params.value4.toArray(array, i4);
          attrib.needsUpdate = true;
        }
        break;
      }
    }
  }
  _addNumericAttributeToObject(coreObject, params) {
    const value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];
    const attribName = params.name;
    coreObject.setAttribValue(attribName, value);
  }
  _addNumericAttributeToCoreGroup(coreGroup, params) {
    const value = [params.value1, params.value2, params.value3, params.value4][params.size - 1];
    const attribName = params.name;
    coreGroup.setAttribValue(attribName, value);
  }
  _addStringAttributeToPoints(object, params) {
    const corePointClass = corePointClassFactory(object);
    const attribName = params.name;
    if (!corePointClass.hasAttribute(object, attribName)) {
      const tmpIndexData = CoreAttribute.arrayToIndexedArrays([""]);
      corePointClass.setIndexedAttribute(object, attribName, tmpIndexData["values"], tmpIndexData["indices"]);
    }
    const value = params.string;
    pointsFromObject(object, _points);
    const indexPoint = _points[params.index];
    let stringValues = new Array(_points.length);
    stringValues = stringValues.length != _points.length ? new Array(_points.length) : stringValues;
    for (const point of _points) {
      let currentValue = point.stringAttribValue(attribName);
      if (currentValue == null) {
        currentValue = "";
      }
      stringValues[point.index()] = currentValue;
    }
    if (indexPoint) {
      stringValues[indexPoint.index()] = value;
    }
    const indexData = CoreAttribute.arrayToIndexedArrays(stringValues);
    corePointClass.setIndexedAttribute(object, attribName, indexData["values"], indexData["indices"]);
  }
  _addStringAttributeToObject(coreObject, params) {
    const value = params.string;
    coreObject.setAttribValue(params.name, value);
  }
  _addStringAttributeToCoreGroup(coreGroup, params) {
    const value = params.string;
    coreGroup.setAttribValue(params.name, value);
  }
  //
  //
  // INTERNAL UTILS
  //
  //
  static _attribType(params) {
    return ATTRIBUTE_TYPES[params.type];
  }
  static defaultAttribValue(params) {
    const attribType = this._attribType(params);
    switch (attribType) {
      case AttribType.NUMERIC: {
        return this._defaultNumericValue(params);
      }
      case AttribType.STRING: {
        return this._defaultStringValue();
      }
    }
    TypeAssert.unreachable(attribType);
  }
  static _defaultStringValue() {
    return "";
  }
  static _defaultNumericValue(params) {
    const size = params.size;
    switch (size) {
      case 1:
        return 0;
      case 2:
        return new Vector2(0, 0);
      case 3:
        return new Vector3(0, 0, 0);
      case 4:
        return new Vector4(0, 0, 0, 0);
    }
  }
};
export let AttribSetAtIndexSopOperation = _AttribSetAtIndexSopOperation;
AttribSetAtIndexSopOperation.DEFAULT_PARAMS = {
  index: 0,
  class: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),
  type: ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC),
  name: "new_attrib",
  size: 1,
  value1: 0,
  value2: new Vector2(0, 0),
  value3: new Vector3(0, 0, 0),
  value4: new Vector4(0, 0, 0, 0),
  string: ""
};
AttribSetAtIndexSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
