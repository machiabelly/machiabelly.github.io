"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { AUDIO_ANALYSER_NODES, NodeContext } from "../../poly/NodeContext";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { isBooleanTrue } from "../../../core/Type";
import { corePointClassFactory } from "../../../core/geometry/CoreObjectFactory";
class AttribAudioAnalyserSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param the point or object index this applies to */
    this.index = ParamConfig.INTEGER("$F", {
      range: [0, 100],
      rangeLocked: [true, false]
    });
    /** @param values size */
    this.valuesSize = ParamConfig.INTEGER(8);
    /** @param sets if audioNode0 is read */
    this.active0 = ParamConfig.BOOLEAN(0);
    /** @param attribute name */
    this.attrib0 = ParamConfig.STRING("audioNode0", { visibleIf: { active0: 1 } });
    /** @param audio node to read data from */
    this.audioNode0 = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.AUDIO,
        types: AUDIO_ANALYSER_NODES
      },
      visibleIf: { active0: 1 }
    });
    /** @param sets if audioNode0 is read */
    this.active1 = ParamConfig.BOOLEAN(0);
    /** @param attribute name */
    this.attrib1 = ParamConfig.STRING("audioNode0", { visibleIf: { active1: 1 } });
    /** @param audio node to read data from */
    this.audioNode1 = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.AUDIO,
        types: AUDIO_ANALYSER_NODES
      },
      visibleIf: { active1: 1 }
    });
    /** @param sets if audioNode0 is read */
    this.active2 = ParamConfig.BOOLEAN(0);
    /** @param attribute name */
    this.attrib2 = ParamConfig.STRING("audioNode0", { visibleIf: { active2: 1 } });
    /** @param audio node to read data from */
    this.audioNode2 = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.AUDIO,
        types: AUDIO_ANALYSER_NODES
      },
      visibleIf: { active2: 1 }
    });
  }
}
const ParamsConfig = new AttribAudioAnalyserSopParamsConfig();
export class AttribAudioAnalyserSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribAudioAnalyser";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.NEVER);
  }
  // private _attribIndex: number = 0;
  cook(inputCoreGroups) {
    this._initParamsByIndex();
    this._registerOnTickHook();
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.allObjects();
    for (const object of objects) {
      this._updateGeometry(object);
    }
    this.setCoreGroup(coreGroup);
  }
  dispose() {
    this._unRegisterOnTickHook();
  }
  _updateGeometry(object) {
    this._updateWithParamSet(object, "0");
    this._updateWithParamSet(object, "1");
    this._updateWithParamSet(object, "2");
  }
  _updateWithParamSet(object, paramSetIndex) {
    if (!this._paramSetByIndex) {
      return;
    }
    const corePointClass = corePointClassFactory(object);
    const paramSet = this._paramSetByIndex[paramSetIndex];
    if (!isBooleanTrue(paramSet.active.value)) {
      return;
    }
    const attribName = paramSet.attribName.value;
    let attrib = corePointClass.attribute(object, attribName);
    if (!attrib) {
      corePointClass.addNumericAttribute(object, attribName, 1, 0);
      attrib = corePointClass.attribute(object, attribName);
    }
    const audioNode = paramSet.node.value.nodeWithContext(NodeContext.AUDIO);
    const audioAnalyserNode = audioNode;
    if (!audioAnalyserNode.getAnalyserValue) {
      return;
    }
    const values = audioAnalyserNode.getAnalyserValue();
    if (!values) {
      return;
    }
    const array = attrib.array;
    const valuesSize = this.pv.valuesSize;
    const analyserValuesCount = values.length;
    const index = this.pv.index;
    const offset = index * valuesSize;
    for (let i = 0; i < valuesSize; i++) {
      const value = i < analyserValuesCount ? values[i] : values[0];
      array[offset + i] = value;
    }
    attrib.needsUpdate = true;
  }
  _initParamsByIndex() {
    this._paramSetByIndex = this._paramSetByIndex || {
      "0": {
        active: this.p.active0,
        attribName: this.p.attrib0,
        node: this.p.audioNode0
      },
      "1": {
        active: this.p.active1,
        attribName: this.p.attrib1,
        node: this.p.audioNode1
      },
      "2": {
        active: this.p.active2,
        attribName: this.p.attrib2,
        node: this.p.audioNode2
      }
    };
  }
  /*
   * REGISTER TICK CALLBACK
   */
  async _registerOnTickHook() {
    if (this.scene().registeredBeforeTickCallbacks().has(this._tickCallbackName())) {
      return;
    }
    this.scene().registerOnBeforeTick(this._tickCallbackName(), () => this.setDirty());
  }
  async _unRegisterOnTickHook() {
    this.scene().unRegisterOnBeforeTick(this._tickCallbackName());
  }
  _tickCallbackName() {
    return `cop/audioAnalyserNode-${this.graphNodeId()}`;
  }
}
