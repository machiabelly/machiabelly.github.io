export default "\n\n// https://stackoverflow.com/questions/23793698/how-to-implement-slerp-in-glsl-hlsl\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t)\n// {\n// 	float dotp = dot(normalize(p0), normalize(p1));\n// 	if ((dotp > 0.9999) || (dotp < -0.9999))\n// 	{\n// 		if (t<=0.5)\n// 			return p0;\n// 		return p1;\n// 	}\n// 	float theta = acos(dotp);\n// 	vec4 P = ((p0*sin((1.0-t)*theta) + p1*sin(t*theta)) / sin(theta));\n// 	P.w = 1.0;\n// 	return P;\n// }\n\n// https://devcry.heiho.net/html/2017/20170521-slerp.html\n// float lerp(float a, float b, float t) {\n// 	return (1.0 - t) * a + t * b;\n// }\n// vec4 quatSlerp(vec4 p0, vec4 p1, float t){\n// 	vec4 qb = p1;\n\n// 	// cos(a) = dot product\n// 	float cos_a = p0.x * qb.x + p0.y * qb.y + p0.z * qb.z + p0.w * qb.w;\n// 	if (cos_a < 0.0f) {\n// 		cos_a = -cos_a;\n// 		qb = -qb;\n// 	}\n\n// 	// close to zero, cos(a) ~= 1\n// 	// do linear interpolation\n// 	if (cos_a > 0.999) {\n// 		return vec4(\n// 			lerp(p0.x, qb.x, t),\n// 			lerp(p0.y, qb.y, t),\n// 			lerp(p0.z, qb.z, t),\n// 			lerp(p0.w, qb.w, t)\n// 		);\n// 	}\n\n// 	float alpha = acos(cos_a);\n// 	return (p0 * sin(1.0 - t) + p1 * sin(t * alpha)) / sin(alpha);\n// }\n\n// https://stackoverflow.com/questions/62943083/interpolate-between-two-quaternions-the-long-way\nvec4 quatSlerp(vec4 q1, vec4 q2, float t){\n	float angle = acos(dot(q1, q2));\n	float denom = sin(angle);\n	//check if denom is zero\n	return (q1*sin((1.0-t)*angle)+q2*sin(t*angle))/denom;\n}\n// TO CHECK:\n// this page https://www.reddit.com/r/opengl/comments/704la7/glsl_quaternion_library/\n// has a link to a potentially nice pdf:\n// http://web.mit.edu/2.998/www/QuaternionReport1.pdf\n\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 quatMult(vec4 q1, vec4 q2)\n{\n	return vec4(\n	q1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n	q1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n	q1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n	q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n	);\n}\n// http://glmatrix.net/docs/quat.js.html#line97\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\n\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\n\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\n\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n//   return out\n\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n	axis = normalize(axis);\n	float s = sin(angle);\n	float c = cos(angle);\n	float oc = 1.0 - c;\n\n 	return mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 quatFromAxisAngle(vec3 axis, float angle)\n{\n	vec4 qr;\n	float half_angle = (angle * 0.5); // * 3.14159 / 180.0;\n	float sin_half_angle = sin(half_angle);\n	qr.x = axis.x * sin_half_angle;\n	qr.y = axis.y * sin_half_angle;\n	qr.z = axis.z * sin_half_angle;\n	qr.w = cos(half_angle);\n	return qr;\n}\nvec3 rotateWithAxisAngle(vec3 position, vec3 axis, float angle)\n{\n	vec4 q = quatFromAxisAngle(axis, angle);\n	vec3 v = position.xyz;\n	return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\n// 	return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n// }\nvec3 rotateWithQuat( vec3 v, vec4 q )\n{\n	// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n	// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n	return v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\n// 	vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// 	vec3 ww = normalize(target - origin);\n// 	vec3 uu = normalize(cross(ww, rr));\n// 	vec3 vv = normalize(cross(uu, ww));\n\n// 	return mat3(uu, vv, ww);\n// }\n// mat3 rotation_matrix(vec3 target, float roll) {\n// 	vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// 	vec3 ww = normalize(target);\n// 	vec3 uu = normalize(cross(ww, rr));\n// 	vec3 vv = normalize(cross(uu, ww));\n\n// 	return mat3(uu, vv, ww);\n// }\n\nfloat vectorAngle(vec3 start, vec3 dest){\n	start = normalize(start);\n	dest = normalize(dest);\n\n	float cosTheta = dot(start, dest);\n	vec3 c1 = cross(start, dest);\n	// We use the dot product of the cross with the Y axis.\n	// This is a little arbitrary, but can still give a good sense of direction\n	vec3 y_axis = vec3(0.0, 1.0, 0.0);\n	float d1 = dot(c1, y_axis);\n	float angle = acos(cosTheta) * sign(d1);\n	return angle;\n}\n\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\nvec4 vectorAlign(vec3 start, vec3 dest){\n	start = normalize(start);\n	dest = normalize(dest);\n\n	float cosTheta = dot(start, dest);\n	vec3 axis;\n\n	// if (cosTheta < -1 + 0.001f){\n	// 	// special case when vectors in opposite directions:\n	// 	// there is no ideal rotation axis\n	// 	// So guess one; any will do as long as it's perpendicular to start\n	// 	axis = cross(vec3(0.0f, 0.0f, 1.0f), start);\n	// 	if (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\n	// 		axis = cross(vec3(1.0f, 0.0f, 0.0f), start);\n\n	// 	axis = normalize(axis);\n	// 	return gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\n	// }\n	if(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\n		axis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\n		if (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\n			axis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\n		}\n	} else {\n		axis = normalize(cross(start, dest));\n	}\n\n	float angle = acos(cosTheta);\n\n	return quatFromAxisAngle(axis, angle);\n}\nvec4 vectorAlignWithUp(vec3 start, vec3 dest, vec3 up){\n	vec4 rot1 = vectorAlign(start, dest);\n	up = normalize(up);\n\n	// Recompute desiredUp so that it's perpendicular to the direction\n	// You can skip that part if you really want to force desiredUp\n	// vec3 right = normalize(cross(dest, up));\n	// up = normalize(cross(right, dest));\n\n	// Because of the 1rst rotation, the up is probably completely screwed up.\n	// Find the rotation between the up of the rotated object, and the desired up\n	vec3 newUp = rotateWithQuat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n	vec4 rot2 = vectorAlign(up, newUp);\n\n	// return rot1;\n	return rot2;\n	// return multQuat(rot1, rot2);\n	// return rot2 * rot1;\n\n}\n\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\nfloat quatToAngle(vec4 q){\n	return 2.0 * acos(q.w);\n}\nvec3 quatToAxis(vec4 q){\n	return vec3(\n		q.x / sqrt(1.0-q.w*q.w),\n		q.y / sqrt(1.0-q.w*q.w),\n		q.z / sqrt(1.0-q.w*q.w)\n	);\n}\n\nvec4 align(vec3 dir, vec3 up){\n	vec3 start_dir = vec3(0.0, 0.0, 1.0);\n	vec3 start_up = vec3(0.0, 1.0, 0.0);\n	vec4 rot1 = vectorAlign(start_dir, dir);\n	up = normalize(up);\n\n	// Recompute desiredUp so that it's perpendicular to the direction\n	// You can skip that part if you really want to force desiredUp\n	vec3 right = normalize(cross(dir, up));\n	if(length(right)<0.001){\n		right = vec3(1.0, 0.0, 0.0);\n	}\n	up = normalize(cross(right, dir));\n\n	// Because of the 1rst rotation, the up is probably completely screwed up.\n	// Find the rotation between the up of the rotated object, and the desired up\n	vec3 newUp = rotateWithQuat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n	vec4 rot2 = vectorAlign(normalize(newUp), up);\n\n	// return rot1;\n	return quatMult(rot1, rot2);\n	// return rot2 * rot1;\n\n}";
