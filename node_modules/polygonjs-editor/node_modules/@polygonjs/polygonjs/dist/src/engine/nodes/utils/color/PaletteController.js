"use strict";
import { TypedNode } from "../../_Base";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { Color } from "three";
import {
  MAX_PALETTE_COLORS_COUNT,
  PALETTES_BY_NAME,
  SORTED_PALETTE_NAMES,
  visibleIfColorsCountAtLeast
} from "../../../../core/color/chromotomeWrapper";
export const paletteControllerCallbackOptions = (method) => {
  return {
    callback: (node) => {
      method(node);
    }
  };
};
export class PaletteController {
  constructor(node) {
    this.node = node;
  }
  static PARAM_CALLBACK_pickNext(node) {
    node.paletteController.PARAM_CALLBACK_pickNext();
  }
  static PARAM_CALLBACK_pickPrevious(node) {
    node.paletteController.PARAM_CALLBACK_pickPrevious();
  }
  static PARAM_CALLBACK_pickRandom(node) {
    node.paletteController.PARAM_CALLBACK_pickRandom();
  }
  static PARAM_CALLBACK_updateColors(node) {
    node.paletteController.PARAM_CALLBACK_updateColors();
  }
  PARAM_CALLBACK_pickNext() {
    const currentIndex = SORTED_PALETTE_NAMES.indexOf(this.node.pv.paletteName);
    const nextIndex = currentIndex < SORTED_PALETTE_NAMES.length - 1 ? currentIndex + 1 : 0;
    this._batchUpdatesWithPalette(nextIndex);
  }
  PARAM_CALLBACK_pickPrevious() {
    const currentIndex = SORTED_PALETTE_NAMES.indexOf(this.node.pv.paletteName);
    const previousIndex = currentIndex == 0 ? SORTED_PALETTE_NAMES.length - 1 : currentIndex - 1;
    this._batchUpdatesWithPalette(previousIndex);
  }
  PARAM_CALLBACK_pickRandom() {
    const randomIndex = Math.floor(Math.random() * SORTED_PALETTE_NAMES.length);
    this._batchUpdatesWithPalette(randomIndex);
  }
  _batchUpdatesWithPalette(paletteIndex) {
    const paletteName = SORTED_PALETTE_NAMES[paletteIndex];
    this.node.scene().batchUpdates(() => {
      this.node.p.paletteName.set(paletteName);
      this._updateColors();
    });
  }
  PARAM_CALLBACK_updateColors() {
    this.node.scene().batchUpdates(() => {
      this._updateColors();
    });
  }
  _updateColors() {
    const node = this.node;
    const name = node.pv.paletteName;
    const palette = PALETTES_BY_NAME.get(name);
    const colorParams = [node.p.color1, node.p.color2, node.p.color3, node.p.color4, node.p.color5];
    node.p.colorsCount.set(palette.colors.length);
    for (let i = 0; i < palette.colors.length; i++) {
      const color = palette.colors[i];
      const param = colorParams[i];
      if (color && param) {
        _tmp_color.set(color);
        _tmp_color.toArray(_tmp_color_array);
        param.set(_tmp_color_array);
      }
    }
    node.p.colorsCount.set(palette.colors.length);
  }
}
class PaletteAbstractNodeParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param name of the palette */
    this.paletteName = ParamConfig.STRING(
      "",
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_updateColors)
    );
    /** @param click to set the node to the next palette */
    this.pickNext = ParamConfig.BUTTON(null, paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickNext));
    /** @param click to set the node to the previous palette */
    this.pickPrevious = ParamConfig.BUTTON(
      null,
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickPrevious)
    );
    /** @param click to set the node to a random palette */
    this.pickRandom = ParamConfig.BUTTON(
      null,
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickRandom)
    );
    this.colorsCount = ParamConfig.INTEGER(0, {
      hidden: true,
      range: [0, MAX_PALETTE_COLORS_COUNT],
      separatorAfter: true
    });
    /** @param palette color 1 */
    this.color1 = ParamConfig.COLOR([0, 0, 0], {
      visibleIf: visibleIfColorsCountAtLeast(1)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 2 */
    this.color2 = ParamConfig.COLOR([0, 0, 0], {
      visibleIf: visibleIfColorsCountAtLeast(2)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 3 */
    this.color3 = ParamConfig.COLOR([0, 0, 0], {
      visibleIf: visibleIfColorsCountAtLeast(3)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 4 */
    this.color4 = ParamConfig.COLOR([0, 0, 0], {
      visibleIf: visibleIfColorsCountAtLeast(4)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 5 */
    this.color5 = ParamConfig.COLOR([0, 0, 0], {
      visibleIf: visibleIfColorsCountAtLeast(5)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
  }
}
const ParamsConfig = new PaletteAbstractNodeParamsConfig();
export class PaletteAbstractNode extends TypedNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    //  static type() {
    // 	 return 'palette';
    //  }
    //  initializeNode() {
    // 	 this.params.onParamsCreated('palette_init', () => {
    // 		PaletteController.paramCallbackUpdateColors(this);
    // 	 });
    //  }
    this.paletteController = new PaletteController(this);
  }
  // static PARAM_CALLBACK_pickNext(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_pickNext();
  // }
  // static PARAM_CALLBACK_pickPrevious(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_pickPrevious();
  // }
  // static PARAM_CALLBACK_pickRandom(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_pickRandom();
  // }
  // static PARAM_CALLBACK_updateColors(node: PaletteAbstractNode<any>) {
  // 	node.paletteController.PARAM_CALLBACK_updateColors();
  // }
}
const _tmp_color = new Color();
const _tmp_color_array = [1, 1, 1];
