"use strict";
import { TypedAudioNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { AudioBuilder } from "../../../core/audio/AudioBuilder";
import { Noise } from "tone/build/esm/source/Noise";
import { effectParamsOptions } from "./utils/EffectsController";
import { isBooleanTrue } from "../../../core/Type";
const NOISE_TYPES = ["white", "brown", "pink"];
export const NOISE_DEFAULTS = {
  fadeIn: 0,
  fadeOut: 0,
  mute: false,
  playbackRate: 1
  // type: "white",
  // volume: 0,
};
const paramCallback = (node) => {
  NoiseAudioNode.PARAM_CALLBACK_updateNoise(node);
};
class NoiseAudioParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param Noise type */
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: NOISE_TYPES.map((name, value) => ({ name, value }))
      },
      ...effectParamsOptions(paramCallback)
    });
    /** playbackRate */
    this.playbackRate = ParamConfig.FLOAT(NOISE_DEFAULTS.playbackRate, {
      range: [0, 1],
      rangeLocked: [true, false],
      ...effectParamsOptions(paramCallback)
    });
    /** fadeIn */
    this.fadeIn = ParamConfig.FLOAT(NOISE_DEFAULTS.fadeIn, {
      range: [0, 1],
      rangeLocked: [true, false],
      ...effectParamsOptions(paramCallback)
    });
    /** fadeOut */
    this.fadeOut = ParamConfig.FLOAT(NOISE_DEFAULTS.fadeOut, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** play */
    this.play = ParamConfig.BOOLEAN(1, effectParamsOptions(paramCallback));
  }
}
const ParamsConfig = new NoiseAudioParamsConfig();
export class NoiseAudioNode extends TypedAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "noise";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputContents) {
    const noise = this._noise();
    this._updateNoise();
    const audioBuilder = new AudioBuilder();
    audioBuilder.setSource(noise);
    this.setAudioBuilder(audioBuilder);
  }
  _noise() {
    return this.__noise__ = this.__noise__ || this._createEffect();
  }
  _createEffect() {
    return new Noise({
      type: NOISE_TYPES[this.pv.type],
      playbackRate: this.pv.playbackRate,
      fadeIn: this.pv.fadeIn,
      fadeOut: this.pv.fadeOut
    });
  }
  static PARAM_CALLBACK_updateNoise(node) {
    node._updateNoise();
  }
  _updateNoise() {
    const noise = this._noise();
    noise.type = NOISE_TYPES[this.pv.type];
    noise.playbackRate = this.pv.playbackRate;
    noise.fadeIn = this.pv.fadeIn;
    noise.fadeOut = this.pv.fadeOut;
    if (isBooleanTrue(this.pv.play)) {
      noise.start();
    } else {
      noise.stop();
    }
  }
}
