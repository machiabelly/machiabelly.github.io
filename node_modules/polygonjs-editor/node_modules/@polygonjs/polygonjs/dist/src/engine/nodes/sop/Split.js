"use strict";
import { TypedSopNode } from "./_Base";
import {
  AttribSize,
  ATTRIBUTE_TYPES,
  AttribType,
  AttribTypeMenuEntries,
  objectTypeFromObject
} from "../../../core/geometry/Constant";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { ThreejsCoreObject } from "../../../core/geometry/modules/three/ThreejsCoreObject";
import { MapUtils } from "../../../core/MapUtils";
import { geometryBuilder } from "../../../core/geometry/modules/three/builders/geometryBuilder";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { pointsFromObject } from "../../../core/geometry/entities/point/CorePointUtils";
const _points = [];
class SplitSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param type of attribute to use */
    this.attribType = ParamConfig.INTEGER(ATTRIBUTE_TYPES.indexOf(AttribType.NUMERIC), {
      menu: {
        entries: AttribTypeMenuEntries
      }
    });
    /** @param name of the attribute */
    this.attribName = ParamConfig.STRING("");
  }
}
const ParamsConfig = new SplitSopParamsConfig();
export class SplitSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._newObjects = [];
  }
  static type() {
    return SopType.SPLIT;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  cook(input_contents) {
    const core_group = input_contents[0];
    this._newObjects.length = 0;
    if (this.pv.attribName != "") {
      this._split_core_group(core_group);
    }
    this.setObjects(this._newObjects);
  }
  _split_core_group(core_group) {
    const core_objects = core_group.threejsCoreObjects();
    for (let core_object of core_objects) {
      this._split_core_object(core_object);
    }
  }
  _split_core_object(coreObject) {
    const object = coreObject.object();
    let attribName = this.pv.attribName;
    const pointsByValue = /* @__PURE__ */ new Map();
    pointsFromObject(object, _points);
    const firstPoint = _points[0];
    if (firstPoint) {
      const attribSize = firstPoint.attribSize(attribName);
      if (!(attribSize == AttribSize.FLOAT || firstPoint.isAttribIndexed(attribName))) {
        this.states.error.set(`attrib '${attribName}' must be a float or a string`);
        return;
      }
      let val;
      if (firstPoint.isAttribIndexed(attribName)) {
        for (const point of _points) {
          val = point.indexedAttribValue(attribName);
          MapUtils.pushOnArrayAtEntry(pointsByValue, val, point);
        }
      } else {
        for (const point of _points) {
          val = point.attribValue(attribName);
          MapUtils.pushOnArrayAtEntry(pointsByValue, val, point);
        }
      }
    }
    const objectType = objectTypeFromObject(object);
    if (objectType) {
      pointsByValue.forEach((points, value) => {
        const builder = geometryBuilder(objectType);
        if (builder) {
          const newGeometry = builder.fromPoints(object, points);
          if (newGeometry) {
            const object2 = this.createObject(newGeometry, objectType);
            if (object2) {
              ThreejsCoreObject.addAttribute(object2, attribName, value);
              this._newObjects.push(object2);
            }
          }
        }
      });
    }
  }
}
