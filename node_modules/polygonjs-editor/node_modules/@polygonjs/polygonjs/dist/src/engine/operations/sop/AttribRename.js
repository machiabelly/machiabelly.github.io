"use strict";
import { BaseSopOperation } from "./_Base";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { AttribClass, ATTRIBUTE_CLASSES } from "../../../core/geometry/Constant";
import { ENTITY_CLASS_FACTORY } from "../../../core/geometry/CoreObjectFactory";
import { filterObjectsFromCoreGroup } from "../../../core/geometry/Mask";
const SPLIT_REGEX = /[ ,]+/g;
export class AttribRenameSopOperation extends BaseSopOperation {
  static type() {
    return "attribRename";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = filterObjectsFromCoreGroup(coreGroup, params);
    const attribClass = ATTRIBUTE_CLASSES[params.class];
    const factory = ENTITY_CLASS_FACTORY[attribClass];
    const newAttribNames = params.newName.split(SPLIT_REGEX);
    if (factory) {
      for (const object of objects) {
        const entityClass = factory(object);
        const oldAttribNames = entityClass.attributeNamesMatchingMask(object, params.oldName);
        const minCount = Math.min(oldAttribNames.length, newAttribNames.length);
        for (let i = 0; i < minCount; i++) {
          entityClass.renameAttribute(object, oldAttribNames[i], newAttribNames[i]);
        }
      }
    } else {
      const oldAttribNames = coreGroup.attributeNamesMatchingMask(params.oldName);
      const minCount = Math.min(oldAttribNames.length, newAttribNames.length);
      for (let i = 0; i < minCount; i++) {
        coreGroup.renameAttribute(oldAttribNames[i], newAttribNames[i]);
      }
    }
    return coreGroup;
  }
}
AttribRenameSopOperation.DEFAULT_PARAMS = {
  group: "",
  class: ATTRIBUTE_CLASSES.indexOf(AttribClass.POINT),
  oldName: "",
  newName: ""
};
AttribRenameSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
