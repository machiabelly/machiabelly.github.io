"use strict";
import { CADSopNode } from "./_BaseCAD";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CadGeometryType } from "../../../core/geometry/modules/cad/CadCommon";
import { cadGeom2dCurveTransform } from "../../../core/geometry/modules/cad/toObject3D/CadGeom2dCurve";
import { cadPnt2dTransform } from "../../../core/geometry/modules/cad/toObject3D/CadPnt2d";
import { SopType } from "../../poly/registers/nodes/types/Sop";
class CADTransform2DSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param translate */
    this.t = ParamConfig.VECTOR2([0, 0]);
    /** @param rotation */
    this.r = ParamConfig.FLOAT(0, {
      range: [-180, 180],
      rangeLocked: [false, false]
    });
    /** @param scale (as a float) */
    this.s = ParamConfig.FLOAT(1, {
      range: [0, 2],
      step: 0.01
    });
    /** @param pivot */
    this.pivot = ParamConfig.VECTOR2([0, 0]);
  }
}
const ParamsConfig = new CADTransform2DSopParamsConfig();
export class CADTransform2DSopNode extends CADSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CAD_TRANSFORM_2D;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  async cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const newObjects = [];
    const cadObjects = coreGroup0.cadObjects();
    if (cadObjects) {
      for (const cadObject of cadObjects) {
        transform2D(cadObject, this.pv.t, this.pv.r, this.pv.s, this.pv.pivot);
        newObjects.push(cadObject);
      }
    }
    this.setCADObjects(newObjects);
  }
}
function transform2D(cadObject, t, r, s, pivot) {
  switch (cadObject.type) {
    case CadGeometryType.POINT_2D: {
      return cadPnt2dTransform(cadObject.cadGeometry(), t);
    }
    case CadGeometryType.CURVE_2D: {
      return cadGeom2dCurveTransform(cadObject.cadGeometry(), t, r, s, pivot);
    }
  }
}
