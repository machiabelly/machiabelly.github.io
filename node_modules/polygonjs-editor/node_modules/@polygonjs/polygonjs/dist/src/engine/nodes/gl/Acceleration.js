"use strict";
import { TypedGlNode } from "./_Base";
import { GlConnectionPointType, GlConnectionPoint } from "../utils/io/connections/Gl";
import { UniformGLDefinition, FunctionGLDefinition } from "./utils/GLDefinition";
import { GlConstant } from "../../../core/geometry/GlConstant";
import { ThreeToGl } from "../../../core/ThreeToGl";
import Physics from "./gl/physics.glsl";
var AccelerationGlInput = /* @__PURE__ */ ((AccelerationGlInput2) => {
  AccelerationGlInput2["POSITION"] = "position";
  AccelerationGlInput2["VELOCITY"] = "velocity";
  AccelerationGlInput2["MASS"] = "mass";
  AccelerationGlInput2["FORCE"] = "force";
  return AccelerationGlInput2;
})(AccelerationGlInput || {});
var AccelerationGlOutput = /* @__PURE__ */ ((AccelerationGlOutput2) => {
  AccelerationGlOutput2["POSITION"] = "position";
  AccelerationGlOutput2["VELOCITY"] = "velocity";
  return AccelerationGlOutput2;
})(AccelerationGlOutput || {});
const INPUT_NAMES = [
  "position" /* POSITION */,
  "velocity" /* VELOCITY */,
  "mass" /* MASS */,
  "force" /* FORCE */
];
const OUTPUT_NAMES = ["position" /* POSITION */, "velocity" /* VELOCITY */];
const INPUT_DEFAULT_VALUE = {
  ["position" /* POSITION */]: [0, 0, 0],
  ["velocity" /* VELOCITY */]: [0, 0, 0],
  ["mass" /* MASS */]: 1,
  ["force" /* FORCE */]: [0, -9.8, 0]
};
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
class AccelerationGlParamsConfig extends NodeParamsConfig {
  // position = ParamConfig.VECTOR3([0, 0, 0]);
  // velocity = ParamConfig.VECTOR3([0, 0, 0]);
  // mass = ParamConfig.FLOAT(1);
  // force = ParamConfig.VECTOR3([0, -9.8, 0]);
}
const ParamsConfig = new AccelerationGlParamsConfig();
export class AccelerationGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "acceleration";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint("position" /* POSITION */, GlConnectionPointType.VEC3),
      new GlConnectionPoint("velocity" /* VELOCITY */, GlConnectionPointType.VEC3)
    ]);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function(this._gl_output_name.bind(this));
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || GlConnectionPointType.VEC3;
    return [type, type, GlConnectionPointType.FLOAT, type];
  }
  _expected_output_types() {
    const in_type = this._expected_input_types()[0];
    return [in_type, in_type];
  }
  _gl_input_name(index) {
    return INPUT_NAMES[index];
  }
  _gl_output_name(index) {
    return OUTPUT_NAMES[index];
  }
  paramDefaultValue(name) {
    return INPUT_DEFAULT_VALUE[name];
  }
  setLines(shaders_collection_controller) {
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!outputConnectionPoints) {
      return;
    }
    const var_type = outputConnectionPoints[0].type();
    const delta_definition = new UniformGLDefinition(this, GlConnectionPointType.FLOAT, GlConstant.DELTA_TIME);
    const function_definition = new FunctionGLDefinition(this, Physics);
    shaders_collection_controller.addDefinitions(this, [delta_definition, function_definition]);
    const input_position = ThreeToGl.any(this.variableForInput("position" /* POSITION */));
    const input_velocity = ThreeToGl.any(this.variableForInput("velocity" /* VELOCITY */));
    const input_mass = ThreeToGl.float(this.variableForInput("mass" /* MASS */));
    const input_force = ThreeToGl.any(this.variableForInput("force" /* FORCE */));
    const position_result = this.glVarName("position" /* POSITION */);
    const velocity_result = this.glVarName("velocity" /* VELOCITY */);
    const velocity_args = [input_velocity, input_force, input_mass, GlConstant.DELTA_TIME].join(", ");
    const velocity_body_line = `${var_type} ${velocity_result} = velFromAccel(${velocity_args})`;
    const position_args = [input_position, velocity_result, GlConstant.DELTA_TIME].join(", ");
    const position_body_line = `${var_type} ${position_result} = posFromVel(${position_args})`;
    shaders_collection_controller.addBodyLines(this, [velocity_body_line, position_body_line]);
  }
}
