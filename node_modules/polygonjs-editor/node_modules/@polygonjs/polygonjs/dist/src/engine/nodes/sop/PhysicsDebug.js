"use strict";
import { TypedActorSopNode } from "./_BaseActor";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { physicsCreateDebugObject } from "../../../core/physics/PhysicsDebug";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { PhysicsIdAttribute } from "../../../core/physics/PhysicsAttribute";
import { CorePhysics } from "../../../core/physics/CorePhysics";
import { coreObjectClassFactory } from "../../../core/geometry/CoreObjectFactory";
class PhysicsDebugSopParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new PhysicsDebugSopParamsConfig();
export class PhysicsDebugSopNode extends TypedActorSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.PHYSICS_DEBUG;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  async cook(inputCoreGroups) {
    this.compilationController.compileIfRequired();
    await CorePhysics();
    const coreGroup = inputCoreGroups[0];
    const worldObjectId = coreGroup.allObjects().map((o) => coreObjectClassFactory(o).attribValue(o, PhysicsIdAttribute.WORLD)).find((id) => id != null);
    if (worldObjectId != null) {
      const debugObject = physicsCreateDebugObject();
      coreObjectClassFactory(debugObject).addAttribute(
        debugObject,
        PhysicsIdAttribute.DEBUG_WORLD,
        worldObjectId
      );
      debugObject.name = `${this.name()}_Debug`;
      const actorNode = this._findActorNode();
      this.scene().actorsManager.assignActorBuilder(debugObject, actorNode);
      this.setObjects([debugObject]);
    } else {
      this.setObjects([]);
    }
  }
  // public override updateObjectOnAdd(object: Object3D) {
  // 	// if (!this._PhysicsLib) {
  // 	// 	return;
  // 	// }
  // 	const worldNodeId = CoreObject.attribValue(object, PhysicsIdAttribute.WORLD);
  // 	if (worldNodeId != null) {
  // 		if (worldNodeId != this.graphNodeId()) {
  // 			return;
  // 		}
  // 		const worldObject = object;
  // 		createOrFindPhysicsDebug(this, worldObject, this.pv.gravity).then(({world, PhysicsLib}) => {
  // 			initCorePhysicsDebug(PhysicsLib, worldObject, this.scene());
  // 			// once world is create, try and find a sibbling that matches the debug object,
  // 			// then updated it accordingly
  // 			const sibblings = worldObject.parent?.children.filter((sibbling) => sibbling.uuid != worldObject.uuid);
  // 			if (!sibblings) {
  // 				return;
  // 			}
  // 			const debugObject = sibblings.find(
  // 				(sibbling) => CoreObject.attribValue(sibbling, PhysicsIdAttribute.DEBUG) == this.graphNodeId()
  // 			);
  // 			if (debugObject) {
  // 				updatePhysicsDebugObject(debugObject);
  // 			}
  // 			// if (isBooleanTrue(this.pv.debug)) {
  // 			// 	const pair = createOrFindPhysicsDebugObject(this, world);
  // 			// 	updatePhysicsDebugObject(pair);
  // 			// 	objects.push(pair.object);
  // 			// }
  // 			// for (let object of objects) {
  // 			// 	this.scene().actorsManager.assignActorBuilder(object, actorNode);
  // 			// }
  // 		});
  // 		// initCorePhysicsDebug(this._PhysicsLib, object, this.scene());
  // 	}
  // }
  _findActorNode() {
    return this;
  }
  //
  // CHILDREN
  //
  // protected override _childrenControllerContext = NodeContext.JS;
  // override createNode<S extends keyof JsNodeChildrenMap>(
  // 	node_class: S,
  // 	options?: NodeCreateOptions
  // ): JsNodeChildrenMap[S];
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K;
  // override createNode<K extends valueof<JsNodeChildrenMap>>(
  // 	node_class: Constructor<K>,
  // 	options?: NodeCreateOptions
  // ): K {
  // 	return super.createNode(node_class, options) as K;
  // }
  // override children() {
  // 	return super.children() as BaseJsNodeType[];
  // }
  // override nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][] {
  // 	return super.nodesByType(type) as JsNodeChildrenMap[K][];
  // }
  // override childrenAllowed() {
  // 	return true;
  // }
}
