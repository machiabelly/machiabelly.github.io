"use strict";
import { BaseSDFGlNode } from "./_BaseSDF";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { JsType } from "../../poly/registers/nodes/types/Js";
var InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF"] = "sdf";
  InputName2["THICKNESS"] = "thickness";
  return InputName2;
})(InputName || {});
const DefaultValues = {
  thickness: 0.1
};
const OUTPUT_NAME = "sdf";
const ALLOWED_TYPES = [GlConnectionPointType.FLOAT, GlConnectionPointType.SDF_CONTEXT];
class SDFOnionGlParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SDFOnionGlParamsConfig();
export class SDFOnionGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.SDF_ONION;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  _glInputName(index) {
    return ["sdf" /* SDF */, "thickness" /* THICKNESS */][index];
  }
  _glOutputName(index) {
    return OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (!firstInputType || ALLOWED_TYPES.includes(firstInputType)) {
      firstInputType = GlConnectionPointType.FLOAT;
    }
    return [firstInputType, GlConnectionPointType.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const sdf = ThreeToGl.float(this.variableForInput("sdf" /* SDF */));
    const thickness = ThreeToGl.float(this.variableForInput("thickness" /* THICKNESS */));
    const firstInputType = this._expectedInputTypes()[0];
    const bodyLines = [];
    if (firstInputType == GlConnectionPointType.FLOAT) {
      const float = this.glVarName(OUTPUT_NAME);
      const bodyLine = `float ${float} = SDFOnion(${sdf}, ${thickness})`;
      bodyLines.push(bodyLine);
    } else {
      const sdfContext = this.glVarName(OUTPUT_NAME);
      const matId = `${sdf}.d`;
      const bodyLine = `SDFContext ${sdfContext} = SDFContext(SDFOnion(${sdf}.d, ${thickness}), 0, ${matId}, ${matId}, 0.)`;
      bodyLines.push(bodyLine);
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    BaseSDFGlNode.addSDFMethods(shadersCollectionController, this);
  }
}
