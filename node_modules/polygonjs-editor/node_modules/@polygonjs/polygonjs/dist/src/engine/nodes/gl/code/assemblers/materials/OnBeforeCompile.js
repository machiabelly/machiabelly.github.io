"use strict";
import { GlParamConfig } from "../../utils/GLParamConfig";
export function cloneOnBeforeCompileData(data, options) {
  const { clonedParamConfigName } = options;
  let { clonedParamConfig } = options;
  const json = OnBeforeCompileDataConverter.toJSON(data);
  const clonedData = OnBeforeCompileDataConverter.fromJSON(json);
  const preservedParamConfigs = data.paramConfigs.filter((p) => p.name() != clonedParamConfigName);
  if (!clonedParamConfig) {
    clonedParamConfig = clonedData.paramConfigs.find((p) => p.name() == clonedParamConfigName);
  }
  const paramConfigs = preservedParamConfigs;
  if (clonedParamConfig) {
    paramConfigs.push(clonedParamConfig);
  }
  return {
    ...clonedData,
    paramConfigs
  };
}
export function assignUniformViaUserData(material, uniformName, newUniform) {
  const uniforms = MaterialUserDataUniforms.getUniforms(material);
  if (uniforms) {
    const currentUniform = uniforms[uniformName];
    if (currentUniform) {
      currentUniform.value = newUniform.value;
    } else {
      uniforms[uniformName] = newUniform;
    }
  } else {
    OnBeforeCompileDataHandler.addAdditionalTexture(material, uniformName, newUniform);
  }
}
export class MaterialUserDataUniforms {
  static getUniforms(material) {
    var _a;
    return ((_a = material.userData) == null ? void 0 : _a.uniforms) || material.uniforms;
  }
  static setUniforms(material, uniforms) {
    material.userData.uniforms = uniforms;
  }
  static removeUniforms(material) {
    const uniforms = this.getUniforms(material);
    if (uniforms) {
      const userData = material.userData;
      delete userData["uniforms"];
    }
    return uniforms;
  }
}
export function assignOnBeforeCompileDataAndFunction(scene, material, data) {
  OnBeforeCompileDataHandler.setData(material, data);
  material.onBeforeCompile = _createOnBeforeCompile(scene, material);
  const key = `${material.uuid}:${performance.now()}`;
  material.customProgramCacheKey = () => key;
}
export function copyOnBeforeCompileData(scene, params) {
  const { src, dest, shareCustomUniforms } = params;
  const data = OnBeforeCompileDataHandler.getData(src);
  if (data) {
    let cloneData2 = function(data2) {
      const json = OnBeforeCompileDataConverter.toJSON(data2);
      return OnBeforeCompileDataConverter.fromJSON(json);
    };
    var cloneData = cloneData2;
    const newData = shareCustomUniforms ? data : cloneData2(data);
    assignOnBeforeCompileDataAndFunction(scene, dest, newData);
  }
}
function _createOnBeforeCompile(scene, material) {
  const onBeforeCompile = (shader) => {
    const data = OnBeforeCompileDataHandler.getData(material);
    if (!data) {
      return;
    }
    const {
      vertexShader,
      fragmentShader,
      paramConfigs,
      additionalTextureUniforms,
      timeDependent,
      resolutionDependent,
      raymarchingLightsWorldCoordsDependent
    } = data;
    shader.vertexShader = vertexShader;
    shader.fragmentShader = fragmentShader;
    scene.uniformsController.addUniforms(shader.uniforms, {
      paramConfigs,
      additionalTextureUniforms,
      timeDependent,
      resolutionDependent,
      raymarchingLightsWorldCoordsDependent
    });
    const shaderMaterial = material;
    shaderMaterial.vertexShader = shader.vertexShader;
    shaderMaterial.fragmentShader = shader.fragmentShader;
    MaterialUserDataUniforms.setUniforms(material, shader.uniforms);
  };
  return onBeforeCompile;
}
export class OnBeforeCompileDataHandler {
  static setData(material, data) {
    material.userData.onBeforeCompileData = data;
  }
  static addAdditionalTexture(material, uniformName, newUniform) {
    const data = this.getData(material);
    if (data) {
      const currentUniform = data.additionalTextureUniforms[uniformName];
      if (currentUniform == null) {
        data.additionalTextureUniforms[uniformName] = newUniform;
      }
    } else {
      console.warn("no data found on material", material);
    }
  }
  static getData(material) {
    return material.userData.onBeforeCompileData;
  }
  static removeData(material) {
    const data = this.getData(material);
    if (data) {
      const userData = material.userData;
      delete userData["onBeforeCompileData"];
    }
    return data;
  }
}
export class OnBeforeCompileDataConverter {
  static toJSON(onBeforeCompileData) {
    const onBeforeCompileDataJSON = {
      vertexShader: onBeforeCompileData.vertexShader,
      fragmentShader: onBeforeCompileData.fragmentShader,
      timeDependent: onBeforeCompileData.timeDependent,
      resolutionDependent: onBeforeCompileData.resolutionDependent,
      raymarchingLightsWorldCoordsDependent: onBeforeCompileData.raymarchingLightsWorldCoordsDependent,
      paramConfigs: onBeforeCompileData.paramConfigs.map((pc) => pc.toJSON())
    };
    return onBeforeCompileDataJSON;
  }
  static fromJSON(json) {
    const onBeforeCompileData = {
      ...json,
      additionalTextureUniforms: {},
      paramConfigs: json.paramConfigs.map((json2) => GlParamConfig.fromJSON(json2))
    };
    return onBeforeCompileData;
  }
}
