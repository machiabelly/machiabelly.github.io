"use strict";
import { TypedSopNode } from "./_Base";
import { NodeContext } from "../../poly/NodeContext";
import { InstanceSopOperation } from "../../operations/sop/Instance";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = InstanceSopOperation.DEFAULT_PARAMS;
class InstanceSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param attributes to copy to the instance */
    this.attributesToCopy = ParamConfig.STRING(DEFAULT.attributesToCopy);
    /** @param toggles on to apply a material. This is useful in most cases, but there may be situations where the material would be apply later, such as when you are feeding this node to a particles system */
    this.applyMaterial = ParamConfig.BOOLEAN(DEFAULT.applyMaterial);
    /** @param material to apply */
    this.material = ParamConfig.NODE_PATH("", {
      visibleIf: { applyMaterial: 1 },
      nodeSelection: {
        context: NodeContext.MAT
      },
      dependentOnFoundNode: false
    });
  }
}
const ParamsConfig = new InstanceSopParamsConfig();
export class InstanceSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.INSTANCE;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(2);
    this.io.inputs.initInputsClonedState(InstanceSopOperation.INPUT_CLONED_STATE);
  }
  async cook(inputCoreGroups) {
    this._operation = this._operation || new InstanceSopOperation(this.scene(), this.states, this);
    const coreGroup = await this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
}
