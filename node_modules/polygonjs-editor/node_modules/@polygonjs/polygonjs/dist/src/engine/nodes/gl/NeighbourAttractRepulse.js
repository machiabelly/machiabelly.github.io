"use strict";
import AttractRepulse from "./gl/neighbour/attractRepulse.glsl";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { ParamConfig, NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType, GlConnectionPoint } from "../utils/io/connections/Gl";
import { FunctionGLDefinition } from "./utils/GLDefinition";
const OUTPUT_NAME = "force";
const visibleIfRepulse = {
  visibleIf: { repulse: true }
};
const visibleIfAttract = {
  visibleIf: { attract: true }
};
class NeighbourAttractRepulseParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.positionAttribName = ParamConfig.STRING("position");
    this.position = ParamConfig.VECTOR3([0, 0, 0]);
    this.repulse = ParamConfig.BOOLEAN(1, {
      separatorBefore: true
    });
    this.repulseAmount = ParamConfig.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false],
      ...visibleIfRepulse
    });
    this.repulseMinDist = ParamConfig.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      ...visibleIfRepulse
    });
    this.repulseMaxDist = ParamConfig.FLOAT(2, {
      range: [0, 10],
      rangeLocked: [true, false],
      ...visibleIfRepulse
    });
    this.attract = ParamConfig.BOOLEAN(1, {
      separatorBefore: true
    });
    this.attractAmount = ParamConfig.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false],
      ...visibleIfAttract
    });
    this.attractStartDist = ParamConfig.FLOAT(3, {
      range: [0, 10],
      rangeLocked: [true, false],
      ...visibleIfAttract
    });
    this.attractMidDist = ParamConfig.FLOAT(4, {
      range: [0, 10],
      rangeLocked: [true, false],
      ...visibleIfAttract
    });
    this.attractEndDist = ParamConfig.FLOAT(5, {
      range: [0, 10],
      rangeLocked: [true, false],
      ...visibleIfAttract
    });
  }
}
const ParamsConfig = new NeighbourAttractRepulseParamsConfig();
export class NeighbourAttractRepulseGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "neighbourAttractRepulse";
  }
  initializeNode() {
    super.initializeNode();
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(OUTPUT_NAME, GlConnectionPointType.VEC3)
    ]);
  }
  setLines(shadersCollectionController) {
    const bodyLines = [];
    const position = ThreeToGl.vector3(this.variableForInputParam(this.p.position));
    const repulse = ThreeToGl.bool(this.variableForInputParam(this.p.repulse));
    const repulseAmount = ThreeToGl.float(this.variableForInputParam(this.p.repulseAmount));
    const repulseMinDist = ThreeToGl.float(this.variableForInputParam(this.p.repulseMinDist));
    const repulseMaxDist = ThreeToGl.float(this.variableForInputParam(this.p.repulseMaxDist));
    const attract = ThreeToGl.float(this.variableForInputParam(this.p.attract));
    const attractAmount = ThreeToGl.float(this.variableForInputParam(this.p.attractAmount));
    const attractStartDist = ThreeToGl.float(this.variableForInputParam(this.p.attractStartDist));
    const attractMidDist = ThreeToGl.float(this.variableForInputParam(this.p.attractMidDist));
    const attractEndDist = ThreeToGl.float(this.variableForInputParam(this.p.attractEndDist));
    const out = this.glVarName(OUTPUT_NAME);
    const assembler = shadersCollectionController.assembler();
    const globalsHandler = assembler.globalsHandler();
    if (!globalsHandler) {
      return;
    }
    if (globalsHandler.attribTextureData) {
      const globalsTextureHandler = globalsHandler;
      const textureData = globalsTextureHandler.attribTextureData(this.pv.positionAttribName);
      if (textureData) {
        const { textureName, component, uvName } = textureData;
        const args = [
          textureName,
          uvName,
          position,
          // repulse
          repulse,
          repulseAmount,
          repulseMinDist,
          repulseMaxDist,
          // attract
          attract,
          attractAmount,
          attractStartDist,
          attractMidDist,
          attractEndDist
        ].join(", ");
        const { functionName, functionDeclaration } = this._templateFlocking(component);
        shadersCollectionController.addDefinitions(this, [new FunctionGLDefinition(this, functionDeclaration)]);
        bodyLines.push(`vec3 ${out} = ${functionName}(${args})`);
      }
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
  }
  _templateFlocking(component) {
    const functionName = `flocking${this.graphNodeId()}`;
    const functionDeclaration = AttractRepulse.replace("__FUNCTION__NAME__", functionName).replace(
      "__COMPONENT__",
      component
    );
    return {
      functionName,
      functionDeclaration
    };
  }
}
