"use strict";
import { TypedParam } from "./_Base";
import { FloatParam } from "./Float";
import { ParamEvent } from "../poly/ParamEvent";
import { CoreType } from "../../core/Type";
export class TypedMultipleParam extends TypedParam {
  constructor() {
    super(...arguments);
    this._components_contructor = FloatParam;
    this._componentsCount = 0;
  }
  get components() {
    return this._components;
  }
  isNumeric() {
    return true;
  }
  isDefault() {
    for (const c of this.components) {
      if (!c.isDefault()) {
        return false;
      }
    }
    return true;
  }
  rawInput() {
    return this._components.map((c) => c.rawInput());
  }
  rawInputSerialized() {
    return this._components.map((c) => c.rawInputSerialized());
  }
  _copyValue(param) {
    for (let i = 0; i < this.components.length; i++) {
      const component = this.components[i];
      const src_component = param.components[i];
      component.copyValue(src_component);
    }
  }
  initComponents() {
    var _a;
    if (this._components != null) {
      return;
    }
    let index = 0;
    this._components = new Array(this.componentNames().length);
    for (const componentName of this.componentNames()) {
      const component = new this._components_contructor(this.scene(), this.node, {
        serializerClass: (_a = this._serializer) == null ? void 0 : _a.constructor
      });
      let default_val;
      if (CoreType.isArray(this._default_value)) {
        default_val = this._default_value[index];
      } else {
        default_val = this._default_value[componentName];
      }
      component.options.copy(this.options);
      component.setInitValue(default_val);
      component.setName(`${this.name()}${componentName}`);
      component.set_parent_param(this);
      this._components[index] = component;
      index++;
    }
    this._componentsCount = this._components.length;
  }
  async processComputation() {
    await this.computeComponents();
    this.setValueFromComponents();
  }
  // set_raw_input_from_components() {}
  hasExpression() {
    var _a;
    for (const c of this.components) {
      if ((_a = c.expressionController) == null ? void 0 : _a.active()) {
        return true;
      }
    }
    return false;
  }
  // private _promises:Promise<void>[] = [];
  async computeComponents() {
    const components = this.components;
    for (const c of components) {
      if (c.isDirty()) {
        await c.compute();
      }
    }
    this.removeDirtyState();
  }
  _prefilterInvalidRawInput(raw_input) {
    if (!CoreType.isArray(raw_input)) {
      const numberOrString = raw_input;
      const raw_input_wrapped_in_array = this.componentNames().map(() => numberOrString);
      return raw_input_wrapped_in_array;
    } else {
      return raw_input;
    }
  }
  processRawInput() {
    const cooker = this.scene().cooker;
    cooker.block();
    const components = this.components;
    for (const c of components) {
      c.emitController.blockParentEmit();
    }
    const value = this._raw_input;
    let prevValue = 0;
    if (CoreType.isArray(value)) {
      for (let i = 0; i < this._componentsCount; i++) {
        let componentValue = value[i];
        if (componentValue == null) {
          componentValue = prevValue;
        }
        components[i].set(componentValue);
        prevValue = componentValue;
      }
    } else {
      for (let i = 0; i < this._componentsCount; i++) {
        const componentName = this.componentNames()[i];
        let componentValue = value[componentName];
        if (componentValue == null) {
          componentValue = prevValue;
        }
        components[i].set(componentValue);
        prevValue = componentValue;
      }
    }
    cooker.unblock();
    for (const component of this.components) {
      component.emitController.unblockParentEmit();
    }
    this.emitController.emit(ParamEvent.VALUE_UPDATED);
  }
}
