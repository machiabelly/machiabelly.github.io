"use strict";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { GlConnectionPointType, GlConnectionPoint } from "../utils/io/connections/Gl";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
class FloatToVec2GlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.x = ParamConfig.FLOAT(0);
    this.y = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig2 = new FloatToVec2GlParamsConfig();
const _FloatToVec2GlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig2;
  }
  static type() {
    return "floatToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_FloatToVec2GlNode.OUTPUT_NAME, GlConnectionPointType.VEC2)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = this.variableForInputParam(this.p.x);
    const y = this.variableForInputParam(this.p.y);
    const vec = this.glVarName(_FloatToVec2GlNode.OUTPUT_NAME);
    const body_line = `vec2 ${vec} = ${ThreeToGl.float2(x, y)}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
};
export let FloatToVec2GlNode = _FloatToVec2GlNode;
FloatToVec2GlNode.OUTPUT_NAME = "vec2";
class FloatToVec3GlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.x = ParamConfig.FLOAT(0);
    this.y = ParamConfig.FLOAT(0);
    this.z = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig3 = new FloatToVec3GlParamsConfig();
const _FloatToVec3GlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig3;
  }
  static type() {
    return "floatToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_FloatToVec3GlNode.OUTPUT_NAME, GlConnectionPointType.VEC3)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = this.variableForInputParam(this.p.x);
    const y = this.variableForInputParam(this.p.y);
    const z = this.variableForInputParam(this.p.z);
    const vec = this.glVarName(_FloatToVec3GlNode.OUTPUT_NAME);
    const body_line = `vec3 ${vec} = ${ThreeToGl.float3(x, y, z)}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
};
export let FloatToVec3GlNode = _FloatToVec3GlNode;
FloatToVec3GlNode.OUTPUT_NAME = "vec3";
class FloatToVec4GlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.x = ParamConfig.FLOAT(0);
    this.y = ParamConfig.FLOAT(0);
    this.z = ParamConfig.FLOAT(0);
    this.w = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig4 = new FloatToVec4GlParamsConfig();
const _FloatToVec4GlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig4;
  }
  static type() {
    return "floatToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint(_FloatToVec4GlNode.OUTPUT_NAME, GlConnectionPointType.VEC4)
    ]);
  }
  setLines(shaders_collection_controller) {
    const x = this.variableForInputParam(this.p.x);
    const y = this.variableForInputParam(this.p.y);
    const z = this.variableForInputParam(this.p.z);
    const w = this.variableForInputParam(this.p.w);
    const vec = this.glVarName(_FloatToVec4GlNode.OUTPUT_NAME);
    const body_line = `vec4 ${vec} = ${ThreeToGl.float4(x, y, z, w)}`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
};
export let FloatToVec4GlNode = _FloatToVec4GlNode;
FloatToVec4GlNode.OUTPUT_NAME = "vec4";
