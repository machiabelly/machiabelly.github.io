"use strict";
import { MouseButton, MouseButtons } from "../../../../../core/MouseButton";
import { TypeAssert } from "../../../../poly/Assert";
export function hasCPUOptions(optionsList) {
  for (const options of optionsList) {
    if (options.cpu != null) {
      return true;
    }
  }
  return false;
}
export function hasGPUOptions(optionsList) {
  for (const options of optionsList) {
    if (options.gpu != null) {
      return true;
    }
  }
  return false;
}
export function GPUOptionsDepthBufferRequired(optionsList) {
  for (const options of optionsList) {
    if (options.gpu != null && options.gpu.worldPosMaterial == null) {
      return true;
    }
  }
  return false;
}
function _cpuOptionsEqual(options1, options2) {
  return options1.traverseChildren == options2.traverseChildren && options1.pointsThreshold == options2.pointsThreshold && options1.lineThreshold == options2.lineThreshold;
}
export function CPUOptionsEqual(optionsList) {
  let firstCPUOptions;
  for (const options of optionsList) {
    if (options.cpu != null) {
      if (firstCPUOptions == null) {
        firstCPUOptions = options.cpu;
      } else {
        if (!_cpuOptionsEqual(firstCPUOptions, options.cpu)) {
          return false;
        }
      }
    }
  }
  return true;
}
export function CPUOptionsMax(optionsList, target) {
  target.traverseChildren = false;
  target.pointsThreshold = -1;
  target.lineThreshold = -1;
  for (const options of optionsList) {
    if (options.cpu != null) {
      if (target.traverseChildren == false && options.cpu.traverseChildren == true) {
        target.traverseChildren = options.cpu.traverseChildren;
      }
      if (target.pointsThreshold < options.cpu.pointsThreshold) {
        target.pointsThreshold = options.cpu.pointsThreshold;
      }
      if (target.lineThreshold < options.cpu.lineThreshold) {
        target.lineThreshold = options.cpu.lineThreshold;
      }
    }
  }
  return target;
}
export var Status = /* @__PURE__ */ ((Status2) => {
  Status2[Status2["REQUIRED"] = 0] = "REQUIRED";
  Status2[Status2["OPTIONAL"] = 1] = "OPTIONAL";
  Status2[Status2["FORBIDDEN"] = 2] = "FORBIDDEN";
  return Status2;
})(Status || {});
export const STATUS_OPTIONS = [0 /* REQUIRED */, 1 /* OPTIONAL */, 2 /* FORBIDDEN */];
export const STATUS_OPTION_LABEL = ["required", "optional", "forbidden"];
export const DEFAULT_STATUS_OPTION = STATUS_OPTIONS.indexOf(1 /* OPTIONAL */);
export const STATUS_MENU_OPTIONS = {
  menu: {
    entries: STATUS_OPTIONS.map((value) => ({
      value,
      name: STATUS_OPTION_LABEL[value]
    }))
  }
};
function statusMatch(modifierProperty, value) {
  switch (modifierProperty) {
    case 0 /* REQUIRED */: {
      return value == true;
    }
    case 1 /* OPTIONAL */: {
      return true;
    }
    case 2 /* FORBIDDEN */: {
      return value == false;
    }
  }
  TypeAssert.unreachable(modifierProperty);
}
export function propertyMatchesButtonConfig(propertyConfig, buttonConfig) {
  switch (buttonConfig.button) {
    case MouseButton.LEFT: {
      if (propertyConfig.button.left == false) {
        return false;
      }
      break;
    }
    case MouseButton.MIDDLE: {
      if (propertyConfig.button.middle == false) {
        return false;
      }
      break;
    }
    case MouseButton.RIGHT: {
      if (propertyConfig.button.right == false) {
        return false;
      }
      break;
    }
  }
  return statusMatch(propertyConfig.modifier.ctrl, buttonConfig.ctrl) && statusMatch(propertyConfig.modifier.shift, buttonConfig.shift) && statusMatch(propertyConfig.modifier.alt, buttonConfig.alt);
}
export function propertyMatchesButtonsConfig(propertyConfig, buttonsConfig) {
  switch (buttonsConfig.buttons) {
    case MouseButtons.LEFT: {
      if (propertyConfig.button.left == 2 /* FORBIDDEN */ || propertyConfig.button.middle == 0 /* REQUIRED */ || propertyConfig.button.right == 0 /* REQUIRED */) {
        return false;
      }
      break;
    }
    case MouseButtons.MIDDLE: {
      if (propertyConfig.button.left == 0 /* REQUIRED */ || propertyConfig.button.middle == 2 /* FORBIDDEN */ || propertyConfig.button.right == 0 /* REQUIRED */) {
        return false;
      }
      break;
    }
    case MouseButtons.RIGHT: {
      if (propertyConfig.button.left == 0 /* REQUIRED */ || propertyConfig.button.middle == 0 /* REQUIRED */ || propertyConfig.button.right == 2 /* FORBIDDEN */) {
        return false;
      }
      break;
    }
    case MouseButtons.LEFT_RIGHT: {
      if (propertyConfig.button.left == 2 /* FORBIDDEN */ || propertyConfig.button.middle == 0 /* REQUIRED */ || propertyConfig.button.right == 2 /* FORBIDDEN */) {
        return false;
      }
      break;
    }
    case MouseButtons.LEFT_MIDDLE: {
      if (propertyConfig.button.left == 2 /* FORBIDDEN */ || propertyConfig.button.middle == 2 /* FORBIDDEN */ || propertyConfig.button.right == 0 /* REQUIRED */) {
        return false;
      }
      break;
    }
    case MouseButtons.MIDDLE_RIGHT: {
      if (propertyConfig.button.left == 0 /* REQUIRED */ || propertyConfig.button.middle == 2 /* FORBIDDEN */ || propertyConfig.button.right == 2 /* FORBIDDEN */) {
        return false;
      }
      break;
    }
    case MouseButtons.LEFT_MIDDLE_RIGHT: {
      if (propertyConfig.button.left == 2 /* FORBIDDEN */ || propertyConfig.button.middle == 2 /* FORBIDDEN */ || propertyConfig.button.right == 2 /* FORBIDDEN */) {
        return false;
      }
      break;
    }
  }
  return statusMatch(propertyConfig.modifier.ctrl, buttonsConfig.ctrl) && statusMatch(propertyConfig.modifier.shift, buttonsConfig.shift) && statusMatch(propertyConfig.modifier.alt, buttonsConfig.alt);
}
function propertiesMatchesButtonConfig(propertiesList, buttonConfig) {
  for (const properties of propertiesList) {
    if (propertyMatchesButtonConfig(properties.config, buttonConfig)) {
      return true;
    }
  }
  return false;
}
function propertiesMatchesButtonsConfig(propertiesList, buttonConfig) {
  for (const properties of propertiesList) {
    if (propertyMatchesButtonsConfig(properties.config, buttonConfig)) {
      return true;
    }
  }
  return false;
}
export function buttonConfigFromEvent(event, target) {
  target.button = event.button || MouseButton.LEFT;
  target.ctrl = event.ctrlKey;
  target.shift = event.shiftKey;
  target.alt = event.altKey;
}
export function buttonsConfigFromEvent(event, target) {
  target.buttons = event.buttons || MouseButtons.LEFT;
  target.ctrl = event.ctrlKey;
  target.shift = event.shiftKey;
  target.alt = event.altKey;
}
const _buttonConfig = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
const _buttonsConfig = { buttons: MouseButtons.LEFT, ctrl: false, shift: false, alt: false };
export function filterObjectsWithMatchButtonConfig(event, objects, propertiesListByObject, target) {
  target.length = 0;
  buttonConfigFromEvent(event, _buttonConfig);
  for (const object of objects) {
    const propertiesList = propertiesListByObject.get(object);
    if (propertiesList) {
      if (propertiesMatchesButtonConfig(propertiesList, _buttonConfig)) {
        target.push(object);
      }
    }
  }
}
export function filterObjectsWithMatchButtonsConfig(event, objects, propertiesListByObject, target) {
  target.length = 0;
  buttonsConfigFromEvent(event, _buttonsConfig);
  for (const object of objects) {
    const propertiesList = propertiesListByObject.get(object);
    if (propertiesList) {
      if (propertiesMatchesButtonsConfig(propertiesList, _buttonsConfig)) {
        target.push(object);
      }
    }
  }
}
