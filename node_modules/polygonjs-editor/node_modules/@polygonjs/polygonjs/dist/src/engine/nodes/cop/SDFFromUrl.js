"use strict";
import { SDFLoader } from "./../../../core/loader/geometry/SDF";
import { TypedCopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CopType } from "../../poly/registers/nodes/types/Cop";
import { EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT } from "../../../core/loader/FileExtensionRegister";
import { NodeContext } from "../../poly/NodeContext";
class SDFFromUrlCopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param url to fetch the image from */
    this.url = ParamConfig.STRING("", {
      fileBrowse: { extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.COP][CopType.SDF_FROM_URL] }
    });
    /** @param reload */
    this.reload = ParamConfig.BUTTON(null, {
      callback: (node) => {
        SDFFromUrlCopNode.PARAM_CALLBACK_reload(node);
      }
    });
    /** @param resolution */
    this.resolution = ParamConfig.VECTOR3([-1, -1, -1], {
      cook: false,
      editable: false,
      separatorBefore: true
    });
    /** @param boundMin */
    this.boundMin = ParamConfig.VECTOR3([-1, -1, -1], {
      cook: false,
      editable: false
    });
    /** @param boundMax */
    this.boundMax = ParamConfig.VECTOR3([1, 1, 1], {
      cook: false,
      editable: false
    });
  }
}
const ParamsConfig = new SDFFromUrlCopParamsConfig();
export class SDFFromUrlCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return CopType.SDF_FROM_URL;
  }
  async cook(inputContents) {
    const url = this.pv.url;
    const loader = new SDFLoader(url, this);
    loader.load(
      (texture) => {
        const dataContainer = texture.image;
        this.scene().batchUpdates(() => {
          this.p.resolution.set([
            dataContainer.resolutionx,
            dataContainer.resolutiony,
            dataContainer.resolutionz
          ]);
          this.p.boundMin.set([dataContainer.boundMinx, dataContainer.boundMiny, dataContainer.boundMinz]);
          this.p.boundMax.set([dataContainer.boundMaxx, dataContainer.boundMaxy, dataContainer.boundMaxz]);
        });
        this.setTexture(texture);
      },
      () => {
      },
      (err) => {
        this.states.error.set(err.message || "loading failed");
      }
    );
  }
  /*
   *
   * CALLBACK
   *
   */
  static PARAM_CALLBACK_reload(node) {
    node.p.url.setDirty();
  }
}
