"use strict";
import { BasePersistedConfig } from "../../../../utils/BasePersistedConfig";
import { TextureAllocationsController } from "../../utils/TextureAllocationsController";
import { ShaderMaterial } from "three";
export class ParticlesPersistedConfig extends BasePersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
  async toData() {
    const assemblerController = this.node.assemblerController();
    if (!assemblerController) {
      return;
    }
    const shaders_by_name = {};
    const node_shaders_by_name = this.node.shadersByName();
    node_shaders_by_name.forEach((shader, shader_name) => {
      shaders_by_name[shader_name] = shader;
    });
    const texture_allocations_data = assemblerController.assembler.textureAllocationsController().toJSON(this.node.scene());
    const param_uniform_pairs = [];
    const uniforms_owner = new ShaderMaterial();
    const param_configs = assemblerController.assembler.param_configs();
    for (const param_config of param_configs) {
      param_uniform_pairs.push([param_config.name(), param_config.uniformName()]);
      uniforms_owner.uniforms[param_config.uniformName()] = param_config.uniform();
    }
    const material_data = this._materialToJson(uniforms_owner, {
      node: this.node,
      suffix: "main"
    });
    const data = {
      texture_allocations: texture_allocations_data,
      param_uniform_pairs,
      uniforms_owner: material_data || {},
      shaders: shaders_by_name
    };
    return data;
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    this._loaded_data = data;
    this.node.init_with_persisted_config();
  }
  loaded_data() {
    return this._loaded_data;
  }
  shaders_by_name() {
    if (this._loaded_data) {
      const shaders_by_name = /* @__PURE__ */ new Map();
      const shaders = this._loaded_data.shaders;
      if (shaders) {
        const shader_names = Object.keys(shaders);
        for (const shader_name of shader_names) {
          shaders_by_name.set(shader_name, shaders[shader_name]);
        }
      }
      return shaders_by_name;
    }
  }
  texture_allocations_controller() {
    if (this._loaded_data) {
      return TextureAllocationsController.fromJSON(this._loaded_data.texture_allocations);
    }
  }
  uniforms() {
    if (this._loaded_data) {
      const uniforms_owner = this._loadMaterial(this._loaded_data.uniforms_owner);
      const uniforms = (uniforms_owner == null ? void 0 : uniforms_owner.uniforms) || {};
      return uniforms;
    }
  }
}
