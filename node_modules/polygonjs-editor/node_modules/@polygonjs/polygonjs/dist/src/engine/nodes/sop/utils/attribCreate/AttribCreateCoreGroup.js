"use strict";
import { COMPONENT_NAMES, vectorByAttribSize } from "./Common";
import { AttribType } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
export async function addCoreGroupAttribute(attribType, coreGroup, params, pv) {
  switch (attribType) {
    case AttribType.NUMERIC:
      await _addNumericAttributeToCoreGroup(coreGroup, params, pv);
      return;
    case AttribType.STRING:
      await _addStringAttributeToCoreGroup(coreGroup, params, pv);
      return;
  }
  TypeAssert.unreachable(attribType);
}
async function _addNumericAttributeToCoreGroup(coreGroup, params, pv) {
  const param = [params.value1, params.value2, params.value3, params.value4][pv.size - 1];
  const attribName = pv.name;
  if (param.hasExpression()) {
    if (pv.size == 1) {
      if (param.expressionController) {
        if (param.expressionController.entitiesDependent()) {
          await param.expressionController.computeExpressionForCoreGroup(coreGroup, (coreGroup2, value) => {
            coreGroup2.setAttribValue(attribName, value);
          });
        } else {
          coreGroup.setAttribValue(attribName, param.value);
        }
      }
    } else {
      const vparam = [params.value2, params.value3, params.value4][pv.size - 2];
      let components = vparam.components;
      let valuesByCoreObjectIndex = /* @__PURE__ */ new Map();
      const initVector = vectorByAttribSize(pv.size);
      if (initVector) {
        valuesByCoreObjectIndex.set(coreGroup.index(), initVector.clone());
        for (let componentIndex = 0; componentIndex < components.length; componentIndex++) {
          const component_param = components[componentIndex];
          const component_name = COMPONENT_NAMES[componentIndex];
          if (component_param.hasExpression() && component_param.expressionController && component_param.expressionController.entitiesDependent()) {
            await component_param.expressionController.computeExpressionForCoreGroup(
              coreGroup,
              (coreGroup2, value2) => {
                const vector = valuesByCoreObjectIndex.get(coreGroup2.index());
                vector[component_name] = value2;
              }
            );
          } else {
            const vector = valuesByCoreObjectIndex.get(coreGroup.index());
            vector[component_name] = component_param.value;
          }
        }
        const value = valuesByCoreObjectIndex.get(coreGroup.index());
        if (value != null) {
          coreGroup.setAttribValue(attribName, value);
        }
      }
    }
  } else {
  }
}
async function _addStringAttributeToCoreGroup(coreGroup, params, pv) {
  const param = params.string;
  const attribName = pv.name;
  if (param.hasExpression() && param.expressionController) {
    if (param.expressionController.entitiesDependent()) {
      await param.expressionController.computeExpressionForCoreGroup(coreGroup, (coreGroup2, value) => {
        coreGroup2.setAttribValue(attribName, value);
      });
    } else {
      coreGroup.setAttribValue(attribName, param.value);
    }
  } else {
  }
}
