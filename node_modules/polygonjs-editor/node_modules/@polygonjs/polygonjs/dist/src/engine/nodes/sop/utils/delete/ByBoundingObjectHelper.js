"use strict";
import { Vector3, Raycaster, Box3 } from "three";
import { MatDoubleSideTmpSetter } from "../../../../../core/render/MatDoubleSideTmpSetter";
const UP = new Vector3(0, 1, 0);
const DOWN = new Vector3(0, -1, 0);
const _pointPosition = new Vector3();
const _bbox = new Box3();
const _raycaster = new Raycaster();
const _intersections = [];
export class ByBoundingObjectHelper {
  constructor(node) {
    this.node = node;
    this._matDoubleSideTmpSetter = new MatDoubleSideTmpSetter();
  }
  evalForEntities(points, coreGroup2) {
    if (!coreGroup2) {
      return;
    }
    const boundingObject = coreGroup2 == null ? void 0 : coreGroup2.threejsObjectsWithGeo()[0];
    if (!boundingObject) {
      return;
    }
    const mesh = boundingObject;
    if (!mesh.isMesh) {
      return;
    }
    this._matDoubleSideTmpSetter.setCoreGroupMaterialDoubleSided(coreGroup2);
    _bbox.setFromObject(boundingObject);
    for (const point of points) {
      point.position(_pointPosition);
      if (_bbox.containsPoint(_pointPosition)) {
        if (this._isPositionInObject(_pointPosition, mesh, UP) && this._isPositionInObject(_pointPosition, mesh, DOWN)) {
          this.node.entitySelectionHelper.select(point);
        }
      }
    }
    this._matDoubleSideTmpSetter.restoreMaterialSideProperty(coreGroup2);
  }
  _isPositionInObject(point, object, raydir) {
    var _a;
    _raycaster.ray.direction.copy(raydir);
    _raycaster.ray.origin.copy(point);
    _intersections.length = 0;
    const intersections = _raycaster.intersectObject(object, false, _intersections);
    if (!intersections) {
      return false;
    }
    if (intersections.length == 0) {
      return false;
    }
    const intersection = intersections[0];
    const normal = (_a = intersection.face) == null ? void 0 : _a.normal;
    if (!normal) {
      return false;
    }
    const dot = _raycaster.ray.direction.dot(normal);
    return dot >= 0;
  }
}
