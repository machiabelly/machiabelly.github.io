"use strict";
import { CoreGraphNode } from "../../core/graph/CoreGraphNode";
import { UIData } from "./utils/UIData";
import { FlagsControllerD } from "./utils/FlagsController";
import { NodeStatesController } from "./utils/StatesController";
import { HierarchyParentController } from "./utils/hierarchy/ParentController";
import { HierarchyChildrenController } from "./utils/hierarchy/ChildrenController";
import { NodeLifeCycleController } from "./utils/LifeCycleController";
import { TypedContainerController } from "./utils/ContainerController";
import { NodeCookController } from "./utils/CookController";
import { NameController } from "./utils/NameController";
import { ParamsController } from "./utils/params/ParamsController";
import { ParamsValueAccessor } from "./utils/params/ParamsValueAccessor";
import { IOController } from "./utils/io/IOController";
import { ParamsAccessor } from "./utils/params/ParamsAccessor";
import { EventDispatcher } from "three";
const ANY_STRING = "any-string";
export const DEFAULT_DATA_TYPE = "default";
export class TypedNode extends CoreGraphNode {
  // get processing_context(): ProcessingContext {
  // 	return (this._processing_context = this._processing_context || new ProcessingContext(this));
  // }
  constructor(scene, nodeName = "BaseNode", createOptions) {
    super(scene, nodeName);
    this.createOptions = createOptions;
    this.containerController = new TypedContainerController(this);
    this.pv = new ParamsValueAccessor();
    // readonly pv: ParamsValueAccessor<K> = new ParamsValueAccessor<K>(this);
    this.p = new ParamsAccessor();
    this._initialized = false;
    const serializerClass = createOptions == null ? void 0 : createOptions.serializerClass;
    if (serializerClass) {
      this._serializer = new serializerClass(this);
    }
  }
  copy_param_values(node) {
    const non_spare = this.params.non_spare;
    for (const param of non_spare) {
      const other_param = node.params.get(param.name());
      if (other_param) {
        param.copyValue(other_param);
      }
    }
  }
  dataType() {
    return DEFAULT_DATA_TYPE;
  }
  get parentController() {
    return this._parentController = this._parentController || new HierarchyParentController(this);
  }
  static displayedInputNames() {
    return void 0;
  }
  displayedInputNames() {
    return this.constructor.displayedInputNames();
  }
  childrenControllerContext() {
    return this._childrenControllerContext;
  }
  _create_childrenController() {
    if (this._childrenControllerContext) {
      return new HierarchyChildrenController(this, this._childrenControllerContext);
    }
  }
  get childrenController() {
    return this._childrenController = this._childrenController || this._create_childrenController();
  }
  childrenAllowed() {
    return this._childrenControllerContext != null;
  }
  sceneReadonly() {
    return false;
  }
  get uiData() {
    return this._uiData = this._uiData || new UIData(this);
  }
  get states() {
    return this._states = this._states || new NodeStatesController(this);
  }
  get lifecycle() {
    return this._lifecycle = this._lifecycle || new NodeLifeCycleController(this);
  }
  get serializer() {
    return this._serializer;
  }
  get cookController() {
    return this._cookController = this._cookController || new NodeCookController(this);
  }
  get io() {
    return this._io = this._io || new IOController(this);
  }
  get nameController() {
    return this._nameController = this._nameController || new NameController(this);
  }
  /**
   * sets the name of a node. Note that if a sibling node already has that name, it will be updated to be unique.
   *
   */
  setName(name) {
    this.nameController.setName(name);
  }
  _setCoreName(name) {
    this._name = name;
  }
  get params() {
    return this._paramsController = this._paramsController || new ParamsController(this);
  }
  initializeBaseAndNode() {
    var _a;
    if (!this._initialized) {
      this._initialized = true;
      (_a = this.displayNodeController) == null ? void 0 : _a.initializeNode();
      this.initializeBaseNode();
      this.initializeNode();
      if (this.polyNodeController) {
        this.polyNodeController.initializeNode();
      }
    } else {
      console.warn("node already initialized");
    }
  }
  initializeBaseNode() {
  }
  initializeNode() {
  }
  static type() {
    throw "type to be overriden";
  }
  /**
   * returns the type of the node.
   *
   */
  type() {
    const c = this.constructor;
    return c.type();
  }
  static context() {
    console.error("node has no node_context", this);
    throw "context requires override";
  }
  /**
   * returns the context.
   *
   */
  context() {
    const c = this.constructor;
    return c.context();
  }
  static requireWebGL2() {
    return false;
  }
  requireWebGL2() {
    const c = this.constructor;
    return c.requireWebGL2();
  }
  setParent(parent) {
    this.parentController.setParent(parent);
  }
  /**
   * returns the parent.
   *
   */
  parent() {
    return this.parentController.parent();
  }
  insideALockedParent() {
    return this.lockedParent() != null;
  }
  lockedOrInsideALockedParent() {
    var _a;
    return ((_a = this.polyNodeController) == null ? void 0 : _a.locked()) || this.insideALockedParent();
  }
  selfOrLockedParent() {
    var _a;
    if ((_a = this.polyNodeController) == null ? void 0 : _a.locked()) {
      return this;
    }
    return this.lockedParent();
  }
  lockedParent() {
    const parent = this.parent();
    if (!parent) {
      return null;
    }
    if (parent.polyNodeController && parent.polyNodeController.locked()) {
      return parent;
    }
    return parent.lockedParent();
  }
  firstAncestorWithContext(context) {
    return this.parentController.firstAncestorWithContext(context);
  }
  root() {
    return this._scene.root();
  }
  /**
   * returns the path.
   *
   */
  path(relative_to_parent) {
    return this.parentController.path(relative_to_parent);
  }
  // params
  createParams() {
  }
  addParam(type, name, default_value, options) {
    var _a;
    return (_a = this._paramsController) == null ? void 0 : _a.addParam(type, name, default_value, options);
  }
  paramDefaultValue(name) {
    return null;
  }
  // cook
  cook(inputContents) {
    return null;
  }
  /**
   * registers a callback that will be run every time the node finishes cooking.
   *
   */
  onCookEnd(callbackName, callback) {
    this.cookController.registerOnCookEnd(callbackName, callback);
  }
  /**
   * returns a promise that will be resolved when the node finishes cooking.
   *
   */
  async compute() {
    var _a, _b;
    if (this.isDirty() || ((_b = (_a = this.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
      return await this.containerController.compute();
    } else {
      return this.containerController.container();
    }
  }
  _setContainer(content) {
    this.containerController.container().set_content(content);
    this.cookController.endCook(
      /*message*/
    );
  }
  /**
   * create a node.
   *
   */
  createNode(nodeClass, options) {
    var _a;
    return (_a = this.childrenController) == null ? void 0 : _a.createNode(nodeClass, options);
  }
  createOperationContainer(type, operation_container_name, options) {
    var _a;
    return (_a = this.childrenController) == null ? void 0 : _a.createOperationContainer(type, operation_container_name, options);
  }
  /**
   * removes a child node
   *
   */
  removeNode(node) {
    var _a;
    (_a = this.childrenController) == null ? void 0 : _a.removeNode(node);
  }
  dispose() {
    super.dispose();
    this.setParent(null);
    if (this._nameController) {
      this._nameController.dispose();
      this._nameController = void 0;
    }
    if (this._io) {
      this._io.dispose();
      this._io = void 0;
    }
    if (this._lifecycle) {
      this._lifecycle.dispose();
      this._lifecycle = void 0;
    }
    if (this.displayNodeController) {
      this.displayNodeController.dispose();
    }
    if (this._childrenController) {
      this._childrenController.dispose();
      this._childrenController = void 0;
    }
    if (this._paramsController) {
      this._paramsController.dispose();
      this._paramsController = void 0;
    }
    if (this._cookController) {
      this._cookController.dispose();
      this._cookController = void 0;
    }
    if (this._serializer) {
      this._serializer.dispose();
      this._serializer = void 0;
    }
    if (this._uiData) {
      this._uiData.dispose();
      this._uiData = void 0;
    }
  }
  /**
   * returns the list of children
   *
   */
  children() {
    var _a;
    return ((_a = this.childrenController) == null ? void 0 : _a.children()) || [];
  }
  /**
   * returns a child node
   *
   */
  node(path) {
    var _a;
    return ((_a = this.parentController) == null ? void 0 : _a.findNode(path)) || null;
  }
  /**
   * returns a sibling node
   *
   */
  nodeSibling(name) {
    var _a;
    const parent = this.parent();
    if (parent) {
      const node = (_a = parent.childrenController) == null ? void 0 : _a.childByName(name);
      if (node) {
        return node;
      }
    }
    return null;
  }
  /**
   * returns the children matching the type
   *
   */
  nodesByType(type) {
    var _a;
    return ((_a = this.childrenController) == null ? void 0 : _a.nodesByType(type)) || [];
  }
  /**
   * sets a node as input
   *
   */
  setInput(inputIndexOrName, node, outputIndexOrName, options) {
    this.io.inputs.setInput(inputIndexOrName, node, outputIndexOrName, options);
  }
  emit(event_name, data = null) {
    this.scene().dispatchController.dispatch(this, event_name, data);
  }
  _eventsDispatcher() {
    return this.__eventsDispatcher = this.__eventsDispatcher || new EventDispatcher();
  }
  dispatchEvent(event) {
    this._eventsDispatcher().dispatchEvent(event);
  }
  addEventListener(type, listener) {
    this._eventsDispatcher().addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this._eventsDispatcher().removeEventListener(type, listener);
  }
  // serializer
  toJSON(includeParamComponents = false) {
    if (!this._serializer) {
      return;
    }
    return this._serializer.toJSON(includeParamComponents);
  }
  // modules
  requiredModules() {
  }
  usedAssembler() {
  }
  integrationData() {
  }
  // error processing
  processError(e) {
    return e;
  }
  updateObjectOnAdd(object, parent) {
  }
  updateObjectOnRemove(object, parent) {
  }
}
export class BaseNodeClass extends TypedNode {
}
export class BaseNodeClassWithDisplayFlag extends TypedNode {
  constructor() {
    super(...arguments);
    this.flags = new FlagsControllerD(this);
  }
}
