"use strict";
import { TypedAudioNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { AudioBuilder } from "../../../core/audio/AudioBuilder";
import { UserMedia } from "tone/build/esm/source/UserMedia";
import { isBooleanTrue } from "../../../core/Type";
class UserMediaAudioParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.autostart = ParamConfig.BOOLEAN(1);
    /** @param play the audio */
    this.open = ParamConfig.BUTTON(null, {
      callback: (node) => {
        UserMediaAudioNode.PARAM_CALLBACK_open(node);
      }
    });
    /** @param stop the audio */
    this.close = ParamConfig.BUTTON(null, {
      callback: (node) => {
        UserMediaAudioNode.PARAM_CALLBACK_close(node);
      }
    });
  }
}
const ParamsConfig = new UserMediaAudioParamsConfig();
export class UserMediaAudioNode extends TypedAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "userMedia";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  async cook(inputContents) {
    const audioBuilder = new AudioBuilder();
    const userMedia = this._userMedia();
    if (isBooleanTrue(this.pv.autostart)) {
      await userMedia.open();
    }
    audioBuilder.setSource(userMedia);
    this.setAudioBuilder(audioBuilder);
  }
  _userMedia() {
    return this.__userMedia__ = this.__userMedia__ || this._createEffect();
  }
  _createEffect() {
    return new UserMedia();
  }
  async open() {
    return await this._userMedia().open();
  }
  close() {
    this._userMedia().close();
  }
  /*
   * STATIC CALLBACKS
   */
  static PARAM_CALLBACK_open(node) {
    node.open();
  }
  static PARAM_CALLBACK_close(node) {
    node.close();
  }
}
