"use strict";
import { CoreType } from "./../../core/Type";
import { TypedPathParam } from "./_BasePath";
import { CoreWalker, TypedParamPathParamValue } from "../../core/Walker";
import { ParamType } from "../poly/ParamType";
const tmpConvertedValue = new TypedParamPathParamValue();
export class ParamPathParam extends TypedPathParam {
  constructor() {
    super(...arguments);
    this._onResolvedParamDisposeBound = this._onResolvedParamDispose.bind(this);
  }
  static type() {
    return ParamType.PARAM_PATH;
  }
  _initializeParam() {
    this._value = new TypedParamPathParamValue();
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return `${this._raw_input}`;
  }
  valueSerialized() {
    return `${this.value}`;
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  setParam(param) {
    this.set(param.path());
  }
  _assignValue(value) {
    const path = CoreType.isString(value) ? value : value.path();
    if (this._value.path() != path) {
      this._setValuePathAndFindTarget(path, false);
    }
  }
  convert(rawVal) {
    if (CoreType.isString(rawVal)) {
      tmpConvertedValue.setPath(rawVal);
      return tmpConvertedValue;
    } else {
      return null;
    }
  }
  // protected override async processComputation() {
  // 	this.findTarget();
  // }
  _findTarget() {
    if (!this.node) {
      return;
    }
    const path = this._value.path();
    let param = null;
    const pathNonEmpty = path != null && path !== "";
    this.scene().referencesController.resetReferenceFromParam(this);
    this.decomposedPath.reset();
    if (pathNonEmpty) {
      param = CoreWalker.findParam(this.node, path, this.decomposedPath);
    }
    const currentFoundEntity = this._value.param();
    const newlyFoundEntity = param;
    if (newlyFoundEntity) {
      if (newlyFoundEntity.graphNodeId() == this.graphNodeId()) {
        this.states.error.set(`param cannot refer to itself`);
        return;
      }
    }
    this._handleReferences(param, path);
    if ((currentFoundEntity == null ? void 0 : currentFoundEntity.graphNodeId()) !== (newlyFoundEntity == null ? void 0 : newlyFoundEntity.graphNodeId())) {
      const dependentOnFoundParam = this.options.dependentOnFoundParam();
      const previouslyFoundParam = this._value.param();
      if (previouslyFoundParam) {
        if (dependentOnFoundParam) {
          this.removeGraphInput(previouslyFoundParam);
        } else {
        }
        previouslyFoundParam.deregisterOnDispose(this._onResolvedParamDisposeBound);
      }
      if (param) {
        this._assignFoundParam(param);
      } else {
        this._value.setParam(null);
      }
      this.options.executeCallback();
    }
    this.removeDirtyState();
  }
  _assignFoundParam(param) {
    const dependentOnFoundParam = this.options.dependentOnFoundParam();
    this._value.setParam(param);
    if (dependentOnFoundParam) {
      this.addGraphInput(param);
    }
    param.onDispose(this._onResolvedParamDisposeBound);
  }
  // private _expected_context() {
  // 	return this.options.node_selection_context;
  // }
  // private _is_node_expected_context(node: BaseNodeType) {
  // 	const expected_context = this._expected_context();
  // 	if (expected_context == null) {
  // 		return true;
  // 	}
  // 	const node_context = node.parent?.childrenController?.context;
  // 	return expected_context == node_context;
  // }
  // private _expected_node_types() {
  // 	return this.options.node_selection_types;
  // }
  // private _is_node_expected_type(node: BaseNodeType) {
  // 	const expected_types = this._expected_node_types();
  // 	if (expected_types == null) {
  // 		return true;
  // 	}
  // 	return expected_types?.includes(node.type);
  // }
  notifyPathRebuildRequired(param) {
    this.decomposedPath.updateFromNameChange(param);
    const new_path = this.decomposedPath.toPath();
    this.set(new_path);
  }
  notifyTargetParamOwnerParamsUpdated(node) {
    this.setDirty();
  }
  async _onResolvedParamDispose() {
    this.setDirty();
    await this.compute();
  }
}
