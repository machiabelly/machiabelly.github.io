"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { Poly } from "../../Poly";
import { Vector2, Vector3 } from "three";
import { ContactShadowController } from "../../../core/contactShadows/ContactShadow";
import { PlaneSopOperation, DEFAULT_PARAMS as DEFAULT_PLANE_PARAMS } from "../../operations/sop/Plane";
const DEFAULT_PLANE_SIZE = new Vector2(10, 10);
const DEFAULT_PLANE_CENTER = new Vector3(0, 0.01, 0);
class ContactShadowsSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.renderAllObjects = ParamConfig.BOOLEAN(true);
    this.objects = ParamConfig.STRING("", {
      visibleIf: { renderAllObjects: 0 },
      objectMask: { fromInputOnly: false }
    });
    /** @param distance from the ground up to which shadows are visible */
    this.dist = ParamConfig.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param shadow resolution */
    this.shadowRes = ParamConfig.VECTOR2([256, 256]);
    /** @param shadow opacity */
    this.opacity = ParamConfig.FLOAT(1);
    /** @param blur amount */
    this.blur = ParamConfig.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      separatorBefore: true
    });
    /** @param toggle on to add a secondary blur, which may be useful to get rid of artefacts */
    this.tblur2 = ParamConfig.BOOLEAN(1);
    /** @param secondary blur amount */
    this.blur2 = ParamConfig.FLOAT(1, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: { tblur2: 1 }
    });
    /** @param show helper */
    this.showHelper = ParamConfig.BOOLEAN(0, {
      separatorBefore: true
    });
  }
}
const ParamsConfig = new ContactShadowsSopParamsConfig();
export class ContactShadowsSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CONTACT_SHADOWS;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0] || this._defaultCoreGroup();
    const objects = coreGroup.threejsObjectsWithGeo();
    for (const object of objects) {
      Poly.onObjectsAddRemoveHooks.assignOnAddHookHandler(object, this);
    }
    this.setCoreGroup(coreGroup);
  }
  _defaultCoreGroup() {
    this._planeOperation = this._planeOperation || new PlaneSopOperation(this.scene(), this.states, this);
    const coreGroup = this._planeOperation.cook([], {
      ...DEFAULT_PLANE_PARAMS,
      size: DEFAULT_PLANE_SIZE,
      center: DEFAULT_PLANE_CENTER
    });
    return coreGroup;
  }
  updateObjectOnAdd(object, parent) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    this._lastContactShadowsController = new ContactShadowController({
      scene: this.scene(),
      mesh: object,
      dist: this.pv.dist,
      renderTargetSize: this.pv.shadowRes,
      darkness: this.pv.opacity,
      blur: this.pv.blur,
      tblur2: this.pv.tblur2,
      blur2: this.pv.blur2,
      renderAllObjects: this.pv.renderAllObjects,
      objectsMask: this.pv.objects,
      showHelper: this.pv.showHelper
    });
  }
  lastContactShadowsController() {
    return this._lastContactShadowsController;
  }
}
