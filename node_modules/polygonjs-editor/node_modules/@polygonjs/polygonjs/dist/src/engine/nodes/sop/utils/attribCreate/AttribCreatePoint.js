"use strict";
import { CoreAttribute } from "../../../../../core/geometry/Attribute";
import { initArrayIfRequired } from "./Common";
import { hasGroupFromParams } from "../../../../operations/sop/utils/attribCreate/Common";
import { AttribType } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
import { pointsFromObject, pointsFromObjectFromGroup } from "../../../../../core/geometry/entities/point/CorePointUtils";
import { corePointClassFactory } from "../../../../../core/geometry/CoreObjectFactory";
const _arraysByObject = {
  X: /* @__PURE__ */ new WeakMap(),
  Y: /* @__PURE__ */ new WeakMap(),
  Z: /* @__PURE__ */ new WeakMap(),
  W: /* @__PURE__ */ new WeakMap()
};
const arraysByGeometryUuid = [_arraysByObject.X, _arraysByObject.Y, _arraysByObject.Z, _arraysByObject.W];
export async function addPointAttribute(attribType, coreGroup, params) {
  const objects = coreGroup.allObjects();
  switch (attribType) {
    case AttribType.NUMERIC: {
      for (const object of objects) {
        await _addNumericAttributeToPoints(object, params);
      }
      return;
    }
    case AttribType.STRING: {
      for (const object of objects) {
        await _addStringAttributeToPoints(object, params);
      }
      return;
    }
  }
  TypeAssert.unreachable(attribType);
}
async function _addNumericAttributeToPoints(object, params) {
  const corePointClass = corePointClassFactory(object);
  const points = [];
  pointsFromObjectFromGroup(object, params.group.value, points);
  const attribName = CoreAttribute.remapName(params.name.value);
  const size = params.size.value;
  const param = [params.value1, params.value2, params.value3, params.value4][size - 1];
  if (param.hasExpression()) {
    if (!corePointClass.hasAttribute(object, attribName)) {
      corePointClass.addNumericAttribute(object, attribName, size, param.value);
    }
    const attrib = corePointClass.attribute(object, attribName);
    if (!attrib) {
      return;
    }
    attrib.needsUpdate = true;
    const array = attrib.array;
    if (size == 1) {
      const paramN = params.value1;
      if (paramN.expressionController) {
        if (paramN.expressionController.entitiesDependent()) {
          await paramN.expressionController.computeExpressionForPoints(points, (point, value) => {
            array[point.index() * size + 0] = value;
          });
        } else {
          for (const point of points) {
            array[point.index() * size + 0] = paramN.value;
          }
        }
      }
    } else {
      const vparam = [params.value2, params.value3, params.value4][size - 2];
      const components = vparam.components;
      const tmpArrays = new Array(components.length);
      for (let i = 0; i < components.length; i++) {
        const componentParam = components[i];
        if (componentParam.hasExpression() && componentParam.expressionController) {
          tmpArrays[i] = initArrayIfRequired(object, arraysByGeometryUuid[i], points.length);
          if (componentParam.expressionController.entitiesDependent()) {
            await componentParam.expressionController.computeExpressionForPoints(
              points,
              (point, value) => {
                tmpArrays[i][point.index()] = value;
              }
            );
          } else {
            for (const point of points) {
              tmpArrays[i][point.index()] = componentParam.value;
            }
          }
        } else {
          const value = componentParam.value;
          for (const point of points) {
            array[point.index() * size + i] = value;
          }
        }
      }
      for (let j = 0; j < tmpArrays.length; j++) {
        const tmpArray = tmpArrays[j];
        if (tmpArray != null) {
          for (let i = 0; i < tmpArray.length; i++) {
            const newVal = tmpArray[i];
            if (newVal != null) {
              array[i * size + j] = newVal;
            }
          }
        }
      }
    }
  } else {
  }
}
async function _addStringAttributeToPoints(object, params) {
  const corePointClass = corePointClassFactory(object);
  const points = [];
  pointsFromObjectFromGroup(object, params.group.value, points);
  const param = params.string;
  const attribName = params.name.value;
  let stringValues = new Array(points.length);
  if (param.hasExpression() && param.expressionController) {
    if (hasGroupFromParams(params)) {
      if (!corePointClass.hasAttribute(object, attribName)) {
        const tmpIndexData = CoreAttribute.arrayToIndexedArrays([""]);
        corePointClass.setIndexedAttribute(object, attribName, tmpIndexData["values"], tmpIndexData["indices"]);
      }
      const allPoints = [];
      pointsFromObject(object, allPoints);
      stringValues = stringValues.length != allPoints.length ? new Array(allPoints.length) : stringValues;
      for (const point of allPoints) {
        let currentValue = point.stringAttribValue(attribName);
        if (currentValue == null) {
          currentValue = "";
        }
        stringValues[point.index()] = currentValue;
      }
    }
    if (param.expressionController.entitiesDependent()) {
      await param.expressionController.computeExpressionForPoints(points, (point, value) => {
        stringValues[point.index()] = value;
      });
    } else {
      for (const point of points) {
        stringValues[point.index()] = param.value;
      }
    }
  } else {
  }
  const indexData = CoreAttribute.arrayToIndexedArrays(stringValues);
  corePointClass.setIndexedAttribute(object, attribName, indexData["values"], indexData["indices"]);
}
