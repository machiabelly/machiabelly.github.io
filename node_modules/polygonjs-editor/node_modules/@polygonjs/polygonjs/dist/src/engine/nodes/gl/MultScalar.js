"use strict";
import { BaseNodeGlMathFunctionArg2GlNode } from "./_BaseMathFunction";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
const DefaultValues = {
  value: 1,
  mult: 1
};
var MultScalarGlNodeInputName = /* @__PURE__ */ ((MultScalarGlNodeInputName2) => {
  MultScalarGlNodeInputName2["VALUE"] = "value";
  MultScalarGlNodeInputName2["MULT"] = "mult";
  return MultScalarGlNodeInputName2;
})(MultScalarGlNodeInputName || {});
export class MultScalarGlNode extends BaseNodeGlMathFunctionArg2GlNode {
  static type() {
    return "multScalar";
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || GlConnectionPointType.VEC3;
    return [type, GlConnectionPointType.FLOAT];
  }
  _gl_input_name(index) {
    return ["value" /* VALUE */, "mult" /* MULT */][index];
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  setLines(shaders_collection_controller) {
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!outputConnectionPoints) {
      return;
    }
    const value = ThreeToGl.any(this.variableForInput("value" /* VALUE */));
    const mult = ThreeToGl.any(this.variableForInput("mult" /* MULT */));
    const gl_type = this._expected_output_types()[0];
    const out_name = outputConnectionPoints[0].name();
    const out = this.glVarName(out_name);
    const body_line = `${gl_type} ${out} = (${mult}*${value})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}
