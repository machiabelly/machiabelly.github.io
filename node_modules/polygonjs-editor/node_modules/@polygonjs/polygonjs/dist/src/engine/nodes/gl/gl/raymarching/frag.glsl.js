export default "precision highp float;\nprecision highp int;\n\n// --- applyMaterial constants definition\nuniform int MAX_STEPS;\nuniform float MAX_DIST;\nuniform float SURF_DIST;\nuniform float NORMALS_BIAS;\nuniform float SHADOW_BIAS;\n#define ZERO 0\nuniform float debugMinSteps;\nuniform float debugMaxSteps;\nuniform float debugMinDepth;\nuniform float debugMaxDepth;\n\n#include <common>\n#include <packing>\n#include <lightmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <fog_pars_fragment>\n\n#if defined( SHADOW_DISTANCE )\n	uniform float shadowDistanceMin;\n	uniform float shadowDistanceMax;\n#endif \n#if defined( SHADOW_DEPTH )\n	uniform float shadowDepthMin;\n	uniform float shadowDepthMax;\n#endif\n\n// varying vec2 vHighPrecisionZW;\n\nvarying vec3 vPw;\nvarying mat4 vModelMatrix;\nvarying mat4 vInverseModelMatrix;\nvarying mat4 VViewMatrix;\n\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLightRayMarching {\n		float penumbra;\n		float shadowBiasAngle;\n		float shadowBiasDistance;\n	};\n	uniform SpotLightRayMarching spotLightsRayMarching[ NUM_SPOT_LIGHTS ];\n	#if NUM_SPOT_LIGHT_COORDS > 0\n\n		uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\n	#endif\n#endif\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLightRayMarching {\n		float penumbra;\n		float shadowBiasAngle;\n		float shadowBiasDistance;\n	};\n	uniform DirectionalLightRayMarching directionalLightsRayMarching[ NUM_DIR_LIGHTS ];\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\n	#endif\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLightRayMarching {\n		float penumbra;\n		float shadowBiasAngle;\n		float shadowBiasDistance;\n	};\n	uniform PointLightRayMarching pointLightsRayMarching[ NUM_POINT_LIGHTS ];\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\n	#endif\n#endif\n\n\nstruct SDFContext {\n	float d;\n	int stepsCount;\n	int matId;\n	int matId2;\n	float matBlend;\n};\n\nSDFContext DefaultSDFContext(){\n	return SDFContext( 0., 0, 0, 0, 0. );\n}\nint DefaultSDFMaterial(){\n	return 0;\n}\n\n// start raymarching builder define code\n\n\nSDFContext GetDist(vec3 p) {\n	SDFContext sdfContext = SDFContext(0., 0, 0, 0, 0.);\n\n	// start GetDist builder body code\n	\n\n	return sdfContext;\n}\n\nSDFContext RayMarch(vec3 ro, vec3 rd, float side) {\n	SDFContext dO = SDFContext(0.,0,0,0,0.);\n\n	#pragma unroll_loop_start\n	for(int i=0; i<MAX_STEPS; i++) {\n		vec3 p = ro + rd*dO.d;\n		SDFContext sdfContext = GetDist(p);\n		dO.d += sdfContext.d * side;\n		#if defined( DEBUG_STEPS_COUNT )\n			dO.stepsCount += 1;\n		#endif\n		dO.matId = sdfContext.matId;\n		dO.matId2 = sdfContext.matId2;\n		dO.matBlend = sdfContext.matBlend;\n		if(dO.d>MAX_DIST || abs(sdfContext.d)<SURF_DIST) break;\n	}\n	#pragma unroll_loop_end\n\n	return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n	SDFContext sdfContext = GetDist(p);\n	vec2 e = vec2(NORMALS_BIAS, 0);\n\n	vec3 n = sdfContext.d - vec3(\n		GetDist(p-e.xyy).d,\n		GetDist(p-e.yxy).d,\n		GetDist(p-e.yyx).d);\n\n	return normalize(n);\n}\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, inout SDFContext sdfContext )\n{\n	float res = 1.0;\n	float ph = 1e20;\n	for( float t=mint; t<maxt; )\n	{\n		float h = GetDist(ro + rd*t).d;\n		#if defined( DEBUG_STEPS_COUNT )\n			sdfContext.stepsCount += 1;\n		#endif\n		if( h<SURF_DIST )\n			return 0.0;\n		float y = h*h/(2.0*ph);\n		float d = sqrt(h*h-y*y);\n		res = min( res, k*d/max(0.0,t-y) );\n		ph = h;\n		t += h;\n	}\n	return res;\n}\n\nvec3 GetLight(vec3 _p, vec3 _n, inout SDFContext sdfContext) {\n	vec3 dif = vec3(0.,0.,0.);\n	// GeometricContext geometry;\n	// geometry.position = _p;\n	// geometry.normal = _n;\n	// geometry.viewDir = rayDir;\n\n	// vec4 mvPosition = vec4( p, 1.0 );\n	// mvPosition = modelViewMatrix * mvPosition;\n	// vec3 vViewPosition = - mvPosition.xyz;\n	vec3 pWorld = ( vModelMatrix * vec4( _p, 1.0 )).xyz;\n	vec3 nWorld = transformDirection(_n, vModelMatrix);\n	// geometry.position = (VViewMatrix * vec4( _p, 1.0 )).xyz;\n	vec3 geometryPosition = (VViewMatrix * vec4(pWorld, 1.0 )).xyz;\n	// geometry.normal = transformDirection(_n, VViewMatrix);\n	// geometry.normal = inverseTransformDirection(transformDirection(_n, VViewMatrix), vInverseModelMatrix);\n	vec3 geometryNormal = transformDirection(nWorld, VViewMatrix);\n	\n\n	#if NUM_SPOT_LIGHTS > 0 || NUM_DIR_LIGHTS > 0 || NUM_HEMI_LIGHTS > 0 || NUM_POINT_LIGHTS > 0 || NUM_RECT_AREA_LIGHTS > 0\n\n		IncidentLight directLight;\n		ReflectedLight reflectedLight;\n		vec3 lightPos, lightDir, worldLightDir, objectSpaceLightDir, lighDif, directDiffuse;\n		float dotNL, lightDistance;\n		#if NUM_SPOT_LIGHTS > 0\n			SpotLightRayMarching spotLightRayMarching;\n			SpotLight spotLight;\n			float spotLightSdfShadow;\n			#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n				SpotLightShadow spotLightShadow;\n			#endif\n			#pragma unroll_loop_start\n			for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n				spotLightRayMarching = spotLightsRayMarching[ i ];\n				spotLight = spotLights[ i ];\n				getSpotLightInfo( spotLight, geometryPosition, directLight );\n\n				// #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n				// 	spotLightShadow = spotLightShadows[ i ];\n				// 	vec4 spotLightShadowCoord = spotLightMatrix[ i ] * vec4(pWorld+SHADOW_BIAS*nWorld, 1.0);\n				// 	directLight.color *= (directLight.visible && receiveShadow) ? getShadow(\n				// 		spotShadowMap[ i ],\n				// 		spotLightShadow.shadowMapSize,\n				// 		spotLightShadow.shadowBias,\n				// 		spotLightShadow.shadowRadius,\n				// 		spotLightShadowCoord\n				// 	) : 1.0;\n				// #endif\n\n				lightPos = spotLight.position;\n				lightDir = normalize(lightPos-geometryPosition);\n				worldLightDir = inverseTransformDirection(lightDir, VViewMatrix);\n				objectSpaceLightDir = inverseTransformDirection(worldLightDir, vModelMatrix);\n				lightDistance = distance(geometryPosition,lightPos);\n				spotLightSdfShadow =\n					dot( _n, objectSpaceLightDir ) < spotLightRayMarching.shadowBiasAngle\n					? 1.\n					: calcSoftshadow(\n						_p,\n						objectSpaceLightDir,\n						spotLightRayMarching.shadowBiasDistance,\n						distance(geometryPosition,lightPos),\n						1./max(spotLightRayMarching.penumbra*0.2,0.001),\n						sdfContext\n					);\n				dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n				directDiffuse = dotNL * directLight.color * BRDF_Lambert( vec3(1.) );\n				dif += directDiffuse * spotLightSdfShadow;\n			}\n			#pragma unroll_loop_end\n		#endif\n		#if NUM_DIR_LIGHTS > 0\n			DirectionalLightRayMarching directionalLightRayMarching;\n			DirectionalLight directionalLight;\n			float dirLightSdfShadow;\n			#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n				DirectionalLightShadow directionalLightShadow;\n			#endif\n			#pragma unroll_loop_start\n			for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n				directionalLightRayMarching = directionalLightsRayMarching[ i ];\n				directionalLight = directionalLights[ i ];\n				\n				getDirectionalLightInfo( directionalLight, directLight );\n\n				// #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n				// 	directionalLightShadow = directionalLightShadows[ i ];\n				// 	vec4 dirLightShadowCoord = directionalShadowMatrix[ i ] * vec4(pWorld+SHADOW_BIAS*nWorld, 1.0);\n				// 	directLight.color *= (directLight.visible && receiveShadow) ? getShadow(\n				// 		directionalShadowMap[ i ],\n				// 		directionalLightShadow.shadowMapSize,\n				// 		directionalLightShadow.shadowBias,\n				// 		directionalLightShadow.shadowRadius,\n				// 		dirLightShadowCoord\n				// 	) : 1.0;\n				// #endif\n\n				lightDir = directionalLight.direction;\n				worldLightDir = inverseTransformDirection(lightDir, VViewMatrix);\n				objectSpaceLightDir = inverseTransformDirection(worldLightDir, vModelMatrix);\n				dirLightSdfShadow =\n					dot( _n, objectSpaceLightDir ) < directionalLightRayMarching.shadowBiasAngle\n					? 1.\n					:\n					calcSoftshadow(\n						_p,\n						objectSpaceLightDir,\n						directionalLightRayMarching.shadowBiasDistance,\n						MAX_DIST,//distance(geometryPosition,lightPos),\n						1./max(directionalLightRayMarching.penumbra*0.2,0.001),\n						sdfContext\n					);\n				dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n				// lighDif = directLight.color * dotNL * dirLightSdfShadow;\n				directDiffuse = dotNL * directLight.color * BRDF_Lambert( vec3(1.) );\n				dif += directDiffuse * dirLightSdfShadow;\n			}\n			#pragma unroll_loop_end\n		#endif\n\n		#if ( NUM_HEMI_LIGHTS > 0 )\n\n			#pragma unroll_loop_start\n			HemisphereLight hemiLight;\n			for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n				hemiLight = hemisphereLights[ i ];\n				dif += getHemisphereLightIrradiance( hemiLight, geometryNormal ) * BRDF_Lambert( vec3(1.) );\n\n			}\n			#pragma unroll_loop_end\n\n		#endif\n\n		#if NUM_POINT_LIGHTS > 0\n			PointLightRayMarching pointLightRayMarching;\n			PointLight pointLight;\n			float pointLightSdfShadow;\n			#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n				PointLightShadow pointLightShadow;\n			#endif\n			#pragma unroll_loop_start\n			for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n				pointLightRayMarching = pointLightsRayMarching[ i ];\n				pointLight = pointLights[ i ];\n				getPointLightInfo( pointLight, geometryPosition, directLight );\n\n\n				#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n					pointLightShadow = pointLightShadows[ i ];\n					vec4 pointLightShadowCoord = pointShadowMatrix[ i ] * vec4(pWorld+SHADOW_BIAS*nWorld, 1.0);\n					directLight.color *= (directLight.visible && receiveShadow) ? getPointShadow(\n						pointShadowMap[ i ],\n						pointLightShadow.shadowMapSize,\n						pointLightShadow.shadowBias,\n						pointLightShadow.shadowRadius,\n						pointLightShadowCoord,\n						pointLightShadow.shadowCameraNear,\n						pointLightShadow.shadowCameraFar\n					) : 1.0;\n				#endif\n\n				lightPos = pointLight.position;\n				lightDir = normalize(lightPos-geometryPosition);\n				worldLightDir = inverseTransformDirection(lightDir, VViewMatrix);\n				objectSpaceLightDir = inverseTransformDirection(worldLightDir, vModelMatrix);\n				pointLightSdfShadow =\n					dot( _n, objectSpaceLightDir ) < pointLightRayMarching.shadowBiasAngle\n					? 1.\n					:\n					calcSoftshadow(\n					_p,\n					objectSpaceLightDir,\n					pointLightRayMarching.shadowBiasDistance,\n					distance(geometryPosition,lightPos),\n					1./max(pointLightRayMarching.penumbra*0.2,0.001),\n					sdfContext\n				);\n				dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n				directDiffuse = dotNL * directLight.color * BRDF_Lambert( vec3(1.) );\n				dif += directDiffuse * pointLightSdfShadow;\n			}\n			#pragma unroll_loop_end\n		#endif\n\n		#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n			RectAreaLight rectAreaLight;\n			// AreaLightRayMarching areaLightRayMarching;\n			PhysicalMaterial material;\n			material.roughness = 1.;\n			material.specularColor = vec3(1.);\n			material.diffuseColor = vec3(1.);\n\n			vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( cameraPosition - geometryPosition );\n			vec3 geometryClearcoatNormal = geometryNormal;\n\n			#pragma unroll_loop_start\n			for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n				// areaLightRayMarching = areaLightsRayMarching[ i ];\n				rectAreaLight = rectAreaLights[ i ];\n				// rectAreaLight.position = areaLightRayMarching.worldPos;\n\n				RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n			}\n			#pragma unroll_loop_end\n			dif += reflectedLight.directDiffuse;\n\n		#endif\n	#endif\n\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n	#if defined( USE_LIGHT_PROBES )\n\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\n	#endif\n\n	dif += irradiance;\n\n	return dif;\n}\n\n\n\n// --- applyMaterial function definition\n\n\n\nvec4 applyShading(vec3 rayOrigin, vec3 rayDir, inout SDFContext sdfContext){\n	vec3 p = rayOrigin + rayDir * sdfContext.d;\n	vec3 n = GetNormal(p);\n	\n	vec3 col = applyMaterial(p, n, rayDir, sdfContext.matId, sdfContext);\n	if(sdfContext.matBlend > 0.) {\n		// blend material colors if needed\n		vec3 col2 = applyMaterial(p, n, rayDir, sdfContext.matId2, sdfContext);\n		col = (1. - sdfContext.matBlend)*col + sdfContext.matBlend*col2;\n	}\n		\n	// gamma\n	//col = pow( col, vec3(0.4545) ); // this gamma leads to a different look than standard materials\n	return vec4(col, 1.);\n}\n\nvoid main()	{\n\n	vec3 rayDir = normalize(vPw - cameraPosition);\n	rayDir = transformDirection(rayDir, vInverseModelMatrix);\n	vec3 rayOrigin = (vInverseModelMatrix * vec4( cameraPosition, 1.0 )).xyz;\n\n	SDFContext sdfContext = RayMarch(rayOrigin, rayDir, 1.);\n\n	#if defined( DEBUG_DEPTH )\n		float normalizedDepth = 1.-(sdfContext.d - debugMinDepth ) / ( debugMaxDepth - debugMinDepth );\n		normalizedDepth = saturate(normalizedDepth); // clamp to [0,1]\n		gl_FragColor = vec4(normalizedDepth);\n		return;\n	#endif\n	#if defined( SHADOW_DEPTH )\n		float normalizedDepth = 1.-(sdfContext.d - debugMinDepth ) / ( debugMaxDepth - debugMinDepth );\n		// float fragCoordZ = sdfContext.d / vHighPrecisionZW[1];\n		float compoundedDepth = 0.5 * (normalizedDepth) + 0.5;\n		float alpha = sdfContext.d < MAX_DIST ? 0.:1.;\n		gl_FragColor = vec4( vec3(compoundedDepth), alpha );\n		// normalizedDepth = 0.5*normalizedDepth+0.5;\n		// gl_FragColor = packDepthToRGBA( normalizedDepth );\n		// gl_FragColor = vec4(0.);\n		return;\n	#endif\n	#if defined( SHADOW_DISTANCE )\n		float normalizedDepth = (sdfContext.d - shadowDistanceMin ) / ( shadowDistanceMax - shadowDistanceMin );\n		normalizedDepth = saturate(normalizedDepth); // clamp to [0,1]\n		gl_FragColor = packDepthToRGBA( normalizedDepth );\n		return;\n	#endif\n\n	if( sdfContext.d < MAX_DIST ){\n		gl_FragColor = applyShading(rayOrigin, rayDir, sdfContext);\n		#if defined( TONE_MAPPING )\n			gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n		#endif\n		gl_FragColor = linearToOutputTexel( gl_FragColor );\n\n		#ifdef USE_FOG\n			float vFogDepth = sdfContext.d;\n			#ifdef FOG_EXP2\n				float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n			#else\n				float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n			#endif\n			gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n		#endif\n		#include <premultiplied_alpha_fragment>\n		#include <dithering_fragment>\n	} else {\n		gl_FragColor = vec4(0.);\n	}\n\n	#if defined( DEBUG_STEPS_COUNT )\n		float normalizedStepsCount = (float(sdfContext.stepsCount) - debugMinSteps ) / ( debugMaxSteps - debugMinSteps );\n		gl_FragColor = vec4(normalizedStepsCount, 1.-normalizedStepsCount, 0., 1.);\n		return;\n	#endif\n	\n}";
