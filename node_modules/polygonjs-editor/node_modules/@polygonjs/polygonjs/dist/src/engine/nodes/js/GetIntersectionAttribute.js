"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import {
  JsConnectionPointType,
  PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES
} from "../utils/io/connections/Js";
import { Poly } from "../../Poly";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
import { TypeAssert } from "../../poly/Assert";
var GetIntersectionAttributeInputName = /* @__PURE__ */ ((GetIntersectionAttributeInputName2) => {
  GetIntersectionAttributeInputName2["attribName"] = "attribName";
  GetIntersectionAttributeInputName2["notFoundValue"] = "notFoundValue";
  return GetIntersectionAttributeInputName2;
})(GetIntersectionAttributeInputName || {});
class GetIntersectionAttributeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.type = ParamConfig.INTEGER(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map((name, value) => ({ name, value }))
      }
    });
    this.interpolated = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new GetIntersectionAttributeJsParamsConfig();
const _GetIntersectionAttributeJsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return "getIntersectionAttribute";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["interpolated"]);
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [this.attribType()]);
    this.io.connection_points.set_input_name_function(this._expectedInputNames.bind(this));
    this.io.connection_points.set_output_name_function(
      (index) => _GetIntersectionAttributeJsNode.OUTPUT_NAME
    );
  }
  _expectedInputTypes() {
    return [JsConnectionPointType.INTERSECTION, JsConnectionPointType.STRING, this.attribType()];
  }
  _expectedInputNames(index) {
    return [
      JsConnectionPointType.INTERSECTION,
      "attribName" /* attribName */,
      "notFoundValue" /* notFoundValue */
    ][index];
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName,
      ["notFoundValue" /* notFoundValue */]: -1
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(type));
  }
  attribType() {
    return PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(shadersCollectionController) {
    const varName = this.jsVarName(_GetIntersectionAttributeJsNode.OUTPUT_NAME);
    const dataType = this.attribType();
    const bodyLine = this._getBodyLine(shadersCollectionController);
    if (bodyLine) {
      shadersCollectionController.addBodyOrComputed(this, [{ dataType, varName, value: bodyLine }]);
    }
  }
  _getBodyLine(shadersCollectionController) {
    const intersection = this.variableForInput(shadersCollectionController, JsConnectionPointType.INTERSECTION);
    const attribName = this.variableForInput(
      shadersCollectionController,
      "attribName" /* attribName */
    );
    const notFoundValue = this.variableForInput(
      shadersCollectionController,
      "notFoundValue" /* notFoundValue */
    );
    const interpolated = this.pv.interpolated;
    const dataType = this.attribType();
    switch (dataType) {
      case JsConnectionPointType.BOOLEAN:
      case JsConnectionPointType.FLOAT:
      case JsConnectionPointType.INT: {
        const functionName = interpolated ? "getIntersectionAttributeNumberInterpolated" : "getIntersectionAttributeNumberNearest";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        return func.asString(intersection, attribName, notFoundValue);
      }
      case JsConnectionPointType.COLOR: {
        const functionName = interpolated ? "getIntersectionAttributeColorInterpolated" : "getIntersectionAttributeColorNearest";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = createVariable(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
      case JsConnectionPointType.STRING: {
        const functionName = "getIntersectionAttributeStringNearest";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        func.asString(intersection, attribName);
        return;
      }
      case JsConnectionPointType.VECTOR2: {
        const functionName = interpolated ? "getIntersectionAttributeVector2Interpolated" : "getIntersectionAttributeVector2Nearest";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = createVariable(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
      case JsConnectionPointType.VECTOR3: {
        const functionName = interpolated ? "getIntersectionAttributeVector3Interpolated" : "getIntersectionAttributeVector3Nearest";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = createVariable(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
      case JsConnectionPointType.VECTOR4: {
        const functionName = interpolated ? "getIntersectionAttributeVector4Interpolated" : "getIntersectionAttributeVector4Nearest";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const variable = createVariable(dataType);
        if (variable) {
          const tmpVarName = shadersCollectionController.addVariable(this, variable);
          func.asString(intersection, attribName, notFoundValue, tmpVarName);
        }
        return;
      }
    }
    TypeAssert.unreachable(dataType);
  }
};
export let GetIntersectionAttributeJsNode = _GetIntersectionAttributeJsNode;
GetIntersectionAttributeJsNode.OUTPUT_NAME = "val";
