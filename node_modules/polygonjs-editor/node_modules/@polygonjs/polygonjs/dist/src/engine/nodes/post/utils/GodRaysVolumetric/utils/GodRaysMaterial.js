"use strict";
import {
  Vector2,
  Vector3,
  Matrix4,
  ShaderMaterial,
  PointLight,
  DirectionalLight,
  TextureLoader,
  RepeatWrapping,
  NearestFilter
} from "three";
import GodraysFragmentShader from "../gl/godrays.frag.glsl";
import GodraysVertexShader from "../gl/godrays.vert.glsl";
import { BlueNoiseTextureDataURI } from "../gl/bluenoise";
const getBlueNoiseTexture = async () => {
  const textureLoader = new TextureLoader();
  const blueNoiseTexture = await textureLoader.loadAsync(BlueNoiseTextureDataURI);
  blueNoiseTexture.wrapS = RepeatWrapping;
  blueNoiseTexture.wrapT = RepeatWrapping;
  blueNoiseTexture.magFilter = NearestFilter;
  blueNoiseTexture.minFilter = NearestFilter;
  return blueNoiseTexture;
};
export class GodraysMaterial extends ShaderMaterial {
  constructor(props) {
    const uniforms = {
      density: { value: 1 / 128 },
      maxDensity: { value: 0.5 },
      distanceAttenuation: { value: 2 },
      sceneDepth: { value: null },
      lightPos: { value: new Vector3(0, 0, 0) },
      cameraPos: { value: new Vector3(0, 0, 0) },
      resolution: { value: new Vector2(1, 1) },
      lightCameraProjectionMatrix: { value: new Matrix4() },
      lightCameraMatrixWorldInverse: { value: new Matrix4() },
      cameraProjectionMatrixInv: { value: new Matrix4() },
      cameraMatrixWorld: { value: new Matrix4() },
      shadowMap: { value: null },
      mapSize: { value: 1 },
      lightCameraNear: { value: 0.1 },
      lightCameraFar: { value: 1e3 },
      blueNoise: { value: null },
      noiseResolution: { value: new Vector2(1, 1) },
      fNormals: { value: [] },
      fConstants: { value: [] }
    };
    const defines = {};
    if (props.light instanceof PointLight || props.light.isPointLight) {
      defines.IS_POINT_LIGHT = "";
    } else if (props.light instanceof DirectionalLight || props.light.isDirectionalLight) {
      defines.IS_DIRECTIONAL_LIGHT = "";
    }
    super({
      name: "GodraysMaterial",
      uniforms,
      fragmentShader: GodraysFragmentShader,
      vertexShader: GodraysVertexShader,
      defines
    });
    getBlueNoiseTexture().then((blueNoiseTexture) => {
      uniforms.blueNoise.value = blueNoiseTexture;
      uniforms.noiseResolution.value.set(blueNoiseTexture.image.width, blueNoiseTexture.image.height);
    });
  }
}
