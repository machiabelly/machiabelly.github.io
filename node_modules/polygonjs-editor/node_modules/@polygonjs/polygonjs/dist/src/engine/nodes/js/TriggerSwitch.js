"use strict";
import { setToArray } from "../../../core/SetUtils";
import { Poly } from "../../Poly";
import { JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF } from "../utils/io/connections/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import {
  getConnectedOutputNodes,
  getOutputIndices,
  nodeMethodName,
  triggerInputIndex
} from "./code/assemblers/actor/ActorAssemblerUtils";
import { TypedJsNode } from "./_Base";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
class TriggerSwitchJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param triggersCount */
    this.triggersCount = ParamConfig.INTEGER(4, {
      range: [1, 10],
      rangeLocked: [true, false]
    });
    /** @param defines which trigger will be dispatched */
    this.index = ParamConfig.INTEGER(0, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new TriggerSwitchJsParamsConfig();
export class TriggerSwitchJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "triggerSwitch";
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),
      new JsConnectionPoint("index", JsConnectionPointType.INT, CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedOutputNames(index) {
    return `${JsConnectionPointType.TRIGGER}${index}`;
  }
  _expectedOutputTypes() {
    const array = new Array(this.pv.triggersCount).fill(JsConnectionPointType.TRIGGER);
    return array;
  }
  setTriggerableLines(shadersCollectionController) {
    const index = this.variableForInputParam(shadersCollectionController, this.p.index);
    const methodNames = this._expectedOutputTypes().map((_, i) => triggerMethod(this, this._expectedOutputNames(i))).join(",");
    const func = Poly.namedFunctionsRegister.getFunction("triggerSwitch", this, shadersCollectionController);
    const bodyLine = func.asString(index, `[${methodNames}]`);
    shadersCollectionController.addTriggerableLines(this, [bodyLine], { addTriggeredLines: false });
  }
}
function triggerMethod(node, outputName) {
  const outputIndex = getOutputIndices(node, (c) => c.name() == outputName)[0];
  const triggerableNodes = /* @__PURE__ */ new Set();
  getConnectedOutputNodes({
    node,
    triggerOutputIndices: [outputIndex],
    triggerableNodes,
    recursive: false
  });
  const triggerableMethodNames = setToArray(triggerableNodes, []).map((triggerableNode) => {
    const argIndex = triggerInputIndex(node, triggerableNode);
    const m = nodeMethodName(triggerableNode);
    return `this.${m}(${argIndex})`;
  });
  return `()=>{ ${triggerableMethodNames.join(";")} }`;
}
