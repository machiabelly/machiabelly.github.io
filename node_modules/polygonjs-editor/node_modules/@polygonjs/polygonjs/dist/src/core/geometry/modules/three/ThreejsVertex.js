"use strict";
import { CoreVertex } from "../../entities/vertex/CoreVertex";
import { verticesCountFromObject } from "../../entities/vertex/CoreVertexUtils";
import { primitiveClassFactoryNonAbstract, primitiveVerticesCountFactory } from "./ThreeModule";
import { ThreejsPoint } from "./ThreejsPoint";
import { attributeNumericValues } from "../../entities/utils/Common";
const target = {
  attributeAdded: false,
  values: []
};
export class ThreejsVertex extends CoreVertex {
  constructor(object, index) {
    super(object, index);
    this._updateGeometry();
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    attributes[attribName] = attribute;
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue = 0) {
    const verticesCount = this.entitiesCount(object);
    target.values = new Array(verticesCount * size);
    attributeNumericValues(object, verticesCountFromObject, size, defaultValue, target);
    const attribute = {
      isString: false,
      array: target.values,
      itemSize: size
    };
    this.addAttribute(object, attribName, attribute);
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    if (!geometry.userData.vertexAttributes) {
      geometry.userData.vertexAttributes = {};
    }
    return geometry.userData.vertexAttributes;
  }
  static indexAttribute(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    return geometry.getIndex();
  }
  static setIndexAttribute(object, index) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    geometry.setIndex(index);
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count;
  }
  position(target2) {
    console.warn("CoreThreejsVertex.position not implemented");
    return target2;
  }
  normal(target2) {
    console.warn("CoreThreejsVertex.normal not implemented");
    return target2;
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedPrimitiveIds(object, pointIndex, target2) {
    target2.length = 1;
    const index = Math.floor(pointIndex / primitiveVerticesCountFactory(object));
    target2[0] = index;
  }
  // static override  relatedPrimitives<T extends CoreObjectType>(object:BaseCoreObject<T>,vertexIndex:number,target: CorePrimitive<T>[]): void {
  // 	this.relatedPrimitiveIds(object,vertexIndex,_ids)
  // 	target.length = _ids.length;
  // 	let i=0
  // 	for(const id of _ids){
  // 		target[i]=(primitiveInstanceFactory(object as any as Mesh,id)) as CorePrimitive<T>
  // 		i++
  // 	}
  // }
  // override relatedPrimitives<T extends CoreObjectType>(target: CorePrimitive<T>[]): void {
  // 	target.length = 0;
  // 	if (!this._object) {
  // 		return;
  // 	}
  // 	const index = Math.floor(this._index / primitiveVerticesCountFactory(this._object));
  // 	const primitive = primitiveInstanceFactory(this._object, index) as CorePrimitive<T> | undefined;
  // 	if (!primitive) {
  // 		return;
  // 	}
  // 	target.push(primitive);
  // }
  static relatedPointIds(object, pointIndex, target2) {
    target2.length = 0;
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const indexArray = index.array;
    const indexValue = indexArray[pointIndex];
    target2[0] = indexValue;
  }
  static relatedPointClass(object) {
    return ThreejsPoint;
  }
  static relatedPrimitiveClass(object) {
    return primitiveClassFactoryNonAbstract(object);
  }
}
