"use strict";
import { Triangle, Vector3, BufferAttribute } from "three";
import { ThreejsPrimitive } from "./ThreejsPrimitive";
import { threeMeshFromPrimitives } from "./builders/Mesh";
import { Attribute } from "../../Attribute";
const _triangle = new Triangle();
const _p0 = new Vector3();
const _p1 = new Vector3();
const _p2 = new Vector3();
const normalsComputedWithPositionAttributeVersion = /* @__PURE__ */ new Map();
export class ThreejsPrimitiveTriangle extends ThreejsPrimitive {
  constructor(object, index) {
    super(object, index);
    this._geometry = object.geometry;
  }
  static primitiveName() {
    return "triangle";
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count / 3;
  }
  static position(object, primitiveIndex, target) {
    if (!(object && object.geometry)) {
      return target;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target;
    }
    const positionArray = positionAttribute.array;
    _p0.fromArray(positionArray, primitiveIndex * 3 + 0);
    _p1.fromArray(positionArray, primitiveIndex * 3 + 1);
    _p2.fromArray(positionArray, primitiveIndex * 3 + 2);
    target.copy(_p0).add(_p1).add(_p2).divideScalar(3);
    return target;
  }
  static normal(object, primitiveIndex, target) {
    if (!(object && object.geometry)) {
      return target;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target;
    }
    const positionArray = positionAttribute.array;
    _triangle.a.fromArray(positionArray, primitiveIndex * 3 + 0);
    _triangle.b.fromArray(positionArray, primitiveIndex * 3 + 1);
    _triangle.c.fromArray(positionArray, primitiveIndex * 3 + 2);
    _triangle.getNormal(target);
    return target;
  }
  position(target) {
    return this.constructor.position(this._object, this._index, target);
  }
  normal(target) {
    return this.constructor.normal(this._object, this._index, target);
  }
  static computeVertexNormalsIfAttributeVersionChanged(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return null;
    }
    const positionAttribute = geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return;
    }
    if (!(positionAttribute instanceof BufferAttribute)) {
      return;
    }
    let lastVersion = normalsComputedWithPositionAttributeVersion.get(geometry.uuid);
    if (lastVersion == null || lastVersion != positionAttribute.version) {
      geometry.computeVertexNormals();
      normalsComputedWithPositionAttributeVersion.set(geometry.uuid, positionAttribute.version);
    }
  }
  builder() {
    return threeMeshFromPrimitives;
  }
  static stride() {
    return 3;
  }
}
