"use strict";
import { ParamConfig } from "../../../engine/nodes/utils/params/ParamsConfig";
import {
  MarkerTrackingSourceMode,
  MARKER_TRACKING_SOURCE_MODES,
  MARKER_TRACKING_TRANSFORM_MODES
} from "../../webXR/markerTracking/Common";
import { CameraAttribute } from "../CoreCamera";
import { CameraWebXRARMarkerTrackingSopOperation } from "../../../engine/operations/sop/CameraWebXRARMarkerTracking";
import { CoreType } from "../../Type";
import { Poly } from "../../../engine/Poly";
import { EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT } from "../../loader/FileExtensionRegister";
import { CameraSopNodeType, NodeContext } from "../../../engine/poly/NodeContext";
import { coreObjectClassFactory } from "../../geometry/CoreObjectFactory";
const DEFAULT = CameraWebXRARMarkerTrackingSopOperation.DEFAULT_PARAMS;
export function CoreCameraMarkerTrackingParamConfig(Base) {
  const defaultBarCodeType = Poly.thirdParty.markerTracking().barCodeTypes()[0];
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param select if you want to use the webcam or an image/video as tracking source */
      this.sourceMode = ParamConfig.INTEGER(DEFAULT.sourceMode, {
        menu: {
          entries: MARKER_TRACKING_SOURCE_MODES.map((name, value) => ({ name, value }))
        }
      });
      /** @param image or video url */
      this.sourceUrl = ParamConfig.STRING(DEFAULT.sourceUrl, {
        fileBrowse: {
          extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.COP][CameraSopNodeType.WEBXR_AR_MARKER_TRACKING]
        },
        visibleIf: [
          { sourceMode: MARKER_TRACKING_SOURCE_MODES.indexOf(MarkerTrackingSourceMode.IMAGE) },
          { sourceMode: MARKER_TRACKING_SOURCE_MODES.indexOf(MarkerTrackingSourceMode.VIDEO) }
        ]
      });
      /** @param transformMode */
      this.transformMode = ParamConfig.INTEGER(DEFAULT.transformMode, {
        menu: {
          entries: MARKER_TRACKING_TRANSFORM_MODES.map((name, value) => ({ name, value }))
        }
      });
      /** @param smooth */
      this.smooth = ParamConfig.BOOLEAN(DEFAULT.smooth, {
        separatorBefore: true
      });
      /** @param  smooth count */
      this.smoothCount = ParamConfig.INTEGER(DEFAULT.smoothCount, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param barcode type */
      this.barCodeType = ParamConfig.STRING(defaultBarCodeType, {
        separatorBefore: true,
        menuString: {
          entries: Poly.thirdParty.markerTracking().barCodeTypes().map((name, value) => ({ name, value: name }))
        }
      });
      /** @param barcode value */
      this.barCodeValue = ParamConfig.INTEGER(DEFAULT.barCodeValue, {
        range: [0, 511],
        rangeLocked: [true, true]
      });
    }
  };
}
export class CoreCameraMarkerTrackingController {
  static process(options) {
    const { canvas, scene, camera, onError } = options;
    const coreObjectClass = coreObjectClassFactory(camera);
    const isARjsTrackMarker = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING);
    if (!isARjsTrackMarker) {
      return;
    }
    const sourceMode = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_SOURCE_MODE
    );
    const sourceUrl = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SOURCE_URL);
    const barCodeType = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_BAR_CODE_TYPE
    );
    const barCodeValue = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_BAR_CODE_VALUE
    );
    const transformMode = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_TRANSFORM_MODE
    );
    if (sourceMode == null || barCodeType == null || barCodeValue == null || transformMode == null) {
      return;
    }
    if (!MARKER_TRACKING_SOURCE_MODES.includes(sourceMode)) {
      return;
    }
    if ([MarkerTrackingSourceMode.IMAGE, MarkerTrackingSourceMode.VIDEO].includes(sourceMode) && sourceUrl == null) {
      return;
    }
    if (!CoreType.isString(barCodeType)) {
      return;
    }
    if (!CoreType.isString(transformMode)) {
      return;
    }
    if (!Poly.thirdParty.markerTracking().barCodeTypes().includes(barCodeType)) {
      return;
    }
    if (!MARKER_TRACKING_TRANSFORM_MODES.includes(transformMode)) {
      return;
    }
    if (!CoreType.isNumber(barCodeValue)) {
      return;
    }
    const smooth = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SMOOTH) || false;
    const smoothCount = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SMOOTH_COUNT) || 0;
    try {
      const controller = Poly.thirdParty.markerTracking().createController({
        sourceMode,
        sourceUrl,
        canvas,
        camera,
        scene: scene.threejsScene(),
        transformMode,
        barCode: {
          type: barCodeType,
          value: barCodeValue
        },
        smooth: {
          active: smooth,
          count: smoothCount
        }
      });
      const errorMessage = controller == null ? void 0 : controller.errorMessage();
      if (errorMessage) {
        onError(errorMessage);
      } else {
        if (!controller) {
          onError(
            "failed to create the MarkerTracking controller. Make sure you have loaded the plugin. See: `https://polygonjs.com/markerTracking`"
          );
        }
      }
      return controller == null ? void 0 : controller.config();
    } catch (err) {
      onError("There was an unknown error while using the MarkerTracking plugin");
    }
  }
}
