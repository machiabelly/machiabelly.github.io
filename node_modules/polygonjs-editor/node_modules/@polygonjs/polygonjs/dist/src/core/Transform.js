"use strict";
import { MathUtils, Euler, Matrix4, Vector3, Quaternion } from "three";
export var TransformTargetType = /* @__PURE__ */ ((TransformTargetType2) => {
  TransformTargetType2["OBJECT"] = "object";
  TransformTargetType2["GEOMETRY"] = "geometry";
  return TransformTargetType2;
})(TransformTargetType || {});
export const TRANSFORM_TARGET_TYPES = ["geometry" /* GEOMETRY */, "object" /* OBJECT */];
export var RotationOrder = /* @__PURE__ */ ((RotationOrder2) => {
  RotationOrder2["XYZ"] = "XYZ";
  RotationOrder2["XZY"] = "XZY";
  RotationOrder2["YXZ"] = "YXZ";
  RotationOrder2["YZX"] = "YZX";
  RotationOrder2["ZYX"] = "ZYX";
  RotationOrder2["ZXY"] = "ZXY";
  return RotationOrder2;
})(RotationOrder || {});
export const ROTATION_ORDERS = [
  "XYZ" /* XYZ */,
  "XZY" /* XZY */,
  "YXZ" /* YXZ */,
  "YZX" /* YZX */,
  "ZXY" /* ZXY */,
  "ZYX" /* ZYX */
];
export const DEFAULT_ROTATION_ORDER = "XYZ" /* XYZ */;
const eulerArray = [0, 0, 0];
const _m = new Matrix4();
const _q = new Quaternion();
const _rotateDirOrigin = new Vector3();
const _rotateDirDest = new Vector3();
export function rotationMatrix(dirOrigin, dirDest, target) {
  _rotateDirDest.copy(dirDest).normalize();
  _rotateDirOrigin.copy(dirOrigin).normalize();
  _q.setFromUnitVectors(_rotateDirOrigin, _rotateDirDest);
  target.makeRotationFromQuaternion(_q);
}
export function rotateGeometry(geometry, dirOrigin, dirDest) {
  _rotateDirDest.copy(dirDest).normalize();
  _rotateDirOrigin.copy(dirOrigin).normalize();
  _q.setFromUnitVectors(_rotateDirOrigin, _rotateDirDest);
  _m.makeRotationFromQuaternion(_q);
  geometry.applyMatrix4(_m);
}
export class CoreTransform {
  constructor() {
    this._translation_matrix = new Matrix4();
    this._translation_matrix_q = new Quaternion();
    this._translation_matrix_s = new Vector3(1, 1, 1);
    this._matrix = new Matrix4().identity();
    this._matrixQ = new Quaternion();
    this._matrixEuler = new Euler();
    this._matrixS = new Vector3();
  }
  static setParamsFromMatrix(matrix, node, options = {}) {
    let update_scale = options["scale"];
    if (update_scale == null) {
      update_scale = true;
    }
    matrix.decompose(
      this.set_params_from_matrix_position,
      this.set_params_from_matrix_quaternion,
      this.set_params_from_matrix_scale
    );
    this.set_params_from_matrix_euler.setFromQuaternion(this.set_params_from_matrix_quaternion);
    this.set_params_from_matrix_euler.toArray(eulerArray);
    this.set_params_from_matrix_rotation.fromArray(eulerArray);
    this.set_params_from_matrix_rotation.divideScalar(Math.PI / 180);
    this.set_params_from_matrix_position.toArray(this.set_params_from_matrix_t);
    this.set_params_from_matrix_rotation.toArray(this.set_params_from_matrix_r);
    this.set_params_from_matrix_scale.toArray(this.set_params_from_matrix_s);
    node.scene().batchUpdates(() => {
      node.params.set_vector3("t", this.set_params_from_matrix_t);
      node.params.set_vector3("r", this.set_params_from_matrix_r);
      node.params.set_vector3("s", this.set_params_from_matrix_s);
      if (update_scale) {
        node.params.set_float("scale", 1);
      }
    });
  }
  static setParamsFromObject(object, node) {
    object.position.toArray(this.set_params_from_object_position_array);
    object.rotation.toArray(this.set_params_from_object_rotation_array);
    this.set_params_from_object_rotation_deg.fromArray(this.set_params_from_object_rotation_array);
    this.set_params_from_object_rotation_deg.multiplyScalar(180 / Math.PI);
    this.set_params_from_object_rotation_deg.toArray(this.set_params_from_object_rotation_array);
    node.scene().batchUpdates(() => {
      node.params.set_vector3("t", this.set_params_from_object_position_array);
      node.params.set_vector3("r", this.set_params_from_object_rotation_array);
    });
  }
  translationMatrix(t) {
    this._translation_matrix.compose(t, this._translation_matrix_q, this._translation_matrix_s);
    return this._translation_matrix;
  }
  matrix(t, r, s, scale, rotationOrder) {
    this._matrixEuler.set(MathUtils.degToRad(r.x), MathUtils.degToRad(r.y), MathUtils.degToRad(r.z), rotationOrder);
    this._matrixQ.setFromEuler(this._matrixEuler);
    this._matrixS.copy(s).multiplyScalar(scale);
    this._matrix.compose(t, this._matrixQ, this._matrixS);
    return this._matrix;
  }
  static rotateObject(object, dirOrigin, dirDest) {
    _rotateDirDest.copy(dirDest).normalize();
    _rotateDirOrigin.copy(dirOrigin).normalize();
    _q.setFromUnitVectors(_rotateDirOrigin, _rotateDirDest);
    _m.makeRotationFromQuaternion(_q);
    object.matrix.multiply(_m);
    object.matrix.decompose(object.position, object.quaternion, object.scale);
  }
  static decomposeMatrix(object) {
    object.matrix.decompose(object.position, object.quaternion, object.scale);
  }
}
CoreTransform.set_params_from_matrix_position = new Vector3();
CoreTransform.set_params_from_matrix_quaternion = new Quaternion();
CoreTransform.set_params_from_matrix_scale = new Vector3();
CoreTransform.set_params_from_matrix_euler = new Euler();
CoreTransform.set_params_from_matrix_rotation = new Vector3();
CoreTransform.set_params_from_matrix_t = [0, 0, 0];
CoreTransform.set_params_from_matrix_r = [0, 0, 0];
CoreTransform.set_params_from_matrix_s = [0, 0, 0];
CoreTransform.set_params_from_object_position_array = [0, 0, 0];
CoreTransform.set_params_from_object_rotation_deg = new Vector3();
CoreTransform.set_params_from_object_rotation_array = [0, 0, 0];
