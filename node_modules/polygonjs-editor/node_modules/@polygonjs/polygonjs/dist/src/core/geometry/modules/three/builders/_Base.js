"use strict";
import { BufferGeometry, Float32BufferAttribute } from "three";
import { uniqWithoutPreservingOrder, arrayCompact } from "../../../../ArrayUtils";
export class CoreGeometryBuilderBase {
  fromPoints(object, points) {
    points = this._filterPoints(points);
    const geometry = new BufferGeometry();
    const firstPoint = points[0];
    if (!firstPoint) {
      return geometry;
    }
    const oldGeometry = firstPoint.geometry();
    if (!oldGeometry) {
      return geometry;
    }
    const new_index_by_old_index = {};
    for (let i = 0; i < points.length; i++) {
      new_index_by_old_index[points[i].index()] = i;
    }
    const indices = this._indicesFromPoints(new_index_by_old_index, oldGeometry);
    if (indices) {
      geometry.setIndex(indices);
    }
    const { attributes } = oldGeometry;
    for (const attribute_name of Object.keys(attributes)) {
      const attrib_values = firstPoint.userDataAttribs()[attribute_name];
      const is_attrib_indexed = attrib_values != null;
      if (is_attrib_indexed) {
        const new_values = [];
        const uniqValues = [];
        uniqWithoutPreservingOrder(
          points.map((point) => point.indexedAttribValue(attribute_name)),
          uniqValues
        );
        arrayCompact(uniqValues, new_values);
        const new_index_by_value = {};
        new_values.forEach((new_value, i) => new_index_by_value[new_value] = i);
        firstPoint.userDataAttribs()[attribute_name] = new_values;
        const new_attrib_indices = [];
        for (const point of points) {
          const oldIndex = point.indexedAttribValue(attribute_name);
          if (oldIndex) {
            const new_index = new_index_by_value[oldIndex];
            new_attrib_indices.push(new_index);
          }
        }
        geometry.setAttribute(attribute_name, new Float32BufferAttribute(new_attrib_indices, 1));
      } else {
        const attrib_size = attributes[attribute_name].itemSize;
        const values = new Array(points.length * attrib_size);
        switch (attrib_size) {
          case 1:
            for (let i = 0; i < points.length; i++) {
              values[i] = points[i].attribValue(attribute_name);
            }
            break;
          default:
            let value;
            for (let i = 0; i < points.length; i++) {
              value = points[i].attribValue(attribute_name);
              value.toArray(values, i * attrib_size);
            }
            break;
        }
        geometry.setAttribute(attribute_name, new Float32BufferAttribute(values, attrib_size));
      }
    }
    return geometry;
  }
}
