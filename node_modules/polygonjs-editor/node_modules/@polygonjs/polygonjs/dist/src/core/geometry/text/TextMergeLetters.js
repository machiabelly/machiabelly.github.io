"use strict";
import { BufferGeometry } from "three";
import { arrayCompact } from "../../ArrayUtils";
import { ObjectType } from "../Constant";
import { ThreejsCoreObject } from "../modules/three/ThreejsCoreObject";
import { isBooleanTrue } from "../../Type";
import { mergeGeometries } from "three/examples/jsm/utils/BufferGeometryUtils";
import { TransformResetSopOperation } from "../../../engine/operations/sop/TransformReset";
import { TypedSopNode } from "../../../engine/nodes/sop/_Base";
import { applyJustifyModeToGeometries } from "./TextJustify";
import { applyTextLineHeight } from "./TextLineHeight";
import { TextType } from "./TextType";
export function textMergeLetters(params) {
  const geometriesByLine = _geometriesByLine(params);
  for (const geometriesForLine of geometriesByLine) {
    applyJustifyModeToGeometries(geometriesForLine, params);
    applyTextLineHeight(geometriesForLine, params);
  }
  const allGeometries = geometriesByLine.flat();
  const objects = _mergeOrSplit({ ...params, geometries: allGeometries });
  if (objects) {
    const compactObjects = [];
    return arrayCompact(objects, compactObjects);
  }
}
function _mergeOrSplit(params) {
  const objectType = params.textType == TextType.LINE ? ObjectType.LINE_SEGMENTS : ObjectType.MESH;
  if (isBooleanTrue(params.splitPerLetter)) {
    let _createObject2 = function(geo) {
      let character = chars[characterIndex];
      if (character === "\n") {
        lineIndex++;
        characterIndex++;
        return;
      }
      if (character == " " && params.keepEmptyGeometries == false) {
        characterIndex++;
        return;
      }
      const object = TypedSopNode.createObject(geo || new BufferGeometry(), objectType);
      TransformResetSopOperation.centerObject(object, { applyMatrixToObject: true });
      const coreObject = new ThreejsCoreObject(object, characterIndex);
      coreObject.addAttribute("character", character);
      object.name = character;
      coreObject.addAttribute("characterId", characterIndex);
      coreObject.addAttribute("lineId", lineIndex);
      characterIndex++;
      return object;
    };
    var _createObject = _createObject2;
    const chars = Array.from(params.text);
    let characterIndex = 0;
    let lineIndex = 0;
    const objects = [];
    for (let i = 0; i < params.geometries.length; i++) {
      const object = _createObject2(params.geometries[i]);
      if (object) {
        objects.push(object);
      }
    }
    return objects;
  } else {
    try {
      const compactGeometries = [];
      arrayCompact(params.geometries, compactGeometries);
      if (compactGeometries.length > 0) {
        const mergedGeometry = mergeGeometries(compactGeometries);
        return [TypedSopNode.createObject(mergedGeometry, objectType)];
      }
    } catch (err) {
      return;
    }
  }
}
function _geometriesByLine(params) {
  const list = [];
  const chars = Array.from(params.text);
  let characterIndex = 0;
  let lineIndex = 0;
  for (const geometry of params.geometries) {
    let character = chars[characterIndex];
    if (character === "\n") {
      lineIndex++;
    }
    list[lineIndex] = list[lineIndex] || [];
    list[lineIndex].push(geometry);
    characterIndex++;
  }
  return list;
}
