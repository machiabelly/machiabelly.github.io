"use strict";
import { ParamConfig } from "../../engine/nodes/utils/params/ParamsConfig";
import {
  Color,
  Group,
  BackSide,
  BufferGeometry,
  Float32BufferAttribute,
  Line,
  LineBasicMaterial,
  Mesh,
  MeshBasicMaterial
} from "three";
export const DEFAULT_AREA_LIGHT_PARAMS = {
  color: new Color(1, 1, 1),
  intensity: 1,
  width: 1,
  height: 1,
  showHelper: false,
  name: "areaLight"
};
const DEFAULT = DEFAULT_AREA_LIGHT_PARAMS;
export function AreaLightParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.light = ParamConfig.FOLDER();
      /** @param light color */
      this.color = ParamConfig.COLOR(DEFAULT.color.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param light intensity */
      this.intensity = ParamConfig.FLOAT(DEFAULT.intensity, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param grid width */
      this.width = ParamConfig.FLOAT(DEFAULT.width, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param grid height */
      this.height = ParamConfig.FLOAT(DEFAULT.height, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      // helper
      /** @param toggle on to show helper */
      this.showHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);
      /** @param light name */
      this.name = ParamConfig.STRING("`$OS`");
    }
  };
}
function createLineGeo() {
  const geometry = new BufferGeometry();
  const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0].map((i) => i * 0.5);
  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  return geometry;
}
function createMeshGeo() {
  const positions = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0].map((i) => i * 0.5);
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
  geometry.computeBoundingSphere();
  return geometry;
}
export class CoreRectAreaLightHelper extends Group {
  constructor(light, nodeName) {
    super();
    this.light = light;
    this.nodeName = nodeName;
    this._childMesh = new Mesh(createMeshGeo(), new MeshBasicMaterial({ side: BackSide, fog: false }));
    this._childLine = new Line(createLineGeo(), new LineBasicMaterial());
    this.matrixAutoUpdate = false;
    this._childMesh.matrixAutoUpdate = false;
    this._childLine.matrixAutoUpdate = false;
    this.name = `CoreRectAreaLightHelper_${this.nodeName}`;
    this._childMesh.name = `CoreRectAreaLightHelperChildMesh_${this.nodeName}`;
    this._childLine.name = `CoreRectAreaLightHelperChildLine_${this.nodeName}`;
    this.add(this._childMesh);
    this.add(this._childLine);
  }
  update() {
    this.scale.set(1 * this.light.width, 1 * this.light.height, 1);
    this.updateMatrix();
    this._childLine.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    const c = this._childLine.material.color;
    const max = Math.max(c.r, c.g, c.b);
    if (max > 1)
      c.multiplyScalar(1 / max);
    this._childMesh.material.color.copy(this._childLine.material.color);
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld);
    this._childMesh.matrixWorld.copy(this.matrixWorld);
  }
  copy(source, recursive) {
    super.copy(source, false);
    return this;
  }
  dispose() {
    this._childLine.geometry.dispose();
    this._childLine.material.dispose();
    this._childMesh.geometry.dispose();
    this._childMesh.material.dispose();
  }
  clone(recursive) {
    const cloned = new CoreRectAreaLightHelper(this.light, this.nodeName);
    cloned.updateMatrixWorld();
    cloned.copy(this, false);
    cloned.update();
    return cloned;
  }
}
