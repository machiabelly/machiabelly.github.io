"use strict";
import { Color } from "three";
import { CoreType } from "../../../Type";
import {
  registerFactoryFunctions
} from "../../CoreObjectFactory";
import { CAD_GEOMETRY_TYPES_SET, CadGeometryType } from "./CadCommon";
import { CadCoreObject } from "./CadCoreObject";
import { CadPoint } from "./CadPoint";
import { CadVertex } from "./CadVertex";
import { TypeAssert } from "../../../../engine/poly/Assert";
import { CadPrimitiveCompound } from "./CadPrimitiveCompound";
import { CadPrimitiveCompSolid } from "./CadPrimitiveCompSolid";
import { CadPrimitiveEdge } from "./CadPrimitiveEdge";
import { CadPrimitiveWire } from "./CadPrimitiveWire";
import { CadPrimitiveFace } from "./CadPrimitiveFace";
import { CadPrimitiveShell } from "./CadPrimitiveShell";
import { CadPrimitiveSolid } from "./CadPrimitiveSolid";
const CAD_TESSELATION_PARAMS = {
  linearTolerance: 0,
  angularTolerance: 0,
  curveAbscissa: 0,
  curveTolerance: 0,
  wireframe: false,
  displayMeshes: false,
  displayEdges: false,
  meshesColor: new Color(),
  edgesColor: new Color()
};
function updateCADTesselationParams(params) {
  CAD_TESSELATION_PARAMS.linearTolerance = params.CADLinearTolerance;
  CAD_TESSELATION_PARAMS.angularTolerance = params.CADAngularTolerance;
  CAD_TESSELATION_PARAMS.curveAbscissa = params.CADCurveAbscissa;
  CAD_TESSELATION_PARAMS.curveTolerance = params.CADCurveTolerance;
  CAD_TESSELATION_PARAMS.wireframe = params.CADWireframe;
  CAD_TESSELATION_PARAMS.displayMeshes = params.CADDisplayMeshes;
  CAD_TESSELATION_PARAMS.displayEdges = params.CADDisplayEdges;
  CAD_TESSELATION_PARAMS.meshesColor.copy(params.CADMeshesColor);
  CAD_TESSELATION_PARAMS.edgesColor.copy(params.CADEdgesColor);
}
const onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newCadObjects = coreGroup.cadObjects();
  if (newCadObjects && newCadObjects.length != 0) {
    updateCADTesselationParams(params);
    for (const cadObject of newCadObjects) {
      const newObject3D = cadObject.toObject3D(CAD_TESSELATION_PARAMS, displayNode);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if (CoreType.isArray(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
export const primitiveClassFactoryNonAbstract = (object) => {
  if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
    const type = object.type;
    switch (type) {
      case CadGeometryType.POINT_2D: {
        return;
      }
      case CadGeometryType.CURVE_2D: {
        return;
      }
      case CadGeometryType.VERTEX: {
        return;
      }
      case CadGeometryType.EDGE: {
        return CadPrimitiveEdge;
      }
      case CadGeometryType.WIRE: {
        return CadPrimitiveWire;
      }
      case CadGeometryType.FACE: {
        return CadPrimitiveFace;
      }
      case CadGeometryType.SHELL: {
        return CadPrimitiveShell;
      }
      case CadGeometryType.SOLID: {
        return CadPrimitiveSolid;
      }
      case CadGeometryType.COMPSOLID: {
        return CadPrimitiveCompSolid;
      }
      case CadGeometryType.COMPOUND: {
        return CadPrimitiveCompound;
      }
    }
    TypeAssert.unreachable(type);
  }
};
export function onCadModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      return CadPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      return new CadPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      return CadVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      return new CadVertex(object, index);
    }
  };
  const primitiveClassFactory = primitiveClassFactoryNonAbstract;
  const primitiveInstanceFactory = (object, index = 0) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      const type = object.type;
      switch (type) {
        case CadGeometryType.POINT_2D: {
          return;
        }
        case CadGeometryType.CURVE_2D: {
          return;
        }
        case CadGeometryType.VERTEX: {
          return;
        }
        case CadGeometryType.EDGE: {
          return new CadPrimitiveEdge(object, index);
        }
        case CadGeometryType.WIRE: {
          return new CadPrimitiveWire(object, index);
        }
        case CadGeometryType.FACE: {
          return new CadPrimitiveFace(object, index);
        }
        case CadGeometryType.SHELL: {
          return new CadPrimitiveShell(object, index);
        }
        case CadGeometryType.SOLID: {
          return new CadPrimitiveSolid(object, index);
        }
        case CadGeometryType.COMPSOLID: {
          return new CadPrimitiveCompSolid(object, index);
        }
        case CadGeometryType.COMPOUND: {
          return new CadPrimitiveCompound(object, index);
        }
      }
      TypeAssert.unreachable(type);
    }
  };
  const objectClassFactory = (object) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      return CadCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (CAD_GEOMETRY_TYPES_SET.has(object.type)) {
      return new CadCoreObject(object, index);
    }
  };
  const factoryFunctions = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  registerFactoryFunctions(factoryFunctions);
  poly.specializedChildren.registerHook("CAD", onAddSpecializedChildren);
}
