"use strict";
import { setUnion, setToArray, setDifference } from "../../../../../SetUtils";
import { randFloat } from "../../../../../math/_Module";
import { sample } from "../../../../../ArrayUtils";
const _triangleIds = /* @__PURE__ */ new Set();
const _edgeIds0 = /* @__PURE__ */ new Set();
const _edgeIds1 = /* @__PURE__ */ new Set();
const _edgeIds2 = /* @__PURE__ */ new Set();
const _edgeIds3 = /* @__PURE__ */ new Set();
const _edgeIds10 = /* @__PURE__ */ new Set();
const _notVisited = /* @__PURE__ */ new Set();
const _edgeIdsArray = [];
export function triangleGraphExpandEdges(graph, startEdgeIds, target, excluded) {
  _triangleIds.clear();
  target.clear();
  startEdgeIds.forEach((edgeId) => {
    const edge = graph.edge(edgeId);
    if (edge) {
      const edgeTriangleIds = edge.triangleIds;
      for (const triangleId of edgeTriangleIds) {
        _triangleIds.add(triangleId);
      }
    }
  });
  _triangleIds.forEach((triangleId) => {
    const triangleEdges = graph.edgesByTriangleId(triangleId);
    if (triangleEdges) {
      for (const edge of triangleEdges) {
        if (!startEdgeIds.has(edge.id) && (excluded == null || !excluded.has(edge.id))) {
          target.add(edge.id);
        }
      }
    }
  });
}
export function triangleGraphFindExpandedEdge(graph, startEdgeId, seed, step, irregularAmount, visited) {
  _edgeIds0.clear();
  _edgeIds0.add(startEdgeId);
  triangleGraphExpandEdges(graph, _edgeIds0, _edgeIds1);
  triangleGraphExpandEdges(graph, _edgeIds1, _edgeIds2, _edgeIds0);
  const _sampleFromEdges2 = () => {
    setDifference(_edgeIds2, visited, _notVisited);
    setToArray(_notVisited, _edgeIdsArray);
    return sample(_edgeIdsArray, seed);
  };
  const _sampleFromEdges3 = () => {
    setUnion(_edgeIds0, _edgeIds1, _edgeIds10);
    triangleGraphExpandEdges(graph, _edgeIds2, _edgeIds3, _edgeIds10);
    setDifference(_edgeIds3, visited, _notVisited);
    setToArray(_notVisited, _edgeIdsArray);
    return sample(_edgeIdsArray, seed);
  };
  const foundEdgeId = randFloat(seed + step) > irregularAmount ? _sampleFromEdges2() : _sampleFromEdges3();
  return foundEdgeId;
}
