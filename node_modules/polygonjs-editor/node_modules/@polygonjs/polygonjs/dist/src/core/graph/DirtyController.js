"use strict";
import { Poly } from "../../engine/Poly";
export class DirtyController {
  constructor(node) {
    this.node = node;
    this._dirtyCount = 0;
    this._dirty = true;
    this._cooker = node.scene().cooker;
  }
  dispose() {
    this._postDirtyHooks = void 0;
    this._postDirtyHookNames = void 0;
  }
  isDirty() {
    return this._dirty === true;
  }
  dirtyTimestamp() {
    return this._dirtyTimestamp;
  }
  dirtyCount() {
    return this._dirtyCount;
  }
  hasPostDirtyHooks() {
    return this._postDirtyHookNames != null && this._postDirtyHookNames.length > 0;
  }
  addPostDirtyHook(name, method) {
    this._postDirtyHookNames = this._postDirtyHookNames || [];
    this._postDirtyHooks = this._postDirtyHooks || [];
    if (!this._postDirtyHookNames.includes(name)) {
      this._postDirtyHookNames.push(name);
      this._postDirtyHooks.push(method);
    } else {
      console.warn(`hook with name ${name} already exists`, this.node);
    }
  }
  removePostDirtyHook(name) {
    if (this._postDirtyHookNames && this._postDirtyHooks) {
      const index = this._postDirtyHookNames.indexOf(name);
      if (index >= 0) {
        this._postDirtyHookNames.splice(index, 1);
        this._postDirtyHooks.splice(index, 1);
      }
    }
  }
  hasHook(name) {
    if (this._postDirtyHookNames) {
      return this._postDirtyHookNames.includes(name);
    }
    return false;
  }
  removeDirtyState() {
    this._dirty = false;
  }
  setDirty(originalTriggerGraphNode, propagate = true) {
    if (originalTriggerGraphNode == null) {
      originalTriggerGraphNode = this.node;
    }
    if (originalTriggerGraphNode == this.node && this.node.selfDirtyForbidden()) {
      return;
    }
    this._dirty = true;
    this._dirtyTimestamp = Poly.performance.performanceManager().now();
    this._dirtyCount += 1;
    this.runPostDirtyHooks(originalTriggerGraphNode);
    if (propagate === true) {
      this.setSuccessorsDirty(originalTriggerGraphNode);
    }
  }
  runPostDirtyHooks(originalTriggerGraphNode) {
    if (this._postDirtyHooks == null || this._postDirtyHooks.length == 0) {
      return;
    }
    if (this._cooker.blocked()) {
      this._cooker.enqueue(this.node, originalTriggerGraphNode);
    } else {
      for (const hook of this._postDirtyHooks) {
        hook(originalTriggerGraphNode);
      }
    }
  }
  setSuccessorsDirty(originalTriggerGraphNode) {
    if (originalTriggerGraphNode == null) {
      originalTriggerGraphNode = this.node;
    }
    this._cooker.block();
    const allSuccessors = this.node.graphAllSuccessors();
    for (const successor of allSuccessors) {
      successor.dirtyController.setDirty(originalTriggerGraphNode, false);
    }
    this._cooker.unblock();
  }
}
