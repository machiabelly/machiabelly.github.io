"use strict";
import {
  selectedIndicesFromSelectionStates
} from "../../engine/nodes/sop/utils/group/GroupCommon";
import { TypeAssert } from "../../engine/poly/Assert";
import { arrayToSet } from "../ArrayUtils";
import { setToArray, setDifference, setIntersection, setUnion } from "../SetUtils";
const _currentIndicesSet = /* @__PURE__ */ new Set();
const _newIndicesSet = /* @__PURE__ */ new Set();
export var GroupOperation = /* @__PURE__ */ ((GroupOperation2) => {
  GroupOperation2["SET"] = "replace existing";
  GroupOperation2["UNION"] = "add to existing";
  GroupOperation2["SUBTRACT"] = "subtract from existing";
  GroupOperation2["INTERSECT"] = "intersect with existing";
  return GroupOperation2;
})(GroupOperation || {});
export const GROUP_OPERATIONS = [
  "replace existing" /* SET */,
  "add to existing" /* UNION */,
  "subtract from existing" /* SUBTRACT */,
  "intersect with existing" /* INTERSECT */
];
export var EntityGroupType = /* @__PURE__ */ ((EntityGroupType2) => {
  EntityGroupType2["POINT"] = "point";
  EntityGroupType2["OBJECT"] = "object";
  EntityGroupType2["EDGE"] = "edge";
  EntityGroupType2["FACE"] = "face";
  return EntityGroupType2;
})(EntityGroupType || {});
const USER_DATA_KEY_GROUPS = "groups";
export class EntityGroupCollection {
  // private _groupsByNameByType: Map<GroupType, Map<string, EntityGroup>> = new Map();
  constructor(_object) {
    this._object = _object;
    this.selectedIndices = /* @__PURE__ */ new Set();
  }
  attributesDictionary() {
    return EntityGroupCollection.attributesDictionary(this._object);
  }
  static attributesDictionary(object) {
    return object.userData[USER_DATA_KEY_GROUPS] || this._createAttributesDictionaryIfNone(object);
  }
  static _createAttributesDictionaryIfNone(object) {
    if (!object.userData[USER_DATA_KEY_GROUPS]) {
      return object.userData[USER_DATA_KEY_GROUPS] = {};
    }
  }
  findOrCreateGroup(type, groupName) {
    const dict = this.attributesDictionary();
    let groupsByName = dict[type];
    if (!groupsByName) {
      groupsByName = {};
      dict[type] = groupsByName;
    }
    let group = groupsByName[groupName];
    if (!group) {
      group = [];
      groupsByName[groupName] = group;
    }
    return group;
  }
  deleteGroup(type, groupName) {
    const dict = this.attributesDictionary();
    const groupsByName = dict[type];
    if (groupsByName) {
      delete groupsByName[groupName];
      if (Object.keys(groupsByName).length == 0) {
        delete dict[type];
      }
    }
  }
  static data(object) {
    const dict = this.attributesDictionary(object);
    const types = Object.keys(dict);
    const data = {};
    for (const type of types) {
      const dataForType = [];
      data[type] = dataForType;
      const groupsForType = dict[type];
      const groupNames = Object.keys(groupsForType);
      for (const groupName of groupNames) {
        const indices = groupsForType[groupName];
        const groupData = {
          name: groupName,
          entitiesCount: indices.length
        };
        dataForType.push(groupData);
      }
    }
    return data;
  }
  indicesSet(type, groupName, target) {
    const dict = this.attributesDictionary();
    const groupsByName = dict[type];
    target.clear();
    if (groupsByName) {
      const indices = groupsByName[groupName];
      if (indices) {
        arrayToSet(indices, target);
      }
    }
  }
  updateGroup(options, selectionStates) {
    const { type, groupName, operation, invert } = options;
    const currentIndices = this.findOrCreateGroup(type, groupName);
    const _updateGroup = (newIndicesSet) => {
      const dict = this.attributesDictionary();
      let groupsByName = dict[type];
      if (!groupsByName) {
        groupsByName = {};
        dict[type] = groupsByName;
      }
      const newIndices = [];
      groupsByName[groupName] = setToArray(newIndicesSet, newIndices);
    };
    this.selectedIndices.clear();
    selectedIndicesFromSelectionStates(selectionStates, this.selectedIndices, invert);
    switch (operation) {
      case "replace existing" /* SET */: {
        _updateGroup(this.selectedIndices);
        return;
      }
      case "add to existing" /* UNION */: {
        arrayToSet(currentIndices, _currentIndicesSet);
        setUnion(_currentIndicesSet, this.selectedIndices, _newIndicesSet);
        _updateGroup(_newIndicesSet);
        return;
      }
      case "subtract from existing" /* SUBTRACT */: {
        arrayToSet(currentIndices, _currentIndicesSet);
        setDifference(_currentIndicesSet, this.selectedIndices, _newIndicesSet);
        _updateGroup(_newIndicesSet);
        return;
      }
      case "intersect with existing" /* INTERSECT */: {
        arrayToSet(currentIndices, _currentIndicesSet);
        setIntersection(_currentIndicesSet, this.selectedIndices, _newIndicesSet);
        _updateGroup(_newIndicesSet);
        return;
      }
    }
    TypeAssert.unreachable(operation);
  }
}
