"use strict";
import {
  CadGC
} from "../CadCommon";
import { BufferGeometry, Float32BufferAttribute } from "three";
import { BaseSopOperation } from "../../../../../engine/operations/sop/_Base";
import { cadMaterialLine } from "../CadConstant";
import { ObjectType } from "../../../Constant";
import { CadLoaderSync } from "../CadLoaderSync";
import { cadShapeClone } from "./CadShapeCommon";
import { objectContentCopyProperties } from "../../../ObjectContent";
const STRIDE = 3;
const v0 = { current: 0 };
const v1 = { current: 0 };
export function cadEdgeObjectToObject3D(cadObject, tesselationParams) {
  const object = cadEdgeToObject3D(cadObject.cadGeometry(), tesselationParams);
  if (object) {
    objectContentCopyProperties(cadObject, object);
  }
  return object;
}
export function cadEdgeToObject3D(edge, tesselationParams) {
  const geometry = cadEdgeToBufferGeometry(edge, tesselationParams);
  if (!geometry) {
    return;
  }
  const object = BaseSopOperation.createObject(
    geometry,
    ObjectType.LINE_SEGMENTS,
    cadMaterialLine(tesselationParams.edgesColor)
  );
  return object;
}
export function cadEdgeToBufferGeometry(edge, tesselationParams) {
  const oc = CadLoaderSync.oc();
  const handle = curveDataFromEdge(oc, edge).curveHandle;
  const curve = handle.get();
  if (!curve) {
    return;
  }
  return CadGC.withGC((r) => {
    const geom2Dadaptor = r(new oc.GeomAdaptor_Curve_2(handle));
    const uniformAbscissa = r(
      new oc.GCPnts_UniformAbscissa_3(
        geom2Dadaptor,
        tesselationParams.curveAbscissa,
        v0.current,
        v1.current,
        tesselationParams.curveTolerance
      )
    );
    let positions;
    let indices;
    const point = CadLoaderSync.gp_Pnt;
    if (uniformAbscissa.IsDone()) {
      const pointsCount = uniformAbscissa.NbPoints();
      positions = new Array(pointsCount * 3);
      indices = new Array(pointsCount);
      for (let i = 0; i < pointsCount; i++) {
        curve.D0(uniformAbscissa.Parameter(i + 1), point);
        const index = i * STRIDE;
        positions[index] = point.X();
        positions[index + 1] = point.Y();
        positions[index + 2] = point.Z();
        if (i > 0) {
          indices[(i - 1) * 2] = i - 1;
          indices[(i - 1) * 2 + 1] = i;
        }
      }
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(positions || [], 3));
    geometry.setIndex(indices || []);
    return geometry;
  });
}
export function curveDataFromEdge(oc, edge) {
  oc.BRep_Tool.Range_1(edge, v0, v1);
  const curveHandle = oc.BRep_Tool.Curve_2(edge, v0.current, v1.current);
  return {
    curveHandle,
    v0: v0.current,
    v1: v1.current
  };
}
export function cadEdgeCreate(oc, curve) {
  return CadGC.withGC((r) => {
    const curveHandle = r(new oc.Handle_Geom_Curve_2(curve));
    const api = r(new oc.BRepBuilderAPI_MakeEdge_24(curveHandle));
    const edge = api.Edge();
    return edge;
  });
}
export function cadEdgeClone(src) {
  const oc = CadLoaderSync.oc();
  return oc.TopoDS.Edge_1(cadShapeClone(src));
}
