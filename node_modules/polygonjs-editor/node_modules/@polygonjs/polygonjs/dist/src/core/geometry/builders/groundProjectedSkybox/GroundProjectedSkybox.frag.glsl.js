export default "varying vec3 vWorldPosition;\n\nuniform float radius;\nuniform float height;\nuniform float angle;\n\n#ifdef ENVMAP_TYPE_CUBE\n\n	uniform samplerCube map;\n\n#else\n\n	uniform sampler2D map;\n\n#endif\n\n// From: https://www.shadertoy.com/view/4tsBD7\nfloat diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) {\n\n	float d = dot ( rd, n );\n\n	if( d > 0.0 ) { return 1e6; }\n\n	vec3  o = ro - c;\n	float t = - dot( n, o ) / d;\n	vec3  q = o + rd * t;\n\n	return ( dot( q, q ) < r * r ) ? t : 1e6;\n\n}\n\n// From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) {\n\n	vec3 oc = ro - ce;\n	float b = dot( oc, rd );\n	float c = dot( oc, oc ) - ra * ra;\n	float h = b * b - c;\n\n	if( h < 0.0 ) { return -1.0; }\n\n	h = sqrt( h );\n\n	return - b + h;\n\n}\n\nvec3 project() {\n\n	vec3 p = normalize( vWorldPosition );\n	vec3 camPos = cameraPosition;\n	camPos.y -= height;\n\n	float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n	if( intersection > 0.0 ) {\n\n		vec3 h = vec3( 0.0, - height, 0.0 );\n		float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n		p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n\n	} else {\n\n		p = vec3( 0.0, 1.0, 0.0 );\n\n	}\n\n	return p;\n\n}\n\n#include <common>\n\nvoid main() {\n\n	vec3 projectedWorldPosition = project();\n\n	#ifdef ENVMAP_TYPE_CUBE\n\n		vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n\n	#else\n\n		vec3 direction = normalize( projectedWorldPosition );\n		vec2 uv = equirectUv( direction );\n		vec3 outcolor = texture2D( map, uv ).rgb;\n\n	#endif\n\n	gl_FragColor = vec4( outcolor, 1.0 );\n\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n\n}";
