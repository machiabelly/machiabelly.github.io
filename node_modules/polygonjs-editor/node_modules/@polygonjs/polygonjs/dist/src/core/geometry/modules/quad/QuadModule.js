"use strict";
import { Color } from "three";
import {
  registerFactoryFunctions
} from "../../CoreObjectFactory";
import { QUAD_OBJECT_TYPES_SET } from "./QuadCommon";
import { QuadCoreObject } from "./QuadCoreObject";
import { isArray } from "../../../Type";
import { QuadPoint } from "./QuadPoint";
import { QuadVertex } from "./QuadVertex";
import { QuadPrimitive } from "./QuadPrimitive";
import { QuadObject } from "./QuadObject";
import { ObjectType, registerObjectType } from "../../Constant";
const QUAD_TESSELATION_PARAMS = {
  triangles: true,
  splitQuads: false,
  wireframe: true,
  wireframeColor: new Color(0, 0, 0),
  center: false,
  innerRadius: false,
  outerRadius: false,
  pointAttributes: "*",
  primitiveAttributes: "*"
};
function updateQUADTesselationParams(params) {
  QUAD_TESSELATION_PARAMS.triangles = params.QUADTriangles;
  QUAD_TESSELATION_PARAMS.splitQuads = params.QUADSplitQuads;
  QUAD_TESSELATION_PARAMS.wireframe = params.QUADWireframe;
  QUAD_TESSELATION_PARAMS.wireframeColor.copy(params.QUADWireframeColor);
  QUAD_TESSELATION_PARAMS.center = params.QUADCenter;
  QUAD_TESSELATION_PARAMS.innerRadius = params.QUADInnerRadius;
  QUAD_TESSELATION_PARAMS.outerRadius = params.QUADOuterRadius;
  QUAD_TESSELATION_PARAMS.pointAttributes = params.QUADPointAttributes;
  QUAD_TESSELATION_PARAMS.primitiveAttributes = params.QUADPrimitiveAttributes;
}
const onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newQuadObjects = coreGroup.quadObjects();
  if (newQuadObjects && newQuadObjects.length != 0) {
    updateQUADTesselationParams(params);
    for (const quadObject of newQuadObjects) {
      const newObject3D = quadObject.toObject3D(QUAD_TESSELATION_PARAMS);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if (isArray(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
export function onQuadModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return QuadPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return new QuadPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return QuadVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return new QuadVertex(object, index);
    }
  };
  const primitiveClassFactory = (object) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return QuadPrimitive;
    }
  };
  const primitiveInstanceFactory = (object, index = 0) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return new QuadPrimitive(object, index);
    }
  };
  const objectClassFactory = (object) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return QuadCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (QUAD_OBJECT_TYPES_SET.has(object.type)) {
      return new QuadCoreObject(object, index);
    }
  };
  const factoryFunction = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  registerFactoryFunctions(factoryFunction);
  poly.specializedChildren.registerHook("QUAD", onAddSpecializedChildren);
  const type = "QuadObject";
  registerObjectType({
    type,
    checkFunc: (o) => {
      if (QUAD_OBJECT_TYPES_SET.has(o.type)) {
        return ObjectType.QUAD;
      }
    },
    ctor: QuadObject,
    humanName: "QuadObject"
  });
}
