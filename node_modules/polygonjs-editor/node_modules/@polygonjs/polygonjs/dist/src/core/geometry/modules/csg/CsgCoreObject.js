"use strict";
import { Box3 } from "three";
import { CsgObject } from "./CsgObject";
import { csgIsGeom2, csgIsGeom3 } from "./CsgCoreType";
import { BaseCoreObject } from "../../entities/object/BaseCoreObject";
import { objectContentCopyProperties } from "../../ObjectContent";
import { TransformTargetType } from "../../../Transform";
import { TypeAssert } from "../../../../engine/poly/Assert";
import { csgApplyTransform, csgApplyMatrix4 } from "./math/CsgMat4";
import { booleans } from "@jscad/modeling";
import { objectData } from "../../entities/object/BaseCoreObjectUtils";
import { CsgPoint } from "./CsgPoint";
import { CsgVertex } from "./CsgVertex";
import { primitiveClassFactoryNonAbstract } from "./CsgModule";
const { union } = booleans;
const _bbox = new Box3();
export class CsgCoreObject extends BaseCoreObject {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  static position(object, target) {
    object.boundingBox(_bbox);
    _bbox.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this._object.boundingSphere(target);
  }
  static objectData(object) {
    const data = objectData(object);
    data.pointsCount = CsgPoint.entitiesCount(object);
    data.verticesCount = CsgVertex.entitiesCount(object);
    const primitiveClass = primitiveClassFactoryNonAbstract(object);
    data.primitivesCount = (primitiveClass == null ? void 0 : primitiveClass.entitiesCount(object)) || 0;
    data.primitiveName = (primitiveClass == null ? void 0 : primitiveClass.primitiveName()) || "";
    return data;
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    switch (transformTargetType) {
      case TransformTargetType.GEOMETRY: {
        return csgApplyMatrix4(object.csgGeometry(), matrix);
      }
      case TransformTargetType.OBJECT: {
        return object.applyMatrix4(matrix);
      }
    }
    TypeAssert.unreachable(transformTargetType);
  }
  static mergeCompact(options) {
    const { objects, material, mergedObjects, onError } = options;
    try {
      const csgObjects = objects;
      const firstObject = csgObjects[0];
      if (!firstObject) {
        return;
      }
      const geometries2 = csgObjects.map((o) => o.csgGeometry());
      const geom2s = [];
      const geom3s = [];
      for (const geometry of geometries2) {
        if (csgIsGeom2(geometry)) {
          geom2s.push(geometry);
        }
        if (csgIsGeom3(geometry)) {
          geom3s.push(geometry);
        }
      }
      const _merge = (typedGeometries) => {
        if (typedGeometries.length == 0) {
          return;
        }
        typedGeometries.forEach(csgApplyTransform);
        const mergedGeom = union(typedGeometries);
        const newObject = new CsgObject(mergedGeom);
        objectContentCopyProperties(firstObject, newObject);
        if (material) {
          newObject.material = material;
        }
        mergedObjects.push(newObject);
      };
      _merge(geom2s);
      _merge(geom3s);
    } catch (e) {
      onError(e.message || "unknown error");
    }
  }
}
