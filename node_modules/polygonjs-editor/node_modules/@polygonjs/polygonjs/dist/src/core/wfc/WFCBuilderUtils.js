"use strict";
import { Vector3 } from "three";
import { tileCubeLatticeDeform } from "./WFCTileDeform";
import { ThreejsCoreObject } from "../geometry/modules/three/ThreejsCoreObject";
import { quadPrimitivePointIndexIndices } from "../geometry/modules/quad/utils/QuadUtils";
import { Attribute } from "../geometry/Attribute";
const tileCorners = {
  p0: new Vector3(),
  p1: new Vector3(),
  p2: new Vector3(),
  p3: new Vector3(),
  height: 1
};
export function placeObjectOnQuad(options) {
  const tileObject = ThreejsCoreObject.clone(options.object);
  quadNodeCorners(options.quadObject, options.primitiveIndex, tileCorners);
  tileCorners.height = options.height;
  tileObject.traverse((child) => {
    tileCubeLatticeDeform(child, tileCorners, options.rotation);
  });
  return tileObject;
}
const _indices = {
  i0: 0,
  i1: 0,
  i2: 0,
  i3: 0
};
export function quadNodeCorners(quadObject, primitiveIndex, target) {
  const quadGeometry = quadObject.geometry;
  const index = quadGeometry.index;
  const positionAttribute = quadGeometry.attributes[Attribute.POSITION];
  if (!positionAttribute) {
    return target;
  }
  quadPrimitivePointIndexIndices(primitiveIndex, _indices);
  const positionArray = positionAttribute.array;
  target.p0.fromArray(positionArray, index[_indices.i0] * 3);
  target.p1.fromArray(positionArray, index[_indices.i3] * 3);
  target.p2.fromArray(positionArray, index[_indices.i2] * 3);
  target.p3.fromArray(positionArray, index[_indices.i1] * 3);
}
