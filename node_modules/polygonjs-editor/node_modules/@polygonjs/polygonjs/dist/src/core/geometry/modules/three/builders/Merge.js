"use strict";
import { Mesh } from "three";
import { mergeGeometries } from "three/examples/jsm/utils/BufferGeometryUtils";
import { CoreGeometryIndexBuilder } from "../../../util/IndexBuilder";
import { pointsFromBufferGeometry } from "../CoreThreejsPointUtils";
import { ThreejsPoint } from "../ThreejsPoint";
const dummyMesh = new Mesh();
export class CoreGeometryBuilderMerge {
  static merge(geometries) {
    if (geometries.length === 0) {
      return;
    }
    for (const geometry of geometries) {
      CoreGeometryIndexBuilder.createIndexIfNone(geometry);
    }
    dummyMesh.geometry = geometries[0];
    const indexed_attribute_names = ThreejsPoint.indexedAttributeNames(dummyMesh);
    const new_values_by_attribute_name = {};
    for (const indexed_attribute_name of indexed_attribute_names) {
      const index_by_values = {};
      const all_geometries_points = [];
      for (const geometry of geometries) {
        const points = pointsFromBufferGeometry(geometry);
        for (const point of points) {
          all_geometries_points.push(point);
          const value = point.indexedAttribValue(indexed_attribute_name);
          if (value) {
            index_by_values[value] != null ? index_by_values[value] : index_by_values[value] = Object.keys(index_by_values).length;
          }
        }
      }
      const values = Object.keys(index_by_values);
      for (const point of all_geometries_points) {
        const value = point.indexedAttribValue(indexed_attribute_name);
        if (value) {
          const new_index = index_by_values[value];
          point.setAttribIndex(indexed_attribute_name, new_index);
        }
      }
      new_values_by_attribute_name[indexed_attribute_name] = values;
    }
    const mergedGeometry = mergeGeometries(geometries);
    dummyMesh.geometry = mergedGeometry;
    Object.keys(new_values_by_attribute_name).forEach((indexed_attribute_name) => {
      const values = new_values_by_attribute_name[indexed_attribute_name];
      ThreejsPoint.setIndexedAttributeValues(dummyMesh, indexed_attribute_name, values);
    });
    if (mergedGeometry) {
      delete mergedGeometry.userData.mergedUserData;
    }
    return mergedGeometry;
  }
}
