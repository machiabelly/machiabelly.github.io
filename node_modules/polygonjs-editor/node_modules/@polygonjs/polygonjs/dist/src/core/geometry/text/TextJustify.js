"use strict";
import { TypeAssert } from "../../../engine/poly/Assert";
export var TextSopJustifiyMode = /* @__PURE__ */ ((TextSopJustifiyMode2) => {
  TextSopJustifiyMode2["LEFT"] = "left";
  TextSopJustifiyMode2["RIGHT"] = "right";
  TextSopJustifiyMode2["CENTER"] = "center";
  return TextSopJustifiyMode2;
})(TextSopJustifiyMode || {});
export const TEXT_SOP_JUSTIFY_MODES = [
  "left" /* LEFT */,
  "right" /* RIGHT */,
  "center" /* CENTER */
];
export function applyJustifyModeToGeometries(geometries, params) {
  if (geometries.length == 0) {
    return;
  }
  let totalBoundingBox = null;
  for (const geometry of geometries) {
    if (!geometry)
      continue;
    geometry.computeBoundingBox();
    if (geometry.boundingBox) {
      if (totalBoundingBox == null) {
        totalBoundingBox = geometry.boundingBox;
      } else {
        totalBoundingBox.union(geometry.boundingBox);
      }
    }
  }
  if (!totalBoundingBox) {
    return;
  }
  const justifyMode = params.justifyMode;
  applyJustifyModeToGeometry(geometries, justifyMode, totalBoundingBox);
}
function applyJustifyModeToGeometry(geometries, justifyMode, totalBoundingBox) {
  switch (justifyMode) {
    case "left" /* LEFT */: {
      return;
    }
    case "center" /* CENTER */: {
      const currentCenter = 0.5 * (totalBoundingBox.min.x + totalBoundingBox.max.x);
      for (const geometry of geometries) {
        geometry == null ? void 0 : geometry.translate(-currentCenter, 0, 0);
      }
      return;
    }
    case "right" /* RIGHT */: {
      const currentRight = totalBoundingBox.max.x;
      for (const geometry of geometries) {
        geometry == null ? void 0 : geometry.translate(-currentRight, 0, 0);
      }
      return;
    }
  }
  TypeAssert.unreachable(justifyMode);
}
