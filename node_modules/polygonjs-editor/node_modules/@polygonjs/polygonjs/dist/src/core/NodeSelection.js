"use strict";
import { NodeEvent } from "../engine/poly/NodeEvent";
import { arrayIsEqual, arrayUnion, arrayDifference, arrayMap, arrayCopy } from "./ArrayUtils";
const _nodes = [];
const _nodeIds = [];
export class CoreNodeSelection {
  constructor(_node) {
    this._node = _node;
    this._nodeIds = [];
  }
  node() {
    return this._node;
  }
  nodeIds() {
    return this._nodeIds;
  }
  nodeFromIndex(index) {
    this._node.scene().graph.nodesFromIds(this._nodeIds, _nodes);
    return _nodes[index];
  }
  nodes(target) {
    this._node.scene().graph.nodesFromIds(this._nodeIds, target);
    return target;
  }
  contains(node) {
    return this._nodeIds.includes(node.graphNodeId());
  }
  equals(nodes) {
    arrayMap(nodes, (node) => node.graphNodeId(), _nodeIds);
    _nodeIds.sort();
    return arrayIsEqual(_nodeIds, this._nodeIds);
  }
  clear() {
    this._nodeIds.length = 0;
    this._sendUpdateEvent();
  }
  set(nodes) {
    this._nodeIds.length = 0;
    this.add(nodes);
  }
  add(nodesToAdd) {
    arrayMap(nodesToAdd, (node) => node.graphNodeId(), _nodeIds);
    arrayUnion(this._nodeIds, _nodeIds, this._nodeIds);
    this._sendUpdateEvent();
  }
  remove(nodesToRemove) {
    arrayMap(nodesToRemove, (node) => node.graphNodeId(), _nodeIds);
    arrayDifference(this._nodeIds, _nodeIds, this._nodeIds);
    this._sendUpdateEvent();
  }
  _checkValidity() {
    this.nodes(_nodes);
    if (_nodes.length != this._nodeIds.length) {
      console.error("selection invalid: at least one node is not part of the graph");
      return;
    }
    for (const node of _nodes) {
      if (node.parent() != this._node) {
        console.error("selection invalid: at least one node is not has another parent");
      }
    }
  }
  _sendUpdateEvent() {
    this._checkValidity();
    this._node.emit(NodeEvent.SELECTION_UPDATED);
  }
  toJSON(target) {
    arrayCopy(this._nodeIds, target);
  }
}
