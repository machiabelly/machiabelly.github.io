"use strict";
import { CameraAttribute } from "../CoreCamera";
import {
  WEBXR_REFERENCE_SPACE_TYPES
} from "../../webXR/Common";
import { WEBXR_VR_FEATURES } from "../../webXR/webXRVR/CommonVR";
import { WEBXR_AR_FEATURES } from "../../webXR/webXRAR/CommonAR";
import { coreObjectClassFactory } from "../../geometry/CoreObjectFactory";
function getFeatures(camera, attribName, existingFeatures) {
  const features = [];
  const featuresStr = coreObjectClassFactory(camera).attribValue(camera, attribName);
  const featuresStrings = featuresStr == null ? void 0 : featuresStr.split(" ");
  if (featuresStrings) {
    for (const featuresString of featuresStrings) {
      if (existingFeatures.includes(featuresString)) {
        features.push(featuresString);
      }
    }
  }
  return features;
}
function _getRequiredAndOptionalFeatures(camera, existingFeatures, attribNames) {
  const optionalFeatures = getFeatures(camera, attribNames.optional, existingFeatures);
  const requiredFeatures = getFeatures(camera, attribNames.required, existingFeatures);
  return { requiredFeatures, optionalFeatures };
}
function _getReferenceSpaceType(camera, options) {
  const coreObjectClass = coreObjectClassFactory(camera);
  let overrideReferenceSpaceType = coreObjectClass.attribValue(camera, options.override);
  let referenceSpaceType = coreObjectClass.attribValue(camera, options.type);
  if (!(referenceSpaceType && WEBXR_REFERENCE_SPACE_TYPES.includes(referenceSpaceType))) {
    overrideReferenceSpaceType = false;
    referenceSpaceType = void 0;
  }
  return { overrideReferenceSpaceType, referenceSpaceType };
}
export class CoreCameraWebXRController {
  static process(options) {
    const { camera, scene, renderer, canvas } = options;
    const controllers = [];
    const subMountFunctions = [];
    const subUnmountFunctions = [];
    const mountFunction = () => {
      for (const subFunc of subMountFunctions) {
        subFunc();
      }
    };
    const unmountFunction = () => {
      for (const subFunc of subUnmountFunctions) {
        subFunc();
      }
    };
    const coreObjectClass = coreObjectClassFactory(camera);
    const isWebAR = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR);
    if (isWebAR == true) {
      const createFunction = scene.webXR.ARControllerCreateFunction();
      if (createFunction) {
        const { overrideReferenceSpaceType, referenceSpaceType } = _getReferenceSpaceType(camera, {
          type: CameraAttribute.WEBXR_AR_OVERRIDE_REFERENCE_SPACE_TYPE,
          override: CameraAttribute.WEBXR_AR_REFERENCE_SPACE_TYPE
        });
        const { requiredFeatures, optionalFeatures } = _getRequiredAndOptionalFeatures(
          camera,
          WEBXR_AR_FEATURES,
          {
            optional: CameraAttribute.WEBXR_AR_FEATURES_OPTIONAL,
            required: CameraAttribute.WEBXR_AR_FEATURES_REQUIRED
          }
        );
        const controller = createFunction(renderer, camera, canvas, {
          overrideReferenceSpaceType: overrideReferenceSpaceType || false,
          referenceSpaceType,
          requiredFeatures,
          optionalFeatures
        });
        controllers.push(controller);
      }
    }
    const isWebVR = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_VR);
    if (isWebVR == true) {
      const createFunction = scene.webXR.VRControllerCreateFunction();
      if (createFunction) {
        const { overrideReferenceSpaceType, referenceSpaceType } = _getReferenceSpaceType(camera, {
          type: CameraAttribute.WEBXR_VR_OVERRIDE_REFERENCE_SPACE_TYPE,
          override: CameraAttribute.WEBXR_VR_REFERENCE_SPACE_TYPE
        });
        const { requiredFeatures, optionalFeatures } = _getRequiredAndOptionalFeatures(
          camera,
          WEBXR_VR_FEATURES,
          {
            optional: CameraAttribute.WEBXR_VR_FEATURES_OPTIONAL,
            required: CameraAttribute.WEBXR_VR_FEATURES_REQUIRED
          }
        );
        const controller = createFunction(renderer, camera, canvas, {
          overrideReferenceSpaceType: overrideReferenceSpaceType || false,
          referenceSpaceType,
          requiredFeatures,
          optionalFeatures
        });
        controllers.push(controller);
      }
    }
    for (const controller of controllers) {
      subMountFunctions.push(() => controller.mount());
      subUnmountFunctions.push(() => controller.unmount());
    }
    return { mountFunction, unmountFunction };
  }
}
