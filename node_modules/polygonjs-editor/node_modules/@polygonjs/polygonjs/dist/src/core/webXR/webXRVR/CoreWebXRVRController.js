"use strict";
import {
  BufferGeometry,
  Float32BufferAttribute,
  AdditiveBlending,
  LineBasicMaterial,
  Line,
  RingGeometry,
  MeshBasicMaterial,
  Mesh
} from "three";
import { CoreVRButton } from "../buttons/CoreVRButton";
import { BaseCoreWebXRController } from "../_BaseCoreWebXRController";
import { BaseXRSessionEventName } from "../Common";
function buildController(data) {
  let geometry, material;
  switch (data.targetRayMode) {
    case "tracked-pointer":
      geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
      geometry.setAttribute("color", new Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
      material = new LineBasicMaterial({ vertexColors: true, blending: AdditiveBlending });
      return new Line(geometry, material);
    case "gaze":
      geometry = new RingGeometry(0.02, 0.04, 32).translate(0, 0, -1);
      material = new MeshBasicMaterial({ opacity: 0.5, transparent: true });
      return new Mesh(geometry, material);
  }
}
export class CoreWebXRVRController extends BaseCoreWebXRController {
  constructor(scene, renderer, camera, canvas, options) {
    super(scene, renderer, camera, canvas, options);
    this.options = options;
    this._baseReferenceSpace = null;
  }
  mount() {
    super.mount();
    const xr = this.renderer.xr;
    xr.addEventListener("sessionstart", () => this._baseReferenceSpace = xr.getReferenceSpace());
  }
  async requestSession(sessionInit, onSessionStarted) {
    var _a;
    super.requestSession(sessionInit, onSessionStarted);
    return (_a = navigator.xr) == null ? void 0 : _a.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
  }
  _onSessionStart() {
    this.scene.webXR.setActiveVRController(this);
    super._onSessionStart();
  }
  _onSessionEnd() {
    this.scene.webXR.setActiveVRController(null);
    super._onSessionEnd();
  }
  baseReferenceSpace() {
    return this._baseReferenceSpace;
  }
  setReferenceSpace(referenceSpace) {
    this.renderer.xr.setReferenceSpace(referenceSpace);
  }
  _addControllerEvents(controllerContainer, controllerIndex) {
    let controllerChild;
    controllerContainer.controller.addEventListener(BaseXRSessionEventName.CONNECTED, function(event) {
      const data = event.data;
      const _controllerChild = buildController(data);
      if (_controllerChild) {
        controllerChild = _controllerChild;
        controllerChild.name = `VR-eye-target-${controllerIndex}`;
        controllerContainer.controller.add(controllerChild);
      }
    });
    controllerContainer.controller.addEventListener(BaseXRSessionEventName.DISCONNECTED, function() {
      if (controllerChild) {
        controllerContainer.controller.remove(controllerChild);
      }
    });
  }
  createButton() {
    return CoreVRButton.createButton(
      {
        renderer: this.renderer,
        controller: this
      },
      {
        optionalFeatures: this.options.optionalFeatures,
        requiredFeatures: this.options.requiredFeatures
      }
    );
  }
  attachButton(parentElement, buttonElement) {
    parentElement.append(buttonElement);
  }
}
