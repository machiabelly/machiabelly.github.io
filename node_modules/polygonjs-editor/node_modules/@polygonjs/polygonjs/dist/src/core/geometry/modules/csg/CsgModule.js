"use strict";
import { Color } from "three";
import { CoreType } from "../../../Type";
import {
  registerFactoryFunctions
} from "../../CoreObjectFactory";
import { CSG_GEOMETRY_TYPES_SET, CsgGeometryType } from "./CsgCommon";
import { CsgCoreObject } from "./CsgCoreObject";
import { CsgPoint } from "./CsgPoint";
import { CsgVertex } from "./CsgVertex";
import { TypeAssert } from "../../../../engine/poly/Assert";
import { CsgPrimitivePath2 } from "./CsgPrimitivePath2";
import { CsgPrimitiveGeom2 } from "./CsgPrimitiveGeom2";
import { CsgPrimitiveGeom3 } from "./CsgPrimitiveGeom3";
const CSG_TESSELATION_PARAMS = {
  facetAngle: 0,
  wireframe: false,
  meshesColor: new Color(),
  linesColor: new Color()
};
function updateCSGTesselationParams(params) {
  CSG_TESSELATION_PARAMS.facetAngle = params.CSGFacetAngle;
  CSG_TESSELATION_PARAMS.wireframe = params.CSGWireframe;
  CSG_TESSELATION_PARAMS.meshesColor.copy(params.CSGMeshesColor);
  CSG_TESSELATION_PARAMS.linesColor.copy(params.CSGLinesColor);
}
const onAddSpecializedChildren = (displayNode, coreGroup, newObjects, params) => {
  let newObjectsAreDifferent = false;
  const newCsgObjects = coreGroup.csgObjects();
  if (newCsgObjects && newCsgObjects.length != 0) {
    updateCSGTesselationParams(params);
    for (const csgObject of newCsgObjects) {
      const newObject3D = csgObject.toObject3D(CSG_TESSELATION_PARAMS);
      if (newObject3D) {
        newObjectsAreDifferent = true;
        if (CoreType.isArray(newObject3D)) {
          newObjects.push(...newObject3D);
        } else {
          newObjects.push(newObject3D);
        }
      }
    }
  }
  return newObjectsAreDifferent;
};
export const primitiveClassFactoryNonAbstract = (object) => {
  if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
    const type = object.type;
    switch (type) {
      case CsgGeometryType.PATH2: {
        return CsgPrimitivePath2;
      }
      case CsgGeometryType.GEOM2: {
        return CsgPrimitiveGeom2;
      }
      case CsgGeometryType.GEOM3: {
        return CsgPrimitiveGeom3;
      }
    }
    TypeAssert.unreachable(type);
  }
};
export function onCsgModuleRegister(poly) {
  const pointClassFactory = (object) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      return CsgPoint;
    }
  };
  const pointInstanceFactory = (object, index = 0) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      return new CsgPoint(object, index);
    }
  };
  const vertexClassFactory = (object) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      return CsgVertex;
    }
  };
  const vertexInstanceFactory = (object, index = 0) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      return new CsgVertex(object, index);
    }
  };
  const primitiveClassFactory = primitiveClassFactoryNonAbstract;
  const primitiveInstanceFactory = (object, index = 0) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      const type = object.type;
      switch (type) {
        case CsgGeometryType.PATH2: {
          return new CsgPrimitivePath2(object, index);
        }
        case CsgGeometryType.GEOM2: {
          return new CsgPrimitiveGeom2(object, index);
        }
        case CsgGeometryType.GEOM3: {
          return new CsgPrimitiveGeom3(object, index);
        }
      }
      TypeAssert.unreachable(type);
    }
  };
  const objectClassFactory = (object) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      return CsgCoreObject;
    }
  };
  const objectInstanceFactory = (object, index = 0) => {
    if (CSG_GEOMETRY_TYPES_SET.has(object.type)) {
      return new CsgCoreObject(object, index);
    }
  };
  const factoryFunctions = {
    pointClass: pointClassFactory,
    pointInstance: pointInstanceFactory,
    vertexClass: vertexClassFactory,
    vertexInstance: vertexInstanceFactory,
    primitiveClass: primitiveClassFactory,
    primitiveInstance: primitiveInstanceFactory,
    objectClass: objectClassFactory,
    objectInstance: objectInstanceFactory
  };
  registerFactoryFunctions(factoryFunctions);
  poly.specializedChildren.registerHook("CSG", onAddSpecializedChildren);
}
