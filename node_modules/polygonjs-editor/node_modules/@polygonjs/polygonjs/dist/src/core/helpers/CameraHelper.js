"use strict";
import {
  PerspectiveCamera,
  Vector3,
  LineSegments,
  Color,
  LineBasicMaterial,
  BufferGeometry,
  Float32BufferAttribute
} from "three";
const _vector = /* @__PURE__ */ new Vector3();
const _camera = /* @__PURE__ */ new PerspectiveCamera();
function _createGeometry() {
  const geometry = new BufferGeometry();
  const colorFrustum = new Color(16755200);
  const colorCone = new Color(16711680);
  const colorUp = new Color(43775);
  const colorTarget = new Color(16777215);
  const colorCross = new Color(3355443);
  const vertices = [];
  const colors = [];
  const pointMap = {};
  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }
  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);
    if (pointMap[id] === void 0) {
      pointMap[id] = [];
    }
    pointMap[id].push(vertices.length / 3 - 1);
  }
  addLine("n1", "n2", colorFrustum);
  addLine("n2", "n4", colorFrustum);
  addLine("n4", "n3", colorFrustum);
  addLine("n3", "n1", colorFrustum);
  addLine("f1", "f2", colorFrustum);
  addLine("f2", "f4", colorFrustum);
  addLine("f4", "f3", colorFrustum);
  addLine("f3", "f1", colorFrustum);
  addLine("n1", "f1", colorFrustum);
  addLine("n2", "f2", colorFrustum);
  addLine("n3", "f3", colorFrustum);
  addLine("n4", "f4", colorFrustum);
  addLine("p", "n1", colorCone);
  addLine("p", "n2", colorCone);
  addLine("p", "n3", colorCone);
  addLine("p", "n4", colorCone);
  addLine("u1", "u2", colorUp);
  addLine("u2", "u3", colorUp);
  addLine("u3", "u1", colorUp);
  addLine("c", "t", colorTarget);
  addLine("p", "c", colorCross);
  addLine("cn1", "cn2", colorCross);
  addLine("cn3", "cn4", colorCross);
  addLine("cf1", "cf2", colorCross);
  addLine("cf3", "cf4", colorCross);
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  return { geometry, pointMap };
}
function _createMaterial() {
  return new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
}
class CameraHelper extends LineSegments {
  constructor(camera) {
    super();
    this._pointMap = {};
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) {
      this.camera.updateProjectionMatrix();
    }
    this.name = "CameraHelper";
    this.type = "CameraHelper";
    this.matrixAutoUpdate = false;
    const { geometry, pointMap } = _createGeometry();
    this.geometry = geometry;
    this._pointMap = pointMap;
    this.material = _createMaterial();
  }
  // private setCamera(camera: Camera) {
  // 	this._camera = camera;
  // 	if ((this._camera as PerspectiveCamera).updateProjectionMatrix) {
  // 		(this._camera as PerspectiveCamera).updateProjectionMatrix();
  // 	}
  // 	this.update();
  // }
  clone() {
    const helper = new CameraHelper(this.camera);
    return helper;
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this._pointMap;
    const w = 1, h = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
    setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
    setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
    setPoint("n4", pointMap, geometry, _camera, w, h, -1);
    setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
    setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
    setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
    setPoint("f4", pointMap, geometry, _camera, w, h, 1);
    setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
}
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}
export { CameraHelper };
