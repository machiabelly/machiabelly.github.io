"use strict";
import { CoreUserAgent } from "../UserAgent";
import { CoreBaseLoader } from "./_Base";
const _CoreLoaderTexture = class extends CoreBaseLoader {
  constructor(_url, _node) {
    super(_url, _node);
    this._node = _node;
  }
  // static pixelData(texture: Texture) {
  // 	const img = texture.image;
  // 	const canvas = document.createElement('canvas');
  // 	canvas.width = img.width;
  // 	canvas.height = img.height;
  // 	const context = canvas.getContext('2d');
  // 	if (context) {
  // 		context.drawImage(img, 0, 0, img.width, img.height);
  // 		return context.getImageData(0, 0, img.width, img.height);
  // 	}
  // }
  static replaceExtension(url, new_extension) {
    const elements = url.split("?");
    const url_without_params = elements[0];
    const url_elements = url_without_params.split(".");
    url_elements.pop();
    url_elements.push(new_extension);
    return [url_elements.join("."), elements[1]].join("?");
  }
  static setMaxConcurrentLoadsCount(method) {
    this._maxConcurrentLoadsCountMethod = method;
  }
  static _init_max_concurrent_loads_count() {
    if (this._maxConcurrentLoadsCountMethod) {
      return this._maxConcurrentLoadsCountMethod();
    }
    return CoreUserAgent.isChrome() ? 10 : 4;
  }
  static _init_concurrent_loads_delay() {
    return CoreUserAgent.isChrome() ? 0 : 10;
  }
  // public static override_max_concurrent_loads_count(count: number) {
  // 	this.MAX_CONCURRENT_LOADS_COUNT = count;
  // }
  static incrementInProgressLoadsCount() {
    this.in_progress_loads_count++;
  }
  static decrementInProgressLoadsCount(url, texture) {
    this.in_progress_loads_count--;
    const queuedResolve = this._queue.pop();
    if (queuedResolve) {
      const delay = this.CONCURRENT_LOADS_DELAY;
      setTimeout(() => {
        queuedResolve();
      }, delay);
    }
    this._runOnAssetLoadedCallbacks(url, texture);
  }
  static async waitForMaxConcurrentLoadsQueueFreed() {
    if (this.in_progress_loads_count <= this.MAX_CONCURRENT_LOADS_COUNT) {
      return;
    } else {
      return new Promise((resolve) => {
        this._queue.push(resolve);
      });
    }
  }
};
export let CoreLoaderTexture = _CoreLoaderTexture;
//
//
// CONCURRENT LOADS
//
//
CoreLoaderTexture.MAX_CONCURRENT_LOADS_COUNT = _CoreLoaderTexture._init_max_concurrent_loads_count();
CoreLoaderTexture.CONCURRENT_LOADS_DELAY = _CoreLoaderTexture._init_concurrent_loads_delay();
CoreLoaderTexture.in_progress_loads_count = 0;
CoreLoaderTexture._queue = [];
