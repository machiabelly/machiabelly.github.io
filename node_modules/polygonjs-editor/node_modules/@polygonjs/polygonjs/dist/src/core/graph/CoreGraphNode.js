"use strict";
import { DirtyController } from "./DirtyController";
export class CoreGraphNode {
  constructor(_scene, _name) {
    this._scene = _scene;
    this._name = _name;
    this._dirtyController = new DirtyController(this);
    this._allPredecessors = [];
    this._allSuccessors = [];
    this._allPredecessorsDirty = true;
    this._allSuccessorsDirty = true;
    this._disposed = false;
    this._graphNodeId = _scene.graph.nextId();
    _scene.graph.addNode(this);
    this._graph = _scene.graph;
  }
  dispose() {
    this._dirtyController.dispose();
    this._allPredecessors.length = 0;
    this._allSuccessors.length = 0;
    this.graphRemove();
    this._disposed = true;
  }
  disposed() {
    return this._disposed;
  }
  /**
   * returns the name
   *
   */
  name() {
    return this._name;
  }
  setName(name) {
    this._name = name;
  }
  /**
   * returns the scene
   *
   */
  scene() {
    return this._scene;
  }
  /**
   * returns the id, which is unique for the scene
   *
   */
  graphNodeId() {
    return this._graphNodeId;
  }
  //
  //
  // DIRTY CONTROLLER
  //
  //
  get dirtyController() {
    return this._dirtyController;
  }
  /**
   * makes the graphNode dirty, which in turns makes its dependencies dirty
   *
   */
  setDirty(trigger) {
    trigger = trigger || this;
    this._dirtyController.setDirty(trigger);
  }
  /**
   * makes dependencies dirty
   *
   */
  setSuccessorsDirty(trigger) {
    this._dirtyController.setSuccessorsDirty(trigger);
  }
  /**
   * removes the dirty state
   *
   */
  removeDirtyState() {
    this._dirtyController.removeDirtyState();
  }
  isDirty() {
    return this._dirtyController.isDirty();
  }
  /**
   * adds a callback that gets run when the graphNode is dirty
   *
   */
  addPostDirtyHook(name, callback) {
    this._dirtyController.addPostDirtyHook(name, callback);
  }
  removePostDirtyHook(name) {
    this._dirtyController.removePostDirtyHook(name);
  }
  //
  //
  // GRAPH
  //
  //
  graphRemove() {
    this._graph.removeNode(this);
  }
  addGraphInput(src, checkCycle = true) {
    return this._graph.connect(src, this, checkCycle);
  }
  removeGraphInput(src) {
    this._graph.disconnect(src, this);
  }
  graphDisconnectPredecessors() {
    this._graph.disconnectPredecessors(this);
  }
  graphDisconnectSuccessors() {
    this._graph.disconnectSuccessors(this);
  }
  graphPredecessorIds() {
    return this._graph.predecessorIds(this._graphNodeId);
  }
  graphPredecessors() {
    return this._graph.predecessors(this);
  }
  graphSuccessorIds() {
    return this._graph.successorIds(this._graphNodeId);
  }
  graphSuccessors() {
    return this._graph.successors(this);
  }
  _clearAllPredecessors() {
    this._allPredecessorsDirty = true;
  }
  _clearAllSuccessors() {
    this._allSuccessorsDirty = true;
  }
  graphAllPredecessors() {
    if (this._allPredecessorsDirty) {
      this._graph.allPredecessors(this, this._allPredecessors);
      this._allPredecessorsDirty = false;
    }
    return this._allPredecessors;
  }
  graphAllSuccessors() {
    if (this._allSuccessorsDirty) {
      this._graph.allSuccessors(this, this._allSuccessors);
      this._allSuccessorsDirty = false;
    }
    return this._allSuccessors;
  }
  hasPredecessor(node) {
    return this.graphAllPredecessors().includes(node);
  }
  clearCachesWithPredecessorsAndSuccessors() {
    const allPredecessors = this.graphAllPredecessors();
    const allSuccessors = this.graphAllSuccessors();
    for (const predecessor of allPredecessors) {
      predecessor._clearAllSuccessors();
    }
    for (const successor of allSuccessors) {
      successor._clearAllPredecessors();
    }
    this._clearAllPredecessors();
    this._clearAllSuccessors();
  }
  //
  setForbiddenTriggerNodes(nodes) {
    this._graph.setForbiddenTriggerNodes(this, nodes);
    this._clearAllSuccessors();
  }
  clearForbiddenTriggerNodes() {
    this._graph.clearForbiddenTriggerNodes(this);
    this._clearAllSuccessors();
  }
  setSelfDirtyForbidden(state) {
    this._graph.setSelfDirtyForbidden(this, state);
  }
  selfDirtyForbidden() {
    return this._graph.selfDirtyForbidden(this);
  }
}
