"use strict";
import { PerspectiveCamera } from "three";
import { PhysicalCamera, ShapedAreaLight, PhysicalSpotLight, IESLoader } from "./three-gpu-pathtracer";
import { PathTracingRendererRopNode } from "../../../engine/nodes/rop/PathTracingRenderer";
import { PathTracingViewer } from "../../../engine/viewers/PathTracingViewer";
import { ThreejsViewer } from "../../../engine/viewers/Threejs";
import { CoreCameraRendererController } from "../../camera/CoreCameraRendererController";
import { CoreCameraPerspectiveFrameMode } from "../../camera/frameMode/CoreCameraPerspectiveFrameMode";
import { monkeyPatchSpotLight } from "../../monkeyPatch/SpotLight";
import {
  CoreSceneObjectsFactory,
  GeneratorName
} from "../../CoreSceneObjectsFactory";
import { IES_PROFILE_LM_63_1995 } from "../../lights/spotlight/ies/lm_63_1995";
import { ObjectType, registerObjectType } from "../../geometry/Constant";
const PHYSICAL_CAMERA_UPDATE = (options) => {
  const { camera, params } = options;
  const { apertureBlades, fStop, focusDistance, apertureRotation, anamorphicRatio } = params;
  camera.apertureBlades = apertureBlades;
  camera.fStop = fStop;
  camera.focusDistance = focusDistance;
  camera.apertureRotation = apertureRotation;
  camera.anamorphicRatio = anamorphicRatio;
};
const PHYSICAL_SPOT_LIGHT_UPDATE = (options) => {
  const { spotLight } = options;
  spotLight.iesTexture = new IESLoader().parse(IES_PROFILE_LM_63_1995);
};
export function onPBRModuleRegister(poly) {
  CoreSceneObjectsFactory.registerGenerator(GeneratorName.PERSPECTIVE_CAMERA, (options) => {
    const { fov, aspect, near, far } = options;
    registerObjectType({
      type: ObjectType.PERSPECTIVE_CAMERA,
      checkFunc: (o) => {
        if (o.isPerspectiveCamera) {
          return ObjectType.PERSPECTIVE_CAMERA;
        }
      },
      ctor: PerspectiveCamera,
      humanName: "PerspectiveCamera"
    });
    registerObjectType({
      type: ObjectType.PHYSICAL_CAMERA,
      checkFunc: (o) => {
        if (o.bokehSize != null) {
          return ObjectType.PHYSICAL_CAMERA;
        }
      },
      ctor: PhysicalCamera,
      humanName: "PhysicalCamera"
    });
    return new PhysicalCamera(fov, aspect, near, far);
  });
  CoreSceneObjectsFactory.registerGenerator(GeneratorName.PERSPECTIVE_CAMERA_UPDATE, PHYSICAL_CAMERA_UPDATE);
  CoreSceneObjectsFactory.registerGenerator(GeneratorName.AREA_LIGHT, (options) => {
    const { color, intensity, width, height } = options;
    registerObjectType({
      type: ObjectType.AREA_LIGHT,
      checkFunc: (o) => {
        if (o.isCircular) {
          return ObjectType.SHAPED_AREA_LIGHT;
        }
      },
      ctor: ShapedAreaLight,
      humanName: "ShapedAreaLight"
    });
    return new ShapedAreaLight(color, intensity, width, height);
  });
  CoreSceneObjectsFactory.registerGenerator(GeneratorName.SPOT_LIGHT, () => {
    registerObjectType({
      type: ObjectType.PHYSICAL_SPOT_LIGHT,
      checkFunc: (o) => {
        if (o.iesTexture) {
          return ObjectType.PHYSICAL_SPOT_LIGHT;
        }
      },
      ctor: PhysicalSpotLight,
      humanName: ObjectType.PHYSICAL_SPOT_LIGHT
    });
    const physicalSpotLight = new PhysicalSpotLight();
    monkeyPatchSpotLight(physicalSpotLight);
    return physicalSpotLight;
  });
  CoreSceneObjectsFactory.registerGenerator(GeneratorName.SPOT_LIGHT_UPDATE, PHYSICAL_SPOT_LIGHT_UPDATE);
  poly.registerCamera(
    PhysicalCamera,
    (options) => {
      const { camera, scene, canvas } = options;
      const rendererNode = canvas ? CoreCameraRendererController.rendererNode({
        camera,
        scene
      }) : void 0;
      if (rendererNode instanceof PathTracingRendererRopNode) {
        const viewer = new PathTracingViewer({
          ...options,
          updateCameraAspect: (aspect, resolution) => {
            CoreCameraPerspectiveFrameMode.updateCameraAspect(options.camera, aspect, { resolution });
          }
        });
        return viewer;
      } else {
        const viewer = new ThreejsViewer({
          ...options,
          updateCameraAspect: (aspect, resolution) => {
            CoreCameraPerspectiveFrameMode.updateCameraAspect(options.camera, aspect, { resolution });
          }
        });
        return viewer;
      }
    }
  );
}
