"use strict";
import { Box3, Vector3 } from "three";
import { QUADObjectType } from "./QuadCommon";
import {
  objectContentCopyProperties
} from "../../ObjectContent";
import { quadToObject3D } from "./toObject3D/QuadToObject3D";
import { CoreType } from "../../../Type";
const _box = new Box3();
const _size = new Vector3();
export class QuadObject {
  constructor(_geometry) {
    this._geometry = _geometry;
    this.visible = true;
    this.userData = {};
    this.name = "";
    this.castShadow = true;
    this.receiveShadow = true;
    this.renderOrder = 0;
    this.frustumCulled = true;
    this.matrixAutoUpdate = false;
    this.children = [];
    this.parent = null;
    this._type = QUADObjectType.DEFAULT;
  }
  get geometry() {
    return this._geometry;
  }
  get type() {
    return this._type;
  }
  quadGeometry() {
    return this.geometry;
  }
  dispose() {
  }
  applyMatrix4(matrix) {
    this._geometry.applyMatrix(matrix);
  }
  add(...object) {
  }
  remove(...object) {
  }
  dispatchEvent(event) {
  }
  traverse(callback) {
    callback(this);
  }
  clone() {
    const clonedGeometry = this.geometry.clone();
    const clone = new QuadObject(clonedGeometry);
    objectContentCopyProperties(this, clone);
    return clone;
  }
  toObject3D(tesselationParams) {
    const object = quadToObject3D(this, tesselationParams);
    const _objectContentCopyProperties = (src, dest) => {
      const options = {
        // the lineSegments objects have castShadow and receiveShadow set to false,
        // we therefore should not take those properties into account
        // if they are false in the dest object
        castShadow: dest.castShadow,
        receiveShadow: dest.receiveShadow
      };
      objectContentCopyProperties(src, dest, options);
    };
    if (object) {
      if (CoreType.isArray(object)) {
        for (const element of object) {
          _objectContentCopyProperties(this, element);
        }
      } else {
        _objectContentCopyProperties(this, object);
      }
    }
    return object;
  }
  boundingBox(target) {
    this.geometry.boundingBox(target);
  }
  boundingSphere(target) {
    this.boundingBox(_box);
    _box.getCenter(target.center);
    _box.getSize(_size);
    const diameter = Math.max(_size.x, _size.y, _size.z);
    target.radius = diameter * 0.5;
  }
}
