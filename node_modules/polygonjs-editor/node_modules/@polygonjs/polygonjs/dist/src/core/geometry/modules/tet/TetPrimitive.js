"use strict";
import { CorePrimitive } from "../../entities/primitive/CorePrimitive";
import { tetCenter } from "./utils/tetCenter";
import { tetObjectFromPrimitives } from "./builders/TetPrimitiveBuilder";
import { attributeNumericValues } from "../../entities/utils/Common";
import { primitivesCountFromObject } from "../../entities/primitive/CorePrimitiveUtils";
const target = {
  attributeAdded: false,
  values: []
};
export class TetPrimitive extends CorePrimitive {
  // public override _geometry?: QuadGeometryWithPrimitiveAttributes;
  constructor(object, index) {
    super(object, index);
  }
  geometry() {
    return this._object.geometry;
  }
  builder() {
    return tetObjectFromPrimitives;
  }
  static entitiesCount(object) {
    return object.tetGeometry().tetsCount();
  }
  static position(tetObject, primitiveIndex, target2) {
    if (!(tetObject && tetObject.geometry)) {
      return target2;
    }
    tetCenter(tetObject.geometry, primitiveIndex, target2);
    return target2;
  }
  //
  //
  // ATTRIBUTES
  //
  //
  static addAttribute(object, attribName, attribute) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    attributes[attribName] = attribute;
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue = 0) {
    const verticesCount = this.entitiesCount(object);
    target.values = new Array(verticesCount * size);
    attributeNumericValues(object, primitivesCountFromObject, size, defaultValue, target);
    const attribute = {
      isString: false,
      array: target.values,
      itemSize: size
    };
    this.addAttribute(object, attribName, attribute);
  }
  static attributesFromGeometry(geometry) {
    if (!geometry.userData.primAttributes) {
      geometry.userData.primAttributes = {};
    }
    return geometry.userData.primAttributes;
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    return this.attributesFromGeometry(geometry);
  }
  //
  //
  // POSITION AND NORMAL
  //
  //
  position(target2) {
    return this.constructor.position(this._object, this._index, target2);
  }
  normal(target2) {
    target2.set(0, 1, 0);
    return target2;
  }
}
