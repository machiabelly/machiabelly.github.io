"use strict";
import { CoreGeometryBuilderBase } from "./_Base";
export class CoreGeometryBuilderLineSegments extends CoreGeometryBuilderBase {
  _filterPoints(points) {
    var _a;
    const firstPoint = points[0];
    if (!firstPoint) {
      return [];
    }
    const geometry = firstPoint.geometry();
    if (!geometry) {
      return [];
    }
    const indices = (_a = geometry.getIndex()) == null ? void 0 : _a.array;
    if (!indices) {
      return [];
    }
    const points_by_index = {};
    for (const point of points) {
      points_by_index[point.index()] = point;
    }
    const filteredPoints = [];
    const index_length = indices.length;
    for (let i = 0; i < index_length; i += 2) {
      const pt0 = points_by_index[indices[i + 0]];
      const pt1 = points_by_index[indices[i + 1]];
      if (pt0 && pt1) {
        filteredPoints.push(pt0);
        filteredPoints.push(pt1);
      }
    }
    return filteredPoints;
  }
  _indicesFromPoints(new_index_by_old_index, old_geometry) {
    const index_attrib = old_geometry.index;
    if (index_attrib != null) {
      const old_indices = index_attrib.array;
      const new_indices = [];
      let old_index0;
      let old_index1;
      let new_index0;
      let new_index1;
      for (let i = 0; i < old_indices.length; i += 2) {
        old_index0 = old_indices[i];
        old_index1 = old_indices[i + 1];
        new_index0 = new_index_by_old_index[old_index0];
        new_index1 = new_index_by_old_index[old_index1];
        if (new_index0 != null && new_index1 != null) {
          new_indices.push(new_index0);
          new_indices.push(new_index1);
        }
      }
      return new_indices;
    }
  }
}
