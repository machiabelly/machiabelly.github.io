"use strict";
import { Vector3 } from "three";
import { CoreGeometryBuilderBase } from "./_Base";
export class CoreGeometryBuilderMesh extends CoreGeometryBuilderBase {
  _filterPoints(points) {
    var _a;
    const firstPoint = points[0];
    if (!firstPoint) {
      return [];
    }
    const geometry = firstPoint.geometry();
    if (!geometry) {
      return [];
    }
    const indices = (_a = geometry.getIndex()) == null ? void 0 : _a.array;
    if (!indices) {
      return [];
    }
    const points_by_index = {};
    for (const point of points) {
      points_by_index[point.index()] = point;
    }
    const filteredPoints = [];
    const index_length = indices.length;
    let pt0;
    let pt1;
    let pt2;
    for (let i = 0; i < index_length; i += 3) {
      pt0 = points_by_index[indices[i + 0]];
      pt1 = points_by_index[indices[i + 1]];
      pt2 = points_by_index[indices[i + 2]];
      if (pt0 && pt1 && pt2) {
        filteredPoints.push(pt0);
        filteredPoints.push(pt1);
        filteredPoints.push(pt2);
      }
    }
    return filteredPoints;
  }
  _indicesFromPoints(new_index_by_old_index, old_geometry) {
    const index_attrib = old_geometry.index;
    if (index_attrib != null) {
      const old_indices = index_attrib.array;
      const new_indices = [];
      let old_index0;
      let old_index1;
      let old_index2;
      let new_index0;
      let new_index1;
      let new_index2;
      for (let i = 0; i < old_indices.length; i += 3) {
        old_index0 = old_indices[i + 0];
        old_index1 = old_indices[i + 1];
        old_index2 = old_indices[i + 2];
        new_index0 = new_index_by_old_index[old_index0];
        new_index1 = new_index_by_old_index[old_index1];
        new_index2 = new_index_by_old_index[old_index2];
        if (new_index0 != null && new_index1 != null && new_index2 != null) {
          new_indices.push(new_index0);
          new_indices.push(new_index1);
          new_indices.push(new_index2);
        }
      }
      return new_indices;
    }
  }
}
const _v3 = new Vector3();
const STRIDE = 3;
export const threeMeshFromPrimitives = (object, entities) => {
  const mesh = object;
  const geometry = mesh.geometry;
  if (!geometry) {
    return void 0;
  }
  const oldIndex = geometry.getIndex();
  if (!oldIndex) {
    return void 0;
  }
  const oldIndexArray = oldIndex.array;
  const primitives = entities;
  const newIndices = new Array(primitives.length * STRIDE);
  let i = 0;
  for (const primitive of primitives) {
    _v3.fromArray(oldIndexArray, primitive.index() * STRIDE);
    _v3.toArray(newIndices, i * STRIDE);
    i++;
  }
  geometry.setIndex(newIndices);
  return mesh;
};
