"use strict";
import { objectCloneDeep } from "../ObjectUtils";
import { assignUniforms, applyCustomMaterials } from "../geometry/Material";
import { GlobalsTextureHandler, GlobalsTextureHandlerPurpose } from "../../engine/nodes/gl/code/globals/Texture";
import { CoreParticlesAttribute } from "./CoreParticlesAttribute";
import {
  OnBeforeCompileDataHandler,
  assignOnBeforeCompileDataAndFunction
} from "../../engine/nodes/gl/code/assemblers/materials/OnBeforeCompile";
export class CoreParticlesRenderController {
  // public readonly object: Object3D;
  constructor(mainController) {
    this.mainController = mainController;
    // protected _particlesGroupObjects: Object3D[] = [];
    // private _allShaderNames: ShaderName[] = [];
    this._uniformByShaderName = /* @__PURE__ */ new Map();
    this._materialGlobalsHandler = new GlobalsTextureHandler(
      GlobalsTextureHandler.UV_VARYING,
      GlobalsTextureHandlerPurpose.MATERIAL
    );
  }
  // setShadersByName(shadersByName: Map<ShaderName, string>) {
  // 	this._allShaderNames = [];
  // 	this._uniformByShaderName.clear();
  // 	this._allUniformNames = [];
  // 	shadersByName.forEach((shader, name) => {
  // 		this._allShaderNames.push(name);
  // 		this._allUniformNames.push(`texture_${name}`);
  // 	});
  // 	this.resetRenderMaterial();
  // }
  dispose() {
  }
  reset() {
    this._renderMaterial = void 0;
  }
  // resetRenderMaterial() {
  // 	// this._particlesGroupObjects = [];
  // }
  assignRenderMaterial() {
    if (!this._renderMaterial) {
      console.warn("no renderMaterial");
      return;
    }
    const object = this.mainController.object();
    if (!object) {
      console.warn("no object");
      return;
    }
    object.material = this._renderMaterial;
    applyCustomMaterials(object, this._renderMaterial);
    object.matrixAutoUpdate = false;
    object.updateMatrix();
    this.updateRenderMaterialUniforms();
    this._renderMaterial.needsUpdate = true;
  }
  updateRenderMaterialUniforms() {
    var _a;
    if (!this._renderMaterial) {
      console.warn("no renderMaterial");
      return;
    }
    const data = OnBeforeCompileDataHandler.getData(this._renderMaterial);
    let uniformName;
    let shaderName;
    const shaderNames = this.mainController.shaderNames();
    const uniformNames = this.mainController.uniformNames();
    for (let i = 0; i < shaderNames.length; i++) {
      shaderName = shaderNames[i];
      uniformName = uniformNames[i];
      let uniform = this._uniformByShaderName.get(shaderName);
      if (!uniform) {
        uniform = { value: null };
        this._uniformByShaderName.set(shaderName, uniform);
      }
      const texture = (_a = this.mainController.gpuController.getCurrentRenderTarget(shaderName)) == null ? void 0 : _a.texture;
      uniform.value = texture || null;
      assignUniforms(this._renderMaterial, uniformName, uniform, this._matNodeAssembler);
      if (data) {
        data.additionalTextureUniforms[uniformName] = uniform;
      }
    }
    if (data) {
      assignOnBeforeCompileDataAndFunction(this.mainController.scene, this._renderMaterial, data);
    }
  }
  material() {
    return this._renderMaterial;
  }
  // initialized(): boolean {
  // 	return this._renderMaterial != null;
  // }
  // initCoreGroup(core_group: CoreGroup) {
  // 	for (let child of core_group.objectsWithGeo()) {
  // 		this._particlesGroupObjects.push(child);
  // 	}
  // }
  async init() {
    var _a;
    const object = this.mainController.object();
    if (!object) {
      console.warn("no object");
      return;
    }
    const node = this.mainController.node();
    const assembler = (_a = node.assemblerController()) == null ? void 0 : _a.assembler;
    if (this._renderMaterial) {
      console.warn("no render material");
      return;
    }
    const matNodeId = CoreParticlesAttribute.getMaterialNodeId(object);
    const matNode = this.mainController.scene.graph.nodeFromId(matNodeId);
    if (matNode) {
      if (assembler) {
        const new_texture_allocations_json = assembler.textureAllocationsController().toJSON(this.mainController.scene);
        const matNodeAssemblerController = matNode.assemblerController();
        if (matNodeAssemblerController) {
          this._materialGlobalsHandler.set_texture_allocations_controller(
            assembler.textureAllocationsController()
          );
          matNodeAssemblerController.setAssemblerGlobalsHandler(this._materialGlobalsHandler);
          this._matNodeAssembler = matNodeAssemblerController.assembler;
        }
        if (!this._texture_allocations_json || JSON.stringify(this._texture_allocations_json) != JSON.stringify(new_texture_allocations_json)) {
          this._texture_allocations_json = objectCloneDeep(new_texture_allocations_json);
          if (matNodeAssemblerController) {
            matNodeAssemblerController.setCompilationRequiredAndDirty();
          }
        }
      }
      this.mainController.debugMessage("renderController: matNode.compute() START");
      const container = await matNode.compute();
      this.mainController.debugMessage("renderController: matNode.compute() END");
      this._renderMaterial = container.material();
    }
    this.assignRenderMaterial();
  }
}
