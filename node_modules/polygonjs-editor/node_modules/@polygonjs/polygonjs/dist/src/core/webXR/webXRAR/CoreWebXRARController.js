"use strict";
import { Vector3, Matrix4, Quaternion } from "three";
import { CoreARButton } from "../buttons/CoreARButton";
import { CoreWebXRAREstimatedLightController } from "./CoreWebXRAREstimatedLightController";
import { BaseCoreWebXRController } from "../_BaseCoreWebXRController";
const s = new Vector3();
export class CoreWebXRARController extends BaseCoreWebXRController {
  // public readonly capture: CoreWebXRARCaptureController;
  constructor(scene, renderer, camera, canvas, options) {
    super(scene, renderer, camera, canvas, options);
    this.options = options;
    this.hitTestSource = null;
    this.hitTestSourceRequested = false;
    this._hitDetected = false;
    this._hitMatrix = new Matrix4();
    this._hitPosition = new Vector3();
    this._hitQuaternion = new Quaternion();
    this._previousSceneBackground = null;
  }
  createButton() {
    return CoreARButton.createButton(
      {
        renderer: this.renderer,
        controller: this
      },
      {
        optionalFeatures: this.options.optionalFeatures,
        requiredFeatures: this.options.requiredFeatures
        // trackedImages: [
        // 	{
        // 		image: ,
        // 		widthInMeters: 0.2,
        // 	},
        // ],
      }
    );
  }
  attachButton(parentElement, buttonElement) {
    parentElement.prepend(buttonElement);
  }
  async requestSession(sessionInit, onSessionStarted) {
    var _a;
    super.requestSession(sessionInit, onSessionStarted);
    this._estimatedLightController = new CoreWebXRAREstimatedLightController();
    this._estimatedLightController.initialize(this.scene, this.renderer);
    return (_a = navigator.xr) == null ? void 0 : _a.requestSession("immersive-ar", sessionInit).then(async (session) => {
      onSessionStarted(session);
    });
  }
  _onSessionStart() {
    this.scene.webXR.setActiveARController(this);
    this._previousSceneBackground = this.scene.threejsScene().background;
    this.scene.threejsScene().background = null;
    super._onSessionStart();
  }
  _onSessionEnd() {
    var _a;
    this.scene.webXR.setActiveARController(null);
    (_a = this._estimatedLightController) == null ? void 0 : _a.dispose();
    this.scene.threejsScene().background = this._previousSceneBackground;
    super._onSessionEnd();
  }
  hitMatrix(target) {
    target.copy(this._hitMatrix);
  }
  hitPosition(target) {
    target.copy(this._hitPosition);
  }
  hitQuaternion(target) {
    target.copy(this._hitQuaternion);
  }
  hitDetected() {
    return this._hitDetected;
  }
  process(frame) {
    super.process(frame);
    if (!frame) {
      return;
    }
    const referenceSpace = this.renderer.xr.getReferenceSpace();
    const session = this.renderer.xr.getSession();
    if (!(session && referenceSpace)) {
      return;
    }
    this._resolveHit(frame, session, referenceSpace);
  }
  _resolveHit(frame, session, referenceSpace) {
    if (!frame) {
      return;
    }
    if (this.hitTestSourceRequested === false) {
      session.requestReferenceSpace("viewer").then((referenceSpace2) => {
        var _a;
        if (!session.requestHitTestSource) {
          return;
        }
        (_a = session.requestHitTestSource({ space: referenceSpace2 })) == null ? void 0 : _a.then((source) => {
          this.hitTestSource = source;
        });
      });
      session.addEventListener("end", () => {
        this.hitTestSourceRequested = false;
        this.hitTestSource = null;
      });
      this.hitTestSourceRequested = true;
    }
    if (!this.hitTestSource) {
      return;
    }
    const hitTestResults = frame.getHitTestResults(this.hitTestSource);
    if (hitTestResults.length) {
      const hit = hitTestResults[0];
      const pose = hit.getPose(referenceSpace);
      if (pose) {
        this._hitDetected = true;
        this._hitMatrix.fromArray(pose.transform.matrix);
        this._hitMatrix.decompose(this._hitPosition, this._hitQuaternion, s);
        return;
      }
    }
    this._hitDetected = false;
  }
}
