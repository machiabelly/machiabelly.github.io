"use strict";
import {
  Object3D,
  LineSegments,
  InstancedMesh,
  Mesh,
  Points,
  Group,
  Scene,
  MeshStandardMaterial,
  PointsMaterial,
  LineBasicMaterial,
  FrontSide
} from "three";
export var ObjectType = /* @__PURE__ */ ((ObjectType2) => {
  ObjectType2["AMBIENT_LIGHT"] = "AmbientLight";
  ObjectType2["AREA_LIGHT"] = "AreaLight";
  ObjectType2["CUBE_CAMERA"] = "CubeCamera";
  ObjectType2["DIRECTIONAL_LIGHT"] = "DirectionalLight";
  ObjectType2["GROUP"] = "Group";
  ObjectType2["HEMISPHERE_LIGHT"] = "HemisphereLight";
  ObjectType2["INSTANCED_MESH"] = "InstancedMesh";
  ObjectType2["LIGHT_PROBE"] = "LightProbe";
  ObjectType2["LINE_SEGMENTS"] = "LineSegments";
  ObjectType2["LOD"] = "LOD";
  ObjectType2["MESH"] = "Mesh";
  ObjectType2["OBJECT3D"] = "Object3D";
  ObjectType2["ORTHOGRAPHIC_CAMERA"] = "OrthographicCamera";
  ObjectType2["PERSPECTIVE_CAMERA"] = "PerspectiveCamera";
  ObjectType2["PHYSICAL_CAMERA"] = "PhysicalCamera";
  ObjectType2["PHYSICAL_SPOT_LIGHT"] = "PhysicalSpotLight";
  ObjectType2["POINT_LIGHT"] = "PointLight";
  ObjectType2["POINTS"] = "Points";
  ObjectType2["SCENE"] = "Scene";
  ObjectType2["SHAPED_AREA_LIGHT"] = "ShapedAreaLight";
  ObjectType2["SPOT_LIGHT"] = "SpotLight";
  ObjectType2["UNKNOWN"] = "Unknown";
  ObjectType2["QUAD"] = "Quad";
  return ObjectType2;
})(ObjectType || {});
export const OBJECT_TYPES = [
  "Group" /* GROUP */,
  "LineSegments" /* LINE_SEGMENTS */,
  "Mesh" /* MESH */,
  "Object3D" /* OBJECT3D */,
  "Points" /* POINTS */,
  "Scene" /* SCENE */
];
const UNKNOWN_OBJECT_TYPE = {
  type: "Unknown" /* UNKNOWN */,
  checkFunc: (o) => "Unknown" /* UNKNOWN */,
  humanName: "Unknown",
  ctor: null
};
function _initializeObjectTypeFromConstructor() {
  const objectTypeCheckFunctions2 = [];
  const dataByObjectType2 = /* @__PURE__ */ new Map();
  const maps = { objectTypeCheckFunctions: objectTypeCheckFunctions2, dataByObjectType: dataByObjectType2 };
  function _register(type, checkFunc, ctor, humanName) {
    _registerObjectType_(maps, {
      type,
      checkFunc,
      ctor,
      humanName: humanName || type
    });
  }
  _register(
    "Object3D" /* OBJECT3D */,
    (o) => o.isObject3D ? "Object3D" /* OBJECT3D */ : void 0,
    Object3D,
    "Object3D"
  );
  _register("Mesh" /* MESH */, (o) => o.isMesh ? "Mesh" /* MESH */ : void 0, Mesh, "Mesh");
  _register("Group" /* GROUP */, (o) => o.isGroup ? "Group" /* GROUP */ : void 0, Group, "Group");
  _register(
    "LineSegments" /* LINE_SEGMENTS */,
    (o) => o.isLineSegments ? "LineSegments" /* LINE_SEGMENTS */ : void 0,
    LineSegments,
    "LineSegments"
  );
  _register(
    "InstancedMesh" /* INSTANCED_MESH */,
    (o) => o.isInstancedMesh ? "InstancedMesh" /* INSTANCED_MESH */ : void 0,
    InstancedMesh,
    "InstancedMesh"
  );
  _register("Points" /* POINTS */, (o) => o.isPoints ? "Points" /* POINTS */ : void 0, Points, "Points");
  _register("Scene" /* SCENE */, (o) => o.isScene ? "Scene" /* SCENE */ : void 0, Scene, "Scene");
  return maps;
}
const { objectTypeCheckFunctions, dataByObjectType } = _initializeObjectTypeFromConstructor();
function _registerObjectType_(maps, data) {
  maps.objectTypeCheckFunctions.unshift(data.checkFunc);
  maps.dataByObjectType.set(data.type, data);
}
export function registerObjectType(data) {
  _registerObjectType_({ objectTypeCheckFunctions, dataByObjectType }, data);
}
export function objectTypeFromObject(object) {
  return dataFromObject(object).type;
}
export function dataFromObject(object) {
  for (const checkFunc of objectTypeCheckFunctions) {
    const objectType = checkFunc(object);
    if (objectType) {
      return dataByObjectType.get(objectType);
    }
  }
  return UNKNOWN_OBJECT_TYPE;
}
export function objectConstructorByObjectType(objectType) {
  const data = dataByObjectType.get(objectType);
  if (data) {
    return data.ctor;
  } else {
    console.warn(`no constructor found for type '${objectType}'`);
    return dataByObjectType.get("Mesh" /* MESH */);
  }
}
export const DEFAULT_MATERIALS = {
  MeshStandard: new MeshStandardMaterial({
    color: 16777215,
    side: FrontSide,
    metalness: 0.5,
    roughness: 0.9
  }),
  // [ObjectType.MESH]: new MeshLambertMaterial({
  // 	color: new Color(1, 1, 1),
  // 	side: FrontSide,
  // 	vertexColors: false,
  // 	transparent: true,
  // 	depthTest: true,
  // }),
  ["Mesh" /* MESH */]: new MeshStandardMaterial({
    color: 16777215,
    side: FrontSide,
    metalness: 0,
    roughness: 0.9
  }),
  ["Points" /* POINTS */]: new PointsMaterial({
    color: 16777215,
    size: 0.1,
    //blending: AdditiveBlending
    depthTest: true
  }),
  ["LineSegments" /* LINE_SEGMENTS */]: new LineBasicMaterial({
    color: 16777215,
    linewidth: 1
  })
};
export var AttribClass = /* @__PURE__ */ ((AttribClass2) => {
  AttribClass2["POINT"] = "point";
  AttribClass2["VERTEX"] = "vertex";
  AttribClass2["PRIMITIVE"] = "primitive";
  AttribClass2["OBJECT"] = "object";
  AttribClass2["CORE_GROUP"] = "coreGroup";
  return AttribClass2;
})(AttribClass || {});
export const ATTRIBUTE_CLASSES = [
  "point" /* POINT */,
  "vertex" /* VERTEX */,
  "primitive" /* PRIMITIVE */,
  "object" /* OBJECT */,
  "coreGroup" /* CORE_GROUP */
];
export const ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP = [
  "point" /* POINT */,
  "vertex" /* VERTEX */,
  "primitive" /* PRIMITIVE */,
  "object" /* OBJECT */
];
export const AttribClassMenuEntries = ATTRIBUTE_CLASSES.map((name, value) => ({ name, value }));
export const AttribClassMenuEntriesWithoutCoreGroup = ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.map((name, value) => ({
  name,
  value
}));
export var AttribType = /* @__PURE__ */ ((AttribType2) => {
  AttribType2["NUMERIC"] = "numeric";
  AttribType2["STRING"] = "string";
  return AttribType2;
})(AttribType || {});
export const ATTRIBUTE_TYPES = ["numeric" /* NUMERIC */, "string" /* STRING */];
export const AttribTypeMenuEntries = ATTRIBUTE_TYPES.map((name, value) => ({ name, value }));
export var AttribSize = /* @__PURE__ */ ((AttribSize2) => {
  AttribSize2[AttribSize2["FLOAT"] = 1] = "FLOAT";
  AttribSize2[AttribSize2["VECTOR2"] = 2] = "VECTOR2";
  AttribSize2[AttribSize2["VECTOR3"] = 3] = "VECTOR3";
  AttribSize2[AttribSize2["VECTOR4"] = 4] = "VECTOR4";
  return AttribSize2;
})(AttribSize || {});
export const ATTRIBUTE_SIZES = [
  1 /* FLOAT */,
  2 /* VECTOR2 */,
  3 /* VECTOR3 */,
  4 /* VECTOR4 */
];
export const ATTRIBUTE_SIZE_RANGE = [1 /* FLOAT */, 4 /* VECTOR4 */];
export var ComponentName = /* @__PURE__ */ ((ComponentName2) => {
  ComponentName2["x"] = "x";
  ComponentName2["y"] = "y";
  ComponentName2["z"] = "z";
  ComponentName2["w"] = "w";
  ComponentName2["r"] = "r";
  ComponentName2["g"] = "g";
  ComponentName2["b"] = "b";
  return ComponentName2;
})(ComponentName || {});
export const COMPONENT_INDICES = {
  x: 0,
  y: 1,
  z: 2,
  w: 3,
  r: 0,
  g: 1,
  b: 2
};
export const DOT = ".";
