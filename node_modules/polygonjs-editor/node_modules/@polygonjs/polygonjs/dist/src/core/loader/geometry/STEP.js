"use strict";
import { Loader, MathUtils } from "three";
import { BaseLoaderHandler } from "./_BaseLoaderHandler";
import { CadLoader } from "../../geometry/modules/cad/CadLoader";
import { cadGeometryTypeFromShape } from "../../geometry/modules/cad/CadCommon";
import { CadLoaderSync } from "../../geometry/modules/cad/CadLoaderSync";
import { CadObject } from "../../geometry/modules/cad/CadObject";
export class STEPLoaderHandler extends BaseLoaderHandler {
  async _getLoader(options) {
    return this._loader = this._loader || await new STEPLoader(this.loadingManager);
  }
  _onLoadSuccess(o) {
    return o;
  }
}
class STEPLoader extends Loader {
  constructor(manager) {
    super(manager);
  }
  load(url, onLoad, onProgress, onError) {
    return new Promise(async (resolve) => {
      const oc = await CadLoader.core();
      const newObjects = [];
      const reader = new oc.STEPControl_Reader_1();
      const response = await fetch(url);
      const text = await response.text();
      const fileNameShort = MathUtils.generateUUID();
      const FSfileName = `file.${fileNameShort}`;
      const canRead = true;
      const canWrite = true;
      const canOwn = true;
      oc.FS.createDataFile("/", FSfileName, text, canRead, canWrite, canOwn);
      const result = reader.ReadFile(FSfileName);
      const isDone = result == oc.IFSelect_ReturnStatus.IFSelect_RetDone;
      if (isDone) {
        reader.TransferRoots(CadLoaderSync.Message_ProgressRange);
        const shapesCount = reader.NbShapes();
        for (let i = 0; i < shapesCount; i++) {
          const shape = reader.Shape(i + 1);
          const type = cadGeometryTypeFromShape(oc, shape);
          if (type) {
            const newObject = new CadObject(shape, type);
            newObjects.push(newObject);
          }
        }
      }
      reader.delete();
      onLoad(newObjects);
    });
  }
}
