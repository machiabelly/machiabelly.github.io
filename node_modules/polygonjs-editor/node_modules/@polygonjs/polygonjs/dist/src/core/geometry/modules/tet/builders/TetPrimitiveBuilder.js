"use strict";
import { TetPrimitive } from "../TetPrimitive";
import { setXOR } from "../../../../SetUtils";
import { primitivesFromObject } from "../../../entities/primitive/CorePrimitiveUtils";
const currentEntities = [];
export const tetObjectFromPrimitives = (object, entities) => {
  const tetObject = object;
  const geometry = tetObject.geometry;
  if (!geometry) {
    return void 0;
  }
  const entitiesCount = entities.length;
  const currentEntitiesIndices = primitivesFromObject(tetObject, currentEntities).map((e) => e.index());
  const newEntitiesIndices = entities.map((e, i2) => e.index());
  const currentEntitiesIndicesSet = new Set(currentEntitiesIndices);
  const newEntitiesIndicesSet = new Set(newEntitiesIndices);
  const toRemoveEntitiesIndicesSet = /* @__PURE__ */ new Set();
  setXOR(currentEntitiesIndicesSet, newEntitiesIndicesSet, toRemoveEntitiesIndicesSet);
  const _tetrahedronsIds = [];
  let i = 0;
  geometry.tetrahedrons.forEach((tetrahedron, id) => {
    if (toRemoveEntitiesIndicesSet.has(i)) {
      _tetrahedronsIds.push(id);
    }
    i++;
  });
  geometry.removeTets(_tetrahedronsIds);
  const primitiveAttributes = TetPrimitive.attributes(object);
  if (primitiveAttributes) {
    const primitiveAttributeNames = Object.keys(primitiveAttributes);
    for (const primitiveAttributeName of primitiveAttributeNames) {
      const primitiveAttribute = primitiveAttributes[primitiveAttributeName];
      const itemSize = primitiveAttribute.itemSize;
      const srcArray = primitiveAttribute.array;
      const newArray = new Array(entitiesCount * itemSize);
      let i2 = 0;
      for (const entity of entities) {
        const index = entity.index();
        for (let k = 0; k < itemSize; k++) {
          newArray[i2 + k] = srcArray[index + k];
        }
        i2++;
      }
      primitiveAttribute.array = newArray;
    }
  }
  return tetObject;
};
