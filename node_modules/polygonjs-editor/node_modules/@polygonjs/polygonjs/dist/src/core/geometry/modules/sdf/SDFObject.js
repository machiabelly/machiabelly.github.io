"use strict";
import { Box3, Vector3, Quaternion, Euler } from "three";
import { SDFObjectType } from "./SDFCommon";
import { objectContentCopyProperties } from "../../ObjectContent";
import { SDFGeometryToObject3D } from "./toObject3D/SDFToObject3D";
import { CoreType } from "../../../Type";
import { SDFLoaderSync } from "./SDFLoaderSync";
const _box = new Box3();
const _size = new Vector3();
const _t = new Vector3();
const _q = new Quaternion();
const _s = new Vector3();
const _euler = new Euler();
const _tN3 = [0, 0, 0];
const _rN3 = [0, 0, 0];
const _sN3 = [1, 1, 1];
export class SDFObject {
  constructor(_geometry) {
    this._geometry = _geometry;
    this.visible = true;
    this.userData = {};
    this.name = "";
    this.castShadow = true;
    this.receiveShadow = true;
    this.renderOrder = 0;
    this.frustumCulled = true;
    this.matrixAutoUpdate = false;
    this.children = [];
    this.parent = null;
    this._type = SDFObjectType.DEFAULT;
  }
  get geometry() {
    return this._geometry;
  }
  get type() {
    return this._type;
  }
  SDFGeometry() {
    return this.geometry;
  }
  dispose() {
  }
  applyMatrix4(matrix) {
    matrix.decompose(_t, _q, _s);
    _euler.setFromQuaternion(_q);
    _t.toArray(_tN3);
    _s.toArray(_sN3);
    _rN3[0] = _euler.x;
    _rN3[1] = _euler.y;
    _rN3[2] = _euler.z;
    const geometry = this.geometry.translate(_tN3).rotate(_rN3).scale(_sN3);
    this._geometry = geometry;
  }
  add(...object) {
  }
  remove(...object) {
  }
  dispatchEvent(event) {
  }
  traverse(callback) {
    callback(this);
  }
  clone() {
    const manifold = SDFLoaderSync.manifold();
    const mesh = this.geometry.getMesh();
    const clonedGeometry = new manifold.Manifold(mesh);
    const clone = new SDFObject(clonedGeometry);
    objectContentCopyProperties(this, clone);
    return clone;
  }
  toObject3D(tesselationParams) {
    const object = SDFGeometryToObject3D(this.geometry, tesselationParams);
    if (object) {
      if (CoreType.isArray(object)) {
        for (const element of object) {
          objectContentCopyProperties(this, element);
        }
      } else {
        objectContentCopyProperties(this, object);
      }
    }
    return object;
  }
  boundingBox(target) {
    const bbox = this.geometry.boundingBox();
    target.min.fromArray(bbox.min);
    target.max.fromArray(bbox.max);
  }
  boundingSphere(target) {
    this.boundingBox(_box);
    _box.getCenter(target.center);
    _box.getSize(_size);
    const diameter = Math.max(_size.x, _size.y, _size.z);
    target.radius = diameter * 0.5;
  }
}
