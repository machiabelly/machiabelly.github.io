"use strict";
import { Float32BufferAttribute, BufferGeometry } from "three";
import { isObject3D } from "../ObjectContent";
import { pointsFromObject, pointAttributeNames, pointAttributeSizes } from "../entities/point/CorePointUtils";
const _points = [];
export class CoreGeometryUtilCurve {
  static accumulatedCurvePointIndices(indices) {
    let curve_point_indices = [];
    const accumulated_curve_point_indices = [];
    let last_index_added = null;
    let index;
    for (let i = 0; i < indices.length; i++) {
      if (i % 2 === 1) {
        index = indices[i];
        const previous_index = indices[i - 1];
        if (last_index_added == null || previous_index === last_index_added) {
          if (curve_point_indices.length === 0) {
            curve_point_indices.push(previous_index);
          }
          curve_point_indices.push(index);
          last_index_added = index;
        } else {
          accumulated_curve_point_indices.push(curve_point_indices);
          curve_point_indices = [previous_index, index];
          last_index_added = index;
        }
      }
    }
    accumulated_curve_point_indices.push(curve_point_indices);
    return accumulated_curve_point_indices;
  }
  static create_line_segment_geometry(points, indices, attrib_names, attrib_sizes_by_name) {
    const new_indices = [];
    const new_attribute_values_by_name = {};
    attrib_names.forEach((attrib_name) => {
      new_attribute_values_by_name[attrib_name] = [];
    });
    indices.forEach((index, i) => {
      const point = points[index];
      attrib_names.forEach((attrib_name) => {
        const attrib_value = point.attribValue(attrib_name);
        const attrib_size = attrib_sizes_by_name[attrib_name];
        let attrib_value_f;
        if (attrib_size > 1) {
          attrib_value_f = attrib_value.toArray();
        } else {
          attrib_value_f = [attrib_value];
        }
        attrib_value_f.forEach((v) => {
          new_attribute_values_by_name[attrib_name].push(v);
        });
      });
      if (i > 0) {
        new_indices.push(i - 1);
        new_indices.push(i);
      }
    });
    const geometry = new BufferGeometry();
    attrib_names.forEach((attrib_name) => {
      const attrib_size = attrib_sizes_by_name[attrib_name];
      const values = new_attribute_values_by_name[attrib_name];
      geometry.setAttribute(attrib_name, new Float32BufferAttribute(values, attrib_size));
    });
    geometry.setIndex(new_indices);
    return geometry;
  }
  static line_segment_to_geometries(object) {
    var _a;
    const geometries = [];
    const attribNames = pointAttributeNames(object);
    pointsFromObject(object, _points);
    if (!isObject3D(object)) {
      return;
    }
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const indices = ((_a = geometry.getIndex()) == null ? void 0 : _a.array) || new Uint32Array(0);
    const accumulated_curve_point_indices = this.accumulatedCurvePointIndices(indices);
    if (accumulated_curve_point_indices.length > 0) {
      const attributeSizesByName = pointAttributeSizes(object);
      accumulated_curve_point_indices.forEach((curvePointIndices, i) => {
        const newGeometry = this.create_line_segment_geometry(
          _points,
          curvePointIndices,
          attribNames,
          attributeSizesByName
        );
        geometries.push(newGeometry);
      });
    }
    return geometries;
  }
}
