"use strict";
import { Vector3 } from "three";
import { Quaternion } from "three";
import { Panner3D } from "tone/build/esm/component/channel/Panner3D";
import { Object3D } from "three";
const _position = new Vector3();
const _quaternion = new Quaternion();
const _scale = new Vector3();
const _orientation = new Vector3();
export var DistanceModel = /* @__PURE__ */ ((DistanceModel2) => {
  DistanceModel2["LINEAR"] = "linear";
  DistanceModel2["INVERSE"] = "inverse";
  DistanceModel2["EXPONENTIAL"] = "exponential";
  return DistanceModel2;
})(DistanceModel || {});
export const DISTANCE_MODELS = [
  "linear" /* LINEAR */,
  "inverse" /* INVERSE */,
  "exponential" /* EXPONENTIAL */
];
export class CorePositionalAudio extends Object3D {
  constructor() {
    super();
    this.listenerTransformAutoUpdate = true;
    this.tonePanner = new Panner3D();
    this.pannerNode = this.tonePanner.input;
  }
  disconnect() {
    this.tonePanner.disconnect();
  }
  setInput(audioNode) {
    if (this._currentAudioNode) {
      this._currentAudioNode.disconnect(this.tonePanner);
    }
    if (audioNode) {
      audioNode.connect(this.tonePanner);
    }
    this._currentAudioNode = audioNode;
  }
  connect(audioNode) {
    this.tonePanner.connect(audioNode);
  }
  // getOutput() {
  // 	return this.panner;
  // }
  getRefDistance() {
    return this.pannerNode.refDistance;
  }
  setRefDistance(value) {
    this.pannerNode.refDistance = value;
    return this;
  }
  getRolloffFactor() {
    return this.pannerNode.rolloffFactor;
  }
  setRolloffFactor(value) {
    this.pannerNode.rolloffFactor = value;
    return this;
  }
  getDistanceModel() {
    return this.pannerNode.distanceModel;
  }
  setDistanceModel(value) {
    this.pannerNode.distanceModel = value;
    return this;
  }
  getMaxDistance() {
    return this.pannerNode.maxDistance;
  }
  setMaxDistance(value) {
    this.pannerNode.maxDistance = value;
    return this;
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.pannerNode.coneInnerAngle = coneInnerAngle;
    this.pannerNode.coneOuterAngle = coneOuterAngle;
    this.pannerNode.coneOuterGain = coneOuterGain;
    return this;
  }
  coneInnerAngle() {
    return this.pannerNode.coneInnerAngle;
  }
  coneOuterAngle() {
    return this.pannerNode.coneOuterAngle;
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.listenerTransformAutoUpdate) {
      return;
    }
    this.matrixWorld.decompose(_position, _quaternion, _scale);
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
    const duration = "+1";
    const panner = this.tonePanner;
    if (panner.positionX) {
      panner.positionX.linearRampToValueAtTime(_position.x, duration);
      panner.positionY.linearRampToValueAtTime(_position.y, duration);
      panner.positionZ.linearRampToValueAtTime(_position.z, duration);
      panner.orientationX.linearRampToValueAtTime(_orientation.x, duration);
      panner.orientationY.linearRampToValueAtTime(_orientation.y, duration);
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, duration);
    } else {
      panner.setPosition(_position.x, _position.y, _position.z);
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
    }
  }
}
