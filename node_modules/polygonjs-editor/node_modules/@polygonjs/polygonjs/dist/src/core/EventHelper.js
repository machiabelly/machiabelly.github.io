"use strict";
export class EventHelper {
  constructor(element) {
    this.element = element;
  }
  setElement(element) {
    this.element = element;
  }
  static elementPosition(event, element, position) {
    const dim = element.getBoundingClientRect();
    if (event.changedTouches) {
      event = event;
      const touch = event.changedTouches[0];
      position.x = touch.pageX - dim.x;
      position.y = touch.pageY - dim.y;
    } else {
      event = event;
      position.x = event.pageX - dim.x;
      position.y = event.pageY - dim.y;
    }
  }
  // static element_position_old(event: MouseEvent, element: HTMLElement) {
  // 	const dim = element.getBoundingClientRect();
  // 	const x = event.pageX - dim.x;
  // 	const y = event.pageY - dim.y;
  // 	// console.log(event, x, y)
  // 	return new Vector2(x, y);
  // }
  static normalizedPosition(event, element, position) {
    this.elementPosition(event, element, position);
    const dim = element.getBoundingClientRect();
    position.x = (position.x - window.scrollX) / dim.width * 2 - 1;
    position.y = -((position.y - window.scrollY) / dim.height * 2 - 1);
  }
  static normalized_position_0_1(event, element, position) {
    this.elementPosition(event, element, position);
    const dim = element.getBoundingClientRect();
    position.x = (position.x - window.scrollX) / dim.width;
    position.y = (position.y - window.scrollY) / dim.height;
  }
  elementPosition(event, position) {
    EventHelper.elementPosition(event, this.element, position);
  }
  // element_position_old(event: MouseEvent) {
  // 	return EventHelper.element_position_old(event, this.element);
  // }
  normalizedPosition(event, position) {
    EventHelper.normalizedPosition(event, this.element, position);
  }
}
