import {
  TypedSopNode
} from "./chunk-XJZFUBTR.js";
import {
  SopType
} from "./chunk-OBFUH3H6.js";
import {
  ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP,
  AttribClass,
  AttribClassMenuEntriesWithoutCoreGroup,
  BaseSopOperation,
  InputCloneMode,
  NodeParamsConfig,
  ParamConfig,
  TypeAssert,
  corePointClassFactory,
  corePrimitiveClassFactory,
  coreVertexClassFactory,
  pointsFromObject,
  primitivesFromObject,
  verticesFromObject
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import "./chunk-O564GFGZ.js";
import {
  BufferAttribute,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/AttribId.js
var _points = [];
var _vertices = [];
var _primitives = [];
var AttribIdSopOperation = class extends BaseSopOperation {
  static type() {
    return "attribId";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const attribClass = ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[params.class];
    this._addAttribute(attribClass, coreGroup, params);
    return coreGroup;
  }
  async _addAttribute(attribClass, coreGroup, params) {
    const objects = coreGroup.allObjects();
    switch (attribClass) {
      case AttribClass.POINT:
        return this._addPointAttributesToObjects(objects, params);
      case AttribClass.VERTEX: {
        this._addVertexAttributesToObjects(objects, params);
        return;
      }
      case AttribClass.PRIMITIVE: {
        this._addPrimitiveAttributesToObjects(objects, params);
        return;
      }
      case AttribClass.OBJECT:
        return this._addAttributesToEntities(coreGroup.allCoreObjects(), params);
      case AttribClass.CORE_GROUP:
        return;
    }
    TypeAssert.unreachable(attribClass);
  }
  // private _addObjectAttributes(coreObjects: BaseCoreObject<CoreObjectType>[], params: AttribIdSopParams) {
  // 	const objectsCount = coreObjects.length;
  // 	if (objectsCount > 1) {
  // 		let i = 0;
  // 		for (const coreObject of coreObjects) {
  // 			if (isBooleanTrue(params.id)) {
  // 				coreObject.addAttribute(params.idName, i);
  // 			}
  // 			if (isBooleanTrue(params.idn)) {
  // 				coreObject.addAttribute(params.idnName, i / (objectsCount - 1));
  // 			}
  // 			i++;
  // 		}
  // 	} else {
  // 		coreObjects[0].addAttribute(params.idName, 0);
  // 		coreObjects[0].addAttribute(params.idnName, 0);
  // 	}
  // }
  _addPointAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addPointAttributesToObject(object, params);
    }
  }
  _addVertexAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addVertexAttributes(object, params);
    }
  }
  _addPrimitiveAttributesToObjects(objects, params) {
    for (const object of objects) {
      this._addPrimitiveAttributes(object, params);
    }
  }
  _addPointAttributesToObject(object, params) {
    const pointClass = corePointClassFactory(object);
    pointsFromObject(object, _points);
    const entitiesCount = _points.length;
    if (isBooleanTrue(params.id)) {
      const idValues = new Array(entitiesCount);
      for (let i = 0; i < entitiesCount; i++) {
        idValues[i] = i;
      }
      const idArray = new Float32Array(idValues);
      const attrib = new BufferAttribute(idArray, 1);
      pointClass.addAttribute(object, params.idName, attrib);
    }
    if (isBooleanTrue(params.idn)) {
      const idnValues = new Array(entitiesCount);
      const pointsCountMinus1 = entitiesCount - 1;
      if (pointsCountMinus1 == 0) {
        for (let i = 0; i < entitiesCount; i++) {
          idnValues[i] = 0;
        }
      } else {
        for (let i = 0; i < entitiesCount; i++) {
          idnValues[i] = i / (entitiesCount - 1);
        }
      }
      const idnArray = new Float32Array(idnValues);
      const attrib = new BufferAttribute(idnArray, 1);
      pointClass.addAttribute(object, params.idnName, attrib);
    }
  }
  _addVertexAttributes(object, params) {
    const vertexClass = coreVertexClassFactory(object);
    verticesFromObject(object, _vertices);
    if (isBooleanTrue(params.id)) {
      const attribute = {
        isString: false,
        array: new Array(_vertices.length),
        itemSize: 1
      };
      vertexClass.addAttribute(object, params.idName, attribute);
    }
    if (isBooleanTrue(params.idn)) {
      const attribute = {
        isString: false,
        array: new Array(_vertices.length),
        itemSize: 1
      };
      vertexClass.addAttribute(object, params.idnName, attribute);
    }
    this._addAttributesToEntities(_vertices, params);
  }
  _addPrimitiveAttributes(object, params) {
    const primitiveClass = corePrimitiveClassFactory(object);
    primitivesFromObject(object, _primitives);
    if (isBooleanTrue(params.id)) {
      const attribute = {
        isString: false,
        array: new Array(_primitives.length),
        itemSize: 1
      };
      primitiveClass.addAttribute(object, params.idName, attribute);
    }
    if (isBooleanTrue(params.idn)) {
      const attribute = {
        isString: false,
        array: new Array(_primitives.length),
        itemSize: 1
      };
      primitiveClass.addAttribute(object, params.idnName, attribute);
    }
    this._addAttributesToEntities(_primitives, params);
  }
  _addAttributesToEntities(entities, params) {
    const entitiesCount = entities.length;
    if (isBooleanTrue(params.id)) {
      let i = 0;
      for (const entity of entities) {
        entity.setAttribValue(params.idName, i);
        i++;
      }
    }
    if (isBooleanTrue(params.idn)) {
      const pointsCountMinus1 = entitiesCount - 1;
      if (pointsCountMinus1 == 0) {
        let i = 0;
        for (const entity of entities) {
          entity.setAttribValue(params.idnName, 0);
          i++;
        }
      } else {
        let i = 0;
        for (const entity of entities) {
          entity.setAttribValue(params.idnName, i / (entitiesCount - 1));
          i++;
        }
      }
    }
  }
};
AttribIdSopOperation.DEFAULT_PARAMS = {
  class: ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(AttribClass.POINT),
  id: true,
  idName: "id",
  idn: true,
  idnName: "idn"
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/AttribId.js
var DEFAULT = AttribIdSopOperation.DEFAULT_PARAMS;
var AttribIdSopParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.class = ParamConfig.INTEGER(DEFAULT.class, {
      menu: {
        entries: AttribClassMenuEntriesWithoutCoreGroup
      }
    });
    this.id = ParamConfig.BOOLEAN(DEFAULT.id);
    this.idName = ParamConfig.STRING(DEFAULT.idName, {
      visibleIf: { id: 1 }
    });
    this.idn = ParamConfig.BOOLEAN(DEFAULT.idn);
    this.idnName = ParamConfig.STRING(DEFAULT.idnName, {
      visibleIf: { idn: 1 }
    });
  }
};
var ParamsConfig = new AttribIdSopParamsConfig();
var AttribIdSopNode = class extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.ATTRIB_ID;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE]);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new AttribIdSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  //
  //
  // API UTILS
  //
  //
  setAttribClass(attribClass) {
    if (ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.includes(attribClass)) {
      this.p.class.set(ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(attribClass));
    } else {
      console.warn(`${attribClass} is not possible on this node`);
    }
  }
  attribClass() {
    return ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[this.pv.class];
  }
};
export {
  AttribIdSopNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_sop_AttribId.js.map
