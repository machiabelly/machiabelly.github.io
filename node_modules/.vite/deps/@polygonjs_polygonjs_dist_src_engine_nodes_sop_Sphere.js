import {
  TypedSopNode
} from "./chunk-XJZFUBTR.js";
import {
  SopType
} from "./chunk-OBFUH3H6.js";
import "./chunk-EGRHWZRV.js";
import {
  BaseSopOperation,
  InputCloneMode,
  NodeParamsConfig,
  ObjectType,
  ParamConfig
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import "./chunk-O564GFGZ.js";
import {
  Box3,
  BufferGeometry,
  Float32BufferAttribute,
  IcosahedronGeometry,
  Vector2,
  Vector3,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/builders/SphereBuilder.js
var SphereBuilder = class {
  static create(parameters) {
    const geometry = new BufferGeometry();
    geometry.type = "SphereBuilder";
    let { radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength, asLines, open } = parameters;
    if (phiStart == null) {
      phiStart = 0;
    }
    if (phiLength == null) {
      phiLength = Math.PI * 2;
    }
    if (thetaStart == null) {
      thetaStart = 0;
    }
    if (thetaLength == null) {
      thetaLength = Math.PI;
    }
    if (open == null) {
      open = false;
    }
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex = new Vector3();
    const normal = new Vector3();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex.x, vertex.y, vertex.z);
        normal.copy(vertex).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (asLines) {
          if (iy !== 0 || thetaStart > 0)
            indices.push(a, b);
          indices.push(b, c);
          if (open) {
            if (ix < widthSegments - 1) {
              indices.push(c, d);
            }
            if (iy < heightSegments - 1) {
              indices.push(a, d);
            }
          }
        } else {
          if (iy !== 0 || thetaStart > 0)
            indices.push(a, b, d);
          if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
            indices.push(b, c, d);
        }
      }
    }
    if (open) {
      const a = grid[heightSegments][widthSegments - 1];
      const b = grid[heightSegments][widthSegments];
      indices.push(a, b);
      const c = grid[heightSegments - 1][widthSegments];
      const d = grid[heightSegments][widthSegments];
      indices.push(c, d);
    }
    geometry.setIndex(indices);
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    geometry.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    return geometry;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/Sphere.js
var tmpBox = new Box3();
var tmpSize = new Vector3();
var tmpCenter = new Vector3();
var SphereType = ((SphereType2) => {
  SphereType2["DEFAULT"] = "default";
  SphereType2["ISOCAHEDRON"] = "isocahedron";
  return SphereType2;
})(SphereType || {});
var SPHERE_TYPE = {
  default: 0,
  isocahedron: 1
};
var SPHERE_TYPES = [
  "default",
  "isocahedron"
  /* ISOCAHEDRON */
];
var SphereSopOperation = class extends BaseSopOperation {
  static type() {
    return "sphere";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const object = coreGroup ? this._cookWithInput(coreGroup, params) : this._cookWithoutInput(params);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    const geometry = this._createRequiredGeometry(params);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    const object = this._createSphereObject(geometry, params);
    return object;
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const geometry = this._createRequiredGeometry(params);
    geometry.scale(tmpSize.x, tmpSize.y, tmpSize.z);
    geometry.translate(params.center.x, params.center.y, params.center.z);
    geometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);
    const object = this._createSphereObject(geometry, params);
    return object;
  }
  _createSphereObject(geometry, params) {
    return BaseSopOperation.createObject(geometry, params.asLines ? ObjectType.LINE_SEGMENTS : ObjectType.MESH);
  }
  _createRequiredGeometry(params) {
    if (params.type == SPHERE_TYPE.default) {
      return this._createDefaultSphere(params);
    } else {
      return this._createDefaultIsocahedron(params);
    }
  }
  _createDefaultSphere(params) {
    const geometry = isBooleanTrue(params.open) ? SphereBuilder.create({
      radius: params.radius,
      widthSegments: params.resolution.x,
      heightSegments: params.resolution.y,
      phiStart: params.phiStart,
      phiLength: params.phiLength,
      thetaStart: params.thetaStart,
      thetaLength: params.thetaLength,
      asLines: params.asLines,
      open: true
    }) : SphereBuilder.create({
      radius: params.radius,
      widthSegments: params.resolution.x,
      heightSegments: params.resolution.y,
      asLines: params.asLines,
      open: false
    });
    return geometry;
  }
  _createDefaultIsocahedron(params) {
    return new IcosahedronGeometry(params.radius, params.detail);
  }
};
SphereSopOperation.DEFAULT_PARAMS = {
  type: SPHERE_TYPE.default,
  radius: 1,
  resolution: new Vector2(30, 30),
  open: false,
  phiStart: 0,
  phiLength: Math.PI * 2,
  thetaStart: 0,
  thetaLength: Math.PI,
  detail: 1,
  center: new Vector3(0, 0, 0),
  asLines: false
};
SphereSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/Sphere.js
var DEFAULT = SphereSopOperation.DEFAULT_PARAMS;
var step = 1e-5;
var SphereSopParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.type = ParamConfig.INTEGER(DEFAULT.type, {
      menu: {
        entries: SPHERE_TYPES.map((name) => {
          return { name, value: SPHERE_TYPE[name] };
        })
      }
    });
    this.radius = ParamConfig.FLOAT(DEFAULT.radius, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    this.resolution = ParamConfig.VECTOR2(DEFAULT.resolution, { visibleIf: { type: SPHERE_TYPE.default } });
    this.open = ParamConfig.BOOLEAN(DEFAULT.open, { visibleIf: { type: SPHERE_TYPE.default } });
    this.phiStart = ParamConfig.FLOAT(DEFAULT.phiStart, {
      range: [0, Math.PI * 2],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    this.phiLength = ParamConfig.FLOAT("$PI*2", {
      range: [0, Math.PI * 2],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    this.thetaStart = ParamConfig.FLOAT(DEFAULT.thetaStart, {
      range: [0, Math.PI],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    this.thetaLength = ParamConfig.FLOAT("$PI", {
      range: [0, Math.PI],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    this.detail = ParamConfig.INTEGER(DEFAULT.detail, {
      range: [0, 5],
      rangeLocked: [true, false],
      visibleIf: { type: SPHERE_TYPE.isocahedron }
    });
    this.center = ParamConfig.VECTOR3(DEFAULT.center);
    this.asLines = ParamConfig.BOOLEAN(DEFAULT.asLines);
  }
};
var ParamsConfig = new SphereSopParamsConfig();
var SphereSopNode = class extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.SPHERE;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(SphereSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new SphereSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
};
export {
  SphereSopNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_sop_Sphere.js.map
