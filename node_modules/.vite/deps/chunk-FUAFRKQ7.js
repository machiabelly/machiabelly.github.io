import {
  CoreGraphNode,
  CoreString,
  CoreWalker,
  DecomposedPath,
  MethodDependency,
  TypedNodePathParamValue,
  TypedParamPathParamValue,
  stringMatchMask,
  stringToAttribNames
} from "./chunk-RVFV2LA3.js";
import {
  CoreMath,
  Easing,
  MapUtils,
  Poly,
  addToSetAtEntry,
  arrayCompact,
  arrayCopy,
  arrayDifference,
  arrayIsEqual,
  arrayMap,
  arrayPushItems,
  arrayShallowClone,
  arraySortBy,
  arraySum,
  arrayToSet,
  arrayUnion,
  arrayUniq,
  objectClone,
  objectCloneDeep,
  objectIsEqual,
  rangeWithEnd,
  setDifference,
  setIntersection,
  setToArray,
  setUnion
} from "./chunk-O564GFGZ.js";
import {
  Box3,
  BufferAttribute,
  BufferGeometry,
  Color,
  CoreType,
  CubicInterpolant,
  DataTexture,
  Euler,
  EventDispatcher,
  Float32BufferAttribute,
  FloatType,
  FrontSide,
  Group,
  InstancedBufferAttribute,
  InstancedBufferGeometry,
  InstancedMesh,
  Int32BufferAttribute,
  LineBasicMaterial,
  LineSegments,
  Material,
  MathUtils,
  Matrix4,
  Mesh,
  MeshStandardMaterial,
  Object3D,
  Points,
  PointsMaterial,
  Quaternion,
  RGBAFormat,
  Scene,
  Sphere,
  Texture,
  Triangle,
  UniformsUtils,
  Vector2,
  Vector3,
  Vector4,
  incrementRefSafely,
  isArray,
  isColor,
  isFunction,
  isNumber,
  isVector,
  ref,
  watch
} from "./chunk-6OBTIB4K.js";
import {
  NetworkChildNodeType,
  NodeContext
} from "./chunk-PQDBXNT6.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UXIASGQL.js";

// node_modules/@jscad/modeling/src/utils/flatten.js
var require_flatten = __commonJS({
  "node_modules/@jscad/modeling/src/utils/flatten.js"(exports, module) {
    var flatten2 = (arr) => arr.reduce((acc, val) => Array.isArray(val) ? acc.concat(flatten2(val)) : acc.concat(val), []);
    module.exports = flatten2;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/clone.js
var require_clone = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/clone.js"(exports, module) {
    var clone = (geometry) => Object.assign({}, geometry);
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/add.js
var require_add = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/add.js"(exports, module) {
    var add = (out, a, b) => {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      out[3] = a[3] + b[3];
      out[4] = a[4] + b[4];
      out[5] = a[5] + b[5];
      out[6] = a[6] + b[6];
      out[7] = a[7] + b[7];
      out[8] = a[8] + b[8];
      out[9] = a[9] + b[9];
      out[10] = a[10] + b[10];
      out[11] = a[11] + b[11];
      out[12] = a[12] + b[12];
      out[13] = a[13] + b[13];
      out[14] = a[14] + b[14];
      out[15] = a[15] + b[15];
      return out;
    };
    module.exports = add;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/create.js
var require_create = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/create.js"(exports, module) {
    var create = () => [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/clone.js
var require_clone2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/clone.js"(exports, module) {
    var create = require_create();
    var clone = (matrix) => {
      const out = create();
      out[0] = matrix[0];
      out[1] = matrix[1];
      out[2] = matrix[2];
      out[3] = matrix[3];
      out[4] = matrix[4];
      out[5] = matrix[5];
      out[6] = matrix[6];
      out[7] = matrix[7];
      out[8] = matrix[8];
      out[9] = matrix[9];
      out[10] = matrix[10];
      out[11] = matrix[11];
      out[12] = matrix[12];
      out[13] = matrix[13];
      out[14] = matrix[14];
      out[15] = matrix[15];
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/copy.js
var require_copy = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/copy.js"(exports, module) {
    var copy = (out, matrix) => {
      out[0] = matrix[0];
      out[1] = matrix[1];
      out[2] = matrix[2];
      out[3] = matrix[3];
      out[4] = matrix[4];
      out[5] = matrix[5];
      out[6] = matrix[6];
      out[7] = matrix[7];
      out[8] = matrix[8];
      out[9] = matrix[9];
      out[10] = matrix[10];
      out[11] = matrix[11];
      out[12] = matrix[12];
      out[13] = matrix[13];
      out[14] = matrix[14];
      out[15] = matrix[15];
      return out;
    };
    module.exports = copy;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/invert.js
var require_invert = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/invert.js"(exports, module) {
    var invert = (out, matrix) => {
      const a00 = matrix[0];
      const a01 = matrix[1];
      const a02 = matrix[2];
      const a03 = matrix[3];
      const a10 = matrix[4];
      const a11 = matrix[5];
      const a12 = matrix[6];
      const a13 = matrix[7];
      const a20 = matrix[8];
      const a21 = matrix[9];
      const a22 = matrix[10];
      const a23 = matrix[11];
      const a30 = matrix[12];
      const a31 = matrix[13];
      const a32 = matrix[14];
      const a33 = matrix[15];
      const b00 = a00 * a11 - a01 * a10;
      const b01 = a00 * a12 - a02 * a10;
      const b02 = a00 * a13 - a03 * a10;
      const b03 = a01 * a12 - a02 * a11;
      const b04 = a01 * a13 - a03 * a11;
      const b05 = a02 * a13 - a03 * a12;
      const b06 = a20 * a31 - a21 * a30;
      const b07 = a20 * a32 - a22 * a30;
      const b08 = a20 * a33 - a23 * a30;
      const b09 = a21 * a32 - a22 * a31;
      const b10 = a21 * a33 - a23 * a31;
      const b11 = a22 * a33 - a23 * a32;
      let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
      if (!det) {
        return null;
      }
      det = 1 / det;
      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
      return out;
    };
    module.exports = invert;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/equals.js
var require_equals = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/equals.js"(exports, module) {
    var equals2 = (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/maths/constants.js
var require_constants = __commonJS({
  "node_modules/@jscad/modeling/src/maths/constants.js"(exports, module) {
    var spatialResolution = 1e5;
    var EPS = 1e-5;
    var NEPS = 1e-13;
    var TAU = Math.PI * 2;
    module.exports = {
      EPS,
      NEPS,
      TAU,
      spatialResolution
    };
  }
});

// node_modules/@jscad/modeling/src/maths/utils/trigonometry.js
var require_trigonometry = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/trigonometry.js"(exports, module) {
    var { NEPS } = require_constants();
    var rezero = (n) => Math.abs(n) < NEPS ? 0 : n;
    var sin = (radians) => rezero(Math.sin(radians));
    var cos = (radians) => rezero(Math.cos(radians));
    module.exports = { sin, cos };
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/identity.js
var require_identity = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/identity.js"(exports, module) {
    var identity = (out) => {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = identity;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromRotation.js
var require_fromRotation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromRotation.js"(exports, module) {
    var { EPS } = require_constants();
    var { sin, cos } = require_trigonometry();
    var identity = require_identity();
    var fromRotation = (out, rad, axis) => {
      let [x, y, z] = axis;
      const lengthSquared = x * x + y * y + z * z;
      if (Math.abs(lengthSquared) < EPS) {
        return identity(out);
      }
      const len = 1 / Math.sqrt(lengthSquared);
      x *= len;
      y *= len;
      z *= len;
      const s = sin(rad);
      const c = cos(rad);
      const t = 1 - c;
      out[0] = x * x * t + c;
      out[1] = y * x * t + z * s;
      out[2] = z * x * t - y * s;
      out[3] = 0;
      out[4] = x * y * t - z * s;
      out[5] = y * y * t + c;
      out[6] = z * y * t + x * s;
      out[7] = 0;
      out[8] = x * z * t + y * s;
      out[9] = y * z * t - x * s;
      out[10] = z * z * t + c;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromRotation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromScaling.js
var require_fromScaling = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromScaling.js"(exports, module) {
    var fromScaling = (out, vector) => {
      out[0] = vector[0];
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = vector[1];
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = vector[2];
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromScaling;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromTaitBryanRotation.js
var require_fromTaitBryanRotation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromTaitBryanRotation.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var fromTaitBryanRotation = (out, yaw, pitch, roll) => {
      const sy = sin(yaw);
      const cy = cos(yaw);
      const sp = sin(pitch);
      const cp = cos(pitch);
      const sr = sin(roll);
      const cr = cos(roll);
      out[0] = cp * cy;
      out[1] = cp * sy;
      out[2] = -sp;
      out[3] = 0;
      out[4] = sr * sp * cy - cr * sy;
      out[5] = cr * cy + sr * sp * sy;
      out[6] = sr * cp;
      out[7] = 0;
      out[8] = sr * sy + cr * sp * cy;
      out[9] = cr * sp * sy - sr * cy;
      out[10] = cr * cp;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromTaitBryanRotation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromTranslation.js
var require_fromTranslation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromTranslation.js"(exports, module) {
    var fromTranslation = (out, vector) => {
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = vector[0];
      out[13] = vector[1];
      out[14] = vector[2];
      out[15] = 1;
      return out;
    };
    module.exports = fromTranslation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromValues.js
var require_fromValues = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromValues.js"(exports, module) {
    var create = require_create();
    var fromValues = (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) => {
      const out = create();
      out[0] = m00;
      out[1] = m01;
      out[2] = m02;
      out[3] = m03;
      out[4] = m10;
      out[5] = m11;
      out[6] = m12;
      out[7] = m13;
      out[8] = m20;
      out[9] = m21;
      out[10] = m22;
      out[11] = m23;
      out[12] = m30;
      out[13] = m31;
      out[14] = m32;
      out[15] = m33;
      return out;
    };
    module.exports = fromValues;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/abs.js
var require_abs = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/abs.js"(exports, module) {
    var abs = (out, vector) => {
      out[0] = Math.abs(vector[0]);
      out[1] = Math.abs(vector[1]);
      out[2] = Math.abs(vector[2]);
      return out;
    };
    module.exports = abs;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/add.js
var require_add2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/add.js"(exports, module) {
    var add = (out, a, b) => {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      out[2] = a[2] + b[2];
      return out;
    };
    module.exports = add;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/dot.js
var require_dot = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/dot.js"(exports, module) {
    var dot = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
    module.exports = dot;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/angle.js
var require_angle = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/angle.js"(exports, module) {
    var dot = require_dot();
    var angle = (a, b) => {
      const ax = a[0];
      const ay = a[1];
      const az = a[2];
      const bx = b[0];
      const by = b[1];
      const bz = b[2];
      const mag1 = Math.sqrt(ax * ax + ay * ay + az * az);
      const mag2 = Math.sqrt(bx * bx + by * by + bz * bz);
      const mag = mag1 * mag2;
      const cosine = mag && dot(a, b) / mag;
      return Math.acos(Math.min(Math.max(cosine, -1), 1));
    };
    module.exports = angle;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/create.js
var require_create2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/create.js"(exports, module) {
    var create = () => [0, 0, 0];
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/clone.js
var require_clone3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/clone.js"(exports, module) {
    var create = require_create2();
    var clone = (vector) => {
      const out = create();
      out[0] = vector[0];
      out[1] = vector[1];
      out[2] = vector[2];
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/copy.js
var require_copy2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/copy.js"(exports, module) {
    var copy = (out, vector) => {
      out[0] = vector[0];
      out[1] = vector[1];
      out[2] = vector[2];
      return out;
    };
    module.exports = copy;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/cross.js
var require_cross = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/cross.js"(exports, module) {
    var cross = (out, a, b) => {
      const ax = a[0];
      const ay = a[1];
      const az = a[2];
      const bx = b[0];
      const by = b[1];
      const bz = b[2];
      out[0] = ay * bz - az * by;
      out[1] = az * bx - ax * bz;
      out[2] = ax * by - ay * bx;
      return out;
    };
    module.exports = cross;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/distance.js
var require_distance = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/distance.js"(exports, module) {
    var distance = (a, b) => {
      const x = b[0] - a[0];
      const y = b[1] - a[1];
      const z = b[2] - a[2];
      return Math.sqrt(x * x + y * y + z * z);
    };
    module.exports = distance;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/divide.js
var require_divide = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/divide.js"(exports, module) {
    var divide = (out, a, b) => {
      out[0] = a[0] / b[0];
      out[1] = a[1] / b[1];
      out[2] = a[2] / b[2];
      return out;
    };
    module.exports = divide;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/equals.js
var require_equals2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/equals.js"(exports, module) {
    var equals2 = (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/fromScalar.js
var require_fromScalar = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/fromScalar.js"(exports, module) {
    var fromScalar = (out, scalar) => {
      out[0] = scalar;
      out[1] = scalar;
      out[2] = scalar;
      return out;
    };
    module.exports = fromScalar;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/fromValues.js
var require_fromValues2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/fromValues.js"(exports, module) {
    var create = require_create2();
    var fromValues = (x, y, z) => {
      const out = create();
      out[0] = x;
      out[1] = y;
      out[2] = z;
      return out;
    };
    module.exports = fromValues;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/fromVec2.js
var require_fromVec2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/fromVec2.js"(exports, module) {
    var fromVector2 = (out, vector, z = 0) => {
      out[0] = vector[0];
      out[1] = vector[1];
      out[2] = z;
      return out;
    };
    module.exports = fromVector2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/length.js
var require_length = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/length.js"(exports, module) {
    var length = (vector) => {
      const x = vector[0];
      const y = vector[1];
      const z = vector[2];
      return Math.sqrt(x * x + y * y + z * z);
    };
    module.exports = length;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/lerp.js
var require_lerp = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/lerp.js"(exports, module) {
    var lerp2 = (out, a, b, t) => {
      out[0] = a[0] + t * (b[0] - a[0]);
      out[1] = a[1] + t * (b[1] - a[1]);
      out[2] = a[2] + t * (b[2] - a[2]);
      return out;
    };
    module.exports = lerp2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/max.js
var require_max = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/max.js"(exports, module) {
    var max = (out, a, b) => {
      out[0] = Math.max(a[0], b[0]);
      out[1] = Math.max(a[1], b[1]);
      out[2] = Math.max(a[2], b[2]);
      return out;
    };
    module.exports = max;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/min.js
var require_min = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/min.js"(exports, module) {
    var min = (out, a, b) => {
      out[0] = Math.min(a[0], b[0]);
      out[1] = Math.min(a[1], b[1]);
      out[2] = Math.min(a[2], b[2]);
      return out;
    };
    module.exports = min;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/multiply.js
var require_multiply = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/multiply.js"(exports, module) {
    var multiply = (out, a, b) => {
      out[0] = a[0] * b[0];
      out[1] = a[1] * b[1];
      out[2] = a[2] * b[2];
      return out;
    };
    module.exports = multiply;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/negate.js
var require_negate = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/negate.js"(exports, module) {
    var negate = (out, vector) => {
      out[0] = -vector[0];
      out[1] = -vector[1];
      out[2] = -vector[2];
      return out;
    };
    module.exports = negate;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/normalize.js
var require_normalize = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/normalize.js"(exports, module) {
    var normalize2 = (out, vector) => {
      const x = vector[0];
      const y = vector[1];
      const z = vector[2];
      let len = x * x + y * y + z * z;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
      }
      out[0] = x * len;
      out[1] = y * len;
      out[2] = z * len;
      return out;
    };
    module.exports = normalize2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/orthogonal.js
var require_orthogonal = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/orthogonal.js"(exports, module) {
    var abs = require_abs();
    var create = require_create2();
    var cross = require_cross();
    var orthogonal = (out, vector) => {
      const bV = abs(create(), vector);
      const b0 = 0 + (bV[0] < bV[1] && bV[0] < bV[2]);
      const b1 = 0 + (bV[1] <= bV[0] && bV[1] < bV[2]);
      const b2 = 0 + (bV[2] <= bV[0] && bV[2] <= bV[1]);
      return cross(out, vector, [b0, b1, b2]);
    };
    module.exports = orthogonal;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/rotateX.js
var require_rotateX = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/rotateX.js"(exports, module) {
    var rotateX = (out, vector, origin, radians) => {
      const p = [];
      const r = [];
      p[0] = vector[0] - origin[0];
      p[1] = vector[1] - origin[1];
      p[2] = vector[2] - origin[2];
      r[0] = p[0];
      r[1] = p[1] * Math.cos(radians) - p[2] * Math.sin(radians);
      r[2] = p[1] * Math.sin(radians) + p[2] * Math.cos(radians);
      out[0] = r[0] + origin[0];
      out[1] = r[1] + origin[1];
      out[2] = r[2] + origin[2];
      return out;
    };
    module.exports = rotateX;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/rotateY.js
var require_rotateY = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/rotateY.js"(exports, module) {
    var rotateY = (out, vector, origin, radians) => {
      const p = [];
      const r = [];
      p[0] = vector[0] - origin[0];
      p[1] = vector[1] - origin[1];
      p[2] = vector[2] - origin[2];
      r[0] = p[2] * Math.sin(radians) + p[0] * Math.cos(radians);
      r[1] = p[1];
      r[2] = p[2] * Math.cos(radians) - p[0] * Math.sin(radians);
      out[0] = r[0] + origin[0];
      out[1] = r[1] + origin[1];
      out[2] = r[2] + origin[2];
      return out;
    };
    module.exports = rotateY;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/rotateZ.js
var require_rotateZ = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/rotateZ.js"(exports, module) {
    var rotateZ = (out, vector, origin, radians) => {
      const p = [];
      const r = [];
      p[0] = vector[0] - origin[0];
      p[1] = vector[1] - origin[1];
      r[0] = p[0] * Math.cos(radians) - p[1] * Math.sin(radians);
      r[1] = p[0] * Math.sin(radians) + p[1] * Math.cos(radians);
      out[0] = r[0] + origin[0];
      out[1] = r[1] + origin[1];
      out[2] = vector[2];
      return out;
    };
    module.exports = rotateZ;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/scale.js
var require_scale = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/scale.js"(exports, module) {
    var scale = (out, vector, amount) => {
      out[0] = vector[0] * amount;
      out[1] = vector[1] * amount;
      out[2] = vector[2] * amount;
      return out;
    };
    module.exports = scale;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/snap.js
var require_snap = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/snap.js"(exports, module) {
    var snap = (out, vector, epsilon) => {
      out[0] = Math.round(vector[0] / epsilon) * epsilon + 0;
      out[1] = Math.round(vector[1] / epsilon) * epsilon + 0;
      out[2] = Math.round(vector[2] / epsilon) * epsilon + 0;
      return out;
    };
    module.exports = snap;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/squaredDistance.js
var require_squaredDistance = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/squaredDistance.js"(exports, module) {
    var squaredDistance = (a, b) => {
      const x = b[0] - a[0];
      const y = b[1] - a[1];
      const z = b[2] - a[2];
      return x * x + y * y + z * z;
    };
    module.exports = squaredDistance;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/squaredLength.js
var require_squaredLength = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/squaredLength.js"(exports, module) {
    var squaredLength = (vector) => {
      const x = vector[0];
      const y = vector[1];
      const z = vector[2];
      return x * x + y * y + z * z;
    };
    module.exports = squaredLength;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/subtract.js
var require_subtract = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/subtract.js"(exports, module) {
    var subtract = (out, a, b) => {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      return out;
    };
    module.exports = subtract;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/toString.js
var require_toString = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/toString.js"(exports, module) {
    var toString = (vec) => `[${vec[0].toFixed(7)}, ${vec[1].toFixed(7)}, ${vec[2].toFixed(7)}]`;
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/transform.js
var require_transform = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/transform.js"(exports, module) {
    var transform = (out, vector, matrix) => {
      const x = vector[0];
      const y = vector[1];
      const z = vector[2];
      let w = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
      w = w || 1;
      out[0] = (matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12]) / w;
      out[1] = (matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13]) / w;
      out[2] = (matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14]) / w;
      return out;
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/maths/vec3/index.js
var require_vec3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec3/index.js"(exports, module) {
    module.exports = {
      abs: require_abs(),
      add: require_add2(),
      angle: require_angle(),
      clone: require_clone3(),
      copy: require_copy2(),
      create: require_create2(),
      cross: require_cross(),
      distance: require_distance(),
      divide: require_divide(),
      dot: require_dot(),
      equals: require_equals2(),
      fromScalar: require_fromScalar(),
      fromValues: require_fromValues2(),
      fromVec2: require_fromVec2(),
      length: require_length(),
      lerp: require_lerp(),
      max: require_max(),
      min: require_min(),
      multiply: require_multiply(),
      negate: require_negate(),
      normalize: require_normalize(),
      orthogonal: require_orthogonal(),
      rotateX: require_rotateX(),
      rotateY: require_rotateY(),
      rotateZ: require_rotateZ(),
      scale: require_scale(),
      snap: require_snap(),
      squaredDistance: require_squaredDistance(),
      squaredLength: require_squaredLength(),
      subtract: require_subtract(),
      toString: require_toString(),
      transform: require_transform()
    };
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromVectorRotation.js
var require_fromVectorRotation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromVectorRotation.js"(exports, module) {
    var vec3 = require_vec3();
    var fromRotation = require_fromRotation();
    var fromVectorRotation = (out, source, target4) => {
      const sourceNormal = vec3.normalize(vec3.create(), source);
      const targetNormal = vec3.normalize(vec3.create(), target4);
      const axis = vec3.cross(vec3.create(), targetNormal, sourceNormal);
      const cosA = vec3.dot(targetNormal, sourceNormal);
      if (cosA === -1)
        return fromRotation(out, Math.PI, vec3.orthogonal(axis, sourceNormal));
      const k = 1 / (1 + cosA);
      out[0] = axis[0] * axis[0] * k + cosA;
      out[1] = axis[1] * axis[0] * k - axis[2];
      out[2] = axis[2] * axis[0] * k + axis[1];
      out[3] = 0;
      out[4] = axis[0] * axis[1] * k + axis[2];
      out[5] = axis[1] * axis[1] * k + cosA;
      out[6] = axis[2] * axis[1] * k - axis[0];
      out[7] = 0;
      out[8] = axis[0] * axis[2] * k - axis[1];
      out[9] = axis[1] * axis[2] * k + axis[0];
      out[10] = axis[2] * axis[2] * k + cosA;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromVectorRotation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromXRotation.js
var require_fromXRotation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromXRotation.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var fromXRotation = (out, radians) => {
      const s = sin(radians);
      const c = cos(radians);
      out[0] = 1;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[5] = c;
      out[6] = s;
      out[7] = 0;
      out[8] = 0;
      out[9] = -s;
      out[10] = c;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromXRotation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromYRotation.js
var require_fromYRotation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromYRotation.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var fromYRotation = (out, radians) => {
      const s = sin(radians);
      const c = cos(radians);
      out[0] = c;
      out[1] = 0;
      out[2] = -s;
      out[3] = 0;
      out[4] = 0;
      out[5] = 1;
      out[6] = 0;
      out[7] = 0;
      out[8] = s;
      out[9] = 0;
      out[10] = c;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromYRotation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/fromZRotation.js
var require_fromZRotation = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/fromZRotation.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var fromZRotation = (out, radians) => {
      const s = sin(radians);
      const c = cos(radians);
      out[0] = c;
      out[1] = s;
      out[2] = 0;
      out[3] = 0;
      out[4] = -s;
      out[5] = c;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[10] = 1;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
      out[15] = 1;
      return out;
    };
    module.exports = fromZRotation;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/isIdentity.js
var require_isIdentity = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/isIdentity.js"(exports, module) {
    var isIdentity = (matrix) => matrix[0] === 1 && matrix[1] === 0 && matrix[2] === 0 && matrix[3] === 0 && matrix[4] === 0 && matrix[5] === 1 && matrix[6] === 0 && matrix[7] === 0 && matrix[8] === 0 && matrix[9] === 0 && matrix[10] === 1 && matrix[11] === 0 && matrix[12] === 0 && matrix[13] === 0 && matrix[14] === 0 && matrix[15] === 1;
    module.exports = isIdentity;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/isOnlyTransformScale.js
var require_isOnlyTransformScale = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/isOnlyTransformScale.js"(exports, module) {
    var isOnlyTransformScale = (matrix) => (
      // TODO check if it is worth the effort to add recognition of 90 deg rotations
      isZero(matrix[1]) && isZero(matrix[2]) && isZero(matrix[3]) && isZero(matrix[4]) && isZero(matrix[6]) && isZero(matrix[7]) && isZero(matrix[8]) && isZero(matrix[9]) && isZero(matrix[11]) && matrix[15] === 1
    );
    var isZero = (num) => Math.abs(num) < Number.EPSILON;
    module.exports = isOnlyTransformScale;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/isMirroring.js
var require_isMirroring = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/isMirroring.js"(exports, module) {
    var isMirroring = (matrix) => {
      const x = matrix[4] * matrix[9] - matrix[8] * matrix[5];
      const y = matrix[8] * matrix[1] - matrix[0] * matrix[9];
      const z = matrix[0] * matrix[5] - matrix[4] * matrix[1];
      const d = x * matrix[2] + y * matrix[6] + z * matrix[10];
      return d < 0;
    };
    module.exports = isMirroring;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/mirrorByPlane.js
var require_mirrorByPlane = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/mirrorByPlane.js"(exports, module) {
    var mirrorByPlane = (out, plane) => {
      const [nx, ny, nz, w] = plane;
      out[0] = 1 - 2 * nx * nx;
      out[1] = -2 * ny * nx;
      out[2] = -2 * nz * nx;
      out[3] = 0;
      out[4] = -2 * nx * ny;
      out[5] = 1 - 2 * ny * ny;
      out[6] = -2 * nz * ny;
      out[7] = 0;
      out[8] = -2 * nx * nz;
      out[9] = -2 * ny * nz;
      out[10] = 1 - 2 * nz * nz;
      out[11] = 0;
      out[12] = 2 * nx * w;
      out[13] = 2 * ny * w;
      out[14] = 2 * nz * w;
      out[15] = 1;
      return out;
    };
    module.exports = mirrorByPlane;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/multiply.js
var require_multiply2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/multiply.js"(exports, module) {
    var multiply = (out, a, b) => {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      const a30 = a[12];
      const a31 = a[13];
      const a32 = a[14];
      const a33 = a[15];
      let b0 = b[0];
      let b1 = b[1];
      let b2 = b[2];
      let b3 = b[3];
      out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[4];
      b1 = b[5];
      b2 = b[6];
      b3 = b[7];
      out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[8];
      b1 = b[9];
      b2 = b[10];
      b3 = b[11];
      out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      b0 = b[12];
      b1 = b[13];
      b2 = b[14];
      b3 = b[15];
      out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
      out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
      out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
      out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
      return out;
    };
    module.exports = multiply;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/rotate.js
var require_rotate = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/rotate.js"(exports, module) {
    var { EPS } = require_constants();
    var { sin, cos } = require_trigonometry();
    var copy = require_copy();
    var rotate = (out, matrix, radians, axis) => {
      let [x, y, z] = axis;
      const lengthSquared = x * x + y * y + z * z;
      if (Math.abs(lengthSquared) < EPS) {
        return copy(out, matrix);
      }
      const len = 1 / Math.sqrt(lengthSquared);
      x *= len;
      y *= len;
      z *= len;
      const s = sin(radians);
      const c = cos(radians);
      const t = 1 - c;
      const a00 = matrix[0];
      const a01 = matrix[1];
      const a02 = matrix[2];
      const a03 = matrix[3];
      const a10 = matrix[4];
      const a11 = matrix[5];
      const a12 = matrix[6];
      const a13 = matrix[7];
      const a20 = matrix[8];
      const a21 = matrix[9];
      const a22 = matrix[10];
      const a23 = matrix[11];
      const b00 = x * x * t + c;
      const b01 = y * x * t + z * s;
      const b02 = z * x * t - y * s;
      const b10 = x * y * t - z * s;
      const b11 = y * y * t + c;
      const b12 = z * y * t + x * s;
      const b20 = x * z * t + y * s;
      const b21 = y * z * t - x * s;
      const b22 = z * z * t + c;
      out[0] = a00 * b00 + a10 * b01 + a20 * b02;
      out[1] = a01 * b00 + a11 * b01 + a21 * b02;
      out[2] = a02 * b00 + a12 * b01 + a22 * b02;
      out[3] = a03 * b00 + a13 * b01 + a23 * b02;
      out[4] = a00 * b10 + a10 * b11 + a20 * b12;
      out[5] = a01 * b10 + a11 * b11 + a21 * b12;
      out[6] = a02 * b10 + a12 * b11 + a22 * b12;
      out[7] = a03 * b10 + a13 * b11 + a23 * b12;
      out[8] = a00 * b20 + a10 * b21 + a20 * b22;
      out[9] = a01 * b20 + a11 * b21 + a21 * b22;
      out[10] = a02 * b20 + a12 * b21 + a22 * b22;
      out[11] = a03 * b20 + a13 * b21 + a23 * b22;
      if (matrix !== out) {
        out[12] = matrix[12];
        out[13] = matrix[13];
        out[14] = matrix[14];
        out[15] = matrix[15];
      }
      return out;
    };
    module.exports = rotate;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/rotateX.js
var require_rotateX2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/rotateX.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var rotateX = (out, matrix, radians) => {
      const s = sin(radians);
      const c = cos(radians);
      const a10 = matrix[4];
      const a11 = matrix[5];
      const a12 = matrix[6];
      const a13 = matrix[7];
      const a20 = matrix[8];
      const a21 = matrix[9];
      const a22 = matrix[10];
      const a23 = matrix[11];
      if (matrix !== out) {
        out[0] = matrix[0];
        out[1] = matrix[1];
        out[2] = matrix[2];
        out[3] = matrix[3];
        out[12] = matrix[12];
        out[13] = matrix[13];
        out[14] = matrix[14];
        out[15] = matrix[15];
      }
      out[4] = a10 * c + a20 * s;
      out[5] = a11 * c + a21 * s;
      out[6] = a12 * c + a22 * s;
      out[7] = a13 * c + a23 * s;
      out[8] = a20 * c - a10 * s;
      out[9] = a21 * c - a11 * s;
      out[10] = a22 * c - a12 * s;
      out[11] = a23 * c - a13 * s;
      return out;
    };
    module.exports = rotateX;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/rotateY.js
var require_rotateY2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/rotateY.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var rotateY = (out, matrix, radians) => {
      const s = sin(radians);
      const c = cos(radians);
      const a00 = matrix[0];
      const a01 = matrix[1];
      const a02 = matrix[2];
      const a03 = matrix[3];
      const a20 = matrix[8];
      const a21 = matrix[9];
      const a22 = matrix[10];
      const a23 = matrix[11];
      if (matrix !== out) {
        out[4] = matrix[4];
        out[5] = matrix[5];
        out[6] = matrix[6];
        out[7] = matrix[7];
        out[12] = matrix[12];
        out[13] = matrix[13];
        out[14] = matrix[14];
        out[15] = matrix[15];
      }
      out[0] = a00 * c - a20 * s;
      out[1] = a01 * c - a21 * s;
      out[2] = a02 * c - a22 * s;
      out[3] = a03 * c - a23 * s;
      out[8] = a00 * s + a20 * c;
      out[9] = a01 * s + a21 * c;
      out[10] = a02 * s + a22 * c;
      out[11] = a03 * s + a23 * c;
      return out;
    };
    module.exports = rotateY;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/rotateZ.js
var require_rotateZ2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/rotateZ.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var rotateZ = (out, matrix, radians) => {
      const s = sin(radians);
      const c = cos(radians);
      const a00 = matrix[0];
      const a01 = matrix[1];
      const a02 = matrix[2];
      const a03 = matrix[3];
      const a10 = matrix[4];
      const a11 = matrix[5];
      const a12 = matrix[6];
      const a13 = matrix[7];
      if (matrix !== out) {
        out[8] = matrix[8];
        out[9] = matrix[9];
        out[10] = matrix[10];
        out[11] = matrix[11];
        out[12] = matrix[12];
        out[13] = matrix[13];
        out[14] = matrix[14];
        out[15] = matrix[15];
      }
      out[0] = a00 * c + a10 * s;
      out[1] = a01 * c + a11 * s;
      out[2] = a02 * c + a12 * s;
      out[3] = a03 * c + a13 * s;
      out[4] = a10 * c - a00 * s;
      out[5] = a11 * c - a01 * s;
      out[6] = a12 * c - a02 * s;
      out[7] = a13 * c - a03 * s;
      return out;
    };
    module.exports = rotateZ;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/scale.js
var require_scale2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/scale.js"(exports, module) {
    var scale = (out, matrix, dimensions) => {
      const x = dimensions[0];
      const y = dimensions[1];
      const z = dimensions[2];
      out[0] = matrix[0] * x;
      out[1] = matrix[1] * x;
      out[2] = matrix[2] * x;
      out[3] = matrix[3] * x;
      out[4] = matrix[4] * y;
      out[5] = matrix[5] * y;
      out[6] = matrix[6] * y;
      out[7] = matrix[7] * y;
      out[8] = matrix[8] * z;
      out[9] = matrix[9] * z;
      out[10] = matrix[10] * z;
      out[11] = matrix[11] * z;
      out[12] = matrix[12];
      out[13] = matrix[13];
      out[14] = matrix[14];
      out[15] = matrix[15];
      return out;
    };
    module.exports = scale;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/subtract.js
var require_subtract2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/subtract.js"(exports, module) {
    var subtract = (out, a, b) => {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      out[2] = a[2] - b[2];
      out[3] = a[3] - b[3];
      out[4] = a[4] - b[4];
      out[5] = a[5] - b[5];
      out[6] = a[6] - b[6];
      out[7] = a[7] - b[7];
      out[8] = a[8] - b[8];
      out[9] = a[9] - b[9];
      out[10] = a[10] - b[10];
      out[11] = a[11] - b[11];
      out[12] = a[12] - b[12];
      out[13] = a[13] - b[13];
      out[14] = a[14] - b[14];
      out[15] = a[15] - b[15];
      return out;
    };
    module.exports = subtract;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/toString.js
var require_toString2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/toString.js"(exports, module) {
    var toString = (mat) => mat.map((n) => n.toFixed(7)).toString();
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/translate.js
var require_translate = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/translate.js"(exports, module) {
    var translate = (out, matrix, offsets) => {
      const x = offsets[0];
      const y = offsets[1];
      const z = offsets[2];
      let a00;
      let a01;
      let a02;
      let a03;
      let a10;
      let a11;
      let a12;
      let a13;
      let a20;
      let a21;
      let a22;
      let a23;
      if (matrix === out) {
        out[12] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12];
        out[13] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13];
        out[14] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14];
        out[15] = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15];
      } else {
        a00 = matrix[0];
        a01 = matrix[1];
        a02 = matrix[2];
        a03 = matrix[3];
        a10 = matrix[4];
        a11 = matrix[5];
        a12 = matrix[6];
        a13 = matrix[7];
        a20 = matrix[8];
        a21 = matrix[9];
        a22 = matrix[10];
        a23 = matrix[11];
        out[0] = a00;
        out[1] = a01;
        out[2] = a02;
        out[3] = a03;
        out[4] = a10;
        out[5] = a11;
        out[6] = a12;
        out[7] = a13;
        out[8] = a20;
        out[9] = a21;
        out[10] = a22;
        out[11] = a23;
        out[12] = a00 * x + a10 * y + a20 * z + matrix[12];
        out[13] = a01 * x + a11 * y + a21 * z + matrix[13];
        out[14] = a02 * x + a12 * y + a22 * z + matrix[14];
        out[15] = a03 * x + a13 * y + a23 * z + matrix[15];
      }
      return out;
    };
    module.exports = translate;
  }
});

// node_modules/@jscad/modeling/src/maths/mat4/index.js
var require_mat4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/mat4/index.js"(exports, module) {
    module.exports = {
      add: require_add(),
      clone: require_clone2(),
      copy: require_copy(),
      create: require_create(),
      invert: require_invert(),
      equals: require_equals(),
      fromRotation: require_fromRotation(),
      fromScaling: require_fromScaling(),
      fromTaitBryanRotation: require_fromTaitBryanRotation(),
      fromTranslation: require_fromTranslation(),
      fromValues: require_fromValues(),
      fromVectorRotation: require_fromVectorRotation(),
      fromXRotation: require_fromXRotation(),
      fromYRotation: require_fromYRotation(),
      fromZRotation: require_fromZRotation(),
      identity: require_identity(),
      isIdentity: require_isIdentity(),
      isOnlyTransformScale: require_isOnlyTransformScale(),
      isMirroring: require_isMirroring(),
      mirrorByPlane: require_mirrorByPlane(),
      multiply: require_multiply2(),
      rotate: require_rotate(),
      rotateX: require_rotateX2(),
      rotateY: require_rotateY2(),
      rotateZ: require_rotateZ2(),
      scale: require_scale2(),
      subtract: require_subtract2(),
      toString: require_toString2(),
      translate: require_translate()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/create.js
var require_create3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/create.js"(exports, module) {
    var mat4 = require_mat4();
    var create = (sides) => {
      if (sides === void 0) {
        sides = [];
      }
      return {
        sides,
        transforms: mat4.create()
      };
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/abs.js
var require_abs2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/abs.js"(exports, module) {
    var abs = (out, vector) => {
      out[0] = Math.abs(vector[0]);
      out[1] = Math.abs(vector[1]);
      return out;
    };
    module.exports = abs;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/add.js
var require_add3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/add.js"(exports, module) {
    var add = (out, a, b) => {
      out[0] = a[0] + b[0];
      out[1] = a[1] + b[1];
      return out;
    };
    module.exports = add;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/angleRadians.js
var require_angleRadians = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/angleRadians.js"(exports, module) {
    var angleRadians = (vector) => Math.atan2(vector[1], vector[0]);
    module.exports = angleRadians;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/angle.js
var require_angle2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/angle.js"(exports, module) {
    module.exports = require_angleRadians();
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/angleDegrees.js
var require_angleDegrees = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/angleDegrees.js"(exports, module) {
    var angleRadians = require_angleRadians();
    var angleDegrees = (vector) => angleRadians(vector) * 57.29577951308232;
    module.exports = angleDegrees;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/create.js
var require_create4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/create.js"(exports, module) {
    var create = () => [0, 0];
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/clone.js
var require_clone4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/clone.js"(exports, module) {
    var create = require_create4();
    var clone = (vector) => {
      const out = create();
      out[0] = vector[0];
      out[1] = vector[1];
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/copy.js
var require_copy3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/copy.js"(exports, module) {
    var copy = (out, vector) => {
      out[0] = vector[0];
      out[1] = vector[1];
      return out;
    };
    module.exports = copy;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/cross.js
var require_cross2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/cross.js"(exports, module) {
    var cross = (out, a, b) => {
      out[0] = 0;
      out[1] = 0;
      out[2] = a[0] * b[1] - a[1] * b[0];
      return out;
    };
    module.exports = cross;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/distance.js
var require_distance2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/distance.js"(exports, module) {
    var distance = (a, b) => {
      const x = b[0] - a[0];
      const y = b[1] - a[1];
      return Math.sqrt(x * x + y * y);
    };
    module.exports = distance;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/divide.js
var require_divide2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/divide.js"(exports, module) {
    var divide = (out, a, b) => {
      out[0] = a[0] / b[0];
      out[1] = a[1] / b[1];
      return out;
    };
    module.exports = divide;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/dot.js
var require_dot2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/dot.js"(exports, module) {
    var dot = (a, b) => a[0] * b[0] + a[1] * b[1];
    module.exports = dot;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/equals.js
var require_equals3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/equals.js"(exports, module) {
    var equals2 = (a, b) => a[0] === b[0] && a[1] === b[1];
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/fromAngleRadians.js
var require_fromAngleRadians = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/fromAngleRadians.js"(exports, module) {
    var { sin, cos } = require_trigonometry();
    var fromAngleRadians = (out, radians) => {
      out[0] = cos(radians);
      out[1] = sin(radians);
      return out;
    };
    module.exports = fromAngleRadians;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/fromAngleDegrees.js
var require_fromAngleDegrees = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/fromAngleDegrees.js"(exports, module) {
    var fromAngleRadians = require_fromAngleRadians();
    var fromAngleDegrees = (out, degrees) => fromAngleRadians(out, degrees * 0.017453292519943295);
    module.exports = fromAngleDegrees;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/fromScalar.js
var require_fromScalar2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/fromScalar.js"(exports, module) {
    var fromScalar = (out, scalar) => {
      out[0] = scalar;
      out[1] = scalar;
      return out;
    };
    module.exports = fromScalar;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/fromValues.js
var require_fromValues3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/fromValues.js"(exports, module) {
    var create = require_create4();
    var fromValues = (x, y) => {
      const out = create();
      out[0] = x;
      out[1] = y;
      return out;
    };
    module.exports = fromValues;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/length.js
var require_length2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/length.js"(exports, module) {
    var length = (vector) => Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1]);
    module.exports = length;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/lerp.js
var require_lerp2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/lerp.js"(exports, module) {
    var lerp2 = (out, a, b, t) => {
      const ax = a[0];
      const ay = a[1];
      out[0] = ax + t * (b[0] - ax);
      out[1] = ay + t * (b[1] - ay);
      return out;
    };
    module.exports = lerp2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/max.js
var require_max2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/max.js"(exports, module) {
    var max = (out, a, b) => {
      out[0] = Math.max(a[0], b[0]);
      out[1] = Math.max(a[1], b[1]);
      return out;
    };
    module.exports = max;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/min.js
var require_min2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/min.js"(exports, module) {
    var min = (out, a, b) => {
      out[0] = Math.min(a[0], b[0]);
      out[1] = Math.min(a[1], b[1]);
      return out;
    };
    module.exports = min;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/multiply.js
var require_multiply3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/multiply.js"(exports, module) {
    var multiply = (out, a, b) => {
      out[0] = a[0] * b[0];
      out[1] = a[1] * b[1];
      return out;
    };
    module.exports = multiply;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/negate.js
var require_negate2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/negate.js"(exports, module) {
    var negate = (out, vector) => {
      out[0] = -vector[0];
      out[1] = -vector[1];
      return out;
    };
    module.exports = negate;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/rotate.js
var require_rotate2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/rotate.js"(exports, module) {
    var rotate = (out, vector, origin, radians) => {
      const x = vector[0] - origin[0];
      const y = vector[1] - origin[1];
      const c = Math.cos(radians);
      const s = Math.sin(radians);
      out[0] = x * c - y * s + origin[0];
      out[1] = x * s + y * c + origin[1];
      return out;
    };
    module.exports = rotate;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/normal.js
var require_normal = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/normal.js"(exports, module) {
    var { TAU } = require_constants();
    var create = require_create4();
    var rotate = require_rotate2();
    var normal = (out, vector) => rotate(out, vector, create(), TAU / 4);
    module.exports = normal;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/normalize.js
var require_normalize2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/normalize.js"(exports, module) {
    var normalize2 = (out, vector) => {
      const x = vector[0];
      const y = vector[1];
      let len = x * x + y * y;
      if (len > 0) {
        len = 1 / Math.sqrt(len);
      }
      out[0] = x * len;
      out[1] = y * len;
      return out;
    };
    module.exports = normalize2;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/scale.js
var require_scale3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/scale.js"(exports, module) {
    var scale = (out, vector, amount) => {
      out[0] = vector[0] * amount;
      out[1] = vector[1] * amount;
      return out;
    };
    module.exports = scale;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/snap.js
var require_snap2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/snap.js"(exports, module) {
    var snap = (out, vector, epsilon) => {
      out[0] = Math.round(vector[0] / epsilon) * epsilon + 0;
      out[1] = Math.round(vector[1] / epsilon) * epsilon + 0;
      return out;
    };
    module.exports = snap;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/squaredDistance.js
var require_squaredDistance2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/squaredDistance.js"(exports, module) {
    var squaredDistance = (a, b) => {
      const x = b[0] - a[0];
      const y = b[1] - a[1];
      return x * x + y * y;
    };
    module.exports = squaredDistance;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/squaredLength.js
var require_squaredLength2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/squaredLength.js"(exports, module) {
    var squaredLength = (vector) => {
      const x = vector[0];
      const y = vector[1];
      return x * x + y * y;
    };
    module.exports = squaredLength;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/subtract.js
var require_subtract3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/subtract.js"(exports, module) {
    var subtract = (out, a, b) => {
      out[0] = a[0] - b[0];
      out[1] = a[1] - b[1];
      return out;
    };
    module.exports = subtract;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/toString.js
var require_toString3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/toString.js"(exports, module) {
    var toString = (vector) => `[${vector[0].toFixed(7)}, ${vector[1].toFixed(7)}]`;
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/transform.js
var require_transform2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/transform.js"(exports, module) {
    var transform = (out, vector, matrix) => {
      const x = vector[0];
      const y = vector[1];
      out[0] = matrix[0] * x + matrix[4] * y + matrix[12];
      out[1] = matrix[1] * x + matrix[5] * y + matrix[13];
      return out;
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/maths/vec2/index.js
var require_vec2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec2/index.js"(exports, module) {
    module.exports = {
      abs: require_abs2(),
      add: require_add3(),
      angle: require_angle2(),
      angleDegrees: require_angleDegrees(),
      angleRadians: require_angleRadians(),
      clone: require_clone4(),
      copy: require_copy3(),
      create: require_create4(),
      cross: require_cross2(),
      distance: require_distance2(),
      divide: require_divide2(),
      dot: require_dot2(),
      equals: require_equals3(),
      fromAngleDegrees: require_fromAngleDegrees(),
      fromAngleRadians: require_fromAngleRadians(),
      fromScalar: require_fromScalar2(),
      fromValues: require_fromValues3(),
      length: require_length2(),
      lerp: require_lerp2(),
      max: require_max2(),
      min: require_min2(),
      multiply: require_multiply3(),
      negate: require_negate2(),
      normal: require_normal(),
      normalize: require_normalize2(),
      rotate: require_rotate2(),
      scale: require_scale3(),
      snap: require_snap2(),
      squaredDistance: require_squaredDistance2(),
      squaredLength: require_squaredLength2(),
      subtract: require_subtract3(),
      toString: require_toString3(),
      transform: require_transform2()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/fromPoints.js
var require_fromPoints = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/fromPoints.js"(exports, module) {
    var vec2 = require_vec2();
    var create = require_create3();
    var fromPoints = (points) => {
      if (!Array.isArray(points)) {
        throw new Error("the given points must be an array");
      }
      let length = points.length;
      if (length < 3) {
        throw new Error("the given points must define a closed geometry with three or more points");
      }
      if (vec2.equals(points[0], points[length - 1]))
        --length;
      const sides = [];
      let prevpoint = points[length - 1];
      for (let i = 0; i < length; i++) {
        const point = points[i];
        sides.push([vec2.clone(prevpoint), vec2.clone(point)]);
        prevpoint = point;
      }
      return create(sides);
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/fromCompactBinary.js
var require_fromCompactBinary = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/fromCompactBinary.js"(exports, module) {
    var mat4 = require_mat4();
    var vec2 = require_vec2();
    var create = require_create3();
    var fromCompactBinary = (data) => {
      if (data[0] !== 0)
        throw new Error("invalid compact binary data");
      const created = create();
      created.transforms = mat4.clone(data.slice(1, 17));
      for (let i = 21; i < data.length; i += 4) {
        const point0 = vec2.fromValues(data[i + 0], data[i + 1]);
        const point1 = vec2.fromValues(data[i + 2], data[i + 3]);
        created.sides.push([point0, point1]);
      }
      if (data[17] >= 0) {
        created.color = [data[17], data[18], data[19], data[20]];
      }
      return created;
    };
    module.exports = fromCompactBinary;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/isA.js
var require_isA = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/isA.js"(exports, module) {
    var isA = (object) => {
      if (object && typeof object === "object") {
        if ("sides" in object && "transforms" in object) {
          if (Array.isArray(object.sides) && "length" in object.transforms) {
            return true;
          }
        }
      }
      return false;
    };
    module.exports = isA;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/applyTransforms.js
var require_applyTransforms = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/applyTransforms.js"(exports, module) {
    var mat4 = require_mat4();
    var vec2 = require_vec2();
    var applyTransforms = (geometry) => {
      if (mat4.isIdentity(geometry.transforms))
        return geometry;
      geometry.sides = geometry.sides.map((side) => {
        const p0 = vec2.transform(vec2.create(), side[0], geometry.transforms);
        const p1 = vec2.transform(vec2.create(), side[1], geometry.transforms);
        return [p0, p1];
      });
      geometry.transforms = mat4.create();
      return geometry;
    };
    module.exports = applyTransforms;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/toSides.js
var require_toSides = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/toSides.js"(exports, module) {
    var applyTransforms = require_applyTransforms();
    var toSides = (geometry) => applyTransforms(geometry).sides;
    module.exports = toSides;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/reverse.js
var require_reverse = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/reverse.js"(exports, module) {
    var create = require_create3();
    var toSides = require_toSides();
    var reverse = (geometry) => {
      const oldsides = toSides(geometry);
      const newsides = oldsides.map((side) => [side[1], side[0]]);
      newsides.reverse();
      return create(newsides);
    };
    module.exports = reverse;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/toOutlines.js
var require_toOutlines = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/toOutlines.js"(exports, module) {
    var vec2 = require_vec2();
    var toSides = require_toSides();
    var toSharedVertices = (sides) => {
      const unique = /* @__PURE__ */ new Map();
      const getUniqueVertex = (vertex2) => {
        const key = vertex2.toString();
        if (unique.has(key)) {
          return unique.get(key);
        } else {
          unique.set(key, vertex2);
          return vertex2;
        }
      };
      return sides.map((side) => side.map(getUniqueVertex));
    };
    var toVertexMap = (sides) => {
      const vertexMap = /* @__PURE__ */ new Map();
      const edges = toSharedVertices(sides);
      edges.forEach((edge) => {
        if (vertexMap.has(edge[0])) {
          vertexMap.get(edge[0]).push(edge);
        } else {
          vertexMap.set(edge[0], [edge]);
        }
      });
      return vertexMap;
    };
    var toOutlines = (geometry) => {
      const vertexMap = toVertexMap(toSides(geometry));
      const outlines = [];
      while (true) {
        let startSide;
        for (const [vertex2, edges] of vertexMap) {
          startSide = edges.shift();
          if (!startSide) {
            vertexMap.delete(vertex2);
            continue;
          }
          break;
        }
        if (startSide === void 0)
          break;
        const connectedVertexPoints = [];
        const startVertex = startSide[0];
        while (true) {
          connectedVertexPoints.push(startSide[0]);
          const nextVertex = startSide[1];
          if (nextVertex === startVertex)
            break;
          const nextPossibleSides = vertexMap.get(nextVertex);
          if (!nextPossibleSides) {
            throw new Error(`geometry is not closed at vertex ${nextVertex}`);
          }
          const nextSide = popNextSide(startSide, nextPossibleSides);
          if (nextPossibleSides.length === 0) {
            vertexMap.delete(nextVertex);
          }
          startSide = nextSide;
        }
        if (connectedVertexPoints.length > 0) {
          connectedVertexPoints.push(connectedVertexPoints.shift());
        }
        outlines.push(connectedVertexPoints);
      }
      vertexMap.clear();
      return outlines;
    };
    var popNextSide = (startSide, nextSides) => {
      if (nextSides.length === 1) {
        return nextSides.pop();
      }
      const v0 = vec2.create();
      const startAngle = vec2.angleDegrees(vec2.subtract(v0, startSide[1], startSide[0]));
      let bestAngle;
      let bestIndex;
      nextSides.forEach((nextSide2, index) => {
        const nextAngle = vec2.angleDegrees(vec2.subtract(v0, nextSide2[1], nextSide2[0]));
        let angle = nextAngle - startAngle;
        if (angle < -180)
          angle += 360;
        if (angle >= 180)
          angle -= 360;
        if (bestIndex === void 0 || angle > bestAngle) {
          bestIndex = index;
          bestAngle = angle;
        }
      });
      const nextSide = nextSides[bestIndex];
      nextSides.splice(bestIndex, 1);
      return nextSide;
    };
    module.exports = toOutlines;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/toPoints.js
var require_toPoints = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/toPoints.js"(exports, module) {
    var toSides = require_toSides();
    var toPoints = (geometry) => {
      const sides = toSides(geometry);
      const points = sides.map((side) => side[0]);
      if (points.length > 0) {
        points.push(points.shift());
      }
      return points;
    };
    module.exports = toPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/toString.js
var require_toString4 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/toString.js"(exports, module) {
    var vec2 = require_vec2();
    var toSides = require_toSides();
    var toString = (geometry) => {
      const sides = toSides(geometry);
      let result = "geom2 (" + sides.length + " sides):\n[\n";
      sides.forEach((side) => {
        result += "  [" + vec2.toString(side[0]) + ", " + vec2.toString(side[1]) + "]\n";
      });
      result += "]\n";
      return result;
    };
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/toCompactBinary.js
var require_toCompactBinary = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/toCompactBinary.js"(exports, module) {
    var toCompactBinary = (geometry) => {
      const sides = geometry.sides;
      const transforms = geometry.transforms;
      let color = [-1, -1, -1, -1];
      if (geometry.color)
        color = geometry.color;
      const compacted = new Float32Array(1 + 16 + 4 + sides.length * 4);
      compacted[0] = 0;
      compacted[1] = transforms[0];
      compacted[2] = transforms[1];
      compacted[3] = transforms[2];
      compacted[4] = transforms[3];
      compacted[5] = transforms[4];
      compacted[6] = transforms[5];
      compacted[7] = transforms[6];
      compacted[8] = transforms[7];
      compacted[9] = transforms[8];
      compacted[10] = transforms[9];
      compacted[11] = transforms[10];
      compacted[12] = transforms[11];
      compacted[13] = transforms[12];
      compacted[14] = transforms[13];
      compacted[15] = transforms[14];
      compacted[16] = transforms[15];
      compacted[17] = color[0];
      compacted[18] = color[1];
      compacted[19] = color[2];
      compacted[20] = color[3];
      for (let i = 0; i < sides.length; i++) {
        const ci = i * 4 + 21;
        const point0 = sides[i][0];
        const point1 = sides[i][1];
        compacted[ci + 0] = point0[0];
        compacted[ci + 1] = point0[1];
        compacted[ci + 2] = point1[0];
        compacted[ci + 3] = point1[1];
      }
      return compacted;
    };
    module.exports = toCompactBinary;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/transform.js
var require_transform3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/transform.js"(exports, module) {
    var mat4 = require_mat4();
    var transform = (matrix, geometry) => {
      const transforms = mat4.multiply(mat4.create(), matrix, geometry.transforms);
      return Object.assign({}, geometry, { transforms });
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/validate.js
var require_validate = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/validate.js"(exports, module) {
    var vec2 = require_vec2();
    var isA = require_isA();
    var toOutlines = require_toOutlines();
    var validate = (object) => {
      if (!isA(object)) {
        throw new Error("invalid geom2 structure");
      }
      toOutlines(object);
      object.sides.forEach((side) => {
        if (vec2.equals(side[0], side[1])) {
          throw new Error(`geom2 self-edge ${side[0]}`);
        }
      });
      if (!object.transforms.every(Number.isFinite)) {
        throw new Error(`geom2 invalid transforms ${object.transforms}`);
      }
    };
    module.exports = validate;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom2/index.js
var require_geom2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom2/index.js"(exports, module) {
    module.exports = {
      clone: require_clone(),
      create: require_create3(),
      fromPoints: require_fromPoints(),
      fromCompactBinary: require_fromCompactBinary(),
      isA: require_isA(),
      reverse: require_reverse(),
      toOutlines: require_toOutlines(),
      toPoints: require_toPoints(),
      toSides: require_toSides(),
      toString: require_toString4(),
      toCompactBinary: require_toCompactBinary(),
      transform: require_transform3(),
      validate: require_validate()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/clone.js
var require_clone5 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/clone.js"(exports, module) {
    var clone = (geometry) => Object.assign({}, geometry);
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/create.js
var require_create5 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/create.js"(exports, module) {
    var mat4 = require_mat4();
    var create = (polygons) => {
      if (polygons === void 0) {
        polygons = [];
      }
      return {
        polygons,
        transforms: mat4.create()
      };
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/create.js
var require_create6 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/create.js"(exports, module) {
    var create = (vertices) => {
      if (vertices === void 0 || vertices.length < 3) {
        vertices = [];
      }
      return { vertices };
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/clone.js
var require_clone6 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/clone.js"(exports, module) {
    var create = require_create6();
    var vec3 = require_vec3();
    var clone = (...params) => {
      let out;
      let poly3;
      if (params.length === 1) {
        out = create();
        poly3 = params[0];
      } else {
        out = params[0];
        poly3 = params[1];
      }
      out.vertices = poly3.vertices.map((vec) => vec3.clone(vec));
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/fromPoints.js
var require_fromPoints2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/fromPoints.js"(exports, module) {
    var vec3 = require_vec3();
    var create = require_create6();
    var fromPoints = (points) => {
      const vertices = points.map((point) => vec3.clone(point));
      return create(vertices);
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/fromPointsAndPlane.js
var require_fromPointsAndPlane = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/fromPointsAndPlane.js"(exports, module) {
    var create = require_create6();
    var fromPointsAndPlane = (vertices, plane) => {
      const poly = create(vertices);
      poly.plane = plane;
      return poly;
    };
    module.exports = fromPointsAndPlane;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/create.js
var require_create7 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/create.js"(exports, module) {
    var create = () => [0, 0, 0, 0];
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/clone.js
var require_clone7 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/clone.js"(exports, module) {
    var create = require_create7();
    var clone = (vector) => {
      const out = create();
      out[0] = vector[0];
      out[1] = vector[1];
      out[2] = vector[2];
      out[3] = vector[3];
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/copy.js
var require_copy4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/copy.js"(exports, module) {
    var copy = (out, vector) => {
      out[0] = vector[0];
      out[1] = vector[1];
      out[2] = vector[2];
      out[3] = vector[3];
      return out;
    };
    module.exports = copy;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/equals.js
var require_equals4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/equals.js"(exports, module) {
    var equals2 = (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/flip.js
var require_flip = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/flip.js"(exports, module) {
    var flip = (out, plane) => {
      out[0] = -plane[0];
      out[1] = -plane[1];
      out[2] = -plane[2];
      out[3] = -plane[3];
      return out;
    };
    module.exports = flip;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/fromNormalAndPoint.js
var require_fromNormalAndPoint = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/fromNormalAndPoint.js"(exports, module) {
    var vec3 = require_vec3();
    var fromNormalAndPoint = (out, normal, point) => {
      const u = vec3.normalize(vec3.create(), normal);
      const w = vec3.dot(point, u);
      out[0] = u[0];
      out[1] = u[1];
      out[2] = u[2];
      out[3] = w;
      return out;
    };
    module.exports = fromNormalAndPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/fromValues.js
var require_fromValues4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/fromValues.js"(exports, module) {
    var create = require_create7();
    var fromValues = (x, y, z, w) => {
      const out = create();
      out[0] = x;
      out[1] = y;
      out[2] = z;
      out[3] = w;
      return out;
    };
    module.exports = fromValues;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/fromPoints.js
var require_fromPoints3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/fromPoints.js"(exports, module) {
    var vec3 = require_vec3();
    var fromPoints = (out, ...vertices) => {
      const len = vertices.length;
      const ba = vec3.create();
      const ca = vec3.create();
      const vertexNormal = (index) => {
        const a = vertices[index];
        const b = vertices[(index + 1) % len];
        const c = vertices[(index + 2) % len];
        vec3.subtract(ba, b, a);
        vec3.subtract(ca, c, a);
        vec3.cross(ba, ba, ca);
        vec3.normalize(ba, ba);
        return ba;
      };
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      if (len === 3) {
        vec3.copy(out, vertexNormal(0));
      } else {
        vertices.forEach((v, i) => {
          vec3.add(out, out, vertexNormal(i));
        });
        vec3.normalize(out, out);
      }
      out[3] = vec3.dot(out, vertices[0]);
      return out;
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/fromPointsRandom.js
var require_fromPointsRandom = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/fromPointsRandom.js"(exports, module) {
    var { EPS } = require_constants();
    var vec3 = require_vec3();
    var fromPointsRandom = (out, a, b, c) => {
      let ba = vec3.subtract(vec3.create(), b, a);
      let ca = vec3.subtract(vec3.create(), c, a);
      if (vec3.length(ba) < EPS) {
        ba = vec3.orthogonal(ba, ca);
      }
      if (vec3.length(ca) < EPS) {
        ca = vec3.orthogonal(ca, ba);
      }
      let normal = vec3.cross(vec3.create(), ba, ca);
      if (vec3.length(normal) < EPS) {
        ca = vec3.orthogonal(ca, ba);
        normal = vec3.cross(normal, ba, ca);
      }
      normal = vec3.normalize(normal, normal);
      const w = vec3.dot(normal, a);
      out[0] = normal[0];
      out[1] = normal[1];
      out[2] = normal[2];
      out[3] = w;
      return out;
    };
    module.exports = fromPointsRandom;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/projectionOfPoint.js
var require_projectionOfPoint = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/projectionOfPoint.js"(exports, module) {
    var vec3 = require_vec3();
    var projectionOfPoint = (plane, point) => {
      const a = point[0] * plane[0] + point[1] * plane[1] + point[2] * plane[2] - plane[3];
      const x = point[0] - a * plane[0];
      const y = point[1] - a * plane[1];
      const z = point[2] - a * plane[2];
      return vec3.fromValues(x, y, z);
    };
    module.exports = projectionOfPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/signedDistanceToPoint.js
var require_signedDistanceToPoint = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/signedDistanceToPoint.js"(exports, module) {
    var vec3 = require_vec3();
    var signedDistanceToPoint = (plane, point) => vec3.dot(plane, point) - plane[3];
    module.exports = signedDistanceToPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/toString.js
var require_toString5 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/toString.js"(exports, module) {
    var toString = (vec) => `(${vec[0].toFixed(9)}, ${vec[1].toFixed(9)}, ${vec[2].toFixed(9)}, ${vec[3].toFixed(9)})`;
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/transform.js
var require_transform4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/transform.js"(exports, module) {
    var mat4 = require_mat4();
    var vec3 = require_vec3();
    var fromPoints = require_fromPoints3();
    var flip = require_flip();
    var transform = (out, plane, matrix) => {
      const ismirror = mat4.isMirroring(matrix);
      const r = vec3.orthogonal(vec3.create(), plane);
      const u = vec3.cross(r, plane, r);
      const v = vec3.cross(vec3.create(), plane, u);
      let point1 = vec3.fromScalar(vec3.create(), plane[3]);
      vec3.multiply(point1, point1, plane);
      let point2 = vec3.add(vec3.create(), point1, u);
      let point3 = vec3.add(vec3.create(), point1, v);
      point1 = vec3.transform(point1, point1, matrix);
      point2 = vec3.transform(point2, point2, matrix);
      point3 = vec3.transform(point3, point3, matrix);
      fromPoints(out, point1, point2, point3);
      if (ismirror) {
        flip(out, out);
      }
      return out;
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/maths/plane/index.js
var require_plane = __commonJS({
  "node_modules/@jscad/modeling/src/maths/plane/index.js"(exports, module) {
    module.exports = {
      /**
       * @see [vec4.clone()]{@link module:modeling/maths/vec4.clone}
       * @function clone
       */
      clone: require_clone7(),
      /**
       * @see [vec4.copy()]{@link module:modeling/maths/vec4.copy}
       * @function copy
       */
      copy: require_copy4(),
      /**
       * @see [vec4.create()]{@link module:modeling/maths/vec4.create}
       * @function create
       */
      create: require_create7(),
      /**
       * @see [vec4.equals()]{@link module:modeling/maths/vec4.equals}
       * @function equals
       */
      equals: require_equals4(),
      flip: require_flip(),
      fromNormalAndPoint: require_fromNormalAndPoint(),
      /**
       * @see [vec4.fromValues()]{@link module:modeling/maths/vec4.fromValues}
       * @function fromValues
       */
      fromValues: require_fromValues4(),
      fromPoints: require_fromPoints3(),
      fromPointsRandom: require_fromPointsRandom(),
      projectionOfPoint: require_projectionOfPoint(),
      signedDistanceToPoint: require_signedDistanceToPoint(),
      /**
       * @see [vec4.toString()]{@link module:modeling/maths/vec4.toString}
       * @function toString
       */
      toString: require_toString5(),
      transform: require_transform4()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/invert.js
var require_invert2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/invert.js"(exports, module) {
    var plane = require_plane();
    var create = require_create6();
    var invert = (polygon) => {
      const vertices = polygon.vertices.slice().reverse();
      const inverted = create(vertices);
      if (polygon.plane) {
        inverted.plane = plane.flip(plane.create(), polygon.plane);
      }
      return inverted;
    };
    module.exports = invert;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/isA.js
var require_isA2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/isA.js"(exports, module) {
    var isA = (object) => {
      if (object && typeof object === "object") {
        if ("vertices" in object) {
          if (Array.isArray(object.vertices)) {
            return true;
          }
        }
      }
      return false;
    };
    module.exports = isA;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/isConvex.js
var require_isConvex = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/isConvex.js"(exports, module) {
    var plane = require_plane();
    var vec3 = require_vec3();
    var isConvex = (polygon) => areVerticesConvex(polygon.vertices);
    var areVerticesConvex = (vertices) => {
      const numvertices = vertices.length;
      if (numvertices > 2) {
        const normal = plane.fromPoints(plane.create(), ...vertices);
        let prevprevpos = vertices[numvertices - 2];
        let prevpos = vertices[numvertices - 1];
        for (let i = 0; i < numvertices; i++) {
          const pos = vertices[i];
          if (!isConvexPoint(prevprevpos, prevpos, pos, normal)) {
            return false;
          }
          prevprevpos = prevpos;
          prevpos = pos;
        }
      }
      return true;
    };
    var isConvexPoint = (prevpoint, point, nextpoint, normal) => {
      const crossproduct = vec3.cross(
        vec3.create(),
        vec3.subtract(vec3.create(), point, prevpoint),
        vec3.subtract(vec3.create(), nextpoint, point)
      );
      const crossdotnormal = vec3.dot(crossproduct, normal);
      return crossdotnormal >= 0;
    };
    module.exports = isConvex;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/plane.js
var require_plane2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/plane.js"(exports, module) {
    var mplane = require_plane();
    var plane = (polygon) => {
      if (!polygon.plane) {
        polygon.plane = mplane.fromPoints(mplane.create(), ...polygon.vertices);
      }
      return polygon.plane;
    };
    module.exports = plane;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/measureArea.js
var require_measureArea = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/measureArea.js"(exports, module) {
    var plane = require_plane2();
    var measureArea = (polygon) => {
      const n = polygon.vertices.length;
      if (n < 3) {
        return 0;
      }
      const vertices = polygon.vertices;
      const normal = plane(polygon);
      const ax = Math.abs(normal[0]);
      const ay = Math.abs(normal[1]);
      const az = Math.abs(normal[2]);
      if (ax + ay + az === 0) {
        return 0;
      }
      let coord = 3;
      if (ax > ay && ax > az) {
        coord = 1;
      } else if (ay > az) {
        coord = 2;
      }
      let area2 = 0;
      let h = 0;
      let i = 1;
      let j = 2;
      switch (coord) {
        case 1:
          for (i = 1; i < n; i++) {
            h = i - 1;
            j = (i + 1) % n;
            area2 += vertices[i][1] * (vertices[j][2] - vertices[h][2]);
          }
          area2 += vertices[0][1] * (vertices[1][2] - vertices[n - 1][2]);
          area2 /= 2 * normal[0];
          break;
        case 2:
          for (i = 1; i < n; i++) {
            h = i - 1;
            j = (i + 1) % n;
            area2 += vertices[i][2] * (vertices[j][0] - vertices[h][0]);
          }
          area2 += vertices[0][2] * (vertices[1][0] - vertices[n - 1][0]);
          area2 /= 2 * normal[1];
          break;
        case 3:
        default:
          for (i = 1; i < n; i++) {
            h = i - 1;
            j = (i + 1) % n;
            area2 += vertices[i][0] * (vertices[j][1] - vertices[h][1]);
          }
          area2 += vertices[0][0] * (vertices[1][1] - vertices[n - 1][1]);
          area2 /= 2 * normal[2];
          break;
      }
      return area2;
    };
    module.exports = measureArea;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/measureBoundingBox.js
var require_measureBoundingBox = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/measureBoundingBox.js"(exports, module) {
    var vec3 = require_vec3();
    var measureBoundingBox = (polygon) => {
      const vertices = polygon.vertices;
      const numvertices = vertices.length;
      const min = numvertices === 0 ? vec3.create() : vec3.clone(vertices[0]);
      const max = vec3.clone(min);
      for (let i = 1; i < numvertices; i++) {
        vec3.min(min, min, vertices[i]);
        vec3.max(max, max, vertices[i]);
      }
      return [min, max];
    };
    module.exports = measureBoundingBox;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/dot.js
var require_dot3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/dot.js"(exports, module) {
    var dot = (a, b) => a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    module.exports = dot;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/fromScalar.js
var require_fromScalar3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/fromScalar.js"(exports, module) {
    var fromScalar = (out, scalar) => {
      out[0] = scalar;
      out[1] = scalar;
      out[2] = scalar;
      out[3] = scalar;
      return out;
    };
    module.exports = fromScalar;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/transform.js
var require_transform5 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/transform.js"(exports, module) {
    var transform = (out, vector, matrix) => {
      const [x, y, z, w] = vector;
      out[0] = matrix[0] * x + matrix[4] * y + matrix[8] * z + matrix[12] * w;
      out[1] = matrix[1] * x + matrix[5] * y + matrix[9] * z + matrix[13] * w;
      out[2] = matrix[2] * x + matrix[6] * y + matrix[10] * z + matrix[14] * w;
      out[3] = matrix[3] * x + matrix[7] * y + matrix[11] * z + matrix[15] * w;
      return out;
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/maths/vec4/index.js
var require_vec4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/vec4/index.js"(exports, module) {
    module.exports = {
      clone: require_clone7(),
      copy: require_copy4(),
      create: require_create7(),
      dot: require_dot3(),
      equals: require_equals4(),
      fromScalar: require_fromScalar3(),
      fromValues: require_fromValues4(),
      toString: require_toString5(),
      transform: require_transform5()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/measureBoundingSphere.js
var require_measureBoundingSphere = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/measureBoundingSphere.js"(exports, module) {
    var vec3 = require_vec3();
    var vec4 = require_vec4();
    var cache = /* @__PURE__ */ new WeakMap();
    var measureBoundingSphere = (polygon) => {
      let boundingSphere = cache.get(polygon);
      if (boundingSphere)
        return boundingSphere;
      const vertices = polygon.vertices;
      const out = vec4.create();
      if (vertices.length === 0) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 0;
        return out;
      }
      let minx = vertices[0];
      let miny = minx;
      let minz = minx;
      let maxx = minx;
      let maxy = minx;
      let maxz = minx;
      vertices.forEach((v) => {
        if (minx[0] > v[0])
          minx = v;
        if (miny[1] > v[1])
          miny = v;
        if (minz[2] > v[2])
          minz = v;
        if (maxx[0] < v[0])
          maxx = v;
        if (maxy[1] < v[1])
          maxy = v;
        if (maxz[2] < v[2])
          maxz = v;
      });
      out[0] = (minx[0] + maxx[0]) * 0.5;
      out[1] = (miny[1] + maxy[1]) * 0.5;
      out[2] = (minz[2] + maxz[2]) * 0.5;
      const x = out[0] - maxx[0];
      const y = out[1] - maxy[1];
      const z = out[2] - maxz[2];
      out[3] = Math.sqrt(x * x + y * y + z * z);
      cache.set(polygon, out);
      return out;
    };
    module.exports = measureBoundingSphere;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/measureSignedVolume.js
var require_measureSignedVolume = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/measureSignedVolume.js"(exports, module) {
    var vec3 = require_vec3();
    var measureSignedVolume = (polygon) => {
      let signedVolume = 0;
      const vertices = polygon.vertices;
      const cross = vec3.create();
      for (let i = 0; i < vertices.length - 2; i++) {
        vec3.cross(cross, vertices[i + 1], vertices[i + 2]);
        signedVolume += vec3.dot(vertices[0], cross);
      }
      signedVolume /= 6;
      return signedVolume;
    };
    module.exports = measureSignedVolume;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/toPoints.js
var require_toPoints2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/toPoints.js"(exports, module) {
    var toPoints = (polygon) => polygon.vertices;
    module.exports = toPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/toString.js
var require_toString6 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/toString.js"(exports, module) {
    var vec3 = require_vec3();
    var toString = (polygon) => {
      let result = "poly3: vertices: [";
      polygon.vertices.forEach((vertex2) => {
        result += `${vec3.toString(vertex2)}, `;
      });
      result += "]";
      return result;
    };
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/transform.js
var require_transform6 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/transform.js"(exports, module) {
    var mat4 = require_mat4();
    var vec3 = require_vec3();
    var create = require_create6();
    var transform = (matrix, polygon) => {
      const vertices = polygon.vertices.map((vertex2) => vec3.transform(vec3.create(), vertex2, matrix));
      if (mat4.isMirroring(matrix)) {
        vertices.reverse();
      }
      return create(vertices);
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/validate.js
var require_validate2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/validate.js"(exports, module) {
    var signedDistanceToPoint = require_signedDistanceToPoint();
    var { NEPS } = require_constants();
    var vec3 = require_vec3();
    var isA = require_isA2();
    var isConvex = require_isConvex();
    var measureArea = require_measureArea();
    var plane = require_plane2();
    var validate = (object) => {
      if (!isA(object)) {
        throw new Error("invalid poly3 structure");
      }
      if (object.vertices.length < 3) {
        throw new Error(`poly3 not enough vertices ${object.vertices.length}`);
      }
      if (measureArea(object) <= 0) {
        throw new Error("poly3 area must be greater than zero");
      }
      for (let i = 0; i < object.vertices.length; i++) {
        if (vec3.equals(object.vertices[i], object.vertices[(i + 1) % object.vertices.length])) {
          throw new Error(`poly3 duplicate vertex ${object.vertices[i]}`);
        }
      }
      if (!isConvex(object)) {
        throw new Error("poly3 must be convex");
      }
      object.vertices.forEach((vertex2) => {
        if (!vertex2.every(Number.isFinite)) {
          throw new Error(`poly3 invalid vertex ${vertex2}`);
        }
      });
      if (object.vertices.length > 3) {
        const normal = plane(object);
        object.vertices.forEach((vertex2) => {
          const dist = Math.abs(signedDistanceToPoint(normal, vertex2));
          if (dist > NEPS) {
            throw new Error(`poly3 must be coplanar: vertex ${vertex2} distance ${dist}`);
          }
        });
      }
    };
    module.exports = validate;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly3/index.js
var require_poly3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly3/index.js"(exports, module) {
    module.exports = {
      clone: require_clone6(),
      create: require_create6(),
      fromPoints: require_fromPoints2(),
      fromPointsAndPlane: require_fromPointsAndPlane(),
      invert: require_invert2(),
      isA: require_isA2(),
      isConvex: require_isConvex(),
      measureArea: require_measureArea(),
      measureBoundingBox: require_measureBoundingBox(),
      measureBoundingSphere: require_measureBoundingSphere(),
      measureSignedVolume: require_measureSignedVolume(),
      plane: require_plane2(),
      toPoints: require_toPoints2(),
      toString: require_toString6(),
      transform: require_transform6(),
      validate: require_validate2()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/fromPoints.js
var require_fromPoints4 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/fromPoints.js"(exports, module) {
    var poly3 = require_poly3();
    var create = require_create5();
    var fromPoints = (listofpoints) => {
      if (!Array.isArray(listofpoints)) {
        throw new Error("the given points must be an array");
      }
      const polygons = listofpoints.map((points, index) => {
        const polygon = poly3.create(points);
        return polygon;
      });
      const result = create(polygons);
      return result;
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/fromCompactBinary.js
var require_fromCompactBinary2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/fromCompactBinary.js"(exports, module) {
    var vec3 = require_vec3();
    var mat4 = require_mat4();
    var poly3 = require_poly3();
    var create = require_create5();
    var fromCompactBinary = (data) => {
      if (data[0] !== 1)
        throw new Error("invalid compact binary data");
      const created = create();
      created.transforms = mat4.clone(data.slice(1, 17));
      const numberOfVertices = data[21];
      let ci = 22;
      let vi = data.length - numberOfVertices * 3;
      while (vi < data.length) {
        const verticesPerPolygon = data[ci];
        ci++;
        const vertices = [];
        for (let i = 0; i < verticesPerPolygon; i++) {
          vertices.push(vec3.fromValues(data[vi], data[vi + 1], data[vi + 2]));
          vi += 3;
        }
        created.polygons.push(poly3.create(vertices));
      }
      if (data[17] >= 0) {
        created.color = [data[17], data[18], data[19], data[20]];
      }
      return created;
    };
    module.exports = fromCompactBinary;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/applyTransforms.js
var require_applyTransforms2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/applyTransforms.js"(exports, module) {
    var mat4 = require_mat4();
    var poly3 = require_poly3();
    var applyTransforms = (geometry) => {
      if (mat4.isIdentity(geometry.transforms))
        return geometry;
      geometry.polygons = geometry.polygons.map((polygon) => poly3.transform(geometry.transforms, polygon));
      geometry.transforms = mat4.create();
      return geometry;
    };
    module.exports = applyTransforms;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/toPolygons.js
var require_toPolygons = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/toPolygons.js"(exports, module) {
    var applyTransforms = require_applyTransforms2();
    var toPolygons = (geometry) => applyTransforms(geometry).polygons;
    module.exports = toPolygons;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/invert.js
var require_invert3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/invert.js"(exports, module) {
    var poly3 = require_poly3();
    var create = require_create5();
    var toPolygons = require_toPolygons();
    var invert = (geometry) => {
      const polygons = toPolygons(geometry);
      const newpolygons = polygons.map((polygon) => poly3.invert(polygon));
      return create(newpolygons);
    };
    module.exports = invert;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/isA.js
var require_isA3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/isA.js"(exports, module) {
    var isA = (object) => {
      if (object && typeof object === "object") {
        if ("polygons" in object && "transforms" in object) {
          if (Array.isArray(object.polygons) && "length" in object.transforms) {
            return true;
          }
        }
      }
      return false;
    };
    module.exports = isA;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/toPoints.js
var require_toPoints3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/toPoints.js"(exports, module) {
    var poly3 = require_poly3();
    var toPolygons = require_toPolygons();
    var toPoints = (geometry) => {
      const polygons = toPolygons(geometry);
      const listofpoints = polygons.map((polygon) => poly3.toPoints(polygon));
      return listofpoints;
    };
    module.exports = toPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/toString.js
var require_toString7 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/toString.js"(exports, module) {
    var poly3 = require_poly3();
    var toPolygons = require_toPolygons();
    var toString = (geometry) => {
      const polygons = toPolygons(geometry);
      let result = "geom3 (" + polygons.length + " polygons):\n";
      polygons.forEach((polygon) => {
        result += "  " + poly3.toString(polygon) + "\n";
      });
      return result;
    };
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/toCompactBinary.js
var require_toCompactBinary2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/toCompactBinary.js"(exports, module) {
    var poly3 = require_poly3();
    var toCompactBinary = (geometry) => {
      const polygons = geometry.polygons;
      const transforms = geometry.transforms;
      const numberOfPolygons = polygons.length;
      const numberOfVertices = polygons.reduce((count, polygon) => count + polygon.vertices.length, 0);
      let color = [-1, -1, -1, -1];
      if (geometry.color)
        color = geometry.color;
      const compacted = new Float32Array(1 + 16 + 4 + 1 + numberOfPolygons + numberOfVertices * 3);
      compacted[0] = 1;
      compacted[1] = transforms[0];
      compacted[2] = transforms[1];
      compacted[3] = transforms[2];
      compacted[4] = transforms[3];
      compacted[5] = transforms[4];
      compacted[6] = transforms[5];
      compacted[7] = transforms[6];
      compacted[8] = transforms[7];
      compacted[9] = transforms[8];
      compacted[10] = transforms[9];
      compacted[11] = transforms[10];
      compacted[12] = transforms[11];
      compacted[13] = transforms[12];
      compacted[14] = transforms[13];
      compacted[15] = transforms[14];
      compacted[16] = transforms[15];
      compacted[17] = color[0];
      compacted[18] = color[1];
      compacted[19] = color[2];
      compacted[20] = color[3];
      compacted[21] = numberOfVertices;
      let ci = 22;
      let vi = ci + numberOfPolygons;
      polygons.forEach((polygon) => {
        const points = poly3.toPoints(polygon);
        compacted[ci] = points.length;
        ci++;
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          compacted[vi + 0] = point[0];
          compacted[vi + 1] = point[1];
          compacted[vi + 2] = point[2];
          vi += 3;
        }
      });
      return compacted;
    };
    module.exports = toCompactBinary;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/transform.js
var require_transform7 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/transform.js"(exports, module) {
    var mat4 = require_mat4();
    var transform = (matrix, geometry) => {
      const transforms = mat4.multiply(mat4.create(), matrix, geometry.transforms);
      return Object.assign({}, geometry, { transforms });
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/validate.js
var require_validate3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/validate.js"(exports, module) {
    var poly3 = require_poly3();
    var isA = require_isA3();
    var validate = (object) => {
      if (!isA(object)) {
        throw new Error("invalid geom3 structure");
      }
      object.polygons.forEach(poly3.validate);
      validateManifold(object);
      if (!object.transforms.every(Number.isFinite)) {
        throw new Error(`geom3 invalid transforms ${object.transforms}`);
      }
    };
    var validateManifold = (object) => {
      const edgeCount = /* @__PURE__ */ new Map();
      object.polygons.forEach(({ vertices }) => {
        vertices.forEach((v, i) => {
          const v1 = `${v}`;
          const v2 = `${vertices[(i + 1) % vertices.length]}`;
          const edge = `${v1}/${v2}`;
          const count = edgeCount.has(edge) ? edgeCount.get(edge) : 0;
          edgeCount.set(edge, count + 1);
        });
      });
      const nonManifold = [];
      edgeCount.forEach((count, edge) => {
        const complementEdge = edge.split("/").reverse().join("/");
        const complementCount = edgeCount.get(complementEdge);
        if (count !== complementCount) {
          nonManifold.push(edge.replace("/", " -> "));
        }
      });
      if (nonManifold.length > 0) {
        throw new Error(`non-manifold edges ${nonManifold.length}
${nonManifold.join("\n")}`);
      }
    };
    module.exports = validate;
  }
});

// node_modules/@jscad/modeling/src/geometries/geom3/index.js
var require_geom3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/geom3/index.js"(exports, module) {
    module.exports = {
      clone: require_clone5(),
      create: require_create5(),
      fromPoints: require_fromPoints4(),
      fromCompactBinary: require_fromCompactBinary2(),
      invert: require_invert3(),
      isA: require_isA3(),
      toPoints: require_toPoints3(),
      toPolygons: require_toPolygons(),
      toString: require_toString7(),
      toCompactBinary: require_toCompactBinary2(),
      transform: require_transform7(),
      validate: require_validate3()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/clone.js
var require_clone8 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/clone.js"(exports, module) {
    var clone = (geometry) => Object.assign({}, geometry);
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/close.js
var require_close = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/close.js"(exports, module) {
    var { EPS } = require_constants();
    var vec2 = require_vec2();
    var clone = require_clone8();
    var close = (geometry) => {
      if (geometry.isClosed)
        return geometry;
      const cloned = clone(geometry);
      cloned.isClosed = true;
      if (cloned.points.length > 1) {
        const points = cloned.points;
        const p0 = points[0];
        let pn = points[points.length - 1];
        while (vec2.distance(p0, pn) < EPS * EPS) {
          points.pop();
          if (points.length === 1)
            break;
          pn = points[points.length - 1];
        }
      }
      return cloned;
    };
    module.exports = close;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/create.js
var require_create8 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/create.js"(exports, module) {
    var mat4 = require_mat4();
    var create = (points) => {
      if (points === void 0) {
        points = [];
      }
      return {
        points,
        isClosed: false,
        transforms: mat4.create()
      };
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/fromPoints.js
var require_fromPoints5 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/fromPoints.js"(exports, module) {
    var { EPS } = require_constants();
    var vec2 = require_vec2();
    var close = require_close();
    var create = require_create8();
    var fromPoints = (options, points) => {
      const defaults = { closed: false };
      let { closed } = Object.assign({}, defaults, options);
      let created = create();
      created.points = points.map((point) => vec2.clone(point));
      if (created.points.length > 1) {
        const p0 = created.points[0];
        const pn = created.points[created.points.length - 1];
        if (vec2.distance(p0, pn) < EPS * EPS) {
          closed = true;
        }
      }
      if (closed === true)
        created = close(created);
      return created;
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/applyTransforms.js
var require_applyTransforms3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/applyTransforms.js"(exports, module) {
    var mat4 = require_mat4();
    var vec2 = require_vec2();
    var applyTransforms = (geometry) => {
      if (mat4.isIdentity(geometry.transforms))
        return geometry;
      geometry.points = geometry.points.map((point) => vec2.transform(vec2.create(), point, geometry.transforms));
      geometry.transforms = mat4.create();
      return geometry;
    };
    module.exports = applyTransforms;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/toPoints.js
var require_toPoints4 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/toPoints.js"(exports, module) {
    var applyTransforms = require_applyTransforms3();
    var toPoints = (geometry) => applyTransforms(geometry).points;
    module.exports = toPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/appendArc.js
var require_appendArc = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/appendArc.js"(exports, module) {
    var { TAU } = require_constants();
    var vec2 = require_vec2();
    var fromPoints = require_fromPoints5();
    var toPoints = require_toPoints4();
    var appendArc = (options, geometry) => {
      const defaults = {
        radius: [0, 0],
        // X and Y radius
        xaxisrotation: 0,
        clockwise: false,
        large: false,
        segments: 16
      };
      let { endpoint, radius, xaxisrotation, clockwise, large, segments } = Object.assign({}, defaults, options);
      if (!Array.isArray(endpoint))
        throw new Error("endpoint must be an array of X and Y values");
      if (endpoint.length < 2)
        throw new Error("endpoint must contain X and Y values");
      endpoint = vec2.clone(endpoint);
      if (!Array.isArray(radius))
        throw new Error("radius must be an array of X and Y values");
      if (radius.length < 2)
        throw new Error("radius must contain X and Y values");
      if (segments < 4)
        throw new Error("segments must be four or more");
      const decimals = 1e5;
      if (geometry.isClosed) {
        throw new Error("the given path cannot be closed");
      }
      const points = toPoints(geometry);
      if (points.length < 1) {
        throw new Error("the given path must contain one or more points (as the starting point for the arc)");
      }
      let xradius = radius[0];
      let yradius = radius[1];
      const startpoint = points[points.length - 1];
      xradius = Math.round(xradius * decimals) / decimals;
      yradius = Math.round(yradius * decimals) / decimals;
      endpoint = vec2.fromValues(Math.round(endpoint[0] * decimals) / decimals, Math.round(endpoint[1] * decimals) / decimals);
      const sweepFlag = !clockwise;
      let newpoints = [];
      if (xradius === 0 || yradius === 0) {
        newpoints.push(endpoint);
      } else {
        xradius = Math.abs(xradius);
        yradius = Math.abs(yradius);
        const phi = xaxisrotation;
        const cosphi = Math.cos(phi);
        const sinphi = Math.sin(phi);
        const minushalfdistance = vec2.subtract(vec2.create(), startpoint, endpoint);
        vec2.scale(minushalfdistance, minushalfdistance, 0.5);
        const x = Math.round((cosphi * minushalfdistance[0] + sinphi * minushalfdistance[1]) * decimals) / decimals;
        const y = Math.round((-sinphi * minushalfdistance[0] + cosphi * minushalfdistance[1]) * decimals) / decimals;
        const startTranslated = vec2.fromValues(x, y);
        const biglambda = startTranslated[0] * startTranslated[0] / (xradius * xradius) + startTranslated[1] * startTranslated[1] / (yradius * yradius);
        if (biglambda > 1) {
          const sqrtbiglambda = Math.sqrt(biglambda);
          xradius *= sqrtbiglambda;
          yradius *= sqrtbiglambda;
          xradius = Math.round(xradius * decimals) / decimals;
          yradius = Math.round(yradius * decimals) / decimals;
        }
        let multiplier1 = Math.sqrt((xradius * xradius * yradius * yradius - xradius * xradius * startTranslated[1] * startTranslated[1] - yradius * yradius * startTranslated[0] * startTranslated[0]) / (xradius * xradius * startTranslated[1] * startTranslated[1] + yradius * yradius * startTranslated[0] * startTranslated[0]));
        if (sweepFlag === large)
          multiplier1 = -multiplier1;
        const centerTranslated = vec2.fromValues(xradius * startTranslated[1] / yradius, -yradius * startTranslated[0] / xradius);
        vec2.scale(centerTranslated, centerTranslated, multiplier1);
        let center = vec2.fromValues(cosphi * centerTranslated[0] - sinphi * centerTranslated[1], sinphi * centerTranslated[0] + cosphi * centerTranslated[1]);
        center = vec2.add(center, center, vec2.scale(vec2.create(), vec2.add(vec2.create(), startpoint, endpoint), 0.5));
        const vector1 = vec2.fromValues((startTranslated[0] - centerTranslated[0]) / xradius, (startTranslated[1] - centerTranslated[1]) / yradius);
        const vector2 = vec2.fromValues((-startTranslated[0] - centerTranslated[0]) / xradius, (-startTranslated[1] - centerTranslated[1]) / yradius);
        const theta1 = vec2.angleRadians(vector1);
        const theta2 = vec2.angleRadians(vector2);
        let deltatheta = theta2 - theta1;
        deltatheta = deltatheta % TAU;
        if (!sweepFlag && deltatheta > 0) {
          deltatheta -= TAU;
        } else if (sweepFlag && deltatheta < 0) {
          deltatheta += TAU;
        }
        let numsteps = Math.ceil(Math.abs(deltatheta) / TAU * segments) + 1;
        if (numsteps < 1)
          numsteps = 1;
        for (let step = 1; step < numsteps; step++) {
          const theta = theta1 + step / numsteps * deltatheta;
          const costheta = Math.cos(theta);
          const sintheta = Math.sin(theta);
          const point = vec2.fromValues(cosphi * xradius * costheta - sinphi * yradius * sintheta, sinphi * xradius * costheta + cosphi * yradius * sintheta);
          vec2.add(point, point, center);
          newpoints.push(point);
        }
        if (numsteps)
          newpoints.push(options.endpoint);
      }
      newpoints = points.concat(newpoints);
      const result = fromPoints({}, newpoints);
      return result;
    };
    module.exports = appendArc;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/concat.js
var require_concat = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/concat.js"(exports, module) {
    var fromPoints = require_fromPoints5();
    var toPoints = require_toPoints4();
    var { equals: equals2 } = require_vec2();
    var concat = (...paths) => {
      let isClosed = false;
      let newpoints = [];
      paths.forEach((path, i) => {
        const tmp6 = toPoints(path).slice();
        if (newpoints.length > 0 && tmp6.length > 0 && equals2(tmp6[0], newpoints[newpoints.length - 1]))
          tmp6.shift();
        if (tmp6.length > 0 && isClosed) {
          throw new Error(`Cannot concatenate to a closed path; check the ${i}th path`);
        }
        isClosed = path.isClosed;
        newpoints = newpoints.concat(tmp6);
      });
      return fromPoints({ closed: isClosed }, newpoints);
    };
    module.exports = concat;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/appendPoints.js
var require_appendPoints = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/appendPoints.js"(exports, module) {
    var concat = require_concat();
    var create = require_create8();
    var appendPoints = (points, geometry) => concat(geometry, create(points));
    module.exports = appendPoints;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/appendBezier.js
var require_appendBezier = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/appendBezier.js"(exports, module) {
    var { TAU } = require_constants();
    var vec2 = require_vec2();
    var vec3 = require_vec2();
    var appendPoints = require_appendPoints();
    var toPoints = require_toPoints4();
    var appendBezier = (options, geometry) => {
      const defaults = {
        segments: 16
      };
      let { controlPoints, segments } = Object.assign({}, defaults, options);
      if (!Array.isArray(controlPoints))
        throw new Error("controlPoints must be an array of one or more points");
      if (controlPoints.length < 1)
        throw new Error("controlPoints must be an array of one or more points");
      if (segments < 4)
        throw new Error("segments must be four or more");
      if (geometry.isClosed) {
        throw new Error("the given geometry cannot be closed");
      }
      const points = toPoints(geometry);
      if (points.length < 1) {
        throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");
      }
      controlPoints = controlPoints.slice();
      const firstControlPoint = controlPoints[0];
      if (firstControlPoint === null) {
        if (controlPoints.length < 2) {
          throw new Error("a null control point must be passed with one more control points");
        }
        let lastBezierControlPoint = points[points.length - 2];
        if ("lastBezierControlPoint" in geometry) {
          lastBezierControlPoint = geometry.lastBezierControlPoint;
        }
        if (!Array.isArray(lastBezierControlPoint)) {
          throw new Error("the given path must contain TWO or more points if given a null control point");
        }
        const controlpoint = vec2.scale(vec2.create(), points[points.length - 1], 2);
        vec2.subtract(controlpoint, controlpoint, lastBezierControlPoint);
        controlPoints[0] = controlpoint;
      }
      controlPoints.unshift(points[points.length - 1]);
      const bezierOrder = controlPoints.length - 1;
      const factorials = [];
      let fact = 1;
      for (let i = 0; i <= bezierOrder; ++i) {
        if (i > 0)
          fact *= i;
        factorials.push(fact);
      }
      const binomials = [];
      for (let i = 0; i <= bezierOrder; ++i) {
        const binomial = factorials[bezierOrder] / (factorials[i] * factorials[bezierOrder - i]);
        binomials.push(binomial);
      }
      const v0 = vec2.create();
      const v1 = vec2.create();
      const v3 = vec3.create();
      const getPointForT = (t) => {
        let tk = 1;
        let oneMinusTNMinusK = Math.pow(1 - t, bezierOrder);
        const invOneMinusT = t !== 1 ? 1 / (1 - t) : 1;
        const point = vec2.create();
        for (let k = 0; k <= bezierOrder; ++k) {
          if (k === bezierOrder)
            oneMinusTNMinusK = 1;
          const bernsteinCoefficient = binomials[k] * tk * oneMinusTNMinusK;
          const derivativePoint = vec2.scale(v0, controlPoints[k], bernsteinCoefficient);
          vec2.add(point, point, derivativePoint);
          tk *= t;
          oneMinusTNMinusK *= invOneMinusT;
        }
        return point;
      };
      const newpoints = [];
      const newpointsT = [];
      const numsteps = bezierOrder + 1;
      for (let i = 0; i < numsteps; ++i) {
        const t = i / (numsteps - 1);
        const point = getPointForT(t);
        newpoints.push(point);
        newpointsT.push(t);
      }
      let subdivideBase = 1;
      const maxangle = TAU / segments;
      const maxsinangle = Math.sin(maxangle);
      while (subdivideBase < newpoints.length - 1) {
        const dir1 = vec2.subtract(v0, newpoints[subdivideBase], newpoints[subdivideBase - 1]);
        vec2.normalize(dir1, dir1);
        const dir2 = vec2.subtract(v1, newpoints[subdivideBase + 1], newpoints[subdivideBase]);
        vec2.normalize(dir2, dir2);
        const sinangle = vec2.cross(v3, dir1, dir2);
        if (Math.abs(sinangle[2]) > maxsinangle) {
          const t0 = newpointsT[subdivideBase - 1];
          const t1 = newpointsT[subdivideBase + 1];
          const newt0 = t0 + (t1 - t0) * 1 / 3;
          const newt1 = t0 + (t1 - t0) * 2 / 3;
          const point0 = getPointForT(newt0);
          const point1 = getPointForT(newt1);
          newpoints.splice(subdivideBase, 1, point0, point1);
          newpointsT.splice(subdivideBase, 1, newt0, newt1);
          subdivideBase--;
          if (subdivideBase < 1)
            subdivideBase = 1;
        } else {
          ++subdivideBase;
        }
      }
      newpoints.shift();
      const result = appendPoints(newpoints, geometry);
      result.lastBezierControlPoint = controlPoints[controlPoints.length - 2];
      return result;
    };
    module.exports = appendBezier;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/equals.js
var require_equals5 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/equals.js"(exports, module) {
    var vec2 = require_vec2();
    var toPoints = require_toPoints4();
    var equals2 = (a, b) => {
      if (a.isClosed !== b.isClosed) {
        return false;
      }
      if (a.points.length !== b.points.length) {
        return false;
      }
      const apoints = toPoints(a);
      const bpoints = toPoints(b);
      const length = apoints.length;
      let offset = 0;
      do {
        let unequal = false;
        for (let i = 0; i < length; i++) {
          if (!vec2.equals(apoints[i], bpoints[(i + offset) % length])) {
            unequal = true;
            break;
          }
        }
        if (unequal === false) {
          return true;
        }
        if (!a.isClosed) {
          return false;
        }
      } while (++offset < length);
      return false;
    };
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/fromCompactBinary.js
var require_fromCompactBinary3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/fromCompactBinary.js"(exports, module) {
    var mat4 = require_mat4();
    var vec2 = require_vec2();
    var create = require_create8();
    var fromCompactBinary = (data) => {
      if (data[0] !== 2)
        throw new Error("invalid compact binary data");
      const created = create();
      created.transforms = mat4.clone(data.slice(1, 17));
      created.isClosed = !!data[17];
      for (let i = 22; i < data.length; i += 2) {
        const point = vec2.fromValues(data[i], data[i + 1]);
        created.points.push(point);
      }
      if (data[18] >= 0) {
        created.color = [data[18], data[19], data[20], data[21]];
      }
      return created;
    };
    module.exports = fromCompactBinary;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/isA.js
var require_isA4 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/isA.js"(exports, module) {
    var isA = (object) => {
      if (object && typeof object === "object") {
        if ("points" in object && "transforms" in object && "isClosed" in object) {
          if (Array.isArray(object.points) && "length" in object.transforms) {
            return true;
          }
        }
      }
      return false;
    };
    module.exports = isA;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/reverse.js
var require_reverse2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/reverse.js"(exports, module) {
    var clone = require_clone8();
    var reverse = (geometry) => {
      const cloned = clone(geometry);
      cloned.points = geometry.points.slice().reverse();
      return cloned;
    };
    module.exports = reverse;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/toString.js
var require_toString8 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/toString.js"(exports, module) {
    var vec2 = require_vec2();
    var toPoints = require_toPoints4();
    var toString = (geometry) => {
      const points = toPoints(geometry);
      let result = "path (" + points.length + " points, " + geometry.isClosed + "):\n[\n";
      points.forEach((point) => {
        result += "  " + vec2.toString(point) + ",\n";
      });
      result += "]\n";
      return result;
    };
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/toCompactBinary.js
var require_toCompactBinary3 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/toCompactBinary.js"(exports, module) {
    var toCompactBinary = (geometry) => {
      const points = geometry.points;
      const transforms = geometry.transforms;
      let color = [-1, -1, -1, -1];
      if (geometry.color)
        color = geometry.color;
      const compacted = new Float32Array(1 + 16 + 1 + 4 + points.length * 2);
      compacted[0] = 2;
      compacted[1] = transforms[0];
      compacted[2] = transforms[1];
      compacted[3] = transforms[2];
      compacted[4] = transforms[3];
      compacted[5] = transforms[4];
      compacted[6] = transforms[5];
      compacted[7] = transforms[6];
      compacted[8] = transforms[7];
      compacted[9] = transforms[8];
      compacted[10] = transforms[9];
      compacted[11] = transforms[10];
      compacted[12] = transforms[11];
      compacted[13] = transforms[12];
      compacted[14] = transforms[13];
      compacted[15] = transforms[14];
      compacted[16] = transforms[15];
      compacted[17] = geometry.isClosed ? 1 : 0;
      compacted[18] = color[0];
      compacted[19] = color[1];
      compacted[20] = color[2];
      compacted[21] = color[3];
      for (let j = 0; j < points.length; j++) {
        const ci = j * 2 + 22;
        const point = points[j];
        compacted[ci] = point[0];
        compacted[ci + 1] = point[1];
      }
      return compacted;
    };
    module.exports = toCompactBinary;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/transform.js
var require_transform8 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/transform.js"(exports, module) {
    var mat4 = require_mat4();
    var transform = (matrix, geometry) => {
      const transforms = mat4.multiply(mat4.create(), matrix, geometry.transforms);
      return Object.assign({}, geometry, { transforms });
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/validate.js
var require_validate4 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/validate.js"(exports, module) {
    var vec2 = require_vec2();
    var isA = require_isA4();
    var validate = (object) => {
      if (!isA(object)) {
        throw new Error("invalid path2 structure");
      }
      if (object.points.length > 1) {
        for (let i = 0; i < object.points.length; i++) {
          if (vec2.equals(object.points[i], object.points[(i + 1) % object.points.length])) {
            throw new Error(`path2 duplicate points ${object.points[i]}`);
          }
        }
      }
      object.points.forEach((point) => {
        if (!point.every(Number.isFinite)) {
          throw new Error(`path2 invalid point ${point}`);
        }
      });
      if (!object.transforms.every(Number.isFinite)) {
        throw new Error(`path2 invalid transforms ${object.transforms}`);
      }
    };
    module.exports = validate;
  }
});

// node_modules/@jscad/modeling/src/geometries/path2/index.js
var require_path2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/path2/index.js"(exports, module) {
    module.exports = {
      appendArc: require_appendArc(),
      appendBezier: require_appendBezier(),
      appendPoints: require_appendPoints(),
      clone: require_clone8(),
      close: require_close(),
      concat: require_concat(),
      create: require_create8(),
      equals: require_equals5(),
      fromPoints: require_fromPoints5(),
      fromCompactBinary: require_fromCompactBinary3(),
      isA: require_isA4(),
      reverse: require_reverse2(),
      toPoints: require_toPoints4(),
      toString: require_toString8(),
      toCompactBinary: require_toCompactBinary3(),
      transform: require_transform8(),
      validate: require_validate4()
    };
  }
});

// node_modules/@jscad/modeling/src/colors/colorize.js
var require_colorize = __commonJS({
  "node_modules/@jscad/modeling/src/colors/colorize.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var poly3 = require_poly3();
    var colorGeom2 = (color, object) => {
      const newgeom2 = geom2.clone(object);
      newgeom2.color = color;
      return newgeom2;
    };
    var colorGeom3 = (color, object) => {
      const newgeom3 = geom3.clone(object);
      newgeom3.color = color;
      return newgeom3;
    };
    var colorPath2 = (color, object) => {
      const newpath2 = path2.clone(object);
      newpath2.color = color;
      return newpath2;
    };
    var colorPoly3 = (color, object) => {
      const newpoly = poly3.clone(object);
      newpoly.color = color;
      return newpoly;
    };
    var colorize = (color, ...objects) => {
      if (!Array.isArray(color))
        throw new Error("color must be an array");
      if (color.length < 3)
        throw new Error("color must contain R, G and B values");
      if (color.length === 3)
        color = [color[0], color[1], color[2], 1];
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      const results = objects.map((object) => {
        if (geom2.isA(object))
          return colorGeom2(color, object);
        if (geom3.isA(object))
          return colorGeom3(color, object);
        if (path2.isA(object))
          return colorPath2(color, object);
        if (poly3.isA(object))
          return colorPoly3(color, object);
        object.color = color;
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = colorize;
  }
});

// node_modules/@jscad/modeling/src/colors/cssColors.js
var require_cssColors = __commonJS({
  "node_modules/@jscad/modeling/src/colors/cssColors.js"(exports, module) {
    var cssColors = {
      // basic color keywords
      black: [0 / 255, 0 / 255, 0 / 255],
      silver: [192 / 255, 192 / 255, 192 / 255],
      gray: [128 / 255, 128 / 255, 128 / 255],
      white: [255 / 255, 255 / 255, 255 / 255],
      maroon: [128 / 255, 0 / 255, 0 / 255],
      red: [255 / 255, 0 / 255, 0 / 255],
      purple: [128 / 255, 0 / 255, 128 / 255],
      fuchsia: [255 / 255, 0 / 255, 255 / 255],
      green: [0 / 255, 128 / 255, 0 / 255],
      lime: [0 / 255, 255 / 255, 0 / 255],
      olive: [128 / 255, 128 / 255, 0 / 255],
      yellow: [255 / 255, 255 / 255, 0 / 255],
      navy: [0 / 255, 0 / 255, 128 / 255],
      blue: [0 / 255, 0 / 255, 255 / 255],
      teal: [0 / 255, 128 / 255, 128 / 255],
      aqua: [0 / 255, 255 / 255, 255 / 255],
      // extended color keywords
      aliceblue: [240 / 255, 248 / 255, 255 / 255],
      antiquewhite: [250 / 255, 235 / 255, 215 / 255],
      // 'aqua': [ 0 / 255, 255 / 255, 255 / 255 ],
      aquamarine: [127 / 255, 255 / 255, 212 / 255],
      azure: [240 / 255, 255 / 255, 255 / 255],
      beige: [245 / 255, 245 / 255, 220 / 255],
      bisque: [255 / 255, 228 / 255, 196 / 255],
      // 'black': [ 0 / 255, 0 / 255, 0 / 255 ],
      blanchedalmond: [255 / 255, 235 / 255, 205 / 255],
      // 'blue': [ 0 / 255, 0 / 255, 255 / 255 ],
      blueviolet: [138 / 255, 43 / 255, 226 / 255],
      brown: [165 / 255, 42 / 255, 42 / 255],
      burlywood: [222 / 255, 184 / 255, 135 / 255],
      cadetblue: [95 / 255, 158 / 255, 160 / 255],
      chartreuse: [127 / 255, 255 / 255, 0 / 255],
      chocolate: [210 / 255, 105 / 255, 30 / 255],
      coral: [255 / 255, 127 / 255, 80 / 255],
      cornflowerblue: [100 / 255, 149 / 255, 237 / 255],
      cornsilk: [255 / 255, 248 / 255, 220 / 255],
      crimson: [220 / 255, 20 / 255, 60 / 255],
      cyan: [0 / 255, 255 / 255, 255 / 255],
      darkblue: [0 / 255, 0 / 255, 139 / 255],
      darkcyan: [0 / 255, 139 / 255, 139 / 255],
      darkgoldenrod: [184 / 255, 134 / 255, 11 / 255],
      darkgray: [169 / 255, 169 / 255, 169 / 255],
      darkgreen: [0 / 255, 100 / 255, 0 / 255],
      darkgrey: [169 / 255, 169 / 255, 169 / 255],
      darkkhaki: [189 / 255, 183 / 255, 107 / 255],
      darkmagenta: [139 / 255, 0 / 255, 139 / 255],
      darkolivegreen: [85 / 255, 107 / 255, 47 / 255],
      darkorange: [255 / 255, 140 / 255, 0 / 255],
      darkorchid: [153 / 255, 50 / 255, 204 / 255],
      darkred: [139 / 255, 0 / 255, 0 / 255],
      darksalmon: [233 / 255, 150 / 255, 122 / 255],
      darkseagreen: [143 / 255, 188 / 255, 143 / 255],
      darkslateblue: [72 / 255, 61 / 255, 139 / 255],
      darkslategray: [47 / 255, 79 / 255, 79 / 255],
      darkslategrey: [47 / 255, 79 / 255, 79 / 255],
      darkturquoise: [0 / 255, 206 / 255, 209 / 255],
      darkviolet: [148 / 255, 0 / 255, 211 / 255],
      deeppink: [255 / 255, 20 / 255, 147 / 255],
      deepskyblue: [0 / 255, 191 / 255, 255 / 255],
      dimgray: [105 / 255, 105 / 255, 105 / 255],
      dimgrey: [105 / 255, 105 / 255, 105 / 255],
      dodgerblue: [30 / 255, 144 / 255, 255 / 255],
      firebrick: [178 / 255, 34 / 255, 34 / 255],
      floralwhite: [255 / 255, 250 / 255, 240 / 255],
      forestgreen: [34 / 255, 139 / 255, 34 / 255],
      // 'fuchsia': [ 255 / 255, 0 / 255, 255 / 255 ],
      gainsboro: [220 / 255, 220 / 255, 220 / 255],
      ghostwhite: [248 / 255, 248 / 255, 255 / 255],
      gold: [255 / 255, 215 / 255, 0 / 255],
      goldenrod: [218 / 255, 165 / 255, 32 / 255],
      // 'gray': [ 128 / 255, 128 / 255, 128 / 255 ],
      // 'green': [ 0 / 255, 128 / 255, 0 / 255 ],
      greenyellow: [173 / 255, 255 / 255, 47 / 255],
      grey: [128 / 255, 128 / 255, 128 / 255],
      honeydew: [240 / 255, 255 / 255, 240 / 255],
      hotpink: [255 / 255, 105 / 255, 180 / 255],
      indianred: [205 / 255, 92 / 255, 92 / 255],
      indigo: [75 / 255, 0 / 255, 130 / 255],
      ivory: [255 / 255, 255 / 255, 240 / 255],
      khaki: [240 / 255, 230 / 255, 140 / 255],
      lavender: [230 / 255, 230 / 255, 250 / 255],
      lavenderblush: [255 / 255, 240 / 255, 245 / 255],
      lawngreen: [124 / 255, 252 / 255, 0 / 255],
      lemonchiffon: [255 / 255, 250 / 255, 205 / 255],
      lightblue: [173 / 255, 216 / 255, 230 / 255],
      lightcoral: [240 / 255, 128 / 255, 128 / 255],
      lightcyan: [224 / 255, 255 / 255, 255 / 255],
      lightgoldenrodyellow: [250 / 255, 250 / 255, 210 / 255],
      lightgray: [211 / 255, 211 / 255, 211 / 255],
      lightgreen: [144 / 255, 238 / 255, 144 / 255],
      lightgrey: [211 / 255, 211 / 255, 211 / 255],
      lightpink: [255 / 255, 182 / 255, 193 / 255],
      lightsalmon: [255 / 255, 160 / 255, 122 / 255],
      lightseagreen: [32 / 255, 178 / 255, 170 / 255],
      lightskyblue: [135 / 255, 206 / 255, 250 / 255],
      lightslategray: [119 / 255, 136 / 255, 153 / 255],
      lightslategrey: [119 / 255, 136 / 255, 153 / 255],
      lightsteelblue: [176 / 255, 196 / 255, 222 / 255],
      lightyellow: [255 / 255, 255 / 255, 224 / 255],
      // 'lime': [ 0 / 255, 255 / 255, 0 / 255 ],
      limegreen: [50 / 255, 205 / 255, 50 / 255],
      linen: [250 / 255, 240 / 255, 230 / 255],
      magenta: [255 / 255, 0 / 255, 255 / 255],
      // 'maroon': [ 128 / 255, 0 / 255, 0 / 255 ],
      mediumaquamarine: [102 / 255, 205 / 255, 170 / 255],
      mediumblue: [0 / 255, 0 / 255, 205 / 255],
      mediumorchid: [186 / 255, 85 / 255, 211 / 255],
      mediumpurple: [147 / 255, 112 / 255, 219 / 255],
      mediumseagreen: [60 / 255, 179 / 255, 113 / 255],
      mediumslateblue: [123 / 255, 104 / 255, 238 / 255],
      mediumspringgreen: [0 / 255, 250 / 255, 154 / 255],
      mediumturquoise: [72 / 255, 209 / 255, 204 / 255],
      mediumvioletred: [199 / 255, 21 / 255, 133 / 255],
      midnightblue: [25 / 255, 25 / 255, 112 / 255],
      mintcream: [245 / 255, 255 / 255, 250 / 255],
      mistyrose: [255 / 255, 228 / 255, 225 / 255],
      moccasin: [255 / 255, 228 / 255, 181 / 255],
      navajowhite: [255 / 255, 222 / 255, 173 / 255],
      // 'navy': [ 0 / 255, 0 / 255, 128 / 255 ],
      oldlace: [253 / 255, 245 / 255, 230 / 255],
      // 'olive': [ 128 / 255, 128 / 255, 0 / 255 ],
      olivedrab: [107 / 255, 142 / 255, 35 / 255],
      orange: [255 / 255, 165 / 255, 0 / 255],
      orangered: [255 / 255, 69 / 255, 0 / 255],
      orchid: [218 / 255, 112 / 255, 214 / 255],
      palegoldenrod: [238 / 255, 232 / 255, 170 / 255],
      palegreen: [152 / 255, 251 / 255, 152 / 255],
      paleturquoise: [175 / 255, 238 / 255, 238 / 255],
      palevioletred: [219 / 255, 112 / 255, 147 / 255],
      papayawhip: [255 / 255, 239 / 255, 213 / 255],
      peachpuff: [255 / 255, 218 / 255, 185 / 255],
      peru: [205 / 255, 133 / 255, 63 / 255],
      pink: [255 / 255, 192 / 255, 203 / 255],
      plum: [221 / 255, 160 / 255, 221 / 255],
      powderblue: [176 / 255, 224 / 255, 230 / 255],
      // 'purple': [ 128 / 255, 0 / 255, 128 / 255 ],
      // 'red': [ 255 / 255, 0 / 255, 0 / 255 ],
      rosybrown: [188 / 255, 143 / 255, 143 / 255],
      royalblue: [65 / 255, 105 / 255, 225 / 255],
      saddlebrown: [139 / 255, 69 / 255, 19 / 255],
      salmon: [250 / 255, 128 / 255, 114 / 255],
      sandybrown: [244 / 255, 164 / 255, 96 / 255],
      seagreen: [46 / 255, 139 / 255, 87 / 255],
      seashell: [255 / 255, 245 / 255, 238 / 255],
      sienna: [160 / 255, 82 / 255, 45 / 255],
      // 'silver': [ 192 / 255, 192 / 255, 192 / 255 ],
      skyblue: [135 / 255, 206 / 255, 235 / 255],
      slateblue: [106 / 255, 90 / 255, 205 / 255],
      slategray: [112 / 255, 128 / 255, 144 / 255],
      slategrey: [112 / 255, 128 / 255, 144 / 255],
      snow: [255 / 255, 250 / 255, 250 / 255],
      springgreen: [0 / 255, 255 / 255, 127 / 255],
      steelblue: [70 / 255, 130 / 255, 180 / 255],
      tan: [210 / 255, 180 / 255, 140 / 255],
      // 'teal': [ 0 / 255, 128 / 255, 128 / 255 ],
      thistle: [216 / 255, 191 / 255, 216 / 255],
      tomato: [255 / 255, 99 / 255, 71 / 255],
      turquoise: [64 / 255, 224 / 255, 208 / 255],
      violet: [238 / 255, 130 / 255, 238 / 255],
      wheat: [245 / 255, 222 / 255, 179 / 255],
      // 'white': [ 255 / 255, 255 / 255, 255 / 255 ],
      whitesmoke: [245 / 255, 245 / 255, 245 / 255],
      // 'yellow': [ 255 / 255, 255 / 255, 0 / 255 ],
      yellowgreen: [154 / 255, 205 / 255, 50 / 255]
    };
    module.exports = cssColors;
  }
});

// node_modules/@jscad/modeling/src/colors/colorNameToRgb.js
var require_colorNameToRgb = __commonJS({
  "node_modules/@jscad/modeling/src/colors/colorNameToRgb.js"(exports, module) {
    var cssColors = require_cssColors();
    var colorNameToRgb = (s) => cssColors[s.toLowerCase()];
    module.exports = colorNameToRgb;
  }
});

// node_modules/@jscad/modeling/src/colors/hexToRgb.js
var require_hexToRgb = __commonJS({
  "node_modules/@jscad/modeling/src/colors/hexToRgb.js"(exports, module) {
    var hexToRgb = (notation) => {
      notation = notation.replace("#", "");
      if (notation.length < 6)
        throw new Error("the given notation must contain 3 or more hex values");
      const r = parseInt(notation.substring(0, 2), 16) / 255;
      const g = parseInt(notation.substring(2, 4), 16) / 255;
      const b = parseInt(notation.substring(4, 6), 16) / 255;
      if (notation.length >= 8) {
        const a = parseInt(notation.substring(6, 8), 16) / 255;
        return [r, g, b, a];
      }
      return [r, g, b];
    };
    module.exports = hexToRgb;
  }
});

// node_modules/@jscad/modeling/src/colors/hueToColorComponent.js
var require_hueToColorComponent = __commonJS({
  "node_modules/@jscad/modeling/src/colors/hueToColorComponent.js"(exports, module) {
    var hueToColorComponent = (p, q, t) => {
      if (t < 0)
        t += 1;
      if (t > 1)
        t -= 1;
      if (t < 1 / 6)
        return p + (q - p) * 6 * t;
      if (t < 1 / 2)
        return q;
      if (t < 2 / 3)
        return p + (q - p) * (2 / 3 - t) * 6;
      return p;
    };
    module.exports = hueToColorComponent;
  }
});

// node_modules/@jscad/modeling/src/colors/hslToRgb.js
var require_hslToRgb = __commonJS({
  "node_modules/@jscad/modeling/src/colors/hslToRgb.js"(exports, module) {
    var flatten2 = require_flatten();
    var hueToColorComponent = require_hueToColorComponent();
    var hslToRgb = (...values) => {
      values = flatten2(values);
      if (values.length < 3)
        throw new Error("values must contain H, S and L values");
      const h = values[0];
      const s = values[1];
      const l = values[2];
      let r = l;
      let g = l;
      let b = l;
      if (s !== 0) {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hueToColorComponent(p, q, h + 1 / 3);
        g = hueToColorComponent(p, q, h);
        b = hueToColorComponent(p, q, h - 1 / 3);
      }
      if (values.length > 3) {
        const a = values[3];
        return [r, g, b, a];
      }
      return [r, g, b];
    };
    module.exports = hslToRgb;
  }
});

// node_modules/@jscad/modeling/src/colors/hsvToRgb.js
var require_hsvToRgb = __commonJS({
  "node_modules/@jscad/modeling/src/colors/hsvToRgb.js"(exports, module) {
    var flatten2 = require_flatten();
    var hsvToRgb = (...values) => {
      values = flatten2(values);
      if (values.length < 3)
        throw new Error("values must contain H, S and V values");
      const h = values[0];
      const s = values[1];
      const v = values[2];
      let r = 0;
      let g = 0;
      let b = 0;
      const i = Math.floor(h * 6);
      const f = h * 6 - i;
      const p = v * (1 - s);
      const q = v * (1 - f * s);
      const t = v * (1 - (1 - f) * s);
      switch (i % 6) {
        case 0:
          r = v;
          g = t;
          b = p;
          break;
        case 1:
          r = q;
          g = v;
          b = p;
          break;
        case 2:
          r = p;
          g = v;
          b = t;
          break;
        case 3:
          r = p;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p;
          b = v;
          break;
        case 5:
          r = v;
          g = p;
          b = q;
          break;
      }
      if (values.length > 3) {
        const a = values[3];
        return [r, g, b, a];
      }
      return [r, g, b];
    };
    module.exports = hsvToRgb;
  }
});

// node_modules/@jscad/modeling/src/colors/rgbToHex.js
var require_rgbToHex = __commonJS({
  "node_modules/@jscad/modeling/src/colors/rgbToHex.js"(exports, module) {
    var flatten2 = require_flatten();
    var rgbToHex = (...values) => {
      values = flatten2(values);
      if (values.length < 3)
        throw new Error("values must contain R, G and B values");
      const r = values[0] * 255;
      const g = values[1] * 255;
      const b = values[2] * 255;
      let s = `#${Number(16777216 + r * 65536 + g * 256 + b).toString(16).substring(1, 7)}`;
      if (values.length > 3) {
        s = s + Number(values[3] * 255).toString(16);
      }
      return s;
    };
    module.exports = rgbToHex;
  }
});

// node_modules/@jscad/modeling/src/colors/rgbToHsl.js
var require_rgbToHsl = __commonJS({
  "node_modules/@jscad/modeling/src/colors/rgbToHsl.js"(exports, module) {
    var flatten2 = require_flatten();
    var rgbToHsl = (...values) => {
      values = flatten2(values);
      if (values.length < 3)
        throw new Error("values must contain R, G and B values");
      const r = values[0];
      const g = values[1];
      const b = values[2];
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h;
      let s;
      const l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      if (values.length > 3) {
        const a = values[3];
        return [h, s, l, a];
      }
      return [h, s, l];
    };
    module.exports = rgbToHsl;
  }
});

// node_modules/@jscad/modeling/src/colors/rgbToHsv.js
var require_rgbToHsv = __commonJS({
  "node_modules/@jscad/modeling/src/colors/rgbToHsv.js"(exports, module) {
    var flatten2 = require_flatten();
    var rgbToHsv = (...values) => {
      values = flatten2(values);
      if (values.length < 3)
        throw new Error("values must contain R, G and B values");
      const r = values[0];
      const g = values[1];
      const b = values[2];
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h;
      const v = max;
      const d = max - min;
      const s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
        }
        h /= 6;
      }
      if (values.length > 3) {
        const a = values[3];
        return [h, s, v, a];
      }
      return [h, s, v];
    };
    module.exports = rgbToHsv;
  }
});

// node_modules/@jscad/modeling/src/colors/index.js
var require_colors = __commonJS({
  "node_modules/@jscad/modeling/src/colors/index.js"(exports, module) {
    module.exports = {
      colorize: require_colorize(),
      colorNameToRgb: require_colorNameToRgb(),
      cssColors: require_cssColors(),
      hexToRgb: require_hexToRgb(),
      hslToRgb: require_hslToRgb(),
      hsvToRgb: require_hsvToRgb(),
      hueToColorComponent: require_hueToColorComponent(),
      rgbToHex: require_rgbToHex(),
      rgbToHsl: require_rgbToHsl(),
      rgbToHsv: require_rgbToHsv()
    };
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/create.js
var require_create9 = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/create.js"(exports, module) {
    var create = (points) => {
      if (!Array.isArray(points))
        throw new Error("Bezier points must be a valid array/");
      if (points.length < 2)
        throw new Error("Bezier points must contain at least 2 values.");
      const pointType = getPointType(points);
      return {
        points,
        pointType,
        dimensions: pointType === "float_single" ? 0 : points[0].length,
        permutations: getPermutations(points.length - 1),
        tangentPermutations: getPermutations(points.length - 2)
      };
    };
    var getPointType = function(points) {
      let firstPointType = null;
      points.forEach((point) => {
        let pType = "";
        if (Number.isFinite(point)) {
          pType = "float_single";
        } else if (Array.isArray(point)) {
          point.forEach((val) => {
            if (!Number.isFinite(val))
              throw new Error("Bezier point values must all be numbers.");
          });
          pType = "float_" + point.length;
        } else
          throw new Error("Bezier points must all be numbers or arrays of number.");
        if (firstPointType == null) {
          firstPointType = pType;
        } else {
          if (firstPointType !== pType) {
            throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.");
          }
        }
      });
      return firstPointType;
    };
    var getPermutations = function(c) {
      const permutations = [];
      for (let i = 0; i <= c; i++) {
        permutations.push(factorial(c) / (factorial(i) * factorial(c - i)));
      }
      return permutations;
    };
    var factorial = function(b) {
      let out = 1;
      for (let i = 2; i <= b; i++) {
        out *= i;
      }
      return out;
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/valueAt.js
var require_valueAt = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/valueAt.js"(exports, module) {
    var valueAt = (t, bezier) => {
      if (t < 0 || t > 1) {
        throw new Error("Bezier valueAt() input must be between 0 and 1");
      }
      if (bezier.pointType === "float_single") {
        return bezierFunction(bezier, bezier.points, t);
      } else {
        const result = [];
        for (let i = 0; i < bezier.dimensions; i++) {
          const singleDimensionPoints = [];
          for (let j = 0; j < bezier.points.length; j++) {
            singleDimensionPoints.push(bezier.points[j][i]);
          }
          result.push(bezierFunction(bezier, singleDimensionPoints, t));
        }
        return result;
      }
    };
    var bezierFunction = function(bezier, p, t) {
      const n = p.length - 1;
      let result = 0;
      for (let i = 0; i <= n; i++) {
        result += bezier.permutations[i] * Math.pow(1 - t, n - i) * Math.pow(t, i) * p[i];
      }
      return result;
    };
    module.exports = valueAt;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/tangentAt.js
var require_tangentAt = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/tangentAt.js"(exports, module) {
    var tangentAt = (t, bezier) => {
      if (t < 0 || t > 1) {
        throw new Error("Bezier tangentAt() input must be between 0 and 1");
      }
      if (bezier.pointType === "float_single") {
        return bezierTangent(bezier, bezier.points, t);
      } else {
        const result = [];
        for (let i = 0; i < bezier.dimensions; i++) {
          const singleDimensionPoints = [];
          for (let j = 0; j < bezier.points.length; j++) {
            singleDimensionPoints.push(bezier.points[j][i]);
          }
          result.push(bezierTangent(bezier, singleDimensionPoints, t));
        }
        return result;
      }
    };
    var bezierTangent = function(bezier, p, t) {
      const n = p.length - 1;
      let result = 0;
      for (let i = 0; i < n; i++) {
        const q = n * (p[i + 1] - p[i]);
        result += bezier.tangentPermutations[i] * Math.pow(1 - t, n - 1 - i) * Math.pow(t, i) * q;
      }
      return result;
    };
    module.exports = tangentAt;
  }
});

// node_modules/@jscad/modeling/src/curves/bezier/index.js
var require_bezier = __commonJS({
  "node_modules/@jscad/modeling/src/curves/bezier/index.js"(exports, module) {
    module.exports = {
      create: require_create9(),
      valueAt: require_valueAt(),
      tangentAt: require_tangentAt()
    };
  }
});

// node_modules/@jscad/modeling/src/curves/index.js
var require_curves = __commonJS({
  "node_modules/@jscad/modeling/src/curves/index.js"(exports, module) {
    module.exports = {
      bezier: require_bezier()
    };
  }
});

// node_modules/@jscad/modeling/src/maths/utils/area.js
var require_area = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/area.js"(exports, module) {
    var area2 = (points) => {
      let area3 = 0;
      for (let i = 0; i < points.length; i++) {
        const j = (i + 1) % points.length;
        area3 += points[i][0] * points[j][1];
        area3 -= points[j][0] * points[i][1];
      }
      return area3 / 2;
    };
    module.exports = area2;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly2/measureArea.js
var require_measureArea2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly2/measureArea.js"(exports, module) {
    var area2 = require_area();
    var measureArea = (polygon) => area2(polygon.vertices);
    module.exports = measureArea;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly2/create.js
var require_create10 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly2/create.js"(exports, module) {
    var create = (vertices) => {
      if (vertices === void 0 || vertices.length < 3) {
        vertices = [];
      }
      return { vertices };
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly2/flip.js
var require_flip2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly2/flip.js"(exports, module) {
    var create = require_create10();
    var flip = (polygon) => {
      const vertices = polygon.vertices.slice().reverse();
      return create(vertices);
    };
    module.exports = flip;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly2/arePointsInside.js
var require_arePointsInside = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly2/arePointsInside.js"(exports, module) {
    var measureArea = require_measureArea2();
    var flip = require_flip2();
    var arePointsInside = (points, polygon) => {
      if (points.length === 0)
        return 0;
      const vertices = polygon.vertices;
      if (vertices.length < 3)
        return 0;
      if (measureArea(polygon) < 0) {
        polygon = flip(polygon);
      }
      const sum = points.reduce((acc, point) => acc + isPointInside(point, vertices), 0);
      return sum === points.length ? 1 : 0;
    };
    var isPointInside = (point, polygon) => {
      const numverts = polygon.length;
      const tx = point[0];
      const ty = point[1];
      let vtx0 = polygon[numverts - 1];
      let vtx1 = polygon[0];
      let yflag0 = vtx0[1] > ty;
      let insideFlag = 0;
      let i = 0;
      for (let j = numverts + 1; --j; ) {
        const yflag1 = vtx1[1] > ty;
        if (yflag0 !== yflag1) {
          const xflag0 = vtx0[0] > tx;
          const xflag1 = vtx1[0] > tx;
          if (xflag0 && xflag1) {
            insideFlag = !insideFlag;
          } else {
            if (vtx1[0] - (vtx1[1] - ty) * (vtx0[0] - vtx1[0]) / (vtx0[1] - vtx1[1]) >= tx) {
              insideFlag = !insideFlag;
            }
          }
        }
        yflag0 = yflag1;
        vtx0 = vtx1;
        vtx1 = polygon[++i];
      }
      return insideFlag;
    };
    module.exports = arePointsInside;
  }
});

// node_modules/@jscad/modeling/src/geometries/poly2/index.js
var require_poly2 = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/poly2/index.js"(exports, module) {
    module.exports = {
      arePointsInside: require_arePointsInside(),
      create: require_create10(),
      flip: require_flip2(),
      measureArea: require_measureArea2()
    };
  }
});

// node_modules/@jscad/modeling/src/geometries/index.js
var require_geometries = __commonJS({
  "node_modules/@jscad/modeling/src/geometries/index.js"(exports, module) {
    module.exports = {
      geom2: require_geom2(),
      geom3: require_geom3(),
      path2: require_path2(),
      poly2: require_poly2(),
      poly3: require_poly3()
    };
  }
});

// node_modules/@jscad/modeling/src/maths/line2/create.js
var require_create11 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/create.js"(exports, module) {
    var create = () => [0, 1, 0];
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/clone.js
var require_clone9 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/clone.js"(exports, module) {
    var create = require_create11();
    var clone = (line) => {
      const out = create();
      out[0] = line[0];
      out[1] = line[1];
      out[2] = line[2];
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/direction.js
var require_direction = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/direction.js"(exports, module) {
    var vec2 = require_vec2();
    var direction = (line) => {
      const vector = vec2.normal(vec2.create(), line);
      vec2.negate(vector, vector);
      return vector;
    };
    module.exports = direction;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/origin.js
var require_origin = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/origin.js"(exports, module) {
    var vec2 = require_vec2();
    var origin = (line) => vec2.scale(vec2.create(), line, line[2]);
    module.exports = origin;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/closestPoint.js
var require_closestPoint = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/closestPoint.js"(exports, module) {
    var vec2 = require_vec2();
    var direction = require_direction();
    var origin = require_origin();
    var closestPoint = (line, point) => {
      const a = origin(line);
      const b = direction(line);
      const m1 = (b[1] - a[1]) / (b[0] - a[0]);
      const t1 = a[1] - m1 * a[0];
      const m2 = -1 / m1;
      const t2 = point[1] - m2 * point[0];
      const x = (t2 - t1) / (m1 - m2);
      const y = m1 * x + t1;
      const closest = vec2.fromValues(x, y);
      return closest;
    };
    module.exports = closestPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/copy.js
var require_copy5 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/copy.js"(exports, module) {
    var copy = (out, line) => {
      out[0] = line[0];
      out[1] = line[1];
      out[2] = line[2];
      return out;
    };
    module.exports = copy;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/distanceToPoint.js
var require_distanceToPoint = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/distanceToPoint.js"(exports, module) {
    var vec2 = require_vec2();
    var distanceToPoint = (line, point) => {
      let distance = vec2.dot(point, line);
      distance = Math.abs(distance - line[2]);
      return distance;
    };
    module.exports = distanceToPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/equals.js
var require_equals6 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/equals.js"(exports, module) {
    var equals2 = (line1, line2) => line1[0] === line2[0] && (line1[1] === line2[1] && line1[2] === line2[2]);
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/fromPoints.js
var require_fromPoints6 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/fromPoints.js"(exports, module) {
    var vec2 = require_vec2();
    var fromPoints = (out, point1, point2) => {
      const vector = vec2.subtract(vec2.create(), point2, point1);
      vec2.normal(vector, vector);
      vec2.normalize(vector, vector);
      const distance = vec2.dot(point1, vector);
      out[0] = vector[0];
      out[1] = vector[1];
      out[2] = distance;
      return out;
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/fromValues.js
var require_fromValues5 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/fromValues.js"(exports, module) {
    var create = require_create11();
    var fromValues = (x, y, d) => {
      const out = create();
      out[0] = x;
      out[1] = y;
      out[2] = d;
      return out;
    };
    module.exports = fromValues;
  }
});

// node_modules/@jscad/modeling/src/maths/utils/aboutEqualNormals.js
var require_aboutEqualNormals = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/aboutEqualNormals.js"(exports, module) {
    var { NEPS } = require_constants();
    var aboutEqualNormals = (a, b) => Math.abs(a[0] - b[0]) <= NEPS && Math.abs(a[1] - b[1]) <= NEPS && Math.abs(a[2] - b[2]) <= NEPS;
    module.exports = aboutEqualNormals;
  }
});

// node_modules/@jscad/modeling/src/maths/utils/interpolateBetween2DPointsForY.js
var require_interpolateBetween2DPointsForY = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/interpolateBetween2DPointsForY.js"(exports, module) {
    var interpolateBetween2DPointsForY = (point1, point2, y) => {
      let f1 = y - point1[1];
      let f2 = point2[1] - point1[1];
      if (f2 < 0) {
        f1 = -f1;
        f2 = -f2;
      }
      let t;
      if (f1 <= 0) {
        t = 0;
      } else if (f1 >= f2) {
        t = 1;
      } else if (f2 < 1e-10) {
        t = 0.5;
      } else {
        t = f1 / f2;
      }
      const result = point1[0] + t * (point2[0] - point1[0]);
      return result;
    };
    module.exports = interpolateBetween2DPointsForY;
  }
});

// node_modules/@jscad/modeling/src/maths/utils/intersect.js
var require_intersect = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/intersect.js"(exports, module) {
    var intersect = (p1, p2, p3, p4) => {
      if (p1[0] === p2[0] && p1[1] === p2[1] || p3[0] === p4[0] && p3[1] === p4[1]) {
        return void 0;
      }
      const denominator = (p4[1] - p3[1]) * (p2[0] - p1[0]) - (p4[0] - p3[0]) * (p2[1] - p1[1]);
      if (Math.abs(denominator) < Number.MIN_VALUE) {
        return void 0;
      }
      const ua = ((p4[0] - p3[0]) * (p1[1] - p3[1]) - (p4[1] - p3[1]) * (p1[0] - p3[0])) / denominator;
      const ub = ((p2[0] - p1[0]) * (p1[1] - p3[1]) - (p2[1] - p1[1]) * (p1[0] - p3[0])) / denominator;
      if (ua < 0 || ua > 1 || ub < 0 || ub > 1) {
        return void 0;
      }
      const x = p1[0] + ua * (p2[0] - p1[0]);
      const y = p1[1] + ua * (p2[1] - p1[1]);
      return [x, y];
    };
    module.exports = intersect;
  }
});

// node_modules/@jscad/modeling/src/maths/utils/solve2Linear.js
var require_solve2Linear = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/solve2Linear.js"(exports, module) {
    var solve2Linear = (a, b, c, d, u, v) => {
      const det = a * d - b * c;
      const invdet = 1 / det;
      let x = u * d - b * v;
      let y = -u * c + a * v;
      x *= invdet;
      y *= invdet;
      return [x, y];
    };
    module.exports = solve2Linear;
  }
});

// node_modules/@jscad/modeling/src/maths/utils/index.js
var require_utils = __commonJS({
  "node_modules/@jscad/modeling/src/maths/utils/index.js"(exports, module) {
    module.exports = {
      aboutEqualNormals: require_aboutEqualNormals(),
      area: require_area(),
      cos: require_trigonometry().cos,
      interpolateBetween2DPointsForY: require_interpolateBetween2DPointsForY(),
      intersect: require_intersect(),
      sin: require_trigonometry().sin,
      solve2Linear: require_solve2Linear()
    };
  }
});

// node_modules/@jscad/modeling/src/maths/line2/intersectPointOfLines.js
var require_intersectPointOfLines = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/intersectPointOfLines.js"(exports, module) {
    var vec2 = require_vec2();
    var { solve2Linear } = require_utils();
    var intersectToLine = (line1, line2) => {
      const point = solve2Linear(line1[0], line1[1], line2[0], line2[1], line1[2], line2[2]);
      return vec2.clone(point);
    };
    module.exports = intersectToLine;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/reverse.js
var require_reverse3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/reverse.js"(exports, module) {
    var vec2 = require_vec2();
    var copy = require_copy5();
    var fromValues = require_fromValues5();
    var reverse = (out, line) => {
      const normal = vec2.negate(vec2.create(), line);
      const distance = -line[2];
      return copy(out, fromValues(normal[0], normal[1], distance));
    };
    module.exports = reverse;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/toString.js
var require_toString9 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/toString.js"(exports, module) {
    var toString = (line) => `line2: (${line[0].toFixed(7)}, ${line[1].toFixed(7)}, ${line[2].toFixed(7)})`;
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/transform.js
var require_transform9 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/transform.js"(exports, module) {
    var vec2 = require_vec2();
    var fromPoints = require_fromPoints6();
    var origin = require_origin();
    var direction = require_direction();
    var transform = (out, line, matrix) => {
      const org = origin(line);
      const dir = direction(line);
      vec2.transform(org, org, matrix);
      vec2.transform(dir, dir, matrix);
      return fromPoints(out, org, dir);
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/xAtY.js
var require_xAtY = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/xAtY.js"(exports, module) {
    var origin = require_origin();
    var xAtY = (line, y) => {
      let x = (line[2] - line[1] * y) / line[0];
      if (Number.isNaN(x)) {
        const org = origin(line);
        x = org[0];
      }
      return x;
    };
    module.exports = xAtY;
  }
});

// node_modules/@jscad/modeling/src/maths/line2/index.js
var require_line2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line2/index.js"(exports, module) {
    module.exports = {
      clone: require_clone9(),
      closestPoint: require_closestPoint(),
      copy: require_copy5(),
      create: require_create11(),
      direction: require_direction(),
      distanceToPoint: require_distanceToPoint(),
      equals: require_equals6(),
      fromPoints: require_fromPoints6(),
      fromValues: require_fromValues5(),
      intersectPointOfLines: require_intersectPointOfLines(),
      origin: require_origin(),
      reverse: require_reverse3(),
      toString: require_toString9(),
      transform: require_transform9(),
      xAtY: require_xAtY()
    };
  }
});

// node_modules/@jscad/modeling/src/maths/line3/create.js
var require_create12 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/create.js"(exports, module) {
    var vec3 = require_vec3();
    var create = () => [
      vec3.fromValues(0, 0, 0),
      // origin
      vec3.fromValues(0, 0, 1)
      // direction
    ];
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/clone.js
var require_clone10 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/clone.js"(exports, module) {
    var vec3 = require_vec3();
    var create = require_create12();
    var clone = (line) => {
      const out = create();
      vec3.copy(out[0], line[0]);
      vec3.copy(out[1], line[1]);
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/closestPoint.js
var require_closestPoint2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/closestPoint.js"(exports, module) {
    var vec3 = require_vec3();
    var closestPoint = (line, point) => {
      const lpoint = line[0];
      const ldirection = line[1];
      const a = vec3.dot(vec3.subtract(vec3.create(), point, lpoint), ldirection);
      const b = vec3.dot(ldirection, ldirection);
      const t = a / b;
      const closestpoint = vec3.scale(vec3.create(), ldirection, t);
      vec3.add(closestpoint, closestpoint, lpoint);
      return closestpoint;
    };
    module.exports = closestPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/copy.js
var require_copy6 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/copy.js"(exports, module) {
    var vec3 = require_vec3();
    var copy = (out, line) => {
      vec3.copy(out[0], line[0]);
      vec3.copy(out[1], line[1]);
      return out;
    };
    module.exports = copy;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/direction.js
var require_direction2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/direction.js"(exports, module) {
    var direction = (line) => line[1];
    module.exports = direction;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/distanceToPoint.js
var require_distanceToPoint2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/distanceToPoint.js"(exports, module) {
    var vec3 = require_vec3();
    var closestPoint = require_closestPoint2();
    var distanceToPoint = (line, point) => {
      const closest = closestPoint(line, point);
      const distancevector = vec3.subtract(vec3.create(), point, closest);
      return vec3.length(distancevector);
    };
    module.exports = distanceToPoint;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/equals.js
var require_equals7 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/equals.js"(exports, module) {
    var vec3 = require_vec3();
    var equals2 = (line1, line2) => {
      if (!vec3.equals(line1[1], line2[1]))
        return false;
      if (!vec3.equals(line1[0], line2[0]))
        return false;
      return true;
    };
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/fromPointAndDirection.js
var require_fromPointAndDirection = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/fromPointAndDirection.js"(exports, module) {
    var vec3 = require_vec3();
    var fromPointAndDirection = (out, point, direction) => {
      const unit = vec3.normalize(vec3.create(), direction);
      vec3.copy(out[0], point);
      vec3.copy(out[1], unit);
      return out;
    };
    module.exports = fromPointAndDirection;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/fromPlanes.js
var require_fromPlanes = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/fromPlanes.js"(exports, module) {
    var vec3 = require_vec3();
    var { solve2Linear } = require_utils();
    var { EPS } = require_constants();
    var fromPointAndDirection = require_fromPointAndDirection();
    var fromPlanes = (out, plane1, plane2) => {
      let direction = vec3.cross(vec3.create(), plane1, plane2);
      let length = vec3.length(direction);
      if (length < EPS) {
        throw new Error("parallel planes do not intersect");
      }
      length = 1 / length;
      direction = vec3.scale(direction, direction, length);
      const absx = Math.abs(direction[0]);
      const absy = Math.abs(direction[1]);
      const absz = Math.abs(direction[2]);
      let origin;
      let r;
      if (absx >= absy && absx >= absz) {
        r = solve2Linear(plane1[1], plane1[2], plane2[1], plane2[2], plane1[3], plane2[3]);
        origin = vec3.fromValues(0, r[0], r[1]);
      } else if (absy >= absx && absy >= absz) {
        r = solve2Linear(plane1[0], plane1[2], plane2[0], plane2[2], plane1[3], plane2[3]);
        origin = vec3.fromValues(r[0], 0, r[1]);
      } else {
        r = solve2Linear(plane1[0], plane1[1], plane2[0], plane2[1], plane1[3], plane2[3]);
        origin = vec3.fromValues(r[0], r[1], 0);
      }
      return fromPointAndDirection(out, origin, direction);
    };
    module.exports = fromPlanes;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/fromPoints.js
var require_fromPoints7 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/fromPoints.js"(exports, module) {
    var vec3 = require_vec3();
    var fromPointAndDirection = require_fromPointAndDirection();
    var fromPoints = (out, point1, point2) => {
      const direction = vec3.subtract(vec3.create(), point2, point1);
      return fromPointAndDirection(out, point1, direction);
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/intersectPointOfLineAndPlane.js
var require_intersectPointOfLineAndPlane = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/intersectPointOfLineAndPlane.js"(exports, module) {
    var vec3 = require_vec3();
    var intersectToPlane = (line, plane) => {
      const pnormal = plane;
      const pw = plane[3];
      const lpoint = line[0];
      const ldirection = line[1];
      const labda = (pw - vec3.dot(pnormal, lpoint)) / vec3.dot(pnormal, ldirection);
      const point = vec3.add(vec3.create(), lpoint, vec3.scale(vec3.create(), ldirection, labda));
      return point;
    };
    module.exports = intersectToPlane;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/origin.js
var require_origin2 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/origin.js"(exports, module) {
    var origin = (line) => line[0];
    module.exports = origin;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/reverse.js
var require_reverse4 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/reverse.js"(exports, module) {
    var vec3 = require_vec3();
    var fromPointAndDirection = require_fromPointAndDirection();
    var reverse = (out, line) => {
      const point = vec3.clone(line[0]);
      const direction = vec3.negate(vec3.create(), line[1]);
      return fromPointAndDirection(out, point, direction);
    };
    module.exports = reverse;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/toString.js
var require_toString10 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/toString.js"(exports, module) {
    var toString = (line) => {
      const point = line[0];
      const direction = line[1];
      return `line3: point: (${point[0].toFixed(7)}, ${point[1].toFixed(7)}, ${point[2].toFixed(7)}) direction: (${direction[0].toFixed(7)}, ${direction[1].toFixed(7)}, ${direction[2].toFixed(7)})`;
    };
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/transform.js
var require_transform10 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/transform.js"(exports, module) {
    var vec3 = require_vec3();
    var fromPointAndDirection = require_fromPointAndDirection();
    var transform = (out, line, matrix) => {
      const point = line[0];
      const direction = line[1];
      const pointPlusDirection = vec3.add(vec3.create(), point, direction);
      const newpoint = vec3.transform(vec3.create(), point, matrix);
      const newPointPlusDirection = vec3.transform(pointPlusDirection, pointPlusDirection, matrix);
      const newdirection = vec3.subtract(newPointPlusDirection, newPointPlusDirection, newpoint);
      return fromPointAndDirection(out, newpoint, newdirection);
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/maths/line3/index.js
var require_line3 = __commonJS({
  "node_modules/@jscad/modeling/src/maths/line3/index.js"(exports, module) {
    module.exports = {
      clone: require_clone10(),
      closestPoint: require_closestPoint2(),
      copy: require_copy6(),
      create: require_create12(),
      direction: require_direction2(),
      distanceToPoint: require_distanceToPoint2(),
      equals: require_equals7(),
      fromPlanes: require_fromPlanes(),
      fromPointAndDirection: require_fromPointAndDirection(),
      fromPoints: require_fromPoints7(),
      intersectPointOfLineAndPlane: require_intersectPointOfLineAndPlane(),
      origin: require_origin2(),
      reverse: require_reverse4(),
      toString: require_toString10(),
      transform: require_transform10()
    };
  }
});

// node_modules/@jscad/modeling/src/maths/index.js
var require_maths = __commonJS({
  "node_modules/@jscad/modeling/src/maths/index.js"(exports, module) {
    module.exports = {
      constants: require_constants(),
      line2: require_line2(),
      line3: require_line3(),
      mat4: require_mat4(),
      plane: require_plane(),
      utils: require_utils(),
      vec2: require_vec2(),
      vec3: require_vec3(),
      vec4: require_vec4()
    };
  }
});

// node_modules/@jscad/modeling/src/measurements/measureArea.js
var require_measureArea3 = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureArea.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var poly3 = require_poly3();
    var cache = /* @__PURE__ */ new WeakMap();
    var measureAreaOfPath2 = () => 0;
    var measureAreaOfGeom2 = (geometry) => {
      let area2 = cache.get(geometry);
      if (area2)
        return area2;
      const sides = geom2.toSides(geometry);
      area2 = sides.reduce((area3, side) => area3 + (side[0][0] * side[1][1] - side[0][1] * side[1][0]), 0);
      area2 *= 0.5;
      cache.set(geometry, area2);
      return area2;
    };
    var measureAreaOfGeom3 = (geometry) => {
      let area2 = cache.get(geometry);
      if (area2)
        return area2;
      const polygons = geom3.toPolygons(geometry);
      area2 = polygons.reduce((area3, polygon) => area3 + poly3.measureArea(polygon), 0);
      cache.set(geometry, area2);
      return area2;
    };
    var measureArea = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return measureAreaOfPath2(geometry);
        if (geom2.isA(geometry))
          return measureAreaOfGeom2(geometry);
        if (geom3.isA(geometry))
          return measureAreaOfGeom3(geometry);
        return 0;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureArea;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureAggregateArea.js
var require_measureAggregateArea = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureAggregateArea.js"(exports, module) {
    var flatten2 = require_flatten();
    var measureArea = require_measureArea3();
    var measureAggregateArea = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("measureAggregateArea: no geometries supplied");
      const areas = measureArea(geometries2);
      if (geometries2.length === 1) {
        return areas;
      }
      const result = 0;
      return areas.reduce((result2, area2) => result2 + area2, result);
    };
    module.exports = measureAggregateArea;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureBoundingBox.js
var require_measureBoundingBox2 = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureBoundingBox.js"(exports, module) {
    var flatten2 = require_flatten();
    var vec2 = require_vec2();
    var vec3 = require_vec3();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var poly3 = require_poly3();
    var cache = /* @__PURE__ */ new WeakMap();
    var measureBoundingBoxOfPath2 = (geometry) => {
      let boundingBox4 = cache.get(geometry);
      if (boundingBox4)
        return boundingBox4;
      const points = path2.toPoints(geometry);
      let minpoint;
      if (points.length === 0) {
        minpoint = vec2.create();
      } else {
        minpoint = vec2.clone(points[0]);
      }
      let maxpoint = vec2.clone(minpoint);
      points.forEach((point) => {
        vec2.min(minpoint, minpoint, point);
        vec2.max(maxpoint, maxpoint, point);
      });
      minpoint = [minpoint[0], minpoint[1], 0];
      maxpoint = [maxpoint[0], maxpoint[1], 0];
      boundingBox4 = [minpoint, maxpoint];
      cache.set(geometry, boundingBox4);
      return boundingBox4;
    };
    var measureBoundingBoxOfGeom2 = (geometry) => {
      let boundingBox4 = cache.get(geometry);
      if (boundingBox4)
        return boundingBox4;
      const points = geom2.toPoints(geometry);
      let minpoint;
      if (points.length === 0) {
        minpoint = vec2.create();
      } else {
        minpoint = vec2.clone(points[0]);
      }
      let maxpoint = vec2.clone(minpoint);
      points.forEach((point) => {
        vec2.min(minpoint, minpoint, point);
        vec2.max(maxpoint, maxpoint, point);
      });
      minpoint = [minpoint[0], minpoint[1], 0];
      maxpoint = [maxpoint[0], maxpoint[1], 0];
      boundingBox4 = [minpoint, maxpoint];
      cache.set(geometry, boundingBox4);
      return boundingBox4;
    };
    var measureBoundingBoxOfGeom3 = (geometry) => {
      let boundingBox4 = cache.get(geometry);
      if (boundingBox4)
        return boundingBox4;
      const polygons = geom3.toPolygons(geometry);
      let minpoint = vec3.create();
      if (polygons.length > 0) {
        const points = poly3.toPoints(polygons[0]);
        vec3.copy(minpoint, points[0]);
      }
      let maxpoint = vec3.clone(minpoint);
      polygons.forEach((polygon) => {
        poly3.toPoints(polygon).forEach((point) => {
          vec3.min(minpoint, minpoint, point);
          vec3.max(maxpoint, maxpoint, point);
        });
      });
      minpoint = [minpoint[0], minpoint[1], minpoint[2]];
      maxpoint = [maxpoint[0], maxpoint[1], maxpoint[2]];
      boundingBox4 = [minpoint, maxpoint];
      cache.set(geometry, boundingBox4);
      return boundingBox4;
    };
    var measureBoundingBox = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return measureBoundingBoxOfPath2(geometry);
        if (geom2.isA(geometry))
          return measureBoundingBoxOfGeom2(geometry);
        if (geom3.isA(geometry))
          return measureBoundingBoxOfGeom3(geometry);
        return [[0, 0, 0], [0, 0, 0]];
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureBoundingBox;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureAggregateBoundingBox.js
var require_measureAggregateBoundingBox = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureAggregateBoundingBox.js"(exports, module) {
    var flatten2 = require_flatten();
    var vec3min = require_min();
    var vec3max = require_max();
    var measureBoundingBox = require_measureBoundingBox2();
    var measureAggregateBoundingBox = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("measureAggregateBoundingBox: no geometries supplied");
      const bounds = measureBoundingBox(geometries2);
      if (geometries2.length === 1) {
        return bounds;
      }
      const result = [[Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE]];
      return bounds.reduce((result2, item) => {
        result2 = [vec3min(result2[0], result2[0], item[0]), vec3max(result2[1], result2[1], item[1])];
        return result2;
      }, result);
    };
    module.exports = measureAggregateBoundingBox;
  }
});

// node_modules/@jscad/modeling/src/measurements/calculateEpsilonFromBounds.js
var require_calculateEpsilonFromBounds = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/calculateEpsilonFromBounds.js"(exports, module) {
    var { EPS } = require_constants();
    var calculateEpsilonFromBounds = (bounds, dimensions) => {
      let total = 0;
      for (let i = 0; i < dimensions; i++) {
        total += bounds[1][i] - bounds[0][i];
      }
      return EPS * total / dimensions;
    };
    module.exports = calculateEpsilonFromBounds;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureAggregateEpsilon.js
var require_measureAggregateEpsilon = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureAggregateEpsilon.js"(exports, module) {
    var flatten2 = require_flatten();
    var measureAggregateBoundingBox = require_measureAggregateBoundingBox();
    var calculateEpsilonFromBounds = require_calculateEpsilonFromBounds();
    var { geom2, geom3, path2 } = require_geometries();
    var measureAggregateEpsilon = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("measureAggregateEpsilon: no geometries supplied");
      const bounds = measureAggregateBoundingBox(geometries2);
      let dimensions = 0;
      dimensions = geometries2.reduce((dimensions2, geometry) => {
        if (path2.isA(geometry) || geom2.isA(geometry))
          return Math.max(dimensions2, 2);
        if (geom3.isA(geometry))
          return Math.max(dimensions2, 3);
        return 0;
      }, dimensions);
      return calculateEpsilonFromBounds(bounds, dimensions);
    };
    module.exports = measureAggregateEpsilon;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureVolume.js
var require_measureVolume = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureVolume.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var poly3 = require_poly3();
    var cache = /* @__PURE__ */ new WeakMap();
    var measureVolumeOfPath2 = () => 0;
    var measureVolumeOfGeom2 = () => 0;
    var measureVolumeOfGeom3 = (geometry) => {
      let volume = cache.get(geometry);
      if (volume)
        return volume;
      const polygons = geom3.toPolygons(geometry);
      volume = polygons.reduce((volume2, polygon) => volume2 + poly3.measureSignedVolume(polygon), 0);
      cache.set(geometry, volume);
      return volume;
    };
    var measureVolume = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return measureVolumeOfPath2(geometry);
        if (geom2.isA(geometry))
          return measureVolumeOfGeom2(geometry);
        if (geom3.isA(geometry))
          return measureVolumeOfGeom3(geometry);
        return 0;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureVolume;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureAggregateVolume.js
var require_measureAggregateVolume = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureAggregateVolume.js"(exports, module) {
    var flatten2 = require_flatten();
    var measureVolume = require_measureVolume();
    var measureAggregateVolume = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("measureAggregateVolume: no geometries supplied");
      const volumes = measureVolume(geometries2);
      if (geometries2.length === 1) {
        return volumes;
      }
      const result = 0;
      return volumes.reduce((result2, volume) => result2 + volume, result);
    };
    module.exports = measureAggregateVolume;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureBoundingSphere.js
var require_measureBoundingSphere2 = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureBoundingSphere.js"(exports, module) {
    var flatten2 = require_flatten();
    var vec2 = require_vec2();
    var vec3 = require_vec3();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var poly3 = require_poly3();
    var cacheOfBoundingSpheres = /* @__PURE__ */ new WeakMap();
    var measureBoundingSphereOfPath2 = (geometry) => {
      let boundingSphere = cacheOfBoundingSpheres.get(geometry);
      if (boundingSphere !== void 0)
        return boundingSphere;
      const centroid = vec3.create();
      let radius = 0;
      const points = path2.toPoints(geometry);
      if (points.length > 0) {
        let numPoints = 0;
        const temp5 = vec3.create();
        points.forEach((point) => {
          vec3.add(centroid, centroid, vec3.fromVec2(temp5, point, 0));
          numPoints++;
        });
        vec3.scale(centroid, centroid, 1 / numPoints);
        points.forEach((point) => {
          radius = Math.max(radius, vec2.squaredDistance(centroid, point));
        });
        radius = Math.sqrt(radius);
      }
      boundingSphere = [centroid, radius];
      cacheOfBoundingSpheres.set(geometry, boundingSphere);
      return boundingSphere;
    };
    var measureBoundingSphereOfGeom2 = (geometry) => {
      let boundingSphere = cacheOfBoundingSpheres.get(geometry);
      if (boundingSphere !== void 0)
        return boundingSphere;
      const centroid = vec3.create();
      let radius = 0;
      const sides = geom2.toSides(geometry);
      if (sides.length > 0) {
        let numPoints = 0;
        const temp5 = vec3.create();
        sides.forEach((side) => {
          vec3.add(centroid, centroid, vec3.fromVec2(temp5, side[0], 0));
          numPoints++;
        });
        vec3.scale(centroid, centroid, 1 / numPoints);
        sides.forEach((side) => {
          radius = Math.max(radius, vec2.squaredDistance(centroid, side[0]));
        });
        radius = Math.sqrt(radius);
      }
      boundingSphere = [centroid, radius];
      cacheOfBoundingSpheres.set(geometry, boundingSphere);
      return boundingSphere;
    };
    var measureBoundingSphereOfGeom3 = (geometry) => {
      let boundingSphere = cacheOfBoundingSpheres.get(geometry);
      if (boundingSphere !== void 0)
        return boundingSphere;
      const centroid = vec3.create();
      let radius = 0;
      const polygons = geom3.toPolygons(geometry);
      if (polygons.length > 0) {
        let numPoints = 0;
        polygons.forEach((polygon) => {
          poly3.toPoints(polygon).forEach((point) => {
            vec3.add(centroid, centroid, point);
            numPoints++;
          });
        });
        vec3.scale(centroid, centroid, 1 / numPoints);
        polygons.forEach((polygon) => {
          poly3.toPoints(polygon).forEach((point) => {
            radius = Math.max(radius, vec3.squaredDistance(centroid, point));
          });
        });
        radius = Math.sqrt(radius);
      }
      boundingSphere = [centroid, radius];
      cacheOfBoundingSpheres.set(geometry, boundingSphere);
      return boundingSphere;
    };
    var measureBoundingSphere = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return measureBoundingSphereOfPath2(geometry);
        if (geom2.isA(geometry))
          return measureBoundingSphereOfGeom2(geometry);
        if (geom3.isA(geometry))
          return measureBoundingSphereOfGeom3(geometry);
        return [[0, 0, 0], 0];
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureBoundingSphere;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureCenter.js
var require_measureCenter = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureCenter.js"(exports, module) {
    var flatten2 = require_flatten();
    var measureBoundingBox = require_measureBoundingBox2();
    var measureCenter = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const results = geometries2.map((geometry) => {
        const bounds = measureBoundingBox(geometry);
        return [
          bounds[0][0] + (bounds[1][0] - bounds[0][0]) / 2,
          bounds[0][1] + (bounds[1][1] - bounds[0][1]) / 2,
          bounds[0][2] + (bounds[1][2] - bounds[0][2]) / 2
        ];
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureCenter;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureCenterOfMass.js
var require_measureCenterOfMass = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureCenterOfMass.js"(exports, module) {
    var flatten2 = require_flatten();
    var vec3 = require_vec3();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var cacheOfCenterOfMass = /* @__PURE__ */ new WeakMap();
    var measureCenterOfMassGeom2 = (geometry) => {
      let centerOfMass = cacheOfCenterOfMass.get(geometry);
      if (centerOfMass !== void 0)
        return centerOfMass;
      const sides = geom2.toSides(geometry);
      let area2 = 0;
      let x = 0;
      let y = 0;
      if (sides.length > 0) {
        for (let i = 0; i < sides.length; i++) {
          const p1 = sides[i][0];
          const p2 = sides[i][1];
          const a = p1[0] * p2[1] - p1[1] * p2[0];
          area2 += a;
          x += (p1[0] + p2[0]) * a;
          y += (p1[1] + p2[1]) * a;
        }
        area2 /= 2;
        const f = 1 / (area2 * 6);
        x *= f;
        y *= f;
      }
      centerOfMass = vec3.fromValues(x, y, 0);
      cacheOfCenterOfMass.set(geometry, centerOfMass);
      return centerOfMass;
    };
    var measureCenterOfMassGeom3 = (geometry) => {
      let centerOfMass = cacheOfCenterOfMass.get(geometry);
      if (centerOfMass !== void 0)
        return centerOfMass;
      centerOfMass = vec3.create();
      const polygons = geom3.toPolygons(geometry);
      if (polygons.length === 0)
        return centerOfMass;
      let totalVolume = 0;
      const vector = vec3.create();
      polygons.forEach((polygon) => {
        const vertices = polygon.vertices;
        for (let i = 0; i < vertices.length - 2; i++) {
          vec3.cross(vector, vertices[i + 1], vertices[i + 2]);
          const volume = vec3.dot(vertices[0], vector) / 6;
          totalVolume += volume;
          vec3.add(vector, vertices[0], vertices[i + 1]);
          vec3.add(vector, vector, vertices[i + 2]);
          const weightedCenter = vec3.scale(vector, vector, 1 / 4 * volume);
          vec3.add(centerOfMass, centerOfMass, weightedCenter);
        }
      });
      vec3.scale(centerOfMass, centerOfMass, 1 / totalVolume);
      cacheOfCenterOfMass.set(geometry, centerOfMass);
      return centerOfMass;
    };
    var measureCenterOfMass = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const results = geometries2.map((geometry) => {
        if (geom2.isA(geometry))
          return measureCenterOfMassGeom2(geometry);
        if (geom3.isA(geometry))
          return measureCenterOfMassGeom3(geometry);
        return [0, 0, 0];
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureCenterOfMass;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureDimensions.js
var require_measureDimensions = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureDimensions.js"(exports, module) {
    var flatten2 = require_flatten();
    var measureBoundingBox = require_measureBoundingBox2();
    var measureDimensions = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const results = geometries2.map((geometry) => {
        const boundingBox4 = measureBoundingBox(geometry);
        return [
          boundingBox4[1][0] - boundingBox4[0][0],
          boundingBox4[1][1] - boundingBox4[0][1],
          boundingBox4[1][2] - boundingBox4[0][2]
        ];
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureDimensions;
  }
});

// node_modules/@jscad/modeling/src/measurements/measureEpsilon.js
var require_measureEpsilon = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/measureEpsilon.js"(exports, module) {
    var flatten2 = require_flatten();
    var { geom2, geom3, path2 } = require_geometries();
    var calculateEpsilonFromBounds = require_calculateEpsilonFromBounds();
    var measureBoundingBox = require_measureBoundingBox2();
    var measureEpsilonOfPath2 = (geometry) => calculateEpsilonFromBounds(measureBoundingBox(geometry), 2);
    var measureEpsilonOfGeom2 = (geometry) => calculateEpsilonFromBounds(measureBoundingBox(geometry), 2);
    var measureEpsilonOfGeom3 = (geometry) => calculateEpsilonFromBounds(measureBoundingBox(geometry), 3);
    var measureEpsilon = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return measureEpsilonOfPath2(geometry);
        if (geom2.isA(geometry))
          return measureEpsilonOfGeom2(geometry);
        if (geom3.isA(geometry))
          return measureEpsilonOfGeom3(geometry);
        return 0;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = measureEpsilon;
  }
});

// node_modules/@jscad/modeling/src/measurements/index.js
var require_measurements = __commonJS({
  "node_modules/@jscad/modeling/src/measurements/index.js"(exports, module) {
    module.exports = {
      measureAggregateArea: require_measureAggregateArea(),
      measureAggregateBoundingBox: require_measureAggregateBoundingBox(),
      measureAggregateEpsilon: require_measureAggregateEpsilon(),
      measureAggregateVolume: require_measureAggregateVolume(),
      measureArea: require_measureArea3(),
      measureBoundingBox: require_measureBoundingBox2(),
      measureBoundingSphere: require_measureBoundingSphere2(),
      measureCenter: require_measureCenter(),
      measureCenterOfMass: require_measureCenterOfMass(),
      measureDimensions: require_measureDimensions(),
      measureEpsilon: require_measureEpsilon(),
      measureVolume: require_measureVolume()
    };
  }
});

// node_modules/@jscad/modeling/src/primitives/commonChecks.js
var require_commonChecks = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/commonChecks.js"(exports, module) {
    var isNumberArray = (array, dimension) => {
      if (Array.isArray(array) && array.length >= dimension) {
        return array.every((n) => Number.isFinite(n));
      }
      return false;
    };
    var isGT = (value, constant) => Number.isFinite(value) && value > constant;
    var isGTE = (value, constant) => Number.isFinite(value) && value >= constant;
    module.exports = {
      isNumberArray,
      isGT,
      isGTE
    };
  }
});

// node_modules/@jscad/modeling/src/primitives/arc.js
var require_arc = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/arc.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var vec2 = require_vec2();
    var path2 = require_path2();
    var { isGT, isGTE, isNumberArray } = require_commonChecks();
    var arc = (options) => {
      const defaults = {
        center: [0, 0],
        radius: 1,
        startAngle: 0,
        endAngle: TAU,
        makeTangent: false,
        segments: 32
      };
      let { center, radius, startAngle, endAngle, makeTangent, segments } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 2))
        throw new Error("center must be an array of X and Y values");
      if (!isGT(radius, 0))
        throw new Error("radius must be greater than zero");
      if (!isGTE(startAngle, 0))
        throw new Error("startAngle must be positive");
      if (!isGTE(endAngle, 0))
        throw new Error("endAngle must be positive");
      if (!isGTE(segments, 4))
        throw new Error("segments must be four or more");
      startAngle = startAngle % TAU;
      endAngle = endAngle % TAU;
      let rotation = TAU;
      if (startAngle < endAngle) {
        rotation = endAngle - startAngle;
      }
      if (startAngle > endAngle) {
        rotation = endAngle + (TAU - startAngle);
      }
      const minangle = Math.acos((radius * radius + radius * radius - EPS * EPS) / (2 * radius * radius));
      const centerv = vec2.clone(center);
      let point;
      const pointArray = [];
      if (rotation < minangle) {
        point = vec2.fromAngleRadians(vec2.create(), startAngle);
        vec2.scale(point, point, radius);
        vec2.add(point, point, centerv);
        pointArray.push(point);
      } else {
        const numsteps = Math.max(1, Math.floor(segments * (rotation / TAU))) + 1;
        let edgestepsize = numsteps * 0.5 / rotation;
        if (edgestepsize > 0.25)
          edgestepsize = 0.25;
        const totalsteps = makeTangent ? numsteps + 2 : numsteps;
        for (let i = 0; i <= totalsteps; i++) {
          let step = i;
          if (makeTangent) {
            step = (i - 1) * (numsteps - 2 * edgestepsize) / numsteps + edgestepsize;
            if (step < 0)
              step = 0;
            if (step > numsteps)
              step = numsteps;
          }
          const angle = startAngle + step * (rotation / numsteps);
          point = vec2.fromAngleRadians(vec2.create(), angle);
          vec2.scale(point, point, radius);
          vec2.add(point, point, centerv);
          pointArray.push(point);
        }
      }
      return path2.fromPoints({ closed: false }, pointArray);
    };
    module.exports = arc;
  }
});

// node_modules/@jscad/modeling/src/primitives/ellipse.js
var require_ellipse = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/ellipse.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var { sin, cos } = require_trigonometry();
    var { isGTE, isNumberArray } = require_commonChecks();
    var ellipse = (options) => {
      const defaults = {
        center: [0, 0],
        radius: [1, 1],
        startAngle: 0,
        endAngle: TAU,
        segments: 32
      };
      let { center, radius, startAngle, endAngle, segments } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 2))
        throw new Error("center must be an array of X and Y values");
      if (!isNumberArray(radius, 2))
        throw new Error("radius must be an array of X and Y values");
      if (!radius.every((n) => n > 0))
        throw new Error("radius values must be greater than zero");
      if (!isGTE(startAngle, 0))
        throw new Error("startAngle must be positive");
      if (!isGTE(endAngle, 0))
        throw new Error("endAngle must be positive");
      if (!isGTE(segments, 3))
        throw new Error("segments must be three or more");
      startAngle = startAngle % TAU;
      endAngle = endAngle % TAU;
      let rotation = TAU;
      if (startAngle < endAngle) {
        rotation = endAngle - startAngle;
      }
      if (startAngle > endAngle) {
        rotation = endAngle + (TAU - startAngle);
      }
      const minradius = Math.min(radius[0], radius[1]);
      const minangle = Math.acos((minradius * minradius + minradius * minradius - EPS * EPS) / (2 * minradius * minradius));
      if (rotation < minangle)
        throw new Error("startAngle and endAngle do not define a significant rotation");
      segments = Math.floor(segments * (rotation / TAU));
      const centerv = vec2.clone(center);
      const step = rotation / segments;
      const points = [];
      segments = rotation < TAU ? segments + 1 : segments;
      for (let i = 0; i < segments; i++) {
        const angle = step * i + startAngle;
        const point = vec2.fromValues(radius[0] * cos(angle), radius[1] * sin(angle));
        vec2.add(point, centerv, point);
        points.push(point);
      }
      if (rotation < TAU)
        points.push(centerv);
      return geom2.fromPoints(points);
    };
    module.exports = ellipse;
  }
});

// node_modules/@jscad/modeling/src/primitives/circle.js
var require_circle = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/circle.js"(exports, module) {
    var { TAU } = require_constants();
    var ellipse = require_ellipse();
    var { isGT } = require_commonChecks();
    var circle = (options) => {
      const defaults = {
        center: [0, 0],
        radius: 1,
        startAngle: 0,
        endAngle: TAU,
        segments: 32
      };
      let { center, radius, startAngle, endAngle, segments } = Object.assign({}, defaults, options);
      if (!isGT(radius, 0))
        throw new Error("radius must be greater than zero");
      radius = [radius, radius];
      return ellipse({ center, radius, startAngle, endAngle, segments });
    };
    module.exports = circle;
  }
});

// node_modules/@jscad/modeling/src/primitives/cuboid.js
var require_cuboid = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/cuboid.js"(exports, module) {
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var { isNumberArray } = require_commonChecks();
    var cuboid = (options) => {
      const defaults = {
        center: [0, 0, 0],
        size: [2, 2, 2]
      };
      const { center, size } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 3))
        throw new Error("center must be an array of X, Y and Z values");
      if (!isNumberArray(size, 3))
        throw new Error("size must be an array of width, depth and height values");
      if (!size.every((n) => n > 0))
        throw new Error("size values must be greater than zero");
      const result = geom3.create(
        // adjust a basic shape to size
        [
          [[0, 4, 6, 2], [-1, 0, 0]],
          [[1, 3, 7, 5], [1, 0, 0]],
          [[0, 1, 5, 4], [0, -1, 0]],
          [[2, 6, 7, 3], [0, 1, 0]],
          [[0, 2, 3, 1], [0, 0, -1]],
          [[4, 5, 7, 6], [0, 0, 1]]
        ].map((info) => {
          const points = info[0].map((i) => {
            const pos = [
              center[0] + size[0] / 2 * (2 * !!(i & 1) - 1),
              center[1] + size[1] / 2 * (2 * !!(i & 2) - 1),
              center[2] + size[2] / 2 * (2 * !!(i & 4) - 1)
            ];
            return pos;
          });
          return poly3.create(points);
        })
      );
      return result;
    };
    module.exports = cuboid;
  }
});

// node_modules/@jscad/modeling/src/primitives/cube.js
var require_cube = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/cube.js"(exports, module) {
    var cuboid = require_cuboid();
    var { isGT } = require_commonChecks();
    var cube = (options) => {
      const defaults = {
        center: [0, 0, 0],
        size: 2
      };
      let { center, size } = Object.assign({}, defaults, options);
      if (!isGT(size, 0))
        throw new Error("size must be greater than zero");
      size = [size, size, size];
      return cuboid({ center, size });
    };
    module.exports = cube;
  }
});

// node_modules/@jscad/modeling/src/primitives/cylinderElliptic.js
var require_cylinderElliptic = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/cylinderElliptic.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var vec3 = require_vec3();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var { sin, cos } = require_trigonometry();
    var { isGT, isGTE, isNumberArray } = require_commonChecks();
    var cylinderElliptic = (options) => {
      const defaults = {
        center: [0, 0, 0],
        height: 2,
        startRadius: [1, 1],
        startAngle: 0,
        endRadius: [1, 1],
        endAngle: TAU,
        segments: 32
      };
      let { center, height, startRadius, startAngle, endRadius, endAngle, segments } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 3))
        throw new Error("center must be an array of X, Y and Z values");
      if (!isGT(height, 0))
        throw new Error("height must be greater then zero");
      if (!isNumberArray(startRadius, 2))
        throw new Error("startRadius must be an array of X and Y values");
      if (!startRadius.every((n) => n >= 0))
        throw new Error("startRadius values must be positive");
      if (!isNumberArray(endRadius, 2))
        throw new Error("endRadius must be an array of X and Y values");
      if (!endRadius.every((n) => n >= 0))
        throw new Error("endRadius values must be positive");
      if (endRadius.every((n) => n === 0) && startRadius.every((n) => n === 0))
        throw new Error("at least one radius must be positive");
      if (!isGTE(startAngle, 0))
        throw new Error("startAngle must be positive");
      if (!isGTE(endAngle, 0))
        throw new Error("endAngle must be positive");
      if (!isGTE(segments, 4))
        throw new Error("segments must be four or more");
      startAngle = startAngle % TAU;
      endAngle = endAngle % TAU;
      let rotation = TAU;
      if (startAngle < endAngle) {
        rotation = endAngle - startAngle;
      }
      if (startAngle > endAngle) {
        rotation = endAngle + (TAU - startAngle);
      }
      const minradius = Math.min(startRadius[0], startRadius[1], endRadius[0], endRadius[1]);
      const minangle = Math.acos((minradius * minradius + minradius * minradius - EPS * EPS) / (2 * minradius * minradius));
      if (rotation < minangle)
        throw new Error("startAngle and endAngle do not define a significant rotation");
      const slices = Math.floor(segments * (rotation / TAU));
      const start = vec3.fromValues(0, 0, -(height / 2));
      const end = vec3.fromValues(0, 0, height / 2);
      const ray2 = vec3.subtract(vec3.create(), end, start);
      const axisX = vec3.fromValues(1, 0, 0);
      const axisY = vec3.fromValues(0, 1, 0);
      const v1 = vec3.create();
      const v2 = vec3.create();
      const v3 = vec3.create();
      const point = (stack, slice, radius) => {
        const angle = slice * rotation + startAngle;
        vec3.scale(v1, axisX, radius[0] * cos(angle));
        vec3.scale(v2, axisY, radius[1] * sin(angle));
        vec3.add(v1, v1, v2);
        vec3.scale(v3, ray2, stack);
        vec3.add(v3, v3, start);
        return vec3.add(vec3.create(), v1, v3);
      };
      const fromPoints = (...points) => {
        const newpoints = points.map((point2) => vec3.add(vec3.create(), point2, center));
        return poly3.create(newpoints);
      };
      const polygons = [];
      for (let i = 0; i < slices; i++) {
        const t0 = i / slices;
        let t1 = (i + 1) / slices;
        if (rotation === TAU && i === slices - 1)
          t1 = 0;
        if (endRadius[0] === startRadius[0] && endRadius[1] === startRadius[1]) {
          polygons.push(fromPoints(start, point(0, t1, endRadius), point(0, t0, endRadius)));
          polygons.push(fromPoints(point(0, t1, endRadius), point(1, t1, endRadius), point(1, t0, endRadius), point(0, t0, endRadius)));
          polygons.push(fromPoints(end, point(1, t0, endRadius), point(1, t1, endRadius)));
        } else {
          if (startRadius[0] > 0 && startRadius[1] > 0) {
            polygons.push(fromPoints(start, point(0, t1, startRadius), point(0, t0, startRadius)));
          }
          if (startRadius[0] > 0 || startRadius[1] > 0) {
            polygons.push(fromPoints(point(0, t0, startRadius), point(0, t1, startRadius), point(1, t0, endRadius)));
          }
          if (endRadius[0] > 0 && endRadius[1] > 0) {
            polygons.push(fromPoints(end, point(1, t0, endRadius), point(1, t1, endRadius)));
          }
          if (endRadius[0] > 0 || endRadius[1] > 0) {
            polygons.push(fromPoints(point(1, t0, endRadius), point(0, t1, startRadius), point(1, t1, endRadius)));
          }
        }
      }
      if (rotation < TAU) {
        polygons.push(fromPoints(start, point(0, 0, startRadius), end));
        polygons.push(fromPoints(point(0, 0, startRadius), point(1, 0, endRadius), end));
        polygons.push(fromPoints(start, end, point(0, 1, startRadius)));
        polygons.push(fromPoints(point(0, 1, startRadius), end, point(1, 1, endRadius)));
      }
      const result = geom3.create(polygons);
      return result;
    };
    module.exports = cylinderElliptic;
  }
});

// node_modules/@jscad/modeling/src/primitives/cylinder.js
var require_cylinder = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/cylinder.js"(exports, module) {
    var cylinderElliptic = require_cylinderElliptic();
    var { isGT } = require_commonChecks();
    var cylinder = (options) => {
      const defaults = {
        center: [0, 0, 0],
        height: 2,
        radius: 1,
        segments: 32
      };
      const { center, height, radius, segments } = Object.assign({}, defaults, options);
      if (!isGT(radius, 0))
        throw new Error("radius must be greater than zero");
      const newoptions = {
        center,
        height,
        startRadius: [radius, radius],
        endRadius: [radius, radius],
        segments
      };
      return cylinderElliptic(newoptions);
    };
    module.exports = cylinder;
  }
});

// node_modules/@jscad/modeling/src/primitives/ellipsoid.js
var require_ellipsoid = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/ellipsoid.js"(exports, module) {
    var { TAU } = require_constants();
    var vec3 = require_vec3();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var { sin, cos } = require_trigonometry();
    var { isGTE, isNumberArray } = require_commonChecks();
    var ellipsoid = (options) => {
      const defaults = {
        center: [0, 0, 0],
        radius: [1, 1, 1],
        segments: 32,
        axes: [[1, 0, 0], [0, -1, 0], [0, 0, 1]]
      };
      const { center, radius, segments, axes } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 3))
        throw new Error("center must be an array of X, Y and Z values");
      if (!isNumberArray(radius, 3))
        throw new Error("radius must be an array of X, Y and Z values");
      if (!radius.every((n) => n > 0))
        throw new Error("radius values must be greater than zero");
      if (!isGTE(segments, 4))
        throw new Error("segments must be four or more");
      const xvector = vec3.scale(vec3.create(), vec3.normalize(vec3.create(), axes[0]), radius[0]);
      const yvector = vec3.scale(vec3.create(), vec3.normalize(vec3.create(), axes[1]), radius[1]);
      const zvector = vec3.scale(vec3.create(), vec3.normalize(vec3.create(), axes[2]), radius[2]);
      const qsegments = Math.round(segments / 4);
      let prevcylinderpoint;
      const polygons = [];
      const p1 = vec3.create();
      const p2 = vec3.create();
      for (let slice1 = 0; slice1 <= segments; slice1++) {
        const angle = TAU * slice1 / segments;
        const cylinderpoint = vec3.add(vec3.create(), vec3.scale(p1, xvector, cos(angle)), vec3.scale(p2, yvector, sin(angle)));
        if (slice1 > 0) {
          let prevcospitch, prevsinpitch;
          for (let slice2 = 0; slice2 <= qsegments; slice2++) {
            const pitch = TAU / 4 * slice2 / qsegments;
            const cospitch = cos(pitch);
            const sinpitch = sin(pitch);
            if (slice2 > 0) {
              let points = [];
              let point;
              point = vec3.subtract(vec3.create(), vec3.scale(p1, prevcylinderpoint, prevcospitch), vec3.scale(p2, zvector, prevsinpitch));
              points.push(vec3.add(point, point, center));
              point = vec3.subtract(vec3.create(), vec3.scale(p1, cylinderpoint, prevcospitch), vec3.scale(p2, zvector, prevsinpitch));
              points.push(vec3.add(point, point, center));
              if (slice2 < qsegments) {
                point = vec3.subtract(vec3.create(), vec3.scale(p1, cylinderpoint, cospitch), vec3.scale(p2, zvector, sinpitch));
                points.push(vec3.add(point, point, center));
              }
              point = vec3.subtract(vec3.create(), vec3.scale(p1, prevcylinderpoint, cospitch), vec3.scale(p2, zvector, sinpitch));
              points.push(vec3.add(point, point, center));
              polygons.push(poly3.create(points));
              points = [];
              point = vec3.add(vec3.create(), vec3.scale(p1, prevcylinderpoint, prevcospitch), vec3.scale(p2, zvector, prevsinpitch));
              points.push(vec3.add(vec3.create(), center, point));
              point = vec3.add(point, vec3.scale(p1, cylinderpoint, prevcospitch), vec3.scale(p2, zvector, prevsinpitch));
              points.push(vec3.add(vec3.create(), center, point));
              if (slice2 < qsegments) {
                point = vec3.add(point, vec3.scale(p1, cylinderpoint, cospitch), vec3.scale(p2, zvector, sinpitch));
                points.push(vec3.add(vec3.create(), center, point));
              }
              point = vec3.add(point, vec3.scale(p1, prevcylinderpoint, cospitch), vec3.scale(p2, zvector, sinpitch));
              points.push(vec3.add(vec3.create(), center, point));
              points.reverse();
              polygons.push(poly3.create(points));
            }
            prevcospitch = cospitch;
            prevsinpitch = sinpitch;
          }
        }
        prevcylinderpoint = cylinderpoint;
      }
      return geom3.create(polygons);
    };
    module.exports = ellipsoid;
  }
});

// node_modules/@jscad/modeling/src/primitives/polyhedron.js
var require_polyhedron = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/polyhedron.js"(exports, module) {
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var { isNumberArray } = require_commonChecks();
    var polyhedron = (options) => {
      const defaults = {
        points: [],
        faces: [],
        colors: void 0,
        orientation: "outward"
      };
      const { points, faces, colors, orientation } = Object.assign({}, defaults, options);
      if (!(Array.isArray(points) && Array.isArray(faces))) {
        throw new Error("points and faces must be arrays");
      }
      if (points.length < 3) {
        throw new Error("three or more points are required");
      }
      if (faces.length < 1) {
        throw new Error("one or more faces are required");
      }
      if (colors) {
        if (!Array.isArray(colors)) {
          throw new Error("colors must be an array");
        }
        if (colors.length !== faces.length) {
          throw new Error("faces and colors must have the same length");
        }
      }
      points.forEach((point, i) => {
        if (!isNumberArray(point, 3))
          throw new Error(`point ${i} must be an array of X, Y, Z values`);
      });
      faces.forEach((face, i) => {
        if (face.length < 3)
          throw new Error(`face ${i} must contain 3 or more indexes`);
        if (!isNumberArray(face, face.length))
          throw new Error(`face ${i} must be an array of numbers`);
      });
      if (orientation !== "outward") {
        faces.forEach((face) => face.reverse());
      }
      const polygons = faces.map((face, findex) => {
        const polygon = poly3.create(face.map((pindex) => points[pindex]));
        if (colors && colors[findex])
          polygon.color = colors[findex];
        return polygon;
      });
      return geom3.create(polygons);
    };
    module.exports = polyhedron;
  }
});

// node_modules/@jscad/modeling/src/primitives/geodesicSphere.js
var require_geodesicSphere = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/geodesicSphere.js"(exports, module) {
    var mat4 = require_mat4();
    var vec3 = require_vec3();
    var geom3 = require_geom3();
    var polyhedron = require_polyhedron();
    var { isGT, isGTE } = require_commonChecks();
    var geodesicSphere = (options) => {
      const defaults = {
        radius: 1,
        frequency: 6
      };
      let { radius, frequency } = Object.assign({}, defaults, options);
      if (!isGT(radius, 0))
        throw new Error("radius must be greater than zero");
      if (!isGTE(frequency, 6))
        throw new Error("frequency must be six or more");
      frequency = Math.floor(frequency / 6);
      const ci = [
        // hard-coded data of icosahedron (20 faces, all triangles)
        [0.850651, 0, -0.525731],
        [0.850651, -0, 0.525731],
        [-0.850651, -0, 0.525731],
        [-0.850651, 0, -0.525731],
        [0, -0.525731, 0.850651],
        [0, 0.525731, 0.850651],
        [0, 0.525731, -0.850651],
        [0, -0.525731, -0.850651],
        [-0.525731, -0.850651, -0],
        [0.525731, -0.850651, -0],
        [0.525731, 0.850651, 0],
        [-0.525731, 0.850651, 0]
      ];
      const ti = [
        [0, 9, 1],
        [1, 10, 0],
        [6, 7, 0],
        [10, 6, 0],
        [7, 9, 0],
        [5, 1, 4],
        [4, 1, 9],
        [5, 10, 1],
        [2, 8, 3],
        [3, 11, 2],
        [2, 5, 4],
        [4, 8, 2],
        [2, 11, 5],
        [3, 7, 6],
        [6, 11, 3],
        [8, 7, 3],
        [9, 8, 4],
        [11, 10, 5],
        [10, 11, 6],
        [8, 9, 7]
      ];
      const geodesicSubDivide = (p, frequency2, offset2) => {
        const p1 = p[0];
        const p2 = p[1];
        const p3 = p[2];
        let n = offset2;
        const c = [];
        const f = [];
        for (let i = 0; i < frequency2; i++) {
          for (let j = 0; j < frequency2 - i; j++) {
            const t0 = i / frequency2;
            const t1 = (i + 1) / frequency2;
            const s0 = j / (frequency2 - i);
            const s1 = (j + 1) / (frequency2 - i);
            const s2 = frequency2 - i - 1 ? j / (frequency2 - i - 1) : 1;
            const q = [];
            q[0] = mix3(mix3(p1, p2, s0), p3, t0);
            q[1] = mix3(mix3(p1, p2, s1), p3, t0);
            q[2] = mix3(mix3(p1, p2, s2), p3, t1);
            for (let k = 0; k < 3; k++) {
              const r = vec3.length(q[k]);
              for (let l = 0; l < 3; l++) {
                q[k][l] /= r;
              }
            }
            c.push(q[0], q[1], q[2]);
            f.push([n, n + 1, n + 2]);
            n += 3;
            if (j < frequency2 - i - 1) {
              const s3 = frequency2 - i - 1 ? (j + 1) / (frequency2 - i - 1) : 1;
              q[0] = mix3(mix3(p1, p2, s1), p3, t0);
              q[1] = mix3(mix3(p1, p2, s3), p3, t1);
              q[2] = mix3(mix3(p1, p2, s2), p3, t1);
              for (let k = 0; k < 3; k++) {
                const r = vec3.length(q[k]);
                for (let l = 0; l < 3; l++) {
                  q[k][l] /= r;
                }
              }
              c.push(q[0], q[1], q[2]);
              f.push([n, n + 1, n + 2]);
              n += 3;
            }
          }
        }
        return { points: c, triangles: f, offset: n };
      };
      const mix3 = (a, b, f) => {
        const _f = 1 - f;
        const c = [];
        for (let i = 0; i < 3; i++) {
          c[i] = a[i] * _f + b[i] * f;
        }
        return c;
      };
      let points = [];
      let faces = [];
      let offset = 0;
      for (let i = 0; i < ti.length; i++) {
        const g = geodesicSubDivide([ci[ti[i][0]], ci[ti[i][1]], ci[ti[i][2]]], frequency, offset);
        points = points.concat(g.points);
        faces = faces.concat(g.triangles);
        offset = g.offset;
      }
      let geometry = polyhedron({ points, faces, orientation: "inward" });
      if (radius !== 1)
        geometry = geom3.transform(mat4.fromScaling(mat4.create(), [radius, radius, radius]), geometry);
      return geometry;
    };
    module.exports = geodesicSphere;
  }
});

// node_modules/@jscad/modeling/src/primitives/line.js
var require_line = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/line.js"(exports, module) {
    var path2 = require_path2();
    var line = (points) => {
      if (!Array.isArray(points))
        throw new Error("points must be an array");
      return path2.fromPoints({}, points);
    };
    module.exports = line;
  }
});

// node_modules/@jscad/modeling/src/primitives/polygon.js
var require_polygon = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/polygon.js"(exports, module) {
    var geom2 = require_geom2();
    var polygon = (options) => {
      const defaults = {
        points: [],
        paths: []
      };
      const { points, paths } = Object.assign({}, defaults, options);
      if (!(Array.isArray(points) && Array.isArray(paths)))
        throw new Error("points and paths must be arrays");
      let listofpolys = points;
      if (Array.isArray(points[0])) {
        if (!Array.isArray(points[0][0])) {
          listofpolys = [points];
        }
      }
      listofpolys.forEach((list, i) => {
        if (!Array.isArray(list))
          throw new Error("list of points " + i + " must be an array");
        if (list.length < 3)
          throw new Error("list of points " + i + " must contain three or more points");
        list.forEach((point, j) => {
          if (!Array.isArray(point))
            throw new Error("list of points " + i + ", point " + j + " must be an array");
          if (point.length < 2)
            throw new Error("list of points " + i + ", point " + j + " must contain by X and Y values");
        });
      });
      let listofpaths = paths;
      if (paths.length === 0) {
        let count = 0;
        listofpaths = listofpolys.map((list) => list.map((point) => count++));
      }
      const allpoints = [];
      listofpolys.forEach((list) => list.forEach((point) => allpoints.push(point)));
      let sides = [];
      listofpaths.forEach((path) => {
        const setofpoints = path.map((index) => allpoints[index]);
        const geometry = geom2.fromPoints(setofpoints);
        sides = sides.concat(geom2.toSides(geometry));
      });
      return geom2.create(sides);
    };
    module.exports = polygon;
  }
});

// node_modules/@jscad/modeling/src/primitives/rectangle.js
var require_rectangle = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/rectangle.js"(exports, module) {
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var { isNumberArray } = require_commonChecks();
    var rectangle = (options) => {
      const defaults = {
        center: [0, 0],
        size: [2, 2]
      };
      const { center, size } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 2))
        throw new Error("center must be an array of X and Y values");
      if (!isNumberArray(size, 2))
        throw new Error("size must be an array of X and Y values");
      if (!size.every((n) => n > 0))
        throw new Error("size values must be greater than zero");
      const point = [size[0] / 2, size[1] / 2];
      const pswap = [point[0], -point[1]];
      const points = [
        vec2.subtract(vec2.create(), center, point),
        vec2.add(vec2.create(), center, pswap),
        vec2.add(vec2.create(), center, point),
        vec2.subtract(vec2.create(), center, pswap)
      ];
      return geom2.fromPoints(points);
    };
    module.exports = rectangle;
  }
});

// node_modules/@jscad/modeling/src/primitives/roundedCuboid.js
var require_roundedCuboid = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/roundedCuboid.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var vec2 = require_vec2();
    var vec3 = require_vec3();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var { sin, cos } = require_trigonometry();
    var { isGT, isGTE, isNumberArray } = require_commonChecks();
    var createCorners = (center, size, radius, segments, slice, positive) => {
      const pitch = TAU / 4 * slice / segments;
      const cospitch = cos(pitch);
      const sinpitch = sin(pitch);
      const layersegments = segments - slice;
      let layerradius = radius * cospitch;
      let layeroffset = size[2] - (radius - radius * sinpitch);
      if (!positive)
        layeroffset = radius - radius * sinpitch - size[2];
      layerradius = layerradius > EPS ? layerradius : 0;
      const corner0 = vec3.add(vec3.create(), center, [size[0] - radius, size[1] - radius, layeroffset]);
      const corner1 = vec3.add(vec3.create(), center, [radius - size[0], size[1] - radius, layeroffset]);
      const corner2 = vec3.add(vec3.create(), center, [radius - size[0], radius - size[1], layeroffset]);
      const corner3 = vec3.add(vec3.create(), center, [size[0] - radius, radius - size[1], layeroffset]);
      const corner0Points = [];
      const corner1Points = [];
      const corner2Points = [];
      const corner3Points = [];
      for (let i = 0; i <= layersegments; i++) {
        const radians = layersegments > 0 ? TAU / 4 * i / layersegments : 0;
        const point2d = vec2.fromAngleRadians(vec2.create(), radians);
        vec2.scale(point2d, point2d, layerradius);
        const point3d = vec3.fromVec2(vec3.create(), point2d);
        corner0Points.push(vec3.add(vec3.create(), corner0, point3d));
        vec3.rotateZ(point3d, point3d, [0, 0, 0], TAU / 4);
        corner1Points.push(vec3.add(vec3.create(), corner1, point3d));
        vec3.rotateZ(point3d, point3d, [0, 0, 0], TAU / 4);
        corner2Points.push(vec3.add(vec3.create(), corner2, point3d));
        vec3.rotateZ(point3d, point3d, [0, 0, 0], TAU / 4);
        corner3Points.push(vec3.add(vec3.create(), corner3, point3d));
      }
      if (!positive) {
        corner0Points.reverse();
        corner1Points.reverse();
        corner2Points.reverse();
        corner3Points.reverse();
        return [corner3Points, corner2Points, corner1Points, corner0Points];
      }
      return [corner0Points, corner1Points, corner2Points, corner3Points];
    };
    var stitchCorners = (previousCorners, currentCorners) => {
      const polygons = [];
      for (let i = 0; i < previousCorners.length; i++) {
        const previous = previousCorners[i];
        const current = currentCorners[i];
        for (let j = 0; j < previous.length - 1; j++) {
          polygons.push(poly3.create([previous[j], previous[j + 1], current[j]]));
          if (j < current.length - 1) {
            polygons.push(poly3.create([current[j], previous[j + 1], current[j + 1]]));
          }
        }
      }
      return polygons;
    };
    var stitchWalls = (previousCorners, currentCorners) => {
      const polygons = [];
      for (let i = 0; i < previousCorners.length; i++) {
        let previous = previousCorners[i];
        let current = currentCorners[i];
        const p0 = previous[previous.length - 1];
        const c0 = current[current.length - 1];
        const j = (i + 1) % previousCorners.length;
        previous = previousCorners[j];
        current = currentCorners[j];
        const p1 = previous[0];
        const c1 = current[0];
        polygons.push(poly3.create([p0, p1, c1, c0]));
      }
      return polygons;
    };
    var stitchSides = (bottomCorners, topCorners) => {
      bottomCorners = [bottomCorners[3], bottomCorners[2], bottomCorners[1], bottomCorners[0]];
      bottomCorners = bottomCorners.map((corner) => corner.slice().reverse());
      const bottomPoints = [];
      bottomCorners.forEach((corner) => {
        corner.forEach((point) => bottomPoints.push(point));
      });
      const topPoints = [];
      topCorners.forEach((corner) => {
        corner.forEach((point) => topPoints.push(point));
      });
      const polygons = [];
      for (let i = 0; i < topPoints.length; i++) {
        const j = (i + 1) % topPoints.length;
        polygons.push(poly3.create([bottomPoints[i], bottomPoints[j], topPoints[j], topPoints[i]]));
      }
      return polygons;
    };
    var roundedCuboid = (options) => {
      const defaults = {
        center: [0, 0, 0],
        size: [2, 2, 2],
        roundRadius: 0.2,
        segments: 32
      };
      let { center, size, roundRadius, segments } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 3))
        throw new Error("center must be an array of X, Y and Z values");
      if (!isNumberArray(size, 3))
        throw new Error("size must be an array of X, Y and Z values");
      if (!size.every((n) => n > 0))
        throw new Error("size values must be greater than zero");
      if (!isGT(roundRadius, 0))
        throw new Error("roundRadius must be greater than zero");
      if (!isGTE(segments, 4))
        throw new Error("segments must be four or more");
      size = size.map((v) => v / 2);
      if (roundRadius > size[0] - EPS || roundRadius > size[1] - EPS || roundRadius > size[2] - EPS)
        throw new Error("roundRadius must be smaller then the radius of all dimensions");
      segments = Math.floor(segments / 4);
      let prevCornersPos = null;
      let prevCornersNeg = null;
      let polygons = [];
      for (let slice = 0; slice <= segments; slice++) {
        const cornersPos = createCorners(center, size, roundRadius, segments, slice, true);
        const cornersNeg = createCorners(center, size, roundRadius, segments, slice, false);
        if (slice === 0) {
          polygons = polygons.concat(stitchSides(cornersNeg, cornersPos));
        }
        if (prevCornersPos) {
          polygons = polygons.concat(
            stitchCorners(prevCornersPos, cornersPos),
            stitchWalls(prevCornersPos, cornersPos)
          );
        }
        if (prevCornersNeg) {
          polygons = polygons.concat(
            stitchCorners(prevCornersNeg, cornersNeg),
            stitchWalls(prevCornersNeg, cornersNeg)
          );
        }
        if (slice === segments) {
          let points = cornersPos.map((corner) => corner[0]);
          polygons.push(poly3.create(points));
          points = cornersNeg.map((corner) => corner[0]);
          polygons.push(poly3.create(points));
        }
        prevCornersPos = cornersPos;
        prevCornersNeg = cornersNeg;
      }
      return geom3.create(polygons);
    };
    module.exports = roundedCuboid;
  }
});

// node_modules/@jscad/modeling/src/primitives/roundedCylinder.js
var require_roundedCylinder = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/roundedCylinder.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var vec3 = require_vec3();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var { sin, cos } = require_trigonometry();
    var { isGT, isGTE, isNumberArray } = require_commonChecks();
    var roundedCylinder = (options) => {
      const defaults = {
        center: [0, 0, 0],
        height: 2,
        radius: 1,
        roundRadius: 0.2,
        segments: 32
      };
      const { center, height, radius, roundRadius, segments } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 3))
        throw new Error("center must be an array of X, Y and Z values");
      if (!isGT(height, 0))
        throw new Error("height must be greater then zero");
      if (!isGT(radius, 0))
        throw new Error("radius must be greater then zero");
      if (!isGT(roundRadius, 0))
        throw new Error("roundRadius must be greater then zero");
      if (roundRadius > radius - EPS)
        throw new Error("roundRadius must be smaller then the radius");
      if (!isGTE(segments, 4))
        throw new Error("segments must be four or more");
      const start = [0, 0, -(height / 2)];
      const end = [0, 0, height / 2];
      const direction = vec3.subtract(vec3.create(), end, start);
      const length = vec3.length(direction);
      if (2 * roundRadius > length - EPS)
        throw new Error("height must be larger than twice roundRadius");
      let defaultnormal;
      if (Math.abs(direction[0]) > Math.abs(direction[1])) {
        defaultnormal = vec3.fromValues(0, 1, 0);
      } else {
        defaultnormal = vec3.fromValues(1, 0, 0);
      }
      const zvector = vec3.scale(vec3.create(), vec3.normalize(vec3.create(), direction), roundRadius);
      const xvector = vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), zvector, defaultnormal)), radius);
      const yvector = vec3.scale(vec3.create(), vec3.normalize(vec3.create(), vec3.cross(vec3.create(), xvector, zvector)), radius);
      vec3.add(start, start, zvector);
      vec3.subtract(end, end, zvector);
      const qsegments = Math.floor(0.25 * segments);
      const fromPoints = (points) => {
        const newpoints = points.map((point) => vec3.add(point, point, center));
        return poly3.create(newpoints);
      };
      const polygons = [];
      const v1 = vec3.create();
      const v2 = vec3.create();
      let prevcylinderpoint;
      for (let slice1 = 0; slice1 <= segments; slice1++) {
        const angle = TAU * slice1 / segments;
        const cylinderpoint = vec3.add(vec3.create(), vec3.scale(v1, xvector, cos(angle)), vec3.scale(v2, yvector, sin(angle)));
        if (slice1 > 0) {
          let points = [];
          points.push(vec3.add(vec3.create(), start, cylinderpoint));
          points.push(vec3.add(vec3.create(), start, prevcylinderpoint));
          points.push(vec3.add(vec3.create(), end, prevcylinderpoint));
          points.push(vec3.add(vec3.create(), end, cylinderpoint));
          polygons.push(fromPoints(points));
          let prevcospitch, prevsinpitch;
          for (let slice2 = 0; slice2 <= qsegments; slice2++) {
            const pitch = TAU / 4 * slice2 / qsegments;
            const cospitch = cos(pitch);
            const sinpitch = sin(pitch);
            if (slice2 > 0) {
              points = [];
              let point;
              point = vec3.add(vec3.create(), start, vec3.subtract(v1, vec3.scale(v1, prevcylinderpoint, prevcospitch), vec3.scale(v2, zvector, prevsinpitch)));
              points.push(point);
              point = vec3.add(vec3.create(), start, vec3.subtract(v1, vec3.scale(v1, cylinderpoint, prevcospitch), vec3.scale(v2, zvector, prevsinpitch)));
              points.push(point);
              if (slice2 < qsegments) {
                point = vec3.add(vec3.create(), start, vec3.subtract(v1, vec3.scale(v1, cylinderpoint, cospitch), vec3.scale(v2, zvector, sinpitch)));
                points.push(point);
              }
              point = vec3.add(vec3.create(), start, vec3.subtract(v1, vec3.scale(v1, prevcylinderpoint, cospitch), vec3.scale(v2, zvector, sinpitch)));
              points.push(point);
              polygons.push(fromPoints(points));
              points = [];
              point = vec3.add(vec3.create(), vec3.scale(v1, prevcylinderpoint, prevcospitch), vec3.scale(v2, zvector, prevsinpitch));
              vec3.add(point, point, end);
              points.push(point);
              point = vec3.add(vec3.create(), vec3.scale(v1, cylinderpoint, prevcospitch), vec3.scale(v2, zvector, prevsinpitch));
              vec3.add(point, point, end);
              points.push(point);
              if (slice2 < qsegments) {
                point = vec3.add(vec3.create(), vec3.scale(v1, cylinderpoint, cospitch), vec3.scale(v2, zvector, sinpitch));
                vec3.add(point, point, end);
                points.push(point);
              }
              point = vec3.add(vec3.create(), vec3.scale(v1, prevcylinderpoint, cospitch), vec3.scale(v2, zvector, sinpitch));
              vec3.add(point, point, end);
              points.push(point);
              points.reverse();
              polygons.push(fromPoints(points));
            }
            prevcospitch = cospitch;
            prevsinpitch = sinpitch;
          }
        }
        prevcylinderpoint = cylinderpoint;
      }
      const result = geom3.create(polygons);
      return result;
    };
    module.exports = roundedCylinder;
  }
});

// node_modules/@jscad/modeling/src/primitives/roundedRectangle.js
var require_roundedRectangle = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/roundedRectangle.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var { isGT, isGTE, isNumberArray } = require_commonChecks();
    var roundedRectangle = (options) => {
      const defaults = {
        center: [0, 0],
        size: [2, 2],
        roundRadius: 0.2,
        segments: 32
      };
      let { center, size, roundRadius, segments } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 2))
        throw new Error("center must be an array of X and Y values");
      if (!isNumberArray(size, 2))
        throw new Error("size must be an array of X and Y values");
      if (!size.every((n) => n > 0))
        throw new Error("size values must be greater than zero");
      if (!isGT(roundRadius, 0))
        throw new Error("roundRadius must be greater than zero");
      if (!isGTE(segments, 4))
        throw new Error("segments must be four or more");
      size = size.map((v) => v / 2);
      if (roundRadius > size[0] - EPS || roundRadius > size[1] - EPS)
        throw new Error("roundRadius must be smaller then the radius of all dimensions");
      const cornersegments = Math.floor(segments / 4);
      const corner0 = vec2.add(vec2.create(), center, [size[0] - roundRadius, size[1] - roundRadius]);
      const corner1 = vec2.add(vec2.create(), center, [roundRadius - size[0], size[1] - roundRadius]);
      const corner2 = vec2.add(vec2.create(), center, [roundRadius - size[0], roundRadius - size[1]]);
      const corner3 = vec2.add(vec2.create(), center, [size[0] - roundRadius, roundRadius - size[1]]);
      const corner0Points = [];
      const corner1Points = [];
      const corner2Points = [];
      const corner3Points = [];
      for (let i = 0; i <= cornersegments; i++) {
        const radians = TAU / 4 * i / cornersegments;
        const point = vec2.fromAngleRadians(vec2.create(), radians);
        vec2.scale(point, point, roundRadius);
        corner0Points.push(vec2.add(vec2.create(), corner0, point));
        vec2.rotate(point, point, vec2.create(), TAU / 4);
        corner1Points.push(vec2.add(vec2.create(), corner1, point));
        vec2.rotate(point, point, vec2.create(), TAU / 4);
        corner2Points.push(vec2.add(vec2.create(), corner2, point));
        vec2.rotate(point, point, vec2.create(), TAU / 4);
        corner3Points.push(vec2.add(vec2.create(), corner3, point));
      }
      return geom2.fromPoints(corner0Points.concat(corner1Points, corner2Points, corner3Points));
    };
    module.exports = roundedRectangle;
  }
});

// node_modules/@jscad/modeling/src/primitives/sphere.js
var require_sphere = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/sphere.js"(exports, module) {
    var ellipsoid = require_ellipsoid();
    var { isGT } = require_commonChecks();
    var sphere = (options) => {
      const defaults = {
        center: [0, 0, 0],
        radius: 1,
        segments: 32,
        axes: [[1, 0, 0], [0, -1, 0], [0, 0, 1]]
      };
      let { center, radius, segments, axes } = Object.assign({}, defaults, options);
      if (!isGT(radius, 0))
        throw new Error("radius must be greater than zero");
      radius = [radius, radius, radius];
      return ellipsoid({ center, radius, segments, axes });
    };
    module.exports = sphere;
  }
});

// node_modules/@jscad/modeling/src/primitives/square.js
var require_square = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/square.js"(exports, module) {
    var rectangle = require_rectangle();
    var { isGT } = require_commonChecks();
    var square = (options) => {
      const defaults = {
        center: [0, 0],
        size: 2
      };
      let { center, size } = Object.assign({}, defaults, options);
      if (!isGT(size, 0))
        throw new Error("size must be greater than zero");
      size = [size, size];
      return rectangle({ center, size });
    };
    module.exports = square;
  }
});

// node_modules/@jscad/modeling/src/primitives/star.js
var require_star = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/star.js"(exports, module) {
    var { TAU } = require_constants();
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var { isGT, isGTE, isNumberArray } = require_commonChecks();
    var getRadiusRatio = (vertices, density) => {
      if (vertices > 0 && density > 1 && density < vertices / 2) {
        return Math.cos(Math.PI * density / vertices) / Math.cos(Math.PI * (density - 1) / vertices);
      }
      return 0;
    };
    var getPoints = (vertices, radius, startAngle, center) => {
      const a = TAU / vertices;
      const points = [];
      for (let i = 0; i < vertices; i++) {
        const point = vec2.fromAngleRadians(vec2.create(), a * i + startAngle);
        vec2.scale(point, point, radius);
        vec2.add(point, center, point);
        points.push(point);
      }
      return points;
    };
    var star = (options) => {
      const defaults = {
        center: [0, 0],
        vertices: 5,
        outerRadius: 1,
        innerRadius: 0,
        density: 2,
        startAngle: 0
      };
      let { center, vertices, outerRadius, innerRadius, density, startAngle } = Object.assign({}, defaults, options);
      if (!isNumberArray(center, 2))
        throw new Error("center must be an array of X and Y values");
      if (!isGTE(vertices, 2))
        throw new Error("vertices must be two or more");
      if (!isGT(outerRadius, 0))
        throw new Error("outerRadius must be greater than zero");
      if (!isGTE(innerRadius, 0))
        throw new Error("innerRadius must be greater than zero");
      if (!isGTE(startAngle, 0))
        throw new Error("startAngle must be greater than zero");
      vertices = Math.floor(vertices);
      density = Math.floor(density);
      startAngle = startAngle % TAU;
      if (innerRadius === 0) {
        if (!isGTE(density, 2))
          throw new Error("density must be two or more");
        innerRadius = outerRadius * getRadiusRatio(vertices, density);
      }
      const centerv = vec2.clone(center);
      const outerPoints = getPoints(vertices, outerRadius, startAngle, centerv);
      const innerPoints = getPoints(vertices, innerRadius, startAngle + Math.PI / vertices, centerv);
      const allPoints = [];
      for (let i = 0; i < vertices; i++) {
        allPoints.push(outerPoints[i]);
        allPoints.push(innerPoints[i]);
      }
      return geom2.fromPoints(allPoints);
    };
    module.exports = star;
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/mirror.js
var require_mirror = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/mirror.js"(exports, module) {
    var flatten2 = require_flatten();
    var mat4 = require_mat4();
    var plane = require_plane();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var mirror = (options, ...objects) => {
      const defaults = {
        origin: [0, 0, 0],
        normal: [0, 0, 1]
        // Z axis
      };
      const { origin, normal } = Object.assign({}, defaults, options);
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      const planeOfMirror = plane.fromNormalAndPoint(plane.create(), normal, origin);
      if (Number.isNaN(planeOfMirror[0])) {
        throw new Error("the given origin and normal do not define a proper plane");
      }
      const matrix = mat4.mirrorByPlane(mat4.create(), planeOfMirror);
      const results = objects.map((object) => {
        if (path2.isA(object))
          return path2.transform(matrix, object);
        if (geom2.isA(object))
          return geom2.transform(matrix, object);
        if (geom3.isA(object))
          return geom3.transform(matrix, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    var mirrorX = (...objects) => mirror({ normal: [1, 0, 0] }, objects);
    var mirrorY = (...objects) => mirror({ normal: [0, 1, 0] }, objects);
    var mirrorZ = (...objects) => mirror({ normal: [0, 0, 1] }, objects);
    module.exports = {
      mirror,
      mirrorX,
      mirrorY,
      mirrorZ
    };
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/calculatePlane.js
var require_calculatePlane = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/calculatePlane.js"(exports, module) {
    var plane = require_plane();
    var vec3 = require_vec3();
    var calculatePlane = (slice) => {
      const edges = slice.edges;
      if (edges.length < 3)
        throw new Error("slices must have 3 or more edges to calculate a plane");
      const midpoint = edges.reduce((point, edge) => vec3.add(vec3.create(), point, edge[0]), vec3.create());
      vec3.scale(midpoint, midpoint, 1 / edges.length);
      let farthestEdge;
      let distance = 0;
      edges.forEach((edge) => {
        if (!vec3.equals(edge[0], edge[1])) {
          const d = vec3.squaredDistance(midpoint, edge[0]);
          if (d > distance) {
            farthestEdge = edge;
            distance = d;
          }
        }
      });
      const beforeEdge = edges.find((edge) => vec3.equals(edge[1], farthestEdge[0]));
      return plane.fromPoints(plane.create(), beforeEdge[0], farthestEdge[0], farthestEdge[1]);
    };
    module.exports = calculatePlane;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/create.js
var require_create13 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/create.js"(exports, module) {
    var create = (edges) => {
      if (!edges) {
        edges = [];
      }
      return { edges };
    };
    module.exports = create;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/clone.js
var require_clone11 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/clone.js"(exports, module) {
    var create = require_create13();
    var vec3 = require_vec3();
    var clone = (...params) => {
      let out;
      let slice;
      if (params.length === 1) {
        out = create();
        slice = params[0];
      } else {
        out = params[0];
        slice = params[1];
      }
      out.edges = slice.edges.map((edge) => [vec3.clone(edge[0]), vec3.clone(edge[1])]);
      return out;
    };
    module.exports = clone;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/equals.js
var require_equals8 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/equals.js"(exports, module) {
    var vec3 = require_vec3();
    var equals2 = (a, b) => {
      const aedges = a.edges;
      const bedges = b.edges;
      if (aedges.length !== bedges.length) {
        return false;
      }
      const isEqual = aedges.reduce((acc, aedge, i) => {
        const bedge = bedges[i];
        const d = vec3.squaredDistance(aedge[0], bedge[0]);
        return acc && d < Number.EPSILON;
      }, true);
      return isEqual;
    };
    module.exports = equals2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/fromPoints.js
var require_fromPoints8 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/fromPoints.js"(exports, module) {
    var vec3 = require_vec3();
    var create = require_create13();
    var fromPoints = (points) => {
      if (!Array.isArray(points))
        throw new Error("the given points must be an array");
      if (points.length < 3)
        throw new Error("the given points must contain THREE or more points");
      const edges = [];
      let prevpoint = points[points.length - 1];
      points.forEach((point) => {
        if (point.length === 2)
          edges.push([vec3.fromVec2(vec3.create(), prevpoint), vec3.fromVec2(vec3.create(), point)]);
        if (point.length === 3)
          edges.push([prevpoint, point]);
        prevpoint = point;
      });
      return create(edges);
    };
    module.exports = fromPoints;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/fromSides.js
var require_fromSides = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/fromSides.js"(exports, module) {
    var vec3 = require_vec3();
    var create = require_create13();
    var fromSides = (sides) => {
      if (!Array.isArray(sides))
        throw new Error("the given sides must be an array");
      const edges = [];
      sides.forEach((side) => {
        edges.push([vec3.fromVec2(vec3.create(), side[0]), vec3.fromVec2(vec3.create(), side[1])]);
      });
      return create(edges);
    };
    module.exports = fromSides;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/isA.js
var require_isA5 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/isA.js"(exports, module) {
    var isA = (object) => {
      if (object && typeof object === "object") {
        if ("edges" in object) {
          if (Array.isArray(object.edges)) {
            return true;
          }
        }
      }
      return false;
    };
    module.exports = isA;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/reverse.js
var require_reverse5 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/reverse.js"(exports, module) {
    var create = require_create13();
    var reverse = (...params) => {
      let out;
      let slice;
      if (params.length === 1) {
        out = create();
        slice = params[0];
      } else {
        out = params[0];
        slice = params[1];
      }
      out.edges = slice.edges.map((edge) => [edge[1], edge[0]]);
      return out;
    };
    module.exports = reverse;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/toEdges.js
var require_toEdges = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/toEdges.js"(exports, module) {
    var toEdges = (slice) => slice.edges;
    module.exports = toEdges;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/linkedListSort.js
var require_linkedListSort = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/linkedListSort.js"(exports, module) {
    var sortLinked2 = (list, fn) => {
      let i, p, q, e, numMerges;
      let inSize = 1;
      do {
        p = list;
        list = null;
        let tail = null;
        numMerges = 0;
        while (p) {
          numMerges++;
          q = p;
          let pSize = 0;
          for (i = 0; i < inSize; i++) {
            pSize++;
            q = q.nextZ;
            if (!q)
              break;
          }
          let qSize = inSize;
          while (pSize > 0 || qSize > 0 && q) {
            if (pSize !== 0 && (qSize === 0 || !q || fn(p) <= fn(q))) {
              e = p;
              p = p.nextZ;
              pSize--;
            } else {
              e = q;
              q = q.nextZ;
              qSize--;
            }
            if (tail)
              tail.nextZ = e;
            else
              list = e;
            e.prevZ = tail;
            tail = e;
          }
          p = q;
        }
        tail.nextZ = null;
        inSize *= 2;
      } while (numMerges > 1);
      return list;
    };
    module.exports = sortLinked2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/linkedList.js
var require_linkedList = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/linkedList.js"(exports, module) {
    var sortLinked2 = require_linkedListSort();
    var Node2 = class {
      constructor(i, x, y) {
        this.i = i;
        this.x = x;
        this.y = y;
        this.prev = null;
        this.next = null;
        this.z = null;
        this.prevZ = null;
        this.nextZ = null;
        this.steiner = false;
      }
    };
    var insertNode2 = (i, x, y, last) => {
      const p = new Node2(i, x, y);
      if (!last) {
        p.prev = p;
        p.next = p;
      } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
      }
      return p;
    };
    var removeNode2 = (p) => {
      p.next.prev = p.prev;
      p.prev.next = p.next;
      if (p.prevZ)
        p.prevZ.nextZ = p.nextZ;
      if (p.nextZ)
        p.nextZ.prevZ = p.prevZ;
    };
    module.exports = { Node: Node2, insertNode: insertNode2, removeNode: removeNode2, sortLinked: sortLinked2 };
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/triangle.js
var require_triangle = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/triangle.js"(exports, module) {
    var pointInTriangle2 = (ax, ay, bx, by, cx, cy, px2, py2) => (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;
    var area2 = (p, q, r) => (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    module.exports = { area: area2, pointInTriangle: pointInTriangle2 };
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/linkedPolygon.js
var require_linkedPolygon = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/linkedPolygon.js"(exports, module) {
    var { Node: Node2, insertNode: insertNode2, removeNode: removeNode2 } = require_linkedList();
    var { area: area2 } = require_triangle();
    var linkedPolygon = (data, start, end, dim, clockwise) => {
      let last;
      if (clockwise === signedArea2(data, start, end, dim) > 0) {
        for (let i = start; i < end; i += dim) {
          last = insertNode2(i, data[i], data[i + 1], last);
        }
      } else {
        for (let i = end - dim; i >= start; i -= dim) {
          last = insertNode2(i, data[i], data[i + 1], last);
        }
      }
      if (last && equals2(last, last.next)) {
        removeNode2(last);
        last = last.next;
      }
      return last;
    };
    var filterPoints2 = (start, end) => {
      if (!start)
        return start;
      if (!end)
        end = start;
      let p = start;
      let again;
      do {
        again = false;
        if (!p.steiner && (equals2(p, p.next) || area2(p.prev, p, p.next) === 0)) {
          removeNode2(p);
          p = end = p.prev;
          if (p === p.next)
            break;
          again = true;
        } else {
          p = p.next;
        }
      } while (again || p !== end);
      return end;
    };
    var cureLocalIntersections2 = (start, triangles, dim) => {
      let p = start;
      do {
        const a = p.prev;
        const b = p.next.next;
        if (!equals2(a, b) && intersects2(a, p, p.next, b) && locallyInside2(a, b) && locallyInside2(b, a)) {
          triangles.push(a.i / dim);
          triangles.push(p.i / dim);
          triangles.push(b.i / dim);
          removeNode2(p);
          removeNode2(p.next);
          p = start = b;
        }
        p = p.next;
      } while (p !== start);
      return filterPoints2(p);
    };
    var intersectsPolygon2 = (a, b) => {
      let p = a;
      do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects2(p, p.next, a, b))
          return true;
        p = p.next;
      } while (p !== a);
      return false;
    };
    var locallyInside2 = (a, b) => area2(a.prev, a, a.next) < 0 ? area2(a, b, a.next) >= 0 && area2(a, a.prev, b) >= 0 : area2(a, b, a.prev) < 0 || area2(a, a.next, b) < 0;
    var middleInside2 = (a, b) => {
      let p = a;
      let inside = false;
      const px2 = (a.x + b.x) / 2;
      const py2 = (a.y + b.y) / 2;
      do {
        if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x) {
          inside = !inside;
        }
        p = p.next;
      } while (p !== a);
      return inside;
    };
    var splitPolygon2 = (a, b) => {
      const a2 = new Node2(a.i, a.x, a.y);
      const b2 = new Node2(b.i, b.x, b.y);
      const an = a.next;
      const bp = b.prev;
      a.next = b;
      b.prev = a;
      a2.next = an;
      an.prev = a2;
      b2.next = a2;
      a2.prev = b2;
      bp.next = b2;
      b2.prev = bp;
      return b2;
    };
    var isValidDiagonal2 = (a, b) => a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon2(a, b) && // doesn't intersect other edges
    (locallyInside2(a, b) && locallyInside2(b, a) && middleInside2(a, b) && // locally visible
    (area2(a.prev, a, b.prev) || area2(a, b.prev, b)) || // does not create opposite-facing sectors
    equals2(a, b) && area2(a.prev, a, a.next) > 0 && area2(b.prev, b, b.next) > 0);
    var intersects2 = (p1, q1, p2, q2) => {
      const o1 = Math.sign(area2(p1, q1, p2));
      const o2 = Math.sign(area2(p1, q1, q2));
      const o3 = Math.sign(area2(p2, q2, p1));
      const o4 = Math.sign(area2(p2, q2, q1));
      if (o1 !== o2 && o3 !== o4)
        return true;
      if (o1 === 0 && onSegment2(p1, p2, q1))
        return true;
      if (o2 === 0 && onSegment2(p1, q2, q1))
        return true;
      if (o3 === 0 && onSegment2(p2, p1, q2))
        return true;
      if (o4 === 0 && onSegment2(p2, q1, q2))
        return true;
      return false;
    };
    var onSegment2 = (p, q, r) => q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
    var signedArea2 = (data, start, end, dim) => {
      let sum = 0;
      for (let i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
      }
      return sum;
    };
    var equals2 = (p1, p2) => p1.x === p2.x && p1.y === p2.y;
    module.exports = { cureLocalIntersections: cureLocalIntersections2, filterPoints: filterPoints2, isValidDiagonal: isValidDiagonal2, linkedPolygon, locallyInside: locallyInside2, splitPolygon: splitPolygon2 };
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/eliminateHoles.js
var require_eliminateHoles = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/eliminateHoles.js"(exports, module) {
    var { filterPoints: filterPoints2, linkedPolygon, locallyInside: locallyInside2, splitPolygon: splitPolygon2 } = require_linkedPolygon();
    var { area: area2, pointInTriangle: pointInTriangle2 } = require_triangle();
    var eliminateHoles2 = (data, holeIndices, outerNode, dim) => {
      const queue = [];
      for (let i = 0, len = holeIndices.length; i < len; i++) {
        const start = holeIndices[i] * dim;
        const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        const list = linkedPolygon(data, start, end, dim, false);
        if (list === list.next)
          list.steiner = true;
        queue.push(getLeftmost2(list));
      }
      queue.sort((a, b) => a.x - b.x);
      for (let i = 0; i < queue.length; i++) {
        outerNode = eliminateHole2(queue[i], outerNode);
        outerNode = filterPoints2(outerNode, outerNode.next);
      }
      return outerNode;
    };
    var eliminateHole2 = (hole, outerNode) => {
      const bridge = findHoleBridge2(hole, outerNode);
      if (!bridge) {
        return outerNode;
      }
      const bridgeReverse = splitPolygon2(bridge, hole);
      const filteredBridge = filterPoints2(bridge, bridge.next);
      filterPoints2(bridgeReverse, bridgeReverse.next);
      return outerNode === bridge ? filteredBridge : outerNode;
    };
    var findHoleBridge2 = (hole, outerNode) => {
      let p = outerNode;
      const hx = hole.x;
      const hy = hole.y;
      let qx = -Infinity;
      let m;
      do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
          const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
          if (x <= hx && x > qx) {
            qx = x;
            if (x === hx) {
              if (hy === p.y)
                return p;
              if (hy === p.next.y)
                return p.next;
            }
            m = p.x < p.next.x ? p : p.next;
          }
        }
        p = p.next;
      } while (p !== outerNode);
      if (!m)
        return null;
      if (hx === qx)
        return m;
      const stop = m;
      const mx = m.x;
      const my = m.y;
      let tanMin = Infinity;
      p = m;
      do {
        if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle2(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
          const tan = Math.abs(hy - p.y) / (hx - p.x);
          if (locallyInside2(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector2(m, p)))) {
            m = p;
            tanMin = tan;
          }
        }
        p = p.next;
      } while (p !== stop);
      return m;
    };
    var sectorContainsSector2 = (m, p) => area2(m.prev, m, p.prev) < 0 && area2(p.next, m, m.next) < 0;
    var getLeftmost2 = (start) => {
      let p = start;
      let leftmost = start;
      do {
        if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
          leftmost = p;
        p = p.next;
      } while (p !== start);
      return leftmost;
    };
    module.exports = eliminateHoles2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/index.js
var require_earcut = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/index.js"(exports, module) {
    var eliminateHoles2 = require_eliminateHoles();
    var { removeNode: removeNode2, sortLinked: sortLinked2 } = require_linkedList();
    var { cureLocalIntersections: cureLocalIntersections2, filterPoints: filterPoints2, isValidDiagonal: isValidDiagonal2, linkedPolygon, splitPolygon: splitPolygon2 } = require_linkedPolygon();
    var { area: area2, pointInTriangle: pointInTriangle2 } = require_triangle();
    var triangulate = (data, holeIndices, dim = 2) => {
      const hasHoles = holeIndices && holeIndices.length;
      const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      let outerNode = linkedPolygon(data, 0, outerLen, dim, true);
      const triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev)
        return triangles;
      let minX, minY, maxX, maxY, invSize;
      if (hasHoles)
        outerNode = eliminateHoles2(data, holeIndices, outerNode, dim);
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (let i = dim; i < outerLen; i += dim) {
          const x = data[i];
          const y = data[i + 1];
          if (x < minX)
            minX = x;
          if (y < minY)
            minY = y;
          if (x > maxX)
            maxX = x;
          if (y > maxY)
            maxY = y;
        }
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
      }
      earcutLinked2(outerNode, triangles, dim, minX, minY, invSize);
      return triangles;
    };
    var earcutLinked2 = (ear, triangles, dim, minX, minY, invSize, pass) => {
      if (!ear)
        return;
      if (!pass && invSize)
        indexCurve2(ear, minX, minY, invSize);
      let stop = ear;
      let prev;
      let next;
      while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;
        if (invSize ? isEarHashed2(ear, minX, minY, invSize) : isEar2(ear)) {
          triangles.push(prev.i / dim);
          triangles.push(ear.i / dim);
          triangles.push(next.i / dim);
          removeNode2(ear);
          ear = next.next;
          stop = next.next;
          continue;
        }
        ear = next;
        if (ear === stop) {
          if (!pass) {
            earcutLinked2(filterPoints2(ear), triangles, dim, minX, minY, invSize, 1);
          } else if (pass === 1) {
            ear = cureLocalIntersections2(filterPoints2(ear), triangles, dim);
            earcutLinked2(ear, triangles, dim, minX, minY, invSize, 2);
          } else if (pass === 2) {
            splitEarcut2(ear, triangles, dim, minX, minY, invSize);
          }
          break;
        }
      }
    };
    var isEar2 = (ear) => {
      const a = ear.prev;
      const b = ear;
      const c = ear.next;
      if (area2(a, b, c) >= 0)
        return false;
      let p = ear.next.next;
      while (p !== ear.prev) {
        if (pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0) {
          return false;
        }
        p = p.next;
      }
      return true;
    };
    var isEarHashed2 = (ear, minX, minY, invSize) => {
      const a = ear.prev;
      const b = ear;
      const c = ear.next;
      if (area2(a, b, c) >= 0)
        return false;
      const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x;
      const minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y;
      const maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x;
      const maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
      const minZ = zOrder2(minTX, minTY, minX, minY, invSize);
      const maxZ = zOrder2(maxTX, maxTY, minX, minY, invSize);
      let p = ear.prevZ;
      let n = ear.nextZ;
      while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
        if (n !== ear.prev && n !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area2(p.prev, p, p.next) >= 0)
          return false;
        p = p.prevZ;
      }
      while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next && pointInTriangle2(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area2(n.prev, n, n.next) >= 0)
          return false;
        n = n.nextZ;
      }
      return true;
    };
    var splitEarcut2 = (start, triangles, dim, minX, minY, invSize) => {
      let a = start;
      do {
        let b = a.next.next;
        while (b !== a.prev) {
          if (a.i !== b.i && isValidDiagonal2(a, b)) {
            let c = splitPolygon2(a, b);
            a = filterPoints2(a, a.next);
            c = filterPoints2(c, c.next);
            earcutLinked2(a, triangles, dim, minX, minY, invSize);
            earcutLinked2(c, triangles, dim, minX, minY, invSize);
            return;
          }
          b = b.next;
        }
        a = a.next;
      } while (a !== start);
    };
    var indexCurve2 = (start, minX, minY, invSize) => {
      let p = start;
      do {
        if (p.z === null)
          p.z = zOrder2(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
      } while (p !== start);
      p.prevZ.nextZ = null;
      p.prevZ = null;
      sortLinked2(p, (p2) => p2.z);
    };
    var zOrder2 = (x, y, minX, minY, invSize) => {
      x = 32767 * (x - minX) * invSize;
      y = 32767 * (y - minY) * invSize;
      x = (x | x << 8) & 16711935;
      x = (x | x << 4) & 252645135;
      x = (x | x << 2) & 858993459;
      x = (x | x << 1) & 1431655765;
      y = (y | y << 8) & 16711935;
      y = (y | y << 4) & 252645135;
      y = (y | y << 2) & 858993459;
      y = (y | y << 1) & 1431655765;
      return x | y << 1;
    };
    module.exports = triangulate;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/assignHoles.js
var require_assignHoles = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/assignHoles.js"(exports, module) {
    var { area: area2 } = require_utils();
    var { toOutlines } = require_geom2();
    var { arePointsInside } = require_poly2();
    var assignHoles = (geometry) => {
      const outlines = toOutlines(geometry);
      const solids = [];
      const holes = [];
      outlines.forEach((outline, i) => {
        const a = area2(outline);
        if (a < 0) {
          holes.push(i);
        } else if (a > 0) {
          solids.push(i);
        }
      });
      const children = [];
      const parents = [];
      solids.forEach((s, i) => {
        const solid = outlines[s];
        children[i] = [];
        holes.forEach((h, j) => {
          const hole = outlines[h];
          if (arePointsInside([hole[0]], { vertices: solid })) {
            children[i].push(h);
            if (!parents[j])
              parents[j] = [];
            parents[j].push(i);
          }
        });
      });
      holes.forEach((h, j) => {
        if (parents[j] && parents[j].length > 1) {
          const directParent = minIndex(parents[j], (p) => children[p].length);
          parents[j].forEach((p, i) => {
            if (i !== directParent) {
              children[p] = children[p].filter((c) => c !== h);
            }
          });
        }
      });
      return children.map((holes2, i) => ({
        solid: outlines[solids[i]],
        holes: holes2.map((h) => outlines[h])
      }));
    };
    var minIndex = (list, score) => {
      let bestIndex;
      let best;
      list.forEach((item, index) => {
        const value = score(item);
        if (best === void 0 || value < best) {
          bestIndex = index;
          best = value;
        }
      });
      return bestIndex;
    };
    module.exports = assignHoles;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/earcut/polygonHierarchy.js
var require_polygonHierarchy = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/earcut/polygonHierarchy.js"(exports, module) {
    var geom2 = require_geom2();
    var plane = require_plane();
    var vec2 = require_vec2();
    var vec3 = require_vec3();
    var calculatePlane = require_calculatePlane();
    var assignHoles = require_assignHoles();
    var PolygonHierarchy = class {
      constructor(slice) {
        this.plane = calculatePlane(slice);
        const rightvector = vec3.orthogonal(vec3.create(), this.plane);
        const perp = vec3.cross(vec3.create(), this.plane, rightvector);
        this.v = vec3.normalize(perp, perp);
        this.u = vec3.cross(vec3.create(), this.v, this.plane);
        this.basisMap = /* @__PURE__ */ new Map();
        const projected = slice.edges.map((e) => e.map((v) => this.to2D(v)));
        const geometry = geom2.create(projected);
        this.roots = assignHoles(geometry);
      }
      /*
       * project a 3D point onto the 2D plane
       */
      to2D(vector3) {
        const vector2 = vec2.fromValues(vec3.dot(vector3, this.u), vec3.dot(vector3, this.v));
        this.basisMap.set(vector2, vector3);
        return vector2;
      }
      /*
       * un-project a 2D point back into 3D
       */
      to3D(vector2) {
        const original = this.basisMap.get(vector2);
        if (original) {
          return original;
        } else {
          console.log("Warning: point not in original slice");
          const v1 = vec3.scale(vec3.create(), this.u, vector2[0]);
          const v2 = vec3.scale(vec3.create(), this.v, vector2[1]);
          const planeOrigin = vec3.scale(vec3.create(), plane, plane[3]);
          const v3 = vec3.add(v1, v1, planeOrigin);
          return vec3.add(v2, v2, v3);
        }
      }
    };
    module.exports = PolygonHierarchy;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/toPolygons.js
var require_toPolygons2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/toPolygons.js"(exports, module) {
    var poly3 = require_poly3();
    var earcut = require_earcut();
    var PolygonHierarchy = require_polygonHierarchy();
    var toPolygons = (slice) => {
      const hierarchy = new PolygonHierarchy(slice);
      const polygons = [];
      hierarchy.roots.forEach(({ solid, holes }) => {
        let index = solid.length;
        const holesIndex = [];
        holes.forEach((hole, i) => {
          holesIndex.push(index);
          index += hole.length;
        });
        const vertices = [solid, ...holes].flat();
        const data = vertices.flat();
        const getVertex = (i) => hierarchy.to3D(vertices[i]);
        const indices = earcut(data, holesIndex);
        for (let i = 0; i < indices.length; i += 3) {
          const tri = indices.slice(i, i + 3).map(getVertex);
          polygons.push(poly3.fromPointsAndPlane(tri, hierarchy.plane));
        }
      });
      return polygons;
    };
    module.exports = toPolygons;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/toString.js
var require_toString11 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/toString.js"(exports, module) {
    var vec3 = require_vec3();
    var edgesToString = (edges) => edges.reduce((result, edge) => result += `[${vec3.toString(edge[0])}, ${vec3.toString(edge[1])}], `, "");
    var toString = (slice) => `[${edgesToString(slice.edges)}]`;
    module.exports = toString;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/transform.js
var require_transform11 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/transform.js"(exports, module) {
    var vec3 = require_vec3();
    var create = require_create13();
    var transform = (matrix, slice) => {
      const edges = slice.edges.map((edge) => [vec3.transform(vec3.create(), edge[0], matrix), vec3.transform(vec3.create(), edge[1], matrix)]);
      return create(edges);
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/index.js
var require_slice = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/index.js"(exports, module) {
    module.exports = {
      calculatePlane: require_calculatePlane(),
      clone: require_clone11(),
      create: require_create13(),
      equals: require_equals8(),
      fromPoints: require_fromPoints8(),
      fromSides: require_fromSides(),
      isA: require_isA5(),
      reverse: require_reverse5(),
      toEdges: require_toEdges(),
      toPolygons: require_toPolygons2(),
      toString: require_toString11(),
      transform: require_transform11()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/slice/repair.js
var require_repair = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/slice/repair.js"(exports, module) {
    var vec3 = require_vec3();
    var create = require_create13();
    var repair = (slice) => {
      if (!slice.edges)
        return slice;
      let edges = slice.edges;
      const vertexMap = /* @__PURE__ */ new Map();
      const edgeCount = /* @__PURE__ */ new Map();
      edges = edges.filter((e) => !vec3.equals(e[0], e[1]));
      edges.forEach((edge) => {
        const inKey = edge[0].toString();
        const outKey = edge[1].toString();
        vertexMap.set(inKey, edge[0]);
        vertexMap.set(outKey, edge[1]);
        edgeCount.set(inKey, (edgeCount.get(inKey) || 0) + 1);
        edgeCount.set(outKey, (edgeCount.get(outKey) || 0) - 1);
      });
      const missingIn = [];
      const missingOut = [];
      edgeCount.forEach((count, vertex2) => {
        if (count < 0)
          missingIn.push(vertex2);
        if (count > 0)
          missingOut.push(vertex2);
      });
      missingIn.forEach((key1) => {
        const v1 = vertexMap.get(key1);
        let bestDistance = Infinity;
        let bestReplacement;
        missingOut.forEach((key2) => {
          const v2 = vertexMap.get(key2);
          const distance = vec3.distance(v1, v2);
          if (distance < bestDistance) {
            bestDistance = distance;
            bestReplacement = v2;
          }
        });
        console.warn(`slice.repair: repairing vertex gap ${v1} to ${bestReplacement} distance ${bestDistance}`);
        edges = edges.map((edge) => {
          if (edge[0].toString() === key1)
            return [bestReplacement, edge[1]];
          if (edge[1].toString() === key1)
            return [edge[0], bestReplacement];
          return edge;
        });
      });
      return create(edges);
    };
    module.exports = repair;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeWalls.js
var require_extrudeWalls = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeWalls.js"(exports, module) {
    var { EPS } = require_constants();
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var slice = require_slice();
    var gcd = (a, b) => {
      if (a === b) {
        return a;
      }
      if (a < b) {
        return gcd(b, a);
      }
      if (b === 1) {
        return 1;
      }
      if (b === 0) {
        return a;
      }
      return gcd(b, a % b);
    };
    var lcm = (a, b) => a * b / gcd(a, b);
    var repartitionEdges = (newlength, edges) => {
      const multiple = newlength / edges.length;
      if (multiple === 1) {
        return edges;
      }
      const divisor = vec3.fromValues(multiple, multiple, multiple);
      const newEdges = [];
      edges.forEach((edge) => {
        const increment = vec3.subtract(vec3.create(), edge[1], edge[0]);
        vec3.divide(increment, increment, divisor);
        let prev = edge[0];
        for (let i = 1; i <= multiple; ++i) {
          const next = vec3.add(vec3.create(), prev, increment);
          newEdges.push([prev, next]);
          prev = next;
        }
      });
      return newEdges;
    };
    var EPSAREA = EPS * EPS / 2 * Math.sin(Math.PI / 3);
    var extrudeWalls = (slice0, slice1) => {
      let edges0 = slice.toEdges(slice0);
      let edges1 = slice.toEdges(slice1);
      if (edges0.length !== edges1.length) {
        const newlength = lcm(edges0.length, edges1.length);
        if (newlength !== edges0.length)
          edges0 = repartitionEdges(newlength, edges0);
        if (newlength !== edges1.length)
          edges1 = repartitionEdges(newlength, edges1);
      }
      const walls = [];
      edges0.forEach((edge0, i) => {
        const edge1 = edges1[i];
        const poly0 = poly3.create([edge0[0], edge0[1], edge1[1]]);
        const poly0area = poly3.measureArea(poly0);
        if (Number.isFinite(poly0area) && poly0area > EPSAREA)
          walls.push(poly0);
        const poly1 = poly3.create([edge0[0], edge1[1], edge1[0]]);
        const poly1area = poly3.measureArea(poly1);
        if (Number.isFinite(poly1area) && poly1area > EPSAREA)
          walls.push(poly1);
      });
      return walls;
    };
    module.exports = extrudeWalls;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeFromSlices.js
var require_extrudeFromSlices = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeFromSlices.js"(exports, module) {
    var mat4 = require_mat4();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var slice = require_slice();
    var repairSlice = require_repair();
    var extrudeWalls = require_extrudeWalls();
    var defaultCallback = (progress, index, base) => {
      let baseSlice = null;
      if (geom2.isA(base))
        baseSlice = slice.fromSides(geom2.toSides(base));
      if (poly3.isA(base))
        baseSlice = slice.fromPoints(poly3.toPoints(base));
      return progress === 0 || progress === 1 ? slice.transform(mat4.fromTranslation(mat4.create(), [0, 0, progress]), baseSlice) : null;
    };
    var extrudeFromSlices = (options, base) => {
      const defaults = {
        numberOfSlices: 2,
        capStart: true,
        capEnd: true,
        close: false,
        repair: true,
        callback: defaultCallback
      };
      const { numberOfSlices, capStart, capEnd, close, repair, callback: generate } = Object.assign({}, defaults, options);
      if (numberOfSlices < 2)
        throw new Error("numberOfSlices must be 2 or more");
      if (repair) {
        base = repairSlice(base);
      }
      const sMax = numberOfSlices - 1;
      let startSlice = null;
      let endSlice = null;
      let prevSlice = null;
      let polygons = [];
      for (let s = 0; s < numberOfSlices; s++) {
        const currentSlice = generate(s / sMax, s, base);
        if (currentSlice) {
          if (!slice.isA(currentSlice))
            throw new Error("the callback function must return slice objects");
          const edges = slice.toEdges(currentSlice);
          if (edges.length === 0)
            throw new Error("the callback function must return slices with one or more edges");
          if (prevSlice) {
            polygons = polygons.concat(extrudeWalls(prevSlice, currentSlice));
          }
          if (s === 0)
            startSlice = currentSlice;
          if (s === numberOfSlices - 1)
            endSlice = currentSlice;
          prevSlice = currentSlice;
        }
      }
      if (capEnd) {
        const endPolygons = slice.toPolygons(endSlice);
        polygons = polygons.concat(endPolygons);
      }
      if (capStart) {
        const startPolygons = slice.toPolygons(startSlice).map(poly3.invert);
        polygons = polygons.concat(startPolygons);
      }
      if (!capStart && !capEnd) {
        if (close && !slice.equals(endSlice, startSlice)) {
          polygons = polygons.concat(extrudeWalls(endSlice, startSlice));
        }
      }
      return geom3.create(polygons);
    };
    module.exports = extrudeFromSlices;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeRotate.js
var require_extrudeRotate = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeRotate.js"(exports, module) {
    var { TAU } = require_constants();
    var mat4 = require_mat4();
    var { mirrorX } = require_mirror();
    var geom2 = require_geom2();
    var slice = require_slice();
    var extrudeFromSlices = require_extrudeFromSlices();
    var extrudeRotate = (options, geometry) => {
      const defaults = {
        segments: 12,
        startAngle: 0,
        angle: TAU,
        overflow: "cap"
      };
      let { segments, startAngle, angle, overflow } = Object.assign({}, defaults, options);
      if (segments < 3)
        throw new Error("segments must be greater then 3");
      startAngle = Math.abs(startAngle) > TAU ? startAngle % TAU : startAngle;
      angle = Math.abs(angle) > TAU ? angle % TAU : angle;
      let endAngle = startAngle + angle;
      endAngle = Math.abs(endAngle) > TAU ? endAngle % TAU : endAngle;
      if (endAngle < startAngle) {
        const x = startAngle;
        startAngle = endAngle;
        endAngle = x;
      }
      let totalRotation = endAngle - startAngle;
      if (totalRotation <= 0)
        totalRotation = TAU;
      if (Math.abs(totalRotation) < TAU) {
        const anglePerSegment = TAU / segments;
        segments = Math.floor(Math.abs(totalRotation) / anglePerSegment);
        if (Math.abs(totalRotation) > segments * anglePerSegment)
          segments++;
      }
      let shapeSides = geom2.toSides(geometry);
      if (shapeSides.length === 0)
        throw new Error("the given geometry cannot be empty");
      const pointsWithNegativeX = shapeSides.filter((s) => s[0][0] < 0);
      const pointsWithPositiveX = shapeSides.filter((s) => s[0][0] >= 0);
      const arePointsWithNegAndPosX = pointsWithNegativeX.length > 0 && pointsWithPositiveX.length > 0;
      if (arePointsWithNegAndPosX && overflow === "cap") {
        if (pointsWithNegativeX.length > pointsWithPositiveX.length) {
          shapeSides = shapeSides.map((side) => {
            let point0 = side[0];
            let point1 = side[1];
            point0 = [Math.min(point0[0], 0), point0[1]];
            point1 = [Math.min(point1[0], 0), point1[1]];
            return [point0, point1];
          });
          geometry = geom2.reverse(geom2.create(shapeSides));
          geometry = mirrorX(geometry);
        } else if (pointsWithPositiveX.length >= pointsWithNegativeX.length) {
          shapeSides = shapeSides.map((side) => {
            let point0 = side[0];
            let point1 = side[1];
            point0 = [Math.max(point0[0], 0), point0[1]];
            point1 = [Math.max(point1[0], 0), point1[1]];
            return [point0, point1];
          });
          geometry = geom2.create(shapeSides);
        }
      }
      const rotationPerSlice = totalRotation / segments;
      const isCapped = Math.abs(totalRotation) < TAU;
      const baseSlice = slice.fromSides(geom2.toSides(geometry));
      slice.reverse(baseSlice, baseSlice);
      const matrix = mat4.create();
      const createSlice = (progress, index, base) => {
        let Zrotation = rotationPerSlice * index + startAngle;
        if (totalRotation === TAU && index === segments) {
          Zrotation = startAngle;
        }
        mat4.multiply(matrix, mat4.fromZRotation(matrix, Zrotation), mat4.fromXRotation(mat4.create(), TAU / 4));
        return slice.transform(matrix, base);
      };
      options = {
        numberOfSlices: segments + 1,
        capStart: isCapped,
        capEnd: isCapped,
        close: !isCapped,
        callback: createSlice
      };
      return extrudeFromSlices(options, baseSlice);
    };
    module.exports = extrudeRotate;
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/rotate.js
var require_rotate3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/rotate.js"(exports, module) {
    var flatten2 = require_flatten();
    var mat4 = require_mat4();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var rotate = (angles, ...objects) => {
      if (!Array.isArray(angles))
        throw new Error("angles must be an array");
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      angles = angles.slice();
      while (angles.length < 3)
        angles.push(0);
      const yaw = angles[2];
      const pitch = angles[1];
      const roll = angles[0];
      const matrix = mat4.fromTaitBryanRotation(mat4.create(), yaw, pitch, roll);
      const results = objects.map((object) => {
        if (path2.isA(object))
          return path2.transform(matrix, object);
        if (geom2.isA(object))
          return geom2.transform(matrix, object);
        if (geom3.isA(object))
          return geom3.transform(matrix, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    var rotateX = (angle, ...objects) => rotate([angle, 0, 0], objects);
    var rotateY = (angle, ...objects) => rotate([0, angle, 0], objects);
    var rotateZ = (angle, ...objects) => rotate([0, 0, angle], objects);
    module.exports = {
      rotate,
      rotateX,
      rotateY,
      rotateZ
    };
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/translate.js
var require_translate2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/translate.js"(exports, module) {
    var flatten2 = require_flatten();
    var mat4 = require_mat4();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var translate = (offset, ...objects) => {
      if (!Array.isArray(offset))
        throw new Error("offset must be an array");
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      offset = offset.slice();
      while (offset.length < 3)
        offset.push(0);
      const matrix = mat4.fromTranslation(mat4.create(), offset);
      const results = objects.map((object) => {
        if (path2.isA(object))
          return path2.transform(matrix, object);
        if (geom2.isA(object))
          return geom2.transform(matrix, object);
        if (geom3.isA(object))
          return geom3.transform(matrix, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    var translateX = (offset, ...objects) => translate([offset, 0, 0], objects);
    var translateY = (offset, ...objects) => translate([0, offset, 0], objects);
    var translateZ = (offset, ...objects) => translate([0, 0, offset], objects);
    module.exports = {
      translate,
      translateX,
      translateY,
      translateZ
    };
  }
});

// node_modules/@jscad/modeling/src/primitives/torus.js
var require_torus = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/torus.js"(exports, module) {
    var { TAU } = require_constants();
    var extrudeRotate = require_extrudeRotate();
    var { rotate } = require_rotate3();
    var { translate } = require_translate2();
    var circle = require_circle();
    var { isGT, isGTE } = require_commonChecks();
    var torus = (options) => {
      const defaults = {
        innerRadius: 1,
        innerSegments: 32,
        outerRadius: 4,
        outerSegments: 32,
        innerRotation: 0,
        startAngle: 0,
        outerRotation: TAU
      };
      const { innerRadius, innerSegments, outerRadius, outerSegments, innerRotation, startAngle, outerRotation } = Object.assign({}, defaults, options);
      if (!isGT(innerRadius, 0))
        throw new Error("innerRadius must be greater than zero");
      if (!isGTE(innerSegments, 3))
        throw new Error("innerSegments must be three or more");
      if (!isGT(outerRadius, 0))
        throw new Error("outerRadius must be greater than zero");
      if (!isGTE(outerSegments, 3))
        throw new Error("outerSegments must be three or more");
      if (!isGTE(startAngle, 0))
        throw new Error("startAngle must be positive");
      if (!isGT(outerRotation, 0))
        throw new Error("outerRotation must be greater than zero");
      if (innerRadius >= outerRadius)
        throw new Error("inner circle is two large to rotate about the outer circle");
      let innerCircle = circle({ radius: innerRadius, segments: innerSegments });
      if (innerRotation !== 0) {
        innerCircle = rotate([0, 0, innerRotation], innerCircle);
      }
      innerCircle = translate([outerRadius, 0], innerCircle);
      const extrudeOptions = {
        startAngle,
        angle: outerRotation,
        segments: outerSegments
      };
      return extrudeRotate(extrudeOptions, innerCircle);
    };
    module.exports = torus;
  }
});

// node_modules/@jscad/modeling/src/primitives/triangle.js
var require_triangle2 = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/triangle.js"(exports, module) {
    var { NEPS } = require_constants();
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var { isNumberArray } = require_commonChecks();
    var solveAngleFromSSS = (a, b, c) => Math.acos((a * a + b * b - c * c) / (2 * a * b));
    var solveSideFromSAS = (a, C, b) => {
      if (C > NEPS) {
        return Math.sqrt(a * a + b * b - 2 * a * b * Math.cos(C));
      }
      return Math.sqrt((a - b) * (a - b) + a * b * C * C * (1 - C * C / 12));
    };
    var solveAAA = (angles) => {
      const eps = Math.abs(angles[0] + angles[1] + angles[2] - Math.PI);
      if (eps > NEPS)
        throw new Error("AAA triangles require angles that sum to PI");
      const A = angles[0];
      const B = angles[1];
      const C = Math.PI - A - B;
      const c = 1;
      const a = c / Math.sin(C) * Math.sin(A);
      const b = c / Math.sin(C) * Math.sin(B);
      return createTriangle(A, B, C, a, b, c);
    };
    var solveAAS = (values) => {
      const A = values[0];
      const B = values[1];
      const C = Math.PI + NEPS - A - B;
      if (C < NEPS)
        throw new Error("AAS triangles require angles that sum to PI");
      const a = values[2];
      const b = a / Math.sin(A) * Math.sin(B);
      const c = a / Math.sin(A) * Math.sin(C);
      return createTriangle(A, B, C, a, b, c);
    };
    var solveASA = (values) => {
      const A = values[0];
      const B = values[2];
      const C = Math.PI + NEPS - A - B;
      if (C < NEPS)
        throw new Error("ASA triangles require angles that sum to PI");
      const c = values[1];
      const a = c / Math.sin(C) * Math.sin(A);
      const b = c / Math.sin(C) * Math.sin(B);
      return createTriangle(A, B, C, a, b, c);
    };
    var solveSAS = (values) => {
      const c = values[0];
      const B = values[1];
      const a = values[2];
      const b = solveSideFromSAS(c, B, a);
      const A = solveAngleFromSSS(b, c, a);
      const C = Math.PI - A - B;
      return createTriangle(A, B, C, a, b, c);
    };
    var solveSSA = (values) => {
      const c = values[0];
      const a = values[1];
      const C = values[2];
      const A = Math.asin(a * Math.sin(C) / c);
      const B = Math.PI - A - C;
      const b = c / Math.sin(C) * Math.sin(B);
      return createTriangle(A, B, C, a, b, c);
    };
    var solveSSS = (lengths) => {
      const a = lengths[1];
      const b = lengths[2];
      const c = lengths[0];
      if (a + b <= c || b + c <= a || c + a <= b) {
        throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");
      }
      const A = solveAngleFromSSS(b, c, a);
      const B = solveAngleFromSSS(c, a, b);
      const C = Math.PI - A - B;
      return createTriangle(A, B, C, a, b, c);
    };
    var createTriangle = (A, B, C, a, b, c) => {
      const p0 = vec2.fromValues(0, 0);
      const p1 = vec2.fromValues(c, 0);
      const p2 = vec2.fromValues(a, 0);
      vec2.add(p2, vec2.rotate(p2, p2, [0, 0], Math.PI - B), p1);
      return geom2.fromPoints([p0, p1, p2]);
    };
    var triangle4 = (options) => {
      const defaults = {
        type: "SSS",
        values: [1, 1, 1]
      };
      let { type, values } = Object.assign({}, defaults, options);
      if (typeof type !== "string")
        throw new Error("triangle type must be a string");
      type = type.toUpperCase();
      if (!((type[0] === "A" || type[0] === "S") && (type[1] === "A" || type[1] === "S") && (type[2] === "A" || type[2] === "S")))
        throw new Error("triangle type must contain three letters; A or S");
      if (!isNumberArray(values, 3))
        throw new Error("triangle values must contain three values");
      if (!values.every((n) => n > 0))
        throw new Error("triangle values must be greater than zero");
      switch (type) {
        case "AAA":
          return solveAAA(values);
        case "AAS":
          return solveAAS(values);
        case "ASA":
          return solveASA(values);
        case "SAS":
          return solveSAS(values);
        case "SSA":
          return solveSSA(values);
        case "SSS":
          return solveSSS(values);
        default:
          throw new Error("invalid triangle type, try again");
      }
    };
    module.exports = triangle4;
  }
});

// node_modules/@jscad/modeling/src/primitives/index.js
var require_primitives = __commonJS({
  "node_modules/@jscad/modeling/src/primitives/index.js"(exports, module) {
    module.exports = {
      arc: require_arc(),
      circle: require_circle(),
      cube: require_cube(),
      cuboid: require_cuboid(),
      cylinder: require_cylinder(),
      cylinderElliptic: require_cylinderElliptic(),
      ellipse: require_ellipse(),
      ellipsoid: require_ellipsoid(),
      geodesicSphere: require_geodesicSphere(),
      line: require_line(),
      polygon: require_polygon(),
      polyhedron: require_polyhedron(),
      rectangle: require_rectangle(),
      roundedCuboid: require_roundedCuboid(),
      roundedCylinder: require_roundedCylinder(),
      roundedRectangle: require_roundedRectangle(),
      sphere: require_sphere(),
      square: require_square(),
      star: require_star(),
      torus: require_torus(),
      triangle: require_triangle2()
    };
  }
});

// node_modules/@jscad/modeling/src/text/fonts/single-line/hershey/simplex.js
var require_simplex = __commonJS({
  "node_modules/@jscad/modeling/src/text/fonts/single-line/hershey/simplex.js"(exports, module) {
    module.exports = {
      height: 14,
      32: [16],
      33: [10, 5, 21, 5, 7, void 0, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],
      34: [16, 4, 21, 4, 14, void 0, 12, 21, 12, 14],
      35: [21, 11, 25, 4, -7, void 0, 17, 25, 10, -7, void 0, 4, 12, 18, 12, void 0, 3, 6, 17, 6],
      36: [20, 8, 25, 8, -4, void 0, 12, 25, 12, -4, void 0, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3],
      37: [24, 21, 21, 3, 0, void 0, 8, 21, 10, 19, 10, 17, 9, 15, 7, 14, 5, 14, 3, 16, 3, 18, 4, 20, 6, 21, 8, 21, 10, 20, 13, 19, 16, 19, 19, 20, 21, 21, void 0, 17, 7, 15, 6, 14, 4, 14, 2, 16, 0, 18, 0, 20, 1, 21, 3, 21, 5, 19, 7, 17, 7],
      38: [26, 23, 12, 23, 13, 22, 14, 21, 14, 20, 13, 19, 11, 17, 6, 15, 3, 13, 1, 11, 0, 7, 0, 5, 1, 4, 2, 3, 4, 3, 6, 4, 8, 5, 9, 12, 13, 13, 14, 14, 16, 14, 18, 13, 20, 11, 21, 9, 20, 8, 18, 8, 16, 9, 13, 11, 10, 16, 3, 18, 1, 20, 0, 22, 0, 23, 1, 23, 2],
      39: [10, 5, 19, 4, 20, 5, 21, 6, 20, 6, 18, 5, 16, 4, 15],
      40: [14, 11, 25, 9, 23, 7, 20, 5, 16, 4, 11, 4, 7, 5, 2, 7, -2, 9, -5, 11, -7],
      41: [14, 3, 25, 5, 23, 7, 20, 9, 16, 10, 11, 10, 7, 9, 2, 7, -2, 5, -5, 3, -7],
      42: [16, 8, 21, 8, 9, void 0, 3, 18, 13, 12, void 0, 13, 18, 3, 12],
      43: [26, 13, 18, 13, 0, void 0, 4, 9, 22, 9],
      44: [10, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],
      45: [26, 4, 9, 22, 9],
      46: [10, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],
      47: [22, 20, 25, 2, -7],
      48: [20, 9, 21, 6, 20, 4, 17, 3, 12, 3, 9, 4, 4, 6, 1, 9, 0, 11, 0, 14, 1, 16, 4, 17, 9, 17, 12, 16, 17, 14, 20, 11, 21, 9, 21],
      49: [20, 6, 17, 8, 18, 11, 21, 11, 0],
      50: [20, 4, 16, 4, 17, 5, 19, 6, 20, 8, 21, 12, 21, 14, 20, 15, 19, 16, 17, 16, 15, 15, 13, 13, 10, 3, 0, 17, 0],
      51: [20, 5, 21, 16, 21, 10, 13, 13, 13, 15, 12, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4],
      52: [20, 13, 21, 3, 7, 18, 7, void 0, 13, 21, 13, 0],
      53: [20, 15, 21, 5, 21, 4, 12, 5, 13, 8, 14, 11, 14, 14, 13, 16, 11, 17, 8, 17, 6, 16, 3, 14, 1, 11, 0, 8, 0, 5, 1, 4, 2, 3, 4],
      54: [20, 16, 18, 15, 20, 12, 21, 10, 21, 7, 20, 5, 17, 4, 12, 4, 7, 5, 3, 7, 1, 10, 0, 11, 0, 14, 1, 16, 3, 17, 6, 17, 7, 16, 10, 14, 12, 11, 13, 10, 13, 7, 12, 5, 10, 4, 7],
      55: [20, 17, 21, 7, 0, void 0, 3, 21, 17, 21],
      56: [20, 8, 21, 5, 20, 4, 18, 4, 16, 5, 14, 7, 13, 11, 12, 14, 11, 16, 9, 17, 7, 17, 4, 16, 2, 15, 1, 12, 0, 8, 0, 5, 1, 4, 2, 3, 4, 3, 7, 4, 9, 6, 11, 9, 12, 13, 13, 15, 14, 16, 16, 16, 18, 15, 20, 12, 21, 8, 21],
      57: [20, 16, 14, 15, 11, 13, 9, 10, 8, 9, 8, 6, 9, 4, 11, 3, 14, 3, 15, 4, 18, 6, 20, 9, 21, 10, 21, 13, 20, 15, 18, 16, 14, 16, 9, 15, 4, 13, 1, 10, 0, 8, 0, 5, 1, 4, 3],
      58: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, void 0, 5, 2, 4, 1, 5, 0, 6, 1, 5, 2],
      59: [10, 5, 14, 4, 13, 5, 12, 6, 13, 5, 14, void 0, 6, 1, 5, 0, 4, 1, 5, 2, 6, 1, 6, -1, 5, -3, 4, -4],
      60: [24, 20, 18, 4, 9, 20, 0],
      61: [26, 4, 12, 22, 12, void 0, 4, 6, 22, 6],
      62: [24, 4, 18, 20, 9, 4, 0],
      63: [18, 3, 16, 3, 17, 4, 19, 5, 20, 7, 21, 11, 21, 13, 20, 14, 19, 15, 17, 15, 15, 14, 13, 13, 12, 9, 10, 9, 7, void 0, 9, 2, 8, 1, 9, 0, 10, 1, 9, 2],
      64: [27, 18, 13, 17, 15, 15, 16, 12, 16, 10, 15, 9, 14, 8, 11, 8, 8, 9, 6, 11, 5, 14, 5, 16, 6, 17, 8, void 0, 12, 16, 10, 14, 9, 11, 9, 8, 10, 6, 11, 5, void 0, 18, 16, 17, 8, 17, 6, 19, 5, 21, 5, 23, 7, 24, 10, 24, 12, 23, 15, 22, 17, 20, 19, 18, 20, 15, 21, 12, 21, 9, 20, 7, 19, 5, 17, 4, 15, 3, 12, 3, 9, 4, 6, 5, 4, 7, 2, 9, 1, 12, 0, 15, 0, 18, 1, 20, 2, 21, 3, void 0, 19, 16, 18, 8, 18, 6, 19, 5],
      65: [18, 9, 21, 1, 0, void 0, 9, 21, 17, 0, void 0, 4, 7, 14, 7],
      66: [21, 4, 21, 4, 0, void 0, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, void 0, 4, 11, 13, 11, 16, 10, 17, 9, 18, 7, 18, 4, 17, 2, 16, 1, 13, 0, 4, 0],
      67: [21, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5],
      68: [21, 4, 21, 4, 0, void 0, 4, 21, 11, 21, 14, 20, 16, 18, 17, 16, 18, 13, 18, 8, 17, 5, 16, 3, 14, 1, 11, 0, 4, 0],
      69: [19, 4, 21, 4, 0, void 0, 4, 21, 17, 21, void 0, 4, 11, 12, 11, void 0, 4, 0, 17, 0],
      70: [18, 4, 21, 4, 0, void 0, 4, 21, 17, 21, void 0, 4, 11, 12, 11],
      71: [21, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 18, 8, void 0, 13, 8, 18, 8],
      72: [22, 4, 21, 4, 0, void 0, 18, 21, 18, 0, void 0, 4, 11, 18, 11],
      73: [8, 4, 21, 4, 0],
      74: [16, 12, 21, 12, 5, 11, 2, 10, 1, 8, 0, 6, 0, 4, 1, 3, 2, 2, 5, 2, 7],
      75: [21, 4, 21, 4, 0, void 0, 18, 21, 4, 7, void 0, 9, 12, 18, 0],
      76: [17, 4, 21, 4, 0, void 0, 4, 0, 16, 0],
      77: [24, 4, 21, 4, 0, void 0, 4, 21, 12, 0, void 0, 20, 21, 12, 0, void 0, 20, 21, 20, 0],
      78: [22, 4, 21, 4, 0, void 0, 4, 21, 18, 0, void 0, 18, 21, 18, 0],
      79: [22, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21],
      80: [21, 4, 21, 4, 0, void 0, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 14, 17, 12, 16, 11, 13, 10, 4, 10],
      81: [22, 9, 21, 7, 20, 5, 18, 4, 16, 3, 13, 3, 8, 4, 5, 5, 3, 7, 1, 9, 0, 13, 0, 15, 1, 17, 3, 18, 5, 19, 8, 19, 13, 18, 16, 17, 18, 15, 20, 13, 21, 9, 21, void 0, 12, 4, 18, -2],
      82: [21, 4, 21, 4, 0, void 0, 4, 21, 13, 21, 16, 20, 17, 19, 18, 17, 18, 15, 17, 13, 16, 12, 13, 11, 4, 11, void 0, 11, 11, 18, 0],
      83: [20, 17, 18, 15, 20, 12, 21, 8, 21, 5, 20, 3, 18, 3, 16, 4, 14, 5, 13, 7, 12, 13, 10, 15, 9, 16, 8, 17, 6, 17, 3, 15, 1, 12, 0, 8, 0, 5, 1, 3, 3],
      84: [16, 8, 21, 8, 0, void 0, 1, 21, 15, 21],
      85: [22, 4, 21, 4, 6, 5, 3, 7, 1, 10, 0, 12, 0, 15, 1, 17, 3, 18, 6, 18, 21],
      86: [18, 1, 21, 9, 0, void 0, 17, 21, 9, 0],
      87: [24, 2, 21, 7, 0, void 0, 12, 21, 7, 0, void 0, 12, 21, 17, 0, void 0, 22, 21, 17, 0],
      88: [20, 3, 21, 17, 0, void 0, 17, 21, 3, 0],
      89: [18, 1, 21, 9, 11, 9, 0, void 0, 17, 21, 9, 11],
      90: [20, 17, 21, 3, 0, void 0, 3, 21, 17, 21, void 0, 3, 0, 17, 0],
      91: [14, 4, 25, 4, -7, void 0, 5, 25, 5, -7, void 0, 4, 25, 11, 25, void 0, 4, -7, 11, -7],
      92: [14, 0, 21, 14, -3],
      93: [14, 9, 25, 9, -7, void 0, 10, 25, 10, -7, void 0, 3, 25, 10, 25, void 0, 3, -7, 10, -7],
      94: [16, 6, 15, 8, 18, 10, 15, void 0, 3, 12, 8, 17, 13, 12, void 0, 8, 17, 8, 0],
      95: [16, 0, -2, 16, -2],
      96: [10, 6, 21, 5, 20, 4, 18, 4, 16, 5, 15, 6, 16, 5, 17],
      97: [19, 15, 14, 15, 0, void 0, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],
      98: [19, 4, 21, 4, 0, void 0, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3],
      99: [18, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],
      100: [19, 15, 21, 15, 0, void 0, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],
      101: [18, 3, 8, 15, 8, 15, 10, 14, 12, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],
      102: [12, 10, 21, 8, 21, 6, 20, 5, 17, 5, 0, void 0, 2, 14, 9, 14],
      103: [19, 15, 14, 15, -2, 14, -5, 13, -6, 11, -7, 8, -7, 6, -6, void 0, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],
      104: [19, 4, 21, 4, 0, void 0, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],
      105: [8, 3, 21, 4, 20, 5, 21, 4, 22, 3, 21, void 0, 4, 14, 4, 0],
      106: [10, 5, 21, 6, 20, 7, 21, 6, 22, 5, 21, void 0, 6, 14, 6, -3, 5, -6, 3, -7, 1, -7],
      107: [17, 4, 21, 4, 0, void 0, 14, 14, 4, 4, void 0, 8, 8, 15, 0],
      108: [8, 4, 21, 4, 0],
      109: [30, 4, 14, 4, 0, void 0, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0, void 0, 15, 10, 18, 13, 20, 14, 23, 14, 25, 13, 26, 10, 26, 0],
      110: [19, 4, 14, 4, 0, void 0, 4, 10, 7, 13, 9, 14, 12, 14, 14, 13, 15, 10, 15, 0],
      111: [19, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3, 16, 6, 16, 8, 15, 11, 13, 13, 11, 14, 8, 14],
      112: [19, 4, 14, 4, -7, void 0, 4, 11, 6, 13, 8, 14, 11, 14, 13, 13, 15, 11, 16, 8, 16, 6, 15, 3, 13, 1, 11, 0, 8, 0, 6, 1, 4, 3],
      113: [19, 15, 14, 15, -7, void 0, 15, 11, 13, 13, 11, 14, 8, 14, 6, 13, 4, 11, 3, 8, 3, 6, 4, 3, 6, 1, 8, 0, 11, 0, 13, 1, 15, 3],
      114: [13, 4, 14, 4, 0, void 0, 4, 8, 5, 11, 7, 13, 9, 14, 12, 14],
      115: [17, 14, 11, 13, 13, 10, 14, 7, 14, 4, 13, 3, 11, 4, 9, 6, 8, 11, 7, 13, 6, 14, 4, 14, 3, 13, 1, 10, 0, 7, 0, 4, 1, 3, 3],
      116: [12, 5, 21, 5, 4, 6, 1, 8, 0, 10, 0, void 0, 2, 14, 9, 14],
      117: [19, 4, 14, 4, 4, 5, 1, 7, 0, 10, 0, 12, 1, 15, 4, void 0, 15, 14, 15, 0],
      118: [16, 2, 14, 8, 0, void 0, 14, 14, 8, 0],
      119: [22, 3, 14, 7, 0, void 0, 11, 14, 7, 0, void 0, 11, 14, 15, 0, void 0, 19, 14, 15, 0],
      120: [17, 3, 14, 14, 0, void 0, 14, 14, 3, 0],
      121: [16, 2, 14, 8, 0, void 0, 14, 14, 8, 0, 6, -4, 4, -6, 2, -7, 1, -7],
      122: [17, 14, 14, 3, 0, void 0, 3, 14, 14, 14, void 0, 3, 0, 14, 0],
      123: [14, 9, 25, 7, 24, 6, 23, 5, 21, 5, 19, 6, 17, 7, 16, 8, 14, 8, 12, 6, 10, void 0, 7, 24, 6, 22, 6, 20, 7, 18, 8, 17, 9, 15, 9, 13, 8, 11, 4, 9, 8, 7, 9, 5, 9, 3, 8, 1, 7, 0, 6, -2, 6, -4, 7, -6, void 0, 6, 8, 8, 6, 8, 4, 7, 2, 6, 1, 5, -1, 5, -3, 6, -5, 7, -6, 9, -7],
      124: [8, 4, 25, 4, -7],
      125: [14, 5, 25, 7, 24, 8, 23, 9, 21, 9, 19, 8, 17, 7, 16, 6, 14, 6, 12, 8, 10, void 0, 7, 24, 8, 22, 8, 20, 7, 18, 6, 17, 5, 15, 5, 13, 6, 11, 10, 9, 6, 7, 5, 5, 5, 3, 6, 1, 7, 0, 8, -2, 8, -4, 7, -6, void 0, 8, 8, 6, 6, 6, 4, 7, 2, 8, 1, 9, -1, 9, -3, 8, -5, 7, -6, 5, -7],
      126: [24, 3, 6, 3, 8, 4, 11, 6, 12, 8, 12, 10, 11, 14, 8, 16, 7, 18, 7, 20, 8, 21, 10, void 0, 3, 8, 4, 10, 6, 11, 8, 11, 10, 10, 14, 7, 16, 6, 18, 6, 20, 7, 21, 10, 21, 12]
    };
  }
});

// node_modules/@jscad/modeling/src/text/vectorParams.js
var require_vectorParams = __commonJS({
  "node_modules/@jscad/modeling/src/text/vectorParams.js"(exports, module) {
    var defaultFont = require_simplex();
    var defaultsVectorParams = {
      xOffset: 0,
      yOffset: 0,
      input: "?",
      align: "left",
      font: defaultFont,
      height: 14,
      // == old vector_xxx simplex font height
      lineSpacing: 2.142857142857143,
      // == 30/14 == old vector_xxx ratio
      letterSpacing: 1,
      extrudeOffset: 0
    };
    var vectorParams = (options, input) => {
      if (!input && typeof options === "string") {
        options = { input: options };
      }
      options = options || {};
      const params = Object.assign({}, defaultsVectorParams, options);
      params.input = input || params.input;
      return params;
    };
    module.exports = vectorParams;
  }
});

// node_modules/@jscad/modeling/src/text/vectorChar.js
var require_vectorChar = __commonJS({
  "node_modules/@jscad/modeling/src/text/vectorChar.js"(exports, module) {
    var vectorParams = require_vectorParams();
    var vectorChar = (options, char) => {
      const {
        xOffset,
        yOffset,
        input,
        font,
        height,
        extrudeOffset
      } = vectorParams(options, char);
      let code = input.charCodeAt(0);
      if (!code || !font[code]) {
        code = 63;
      }
      const glyph = [].concat(font[code]);
      const ratio = (height - extrudeOffset) / font.height;
      const extrudeYOffset = extrudeOffset / 2;
      const width = glyph.shift() * ratio;
      const segments = [];
      let polyline = [];
      for (let i = 0, il = glyph.length; i < il; i += 2) {
        const gx = ratio * glyph[i] + xOffset;
        const gy = ratio * glyph[i + 1] + yOffset + extrudeYOffset;
        if (glyph[i] !== void 0) {
          polyline.push([gx, gy]);
          continue;
        }
        segments.push(polyline);
        polyline = [];
        i--;
      }
      if (polyline.length) {
        segments.push(polyline);
      }
      return { width, height, segments };
    };
    module.exports = vectorChar;
  }
});

// node_modules/@jscad/modeling/src/text/vectorText.js
var require_vectorText = __commonJS({
  "node_modules/@jscad/modeling/src/text/vectorText.js"(exports, module) {
    var vectorChar = require_vectorChar();
    var vectorParams = require_vectorParams();
    var translateLine = (options, line) => {
      const { x, y } = Object.assign({ x: 0, y: 0 }, options || {});
      const segments = line.segments;
      let segment = null;
      let point = null;
      for (let i = 0, il = segments.length; i < il; i++) {
        segment = segments[i];
        for (let j = 0, jl = segment.length; j < jl; j++) {
          point = segment[j];
          segment[j] = [point[0] + x, point[1] + y];
        }
      }
      return line;
    };
    var vectorText = (options, text) => {
      const {
        xOffset,
        yOffset,
        input,
        font,
        height,
        align,
        extrudeOffset,
        lineSpacing,
        letterSpacing
      } = vectorParams(options, text);
      let [x, y] = [xOffset, yOffset];
      let i, il, char, vect, width, diff;
      let line = { width: 0, segments: [] };
      const lines = [];
      let output = [];
      let maxWidth = 0;
      const lineStart = x;
      const pushLine = () => {
        lines.push(line);
        maxWidth = Math.max(maxWidth, line.width);
        line = { width: 0, segments: [] };
      };
      for (i = 0, il = input.length; i < il; i++) {
        char = input[i];
        vect = vectorChar({ xOffset: x, yOffset: y, font, height, extrudeOffset }, char);
        if (char === "\n") {
          x = lineStart;
          y -= vect.height * lineSpacing;
          pushLine();
          continue;
        }
        width = vect.width * letterSpacing;
        line.width += width;
        x += width;
        if (char !== " ") {
          line.segments = line.segments.concat(vect.segments);
        }
      }
      if (line.segments.length) {
        pushLine();
      }
      for (i = 0, il = lines.length; i < il; i++) {
        line = lines[i];
        if (maxWidth > line.width) {
          diff = maxWidth - line.width;
          if (align === "right") {
            line = translateLine({ x: diff }, line);
          } else if (align === "center") {
            line = translateLine({ x: diff / 2 }, line);
          }
        }
        output = output.concat(line.segments);
      }
      return output;
    };
    module.exports = vectorText;
  }
});

// node_modules/@jscad/modeling/src/text/index.js
var require_text = __commonJS({
  "node_modules/@jscad/modeling/src/text/index.js"(exports, module) {
    module.exports = {
      vectorChar: require_vectorChar(),
      vectorText: require_vectorText()
    };
  }
});

// node_modules/@jscad/modeling/src/utils/areAllShapesTheSameType.js
var require_areAllShapesTheSameType = __commonJS({
  "node_modules/@jscad/modeling/src/utils/areAllShapesTheSameType.js"(exports, module) {
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var areAllShapesTheSameType = (shapes) => {
      let previousType;
      for (const shape of shapes) {
        let currentType = 0;
        if (geom2.isA(shape))
          currentType = 1;
        if (geom3.isA(shape))
          currentType = 2;
        if (path2.isA(shape))
          currentType = 3;
        if (previousType && currentType !== previousType)
          return false;
        previousType = currentType;
      }
      return true;
    };
    module.exports = areAllShapesTheSameType;
  }
});

// node_modules/@jscad/modeling/src/utils/degToRad.js
var require_degToRad = __commonJS({
  "node_modules/@jscad/modeling/src/utils/degToRad.js"(exports, module) {
    var degToRad = (degrees) => degrees * 0.017453292519943295;
    module.exports = degToRad;
  }
});

// node_modules/@jscad/modeling/src/utils/fnNumberSort.js
var require_fnNumberSort = __commonJS({
  "node_modules/@jscad/modeling/src/utils/fnNumberSort.js"(exports, module) {
    var fnNumberSort = (a, b) => a - b;
    module.exports = fnNumberSort;
  }
});

// node_modules/@jscad/modeling/src/utils/insertSorted.js
var require_insertSorted = __commonJS({
  "node_modules/@jscad/modeling/src/utils/insertSorted.js"(exports, module) {
    var insertSorted = (array, element, comparefunc) => {
      let leftbound = 0;
      let rightbound = array.length;
      while (rightbound > leftbound) {
        const testindex = Math.floor((leftbound + rightbound) / 2);
        const testelement = array[testindex];
        const compareresult = comparefunc(element, testelement);
        if (compareresult > 0) {
          leftbound = testindex + 1;
        } else {
          rightbound = testindex;
        }
      }
      array.splice(leftbound, 0, element);
    };
    module.exports = insertSorted;
  }
});

// node_modules/@jscad/modeling/src/utils/radiusToSegments.js
var require_radiusToSegments = __commonJS({
  "node_modules/@jscad/modeling/src/utils/radiusToSegments.js"(exports, module) {
    var { TAU } = require_constants();
    var radiusToSegments = (radius, minimumLength, minimumAngle) => {
      const ss = minimumLength > 0 ? radius * TAU / minimumLength : 0;
      const as = minimumAngle > 0 ? TAU / minimumAngle : 0;
      return Math.ceil(Math.max(ss, as, 4));
    };
    module.exports = radiusToSegments;
  }
});

// node_modules/@jscad/modeling/src/utils/radToDeg.js
var require_radToDeg = __commonJS({
  "node_modules/@jscad/modeling/src/utils/radToDeg.js"(exports, module) {
    var radToDeg = (radians) => radians * 57.29577951308232;
    module.exports = radToDeg;
  }
});

// node_modules/@jscad/modeling/src/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/@jscad/modeling/src/utils/index.js"(exports, module) {
    module.exports = {
      areAllShapesTheSameType: require_areAllShapesTheSameType(),
      degToRad: require_degToRad(),
      flatten: require_flatten(),
      fnNumberSort: require_fnNumberSort(),
      insertSorted: require_insertSorted(),
      radiusToSegments: require_radiusToSegments(),
      radToDeg: require_radToDeg()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/fromFakePolygons.js
var require_fromFakePolygons = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/fromFakePolygons.js"(exports, module) {
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var fromFakePolygon = (epsilon, polygon) => {
      if (polygon.vertices.length < 4) {
        return null;
      }
      const vert1Indices = [];
      const points3D = polygon.vertices.filter((vertex2, i) => {
        if (vertex2[2] > 0) {
          vert1Indices.push(i);
          return true;
        }
        return false;
      });
      if (points3D.length !== 2) {
        throw new Error("Assertion failed: fromFakePolygon: not enough points found");
      }
      const points2D = points3D.map((v3) => {
        const x = Math.round(v3[0] / epsilon) * epsilon + 0;
        const y = Math.round(v3[1] / epsilon) * epsilon + 0;
        return vec2.fromValues(x, y);
      });
      if (vec2.equals(points2D[0], points2D[1]))
        return null;
      const d = vert1Indices[1] - vert1Indices[0];
      if (d === 1 || d === 3) {
        if (d === 1) {
          points2D.reverse();
        }
      } else {
        throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");
      }
      return points2D;
    };
    var fromFakePolygons = (epsilon, polygons) => {
      const sides = polygons.map((polygon) => fromFakePolygon(epsilon, polygon)).filter((polygon) => polygon !== null);
      return geom2.create(sides);
    };
    module.exports = fromFakePolygons;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/to3DWalls.js
var require_to3DWalls = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/to3DWalls.js"(exports, module) {
    var vec3 = require_vec3();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var to3DWall = (z0, z1, side) => {
      const points = [
        vec3.fromVec2(vec3.create(), side[0], z0),
        vec3.fromVec2(vec3.create(), side[1], z0),
        vec3.fromVec2(vec3.create(), side[1], z1),
        vec3.fromVec2(vec3.create(), side[0], z1)
      ];
      return poly3.create(points);
    };
    var to3DWalls = (options, geometry) => {
      const sides = geom2.toSides(geometry);
      const polygons = sides.map((side) => to3DWall(options.z0, options.z1, side));
      const result = geom3.create(polygons);
      return result;
    };
    module.exports = to3DWalls;
  }
});

// node_modules/@jscad/modeling/src/maths/OrthoNormalBasis.js
var require_OrthoNormalBasis = __commonJS({
  "node_modules/@jscad/modeling/src/maths/OrthoNormalBasis.js"(exports, module) {
    var mat4 = require_mat4();
    var vec2 = require_vec2();
    var vec3 = require_vec3();
    var OrthoNormalBasis = function(plane, rightvector) {
      if (arguments.length < 2) {
        rightvector = vec3.orthogonal(vec3.create(), plane);
      }
      this.v = vec3.normalize(vec3.create(), vec3.cross(vec3.create(), plane, rightvector));
      this.u = vec3.cross(vec3.create(), this.v, plane);
      this.plane = plane;
      this.planeorigin = vec3.scale(vec3.create(), plane, plane[3]);
    };
    OrthoNormalBasis.GetCartesian = function(xaxisid, yaxisid) {
      const axisid = xaxisid + "/" + yaxisid;
      let planenormal, rightvector;
      if (axisid === "X/Y") {
        planenormal = [0, 0, 1];
        rightvector = [1, 0, 0];
      } else if (axisid === "Y/-X") {
        planenormal = [0, 0, 1];
        rightvector = [0, 1, 0];
      } else if (axisid === "-X/-Y") {
        planenormal = [0, 0, 1];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Y/X") {
        planenormal = [0, 0, 1];
        rightvector = [0, -1, 0];
      } else if (axisid === "-X/Y") {
        planenormal = [0, 0, -1];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Y/-X") {
        planenormal = [0, 0, -1];
        rightvector = [0, -1, 0];
      } else if (axisid === "X/-Y") {
        planenormal = [0, 0, -1];
        rightvector = [1, 0, 0];
      } else if (axisid === "Y/X") {
        planenormal = [0, 0, -1];
        rightvector = [0, 1, 0];
      } else if (axisid === "X/Z") {
        planenormal = [0, -1, 0];
        rightvector = [1, 0, 0];
      } else if (axisid === "Z/-X") {
        planenormal = [0, -1, 0];
        rightvector = [0, 0, 1];
      } else if (axisid === "-X/-Z") {
        planenormal = [0, -1, 0];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Z/X") {
        planenormal = [0, -1, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "-X/Z") {
        planenormal = [0, 1, 0];
        rightvector = [-1, 0, 0];
      } else if (axisid === "-Z/-X") {
        planenormal = [0, 1, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "X/-Z") {
        planenormal = [0, 1, 0];
        rightvector = [1, 0, 0];
      } else if (axisid === "Z/X") {
        planenormal = [0, 1, 0];
        rightvector = [0, 0, 1];
      } else if (axisid === "Y/Z") {
        planenormal = [1, 0, 0];
        rightvector = [0, 1, 0];
      } else if (axisid === "Z/-Y") {
        planenormal = [1, 0, 0];
        rightvector = [0, 0, 1];
      } else if (axisid === "-Y/-Z") {
        planenormal = [1, 0, 0];
        rightvector = [0, -1, 0];
      } else if (axisid === "-Z/Y") {
        planenormal = [1, 0, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "-Y/Z") {
        planenormal = [-1, 0, 0];
        rightvector = [0, -1, 0];
      } else if (axisid === "-Z/-Y") {
        planenormal = [-1, 0, 0];
        rightvector = [0, 0, -1];
      } else if (axisid === "Y/-Z") {
        planenormal = [-1, 0, 0];
        rightvector = [0, 1, 0];
      } else if (axisid === "Z/Y") {
        planenormal = [-1, 0, 0];
        rightvector = [0, 0, 1];
      } else {
        throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");
      }
      return new OrthoNormalBasis(new Plane(new Vector3D(planenormal), 0), new Vector3D(rightvector));
    };
    OrthoNormalBasis.Z0Plane = function() {
      const plane = new Plane(new Vector3D([0, 0, 1]), 0);
      return new OrthoNormalBasis(plane, new Vector3D([1, 0, 0]));
    };
    OrthoNormalBasis.prototype = {
      getProjectionMatrix: function() {
        return mat4.fromValues(
          this.u[0],
          this.v[0],
          this.plane[0],
          0,
          this.u[1],
          this.v[1],
          this.plane[1],
          0,
          this.u[2],
          this.v[2],
          this.plane[2],
          0,
          0,
          0,
          -this.plane[3],
          1
        );
      },
      getInverseProjectionMatrix: function() {
        const p = vec3.scale(vec3.create(), this.plane, this.plane[3]);
        return mat4.fromValues(
          this.u[0],
          this.u[1],
          this.u[2],
          0,
          this.v[0],
          this.v[1],
          this.v[2],
          0,
          this.plane[0],
          this.plane[1],
          this.plane[2],
          0,
          p[0],
          p[1],
          p[2],
          1
        );
      },
      to2D: function(point) {
        return vec2.fromValues(vec3.dot(point, this.u), vec3.dot(point, this.v));
      },
      to3D: function(point) {
        const v1 = vec3.scale(vec3.create(), this.u, point[0]);
        const v2 = vec3.scale(vec3.create(), this.v, point[1]);
        const v3 = vec3.add(v1, v1, this.planeorigin);
        const v4 = vec3.add(v2, v2, v3);
        return v4;
      },
      line3Dto2D: function(line3d) {
        const a = line3d.point;
        const b = line3d.direction.plus(a);
        const a2d = this.to2D(a);
        const b2d = this.to2D(b);
        return Line2D.fromPoints(a2d, b2d);
      },
      line2Dto3D: function(line2d) {
        const a = line2d.origin();
        const b = line2d.direction().plus(a);
        const a3d = this.to3D(a);
        const b3d = this.to3D(b);
        return Line3D.fromPoints(a3d, b3d);
      },
      transform: function(matrix4x4) {
        const newplane = this.plane.transform(matrix4x4);
        const rightpointTransformed = this.u.transform(matrix4x4);
        const originTransformed = new Vector3D(0, 0, 0).transform(matrix4x4);
        const newrighthandvector = rightpointTransformed.minus(originTransformed);
        const newbasis = new OrthoNormalBasis(newplane, newrighthandvector);
        return newbasis;
      }
    };
    module.exports = OrthoNormalBasis;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/reTesselateCoplanarPolygons.js
var require_reTesselateCoplanarPolygons = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/reTesselateCoplanarPolygons.js"(exports, module) {
    var { EPS } = require_constants();
    var line2 = require_line2();
    var vec2 = require_vec2();
    var OrthoNormalBasis = require_OrthoNormalBasis();
    var interpolateBetween2DPointsForY = require_interpolateBetween2DPointsForY();
    var { insertSorted, fnNumberSort } = require_utils2();
    var poly3 = require_poly3();
    var reTesselateCoplanarPolygons = (sourcepolygons) => {
      if (sourcepolygons.length < 2)
        return sourcepolygons;
      const destpolygons = [];
      const numpolygons = sourcepolygons.length;
      const plane = poly3.plane(sourcepolygons[0]);
      const orthobasis = new OrthoNormalBasis(plane);
      const polygonvertices2d = [];
      const polygontopvertexindexes = [];
      const topy2polygonindexes = /* @__PURE__ */ new Map();
      const ycoordinatetopolygonindexes = /* @__PURE__ */ new Map();
      const ycoordinatebins = /* @__PURE__ */ new Map();
      const ycoordinateBinningFactor = 10 / EPS;
      for (let polygonindex = 0; polygonindex < numpolygons; polygonindex++) {
        const poly3d = sourcepolygons[polygonindex];
        let vertices2d = [];
        let numvertices = poly3d.vertices.length;
        let minindex = -1;
        if (numvertices > 0) {
          let miny;
          let maxy;
          for (let i = 0; i < numvertices; i++) {
            let pos2d = orthobasis.to2D(poly3d.vertices[i]);
            const ycoordinatebin = Math.floor(pos2d[1] * ycoordinateBinningFactor);
            let newy;
            if (ycoordinatebins.has(ycoordinatebin)) {
              newy = ycoordinatebins.get(ycoordinatebin);
            } else if (ycoordinatebins.has(ycoordinatebin + 1)) {
              newy = ycoordinatebins.get(ycoordinatebin + 1);
            } else if (ycoordinatebins.has(ycoordinatebin - 1)) {
              newy = ycoordinatebins.get(ycoordinatebin - 1);
            } else {
              newy = pos2d[1];
              ycoordinatebins.set(ycoordinatebin, pos2d[1]);
            }
            pos2d = vec2.fromValues(pos2d[0], newy);
            vertices2d.push(pos2d);
            const y = pos2d[1];
            if (i === 0 || y < miny) {
              miny = y;
              minindex = i;
            }
            if (i === 0 || y > maxy) {
              maxy = y;
            }
            let polygonindexes = ycoordinatetopolygonindexes.get(y);
            if (!polygonindexes) {
              polygonindexes = {};
              ycoordinatetopolygonindexes.set(y, polygonindexes);
            }
            polygonindexes[polygonindex] = true;
          }
          if (miny >= maxy) {
            vertices2d = [];
            numvertices = 0;
            minindex = -1;
          } else {
            let polygonindexes = topy2polygonindexes.get(miny);
            if (!polygonindexes) {
              polygonindexes = [];
              topy2polygonindexes.set(miny, polygonindexes);
            }
            polygonindexes.push(polygonindex);
          }
        }
        vertices2d.reverse();
        minindex = numvertices - minindex - 1;
        polygonvertices2d.push(vertices2d);
        polygontopvertexindexes.push(minindex);
      }
      const ycoordinates = [];
      ycoordinatetopolygonindexes.forEach((polylist, y) => ycoordinates.push(y));
      ycoordinates.sort(fnNumberSort);
      let activepolygons = [];
      let prevoutpolygonrow = [];
      for (let yindex = 0; yindex < ycoordinates.length; yindex++) {
        const newoutpolygonrow = [];
        const ycoordinate = ycoordinates[yindex];
        const polygonindexeswithcorner = ycoordinatetopolygonindexes.get(ycoordinate);
        for (let activepolygonindex = 0; activepolygonindex < activepolygons.length; ++activepolygonindex) {
          const activepolygon = activepolygons[activepolygonindex];
          const polygonindex = activepolygon.polygonindex;
          if (polygonindexeswithcorner[polygonindex]) {
            const vertices2d = polygonvertices2d[polygonindex];
            const numvertices = vertices2d.length;
            let newleftvertexindex = activepolygon.leftvertexindex;
            let newrightvertexindex = activepolygon.rightvertexindex;
            while (true) {
              let nextleftvertexindex = newleftvertexindex + 1;
              if (nextleftvertexindex >= numvertices)
                nextleftvertexindex = 0;
              if (vertices2d[nextleftvertexindex][1] !== ycoordinate)
                break;
              newleftvertexindex = nextleftvertexindex;
            }
            let nextrightvertexindex = newrightvertexindex - 1;
            if (nextrightvertexindex < 0)
              nextrightvertexindex = numvertices - 1;
            if (vertices2d[nextrightvertexindex][1] === ycoordinate) {
              newrightvertexindex = nextrightvertexindex;
            }
            if (newleftvertexindex !== activepolygon.leftvertexindex && newleftvertexindex === newrightvertexindex) {
              activepolygons.splice(activepolygonindex, 1);
              --activepolygonindex;
            } else {
              activepolygon.leftvertexindex = newleftvertexindex;
              activepolygon.rightvertexindex = newrightvertexindex;
              activepolygon.topleft = vertices2d[newleftvertexindex];
              activepolygon.topright = vertices2d[newrightvertexindex];
              let nextleftvertexindex = newleftvertexindex + 1;
              if (nextleftvertexindex >= numvertices)
                nextleftvertexindex = 0;
              activepolygon.bottomleft = vertices2d[nextleftvertexindex];
              let nextrightvertexindex2 = newrightvertexindex - 1;
              if (nextrightvertexindex2 < 0)
                nextrightvertexindex2 = numvertices - 1;
              activepolygon.bottomright = vertices2d[nextrightvertexindex2];
            }
          }
        }
        let nextycoordinate;
        if (yindex >= ycoordinates.length - 1) {
          activepolygons = [];
          nextycoordinate = null;
        } else {
          nextycoordinate = Number(ycoordinates[yindex + 1]);
          const middleycoordinate = 0.5 * (ycoordinate + nextycoordinate);
          const startingpolygonindexes = topy2polygonindexes.get(ycoordinate);
          for (const polygonindexKey in startingpolygonindexes) {
            const polygonindex = startingpolygonindexes[polygonindexKey];
            const vertices2d = polygonvertices2d[polygonindex];
            const numvertices = vertices2d.length;
            const topvertexindex = polygontopvertexindexes[polygonindex];
            let topleftvertexindex = topvertexindex;
            while (true) {
              let i = topleftvertexindex + 1;
              if (i >= numvertices)
                i = 0;
              if (vertices2d[i][1] !== ycoordinate)
                break;
              if (i === topvertexindex)
                break;
              topleftvertexindex = i;
            }
            let toprightvertexindex = topvertexindex;
            while (true) {
              let i = toprightvertexindex - 1;
              if (i < 0)
                i = numvertices - 1;
              if (vertices2d[i][1] !== ycoordinate)
                break;
              if (i === topleftvertexindex)
                break;
              toprightvertexindex = i;
            }
            let nextleftvertexindex = topleftvertexindex + 1;
            if (nextleftvertexindex >= numvertices)
              nextleftvertexindex = 0;
            let nextrightvertexindex = toprightvertexindex - 1;
            if (nextrightvertexindex < 0)
              nextrightvertexindex = numvertices - 1;
            const newactivepolygon = {
              polygonindex,
              leftvertexindex: topleftvertexindex,
              rightvertexindex: toprightvertexindex,
              topleft: vertices2d[topleftvertexindex],
              topright: vertices2d[toprightvertexindex],
              bottomleft: vertices2d[nextleftvertexindex],
              bottomright: vertices2d[nextrightvertexindex]
            };
            insertSorted(activepolygons, newactivepolygon, (el1, el2) => {
              const x1 = interpolateBetween2DPointsForY(el1.topleft, el1.bottomleft, middleycoordinate);
              const x2 = interpolateBetween2DPointsForY(el2.topleft, el2.bottomleft, middleycoordinate);
              if (x1 > x2)
                return 1;
              if (x1 < x2)
                return -1;
              return 0;
            });
          }
        }
        for (const activepolygonKey in activepolygons) {
          const activepolygon = activepolygons[activepolygonKey];
          let x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, ycoordinate);
          const topleft = vec2.fromValues(x, ycoordinate);
          x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, ycoordinate);
          const topright = vec2.fromValues(x, ycoordinate);
          x = interpolateBetween2DPointsForY(activepolygon.topleft, activepolygon.bottomleft, nextycoordinate);
          const bottomleft = vec2.fromValues(x, nextycoordinate);
          x = interpolateBetween2DPointsForY(activepolygon.topright, activepolygon.bottomright, nextycoordinate);
          const bottomright = vec2.fromValues(x, nextycoordinate);
          const outpolygon = {
            topleft,
            topright,
            bottomleft,
            bottomright,
            leftline: line2.fromPoints(line2.create(), topleft, bottomleft),
            rightline: line2.fromPoints(line2.create(), bottomright, topright)
          };
          if (newoutpolygonrow.length > 0) {
            const prevoutpolygon = newoutpolygonrow[newoutpolygonrow.length - 1];
            const d1 = vec2.distance(outpolygon.topleft, prevoutpolygon.topright);
            const d2 = vec2.distance(outpolygon.bottomleft, prevoutpolygon.bottomright);
            if (d1 < EPS && d2 < EPS) {
              outpolygon.topleft = prevoutpolygon.topleft;
              outpolygon.leftline = prevoutpolygon.leftline;
              outpolygon.bottomleft = prevoutpolygon.bottomleft;
              newoutpolygonrow.splice(newoutpolygonrow.length - 1, 1);
            }
          }
          newoutpolygonrow.push(outpolygon);
        }
        if (yindex > 0) {
          const prevcontinuedindexes = /* @__PURE__ */ new Set();
          const matchedindexes = /* @__PURE__ */ new Set();
          for (let i = 0; i < newoutpolygonrow.length; i++) {
            const thispolygon = newoutpolygonrow[i];
            for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {
              if (!matchedindexes.has(ii)) {
                const prevpolygon = prevoutpolygonrow[ii];
                if (vec2.distance(prevpolygon.bottomleft, thispolygon.topleft) < EPS) {
                  if (vec2.distance(prevpolygon.bottomright, thispolygon.topright) < EPS) {
                    matchedindexes.add(ii);
                    const v1 = line2.direction(thispolygon.leftline);
                    const v2 = line2.direction(prevpolygon.leftline);
                    const d1 = v1[0] - v2[0];
                    const v3 = line2.direction(thispolygon.rightline);
                    const v4 = line2.direction(prevpolygon.rightline);
                    const d2 = v3[0] - v4[0];
                    const leftlinecontinues = Math.abs(d1) < EPS;
                    const rightlinecontinues = Math.abs(d2) < EPS;
                    const leftlineisconvex = leftlinecontinues || d1 >= 0;
                    const rightlineisconvex = rightlinecontinues || d2 >= 0;
                    if (leftlineisconvex && rightlineisconvex) {
                      thispolygon.outpolygon = prevpolygon.outpolygon;
                      thispolygon.leftlinecontinues = leftlinecontinues;
                      thispolygon.rightlinecontinues = rightlinecontinues;
                      prevcontinuedindexes.add(ii);
                    }
                    break;
                  }
                }
              }
            }
          }
          for (let ii = 0; ii < prevoutpolygonrow.length; ii++) {
            if (!prevcontinuedindexes.has(ii)) {
              const prevpolygon = prevoutpolygonrow[ii];
              prevpolygon.outpolygon.rightpoints.push(prevpolygon.bottomright);
              if (vec2.distance(prevpolygon.bottomright, prevpolygon.bottomleft) > EPS) {
                prevpolygon.outpolygon.leftpoints.push(prevpolygon.bottomleft);
              }
              prevpolygon.outpolygon.leftpoints.reverse();
              const points2d = prevpolygon.outpolygon.rightpoints.concat(prevpolygon.outpolygon.leftpoints);
              const vertices3d = points2d.map((point2d) => orthobasis.to3D(point2d));
              const polygon = poly3.fromPointsAndPlane(vertices3d, plane);
              if (polygon.vertices.length)
                destpolygons.push(polygon);
            }
          }
        }
        for (let i = 0; i < newoutpolygonrow.length; i++) {
          const thispolygon = newoutpolygonrow[i];
          if (!thispolygon.outpolygon) {
            thispolygon.outpolygon = {
              leftpoints: [],
              rightpoints: []
            };
            thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);
            if (vec2.distance(thispolygon.topleft, thispolygon.topright) > EPS) {
              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);
            }
          } else {
            if (!thispolygon.leftlinecontinues) {
              thispolygon.outpolygon.leftpoints.push(thispolygon.topleft);
            }
            if (!thispolygon.rightlinecontinues) {
              thispolygon.outpolygon.rightpoints.push(thispolygon.topright);
            }
          }
        }
        prevoutpolygonrow = newoutpolygonrow;
      }
      return destpolygons;
    };
    module.exports = reTesselateCoplanarPolygons;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/retessellate.js
var require_retessellate = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/retessellate.js"(exports, module) {
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var aboutEqualNormals = require_aboutEqualNormals();
    var reTesselateCoplanarPolygons = require_reTesselateCoplanarPolygons();
    var coplanar = (plane1, plane2) => {
      if (Math.abs(plane1[3] - plane2[3]) < 15e-8) {
        return aboutEqualNormals(plane1, plane2);
      }
      return false;
    };
    var retessellate = (geometry) => {
      if (geometry.isRetesselated) {
        return geometry;
      }
      const polygons = geom3.toPolygons(geometry);
      const polygonsPerPlane = [];
      polygons.forEach((polygon) => {
        const mapping = polygonsPerPlane.find((element) => coplanar(element[0], poly3.plane(polygon)));
        if (mapping) {
          const polygons2 = mapping[1];
          polygons2.push(polygon);
        } else {
          polygonsPerPlane.push([poly3.plane(polygon), [polygon]]);
        }
      });
      let destpolygons = [];
      polygonsPerPlane.forEach((mapping) => {
        const sourcepolygons = mapping[1];
        const retesselayedpolygons = reTesselateCoplanarPolygons(sourcepolygons);
        destpolygons = destpolygons.concat(retesselayedpolygons);
      });
      const result = geom3.create(destpolygons);
      result.isRetesselated = true;
      return result;
    };
    module.exports = retessellate;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/mayOverlap.js
var require_mayOverlap = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/mayOverlap.js"(exports, module) {
    var { EPS } = require_constants();
    var measureBoundingBox = require_measureBoundingBox2();
    var mayOverlap = (geometry1, geometry2) => {
      if (geometry1.polygons.length === 0 || geometry2.polygons.length === 0) {
        return false;
      }
      const bounds1 = measureBoundingBox(geometry1);
      const min1 = bounds1[0];
      const max1 = bounds1[1];
      const bounds2 = measureBoundingBox(geometry2);
      const min2 = bounds2[0];
      const max2 = bounds2[1];
      if (min2[0] - max1[0] > EPS)
        return false;
      if (min1[0] - max2[0] > EPS)
        return false;
      if (min2[1] - max1[1] > EPS)
        return false;
      if (min1[1] - max2[1] > EPS)
        return false;
      if (min2[2] - max1[2] > EPS)
        return false;
      if (min1[2] - max2[2] > EPS)
        return false;
      return true;
    };
    module.exports = mayOverlap;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/trees/Node.js
var require_Node = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/trees/Node.js"(exports, module) {
    var plane = require_plane();
    var poly3 = require_poly3();
    var Node2 = class _Node {
      constructor(parent) {
        this.plane = null;
        this.front = null;
        this.back = null;
        this.polygontreenodes = [];
        this.parent = parent;
      }
      // Convert solid space to empty space and empty space to solid space.
      invert() {
        const queue = [this];
        let node;
        for (let i = 0; i < queue.length; i++) {
          node = queue[i];
          if (node.plane)
            node.plane = plane.flip(plane.create(), node.plane);
          if (node.front)
            queue.push(node.front);
          if (node.back)
            queue.push(node.back);
          const temp5 = node.front;
          node.front = node.back;
          node.back = temp5;
        }
      }
      // clip polygontreenodes to our plane
      // calls remove() for all clipped PolygonTreeNodes
      clipPolygons(polygontreenodes, alsoRemovecoplanarFront) {
        let current = { node: this, polygontreenodes };
        let node;
        const stack = [];
        do {
          node = current.node;
          polygontreenodes = current.polygontreenodes;
          if (node.plane) {
            const plane2 = node.plane;
            const backnodes = [];
            const frontnodes = [];
            const coplanarfrontnodes = alsoRemovecoplanarFront ? backnodes : frontnodes;
            const numpolygontreenodes = polygontreenodes.length;
            for (let i = 0; i < numpolygontreenodes; i++) {
              const treenode = polygontreenodes[i];
              if (!treenode.isRemoved()) {
                treenode.splitByPlane(plane2, coplanarfrontnodes, backnodes, frontnodes, backnodes);
              }
            }
            if (node.front && frontnodes.length > 0) {
              stack.push({ node: node.front, polygontreenodes: frontnodes });
            }
            const numbacknodes = backnodes.length;
            if (node.back && numbacknodes > 0) {
              stack.push({ node: node.back, polygontreenodes: backnodes });
            } else {
              for (let i = 0; i < numbacknodes; i++) {
                backnodes[i].remove();
              }
            }
          }
          current = stack.pop();
        } while (current !== void 0);
      }
      // Remove all polygons in this BSP tree that are inside the other BSP tree
      // `tree`.
      clipTo(tree, alsoRemovecoplanarFront) {
        let node = this;
        const stack = [];
        do {
          if (node.polygontreenodes.length > 0) {
            tree.rootnode.clipPolygons(node.polygontreenodes, alsoRemovecoplanarFront);
          }
          if (node.front)
            stack.push(node.front);
          if (node.back)
            stack.push(node.back);
          node = stack.pop();
        } while (node !== void 0);
      }
      addPolygonTreeNodes(newpolygontreenodes) {
        let current = { node: this, polygontreenodes: newpolygontreenodes };
        const stack = [];
        do {
          const node = current.node;
          const polygontreenodes = current.polygontreenodes;
          if (polygontreenodes.length === 0) {
            current = stack.pop();
            continue;
          }
          if (!node.plane) {
            let index = 0;
            index = Math.floor(polygontreenodes.length / 2);
            const bestpoly = polygontreenodes[index].getPolygon();
            node.plane = poly3.plane(bestpoly);
          }
          const frontnodes = [];
          const backnodes = [];
          const n = polygontreenodes.length;
          for (let i = 0; i < n; ++i) {
            polygontreenodes[i].splitByPlane(node.plane, node.polygontreenodes, backnodes, frontnodes, backnodes);
          }
          if (frontnodes.length > 0) {
            if (!node.front)
              node.front = new _Node(node);
            const stopCondition = n === frontnodes.length && backnodes.length === 0;
            if (stopCondition)
              node.front.polygontreenodes = frontnodes;
            else
              stack.push({ node: node.front, polygontreenodes: frontnodes });
          }
          if (backnodes.length > 0) {
            if (!node.back)
              node.back = new _Node(node);
            const stopCondition = n === backnodes.length && frontnodes.length === 0;
            if (stopCondition)
              node.back.polygontreenodes = backnodes;
            else
              stack.push({ node: node.back, polygontreenodes: backnodes });
          }
          current = stack.pop();
        } while (current !== void 0);
      }
    };
    module.exports = Node2;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/trees/splitLineSegmentByPlane.js
var require_splitLineSegmentByPlane = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/trees/splitLineSegmentByPlane.js"(exports, module) {
    var vec3 = require_vec3();
    var splitLineSegmentByPlane = (plane, p1, p2) => {
      const direction = vec3.subtract(vec3.create(), p2, p1);
      let lambda = (plane[3] - vec3.dot(plane, p1)) / vec3.dot(plane, direction);
      if (Number.isNaN(lambda))
        lambda = 0;
      if (lambda > 1)
        lambda = 1;
      if (lambda < 0)
        lambda = 0;
      vec3.scale(direction, direction, lambda);
      vec3.add(direction, p1, direction);
      return direction;
    };
    module.exports = splitLineSegmentByPlane;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/trees/splitPolygonByPlane.js
var require_splitPolygonByPlane = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/trees/splitPolygonByPlane.js"(exports, module) {
    var { EPS } = require_constants();
    var plane = require_plane();
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var splitLineSegmentByPlane = require_splitLineSegmentByPlane();
    var splitPolygonByPlane = (splane, polygon) => {
      const result = {
        type: null,
        front: null,
        back: null
      };
      const vertices = polygon.vertices;
      const numvertices = vertices.length;
      const pplane = poly3.plane(polygon);
      if (plane.equals(pplane, splane)) {
        result.type = 0;
      } else {
        let hasfront = false;
        let hasback = false;
        const vertexIsBack = [];
        const MINEPS = -EPS;
        for (let i = 0; i < numvertices; i++) {
          const t = vec3.dot(splane, vertices[i]) - splane[3];
          const isback = t < MINEPS;
          vertexIsBack.push(isback);
          if (t > EPS)
            hasfront = true;
          if (t < MINEPS)
            hasback = true;
        }
        if (!hasfront && !hasback) {
          const t = vec3.dot(splane, pplane);
          result.type = t >= 0 ? 0 : 1;
        } else if (!hasback) {
          result.type = 2;
        } else if (!hasfront) {
          result.type = 3;
        } else {
          result.type = 4;
          const frontvertices = [];
          const backvertices = [];
          let isback = vertexIsBack[0];
          for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {
            const vertex2 = vertices[vertexindex];
            let nextvertexindex = vertexindex + 1;
            if (nextvertexindex >= numvertices)
              nextvertexindex = 0;
            const nextisback = vertexIsBack[nextvertexindex];
            if (isback === nextisback) {
              if (isback) {
                backvertices.push(vertex2);
              } else {
                frontvertices.push(vertex2);
              }
            } else {
              const nextpoint = vertices[nextvertexindex];
              const intersectionpoint = splitLineSegmentByPlane(splane, vertex2, nextpoint);
              if (isback) {
                backvertices.push(vertex2);
                backvertices.push(intersectionpoint);
                frontvertices.push(intersectionpoint);
              } else {
                frontvertices.push(vertex2);
                frontvertices.push(intersectionpoint);
                backvertices.push(intersectionpoint);
              }
            }
            isback = nextisback;
          }
          const EPS_SQUARED = EPS * EPS;
          if (backvertices.length >= 3) {
            let prevvertex = backvertices[backvertices.length - 1];
            for (let vertexindex = 0; vertexindex < backvertices.length; vertexindex++) {
              const vertex2 = backvertices[vertexindex];
              if (vec3.squaredDistance(vertex2, prevvertex) < EPS_SQUARED) {
                backvertices.splice(vertexindex, 1);
                vertexindex--;
              }
              prevvertex = vertex2;
            }
          }
          if (frontvertices.length >= 3) {
            let prevvertex = frontvertices[frontvertices.length - 1];
            for (let vertexindex = 0; vertexindex < frontvertices.length; vertexindex++) {
              const vertex2 = frontvertices[vertexindex];
              if (vec3.squaredDistance(vertex2, prevvertex) < EPS_SQUARED) {
                frontvertices.splice(vertexindex, 1);
                vertexindex--;
              }
              prevvertex = vertex2;
            }
          }
          if (frontvertices.length >= 3) {
            result.front = poly3.fromPointsAndPlane(frontvertices, pplane);
          }
          if (backvertices.length >= 3) {
            result.back = poly3.fromPointsAndPlane(backvertices, pplane);
          }
        }
      }
      return result;
    };
    module.exports = splitPolygonByPlane;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/trees/PolygonTreeNode.js
var require_PolygonTreeNode = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/trees/PolygonTreeNode.js"(exports, module) {
    var { EPS } = require_constants();
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var splitPolygonByPlane = require_splitPolygonByPlane();
    var PolygonTreeNode = class _PolygonTreeNode {
      // constructor creates the root node
      constructor(parent, polygon) {
        this.parent = parent;
        this.children = [];
        this.polygon = polygon;
        this.removed = false;
      }
      // fill the tree with polygons. Should be called on the root node only; child nodes must
      // always be a derivate (split) of the parent node.
      addPolygons(polygons) {
        if (!this.isRootNode()) {
          throw new Error("Assertion failed");
        }
        const _this = this;
        polygons.forEach((polygon) => {
          _this.addChild(polygon);
        });
      }
      // remove a node
      // - the siblings become toplevel nodes
      // - the parent is removed recursively
      remove() {
        if (!this.removed) {
          this.removed = true;
          this.polygon = null;
          const parentschildren = this.parent.children;
          const i = parentschildren.indexOf(this);
          if (i < 0)
            throw new Error("Assertion failed");
          parentschildren.splice(i, 1);
          this.parent.recursivelyInvalidatePolygon();
        }
      }
      isRemoved() {
        return this.removed;
      }
      isRootNode() {
        return !this.parent;
      }
      // invert all polygons in the tree. Call on the root node
      invert() {
        if (!this.isRootNode())
          throw new Error("Assertion failed");
        this.invertSub();
      }
      getPolygon() {
        if (!this.polygon)
          throw new Error("Assertion failed");
        return this.polygon;
      }
      getPolygons(result) {
        let children = [this];
        const queue = [children];
        let i, j, l, node;
        for (i = 0; i < queue.length; ++i) {
          children = queue[i];
          for (j = 0, l = children.length; j < l; j++) {
            node = children[j];
            if (node.polygon) {
              result.push(node.polygon);
            } else {
              if (node.children.length > 0)
                queue.push(node.children);
            }
          }
        }
      }
      // split the node by a plane; add the resulting nodes to the frontnodes and backnodes array
      // If the plane doesn't intersect the polygon, the 'this' object is added to one of the arrays
      // If the plane does intersect the polygon, two new child nodes are created for the front and back fragments,
      //  and added to both arrays.
      splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {
        if (this.children.length) {
          const queue = [this.children];
          let i;
          let j;
          let l;
          let node;
          let nodes;
          for (i = 0; i < queue.length; i++) {
            nodes = queue[i];
            for (j = 0, l = nodes.length; j < l; j++) {
              node = nodes[j];
              if (node.children.length > 0) {
                queue.push(node.children);
              } else {
                node._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);
              }
            }
          }
        } else {
          this._splitByPlane(plane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes);
        }
      }
      // only to be called for nodes with no children
      _splitByPlane(splane, coplanarfrontnodes, coplanarbacknodes, frontnodes, backnodes) {
        const polygon = this.polygon;
        if (polygon) {
          const bound = poly3.measureBoundingSphere(polygon);
          const sphereradius = bound[3] + EPS;
          const spherecenter = bound;
          const d = vec3.dot(splane, spherecenter) - splane[3];
          if (d > sphereradius) {
            frontnodes.push(this);
          } else if (d < -sphereradius) {
            backnodes.push(this);
          } else {
            const splitresult = splitPolygonByPlane(splane, polygon);
            switch (splitresult.type) {
              case 0:
                coplanarfrontnodes.push(this);
                break;
              case 1:
                coplanarbacknodes.push(this);
                break;
              case 2:
                frontnodes.push(this);
                break;
              case 3:
                backnodes.push(this);
                break;
              case 4:
                if (splitresult.front) {
                  const frontnode = this.addChild(splitresult.front);
                  frontnodes.push(frontnode);
                }
                if (splitresult.back) {
                  const backnode = this.addChild(splitresult.back);
                  backnodes.push(backnode);
                }
                break;
            }
          }
        }
      }
      // PRIVATE methods from here:
      // add child to a node
      // this should be called whenever the polygon is split
      // a child should be created for every fragment of the split polygon
      // returns the newly created child
      addChild(polygon) {
        const newchild = new _PolygonTreeNode(this, polygon);
        this.children.push(newchild);
        return newchild;
      }
      invertSub() {
        let children = [this];
        const queue = [children];
        let i, j, l, node;
        for (i = 0; i < queue.length; i++) {
          children = queue[i];
          for (j = 0, l = children.length; j < l; j++) {
            node = children[j];
            if (node.polygon) {
              node.polygon = poly3.invert(node.polygon);
            }
            if (node.children.length > 0)
              queue.push(node.children);
          }
        }
      }
      // private method
      // remove the polygon from the node, and all parent nodes above it
      // called to invalidate parents of removed nodes
      recursivelyInvalidatePolygon() {
        this.polygon = null;
        if (this.parent) {
          this.parent.recursivelyInvalidatePolygon();
        }
      }
      clear() {
        let children = [this];
        const queue = [children];
        for (let i = 0; i < queue.length; ++i) {
          children = queue[i];
          const l = children.length;
          for (let j = 0; j < l; j++) {
            const node = children[j];
            if (node.polygon) {
              node.polygon = null;
            }
            if (node.parent) {
              node.parent = null;
            }
            if (node.children.length > 0)
              queue.push(node.children);
            node.children = [];
          }
        }
      }
      toString() {
        let result = "";
        let children = [this];
        const queue = [children];
        let i, j, l, node;
        for (i = 0; i < queue.length; ++i) {
          children = queue[i];
          const prefix = " ".repeat(i);
          for (j = 0, l = children.length; j < l; j++) {
            node = children[j];
            result += `${prefix}PolygonTreeNode (${node.isRootNode()}): ${node.children.length}`;
            if (node.polygon) {
              result += `
 ${prefix}polygon: ${node.polygon.vertices}
`;
            } else {
              result += "\n";
            }
            if (node.children.length > 0)
              queue.push(node.children);
          }
        }
        return result;
      }
    };
    module.exports = PolygonTreeNode;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/trees/Tree.js
var require_Tree = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/trees/Tree.js"(exports, module) {
    var Node2 = require_Node();
    var PolygonTreeNode = require_PolygonTreeNode();
    var Tree = class {
      constructor(polygons) {
        this.polygonTree = new PolygonTreeNode();
        this.rootnode = new Node2(null);
        if (polygons)
          this.addPolygons(polygons);
      }
      invert() {
        this.polygonTree.invert();
        this.rootnode.invert();
      }
      // Remove all polygons in this BSP tree that are inside the other BSP tree
      // `tree`.
      clipTo(tree, alsoRemovecoplanarFront = false) {
        this.rootnode.clipTo(tree, alsoRemovecoplanarFront);
      }
      allPolygons() {
        const result = [];
        this.polygonTree.getPolygons(result);
        return result;
      }
      addPolygons(polygons) {
        const polygontreenodes = new Array(polygons.length);
        for (let i = 0; i < polygons.length; i++) {
          polygontreenodes[i] = this.polygonTree.addChild(polygons[i]);
        }
        this.rootnode.addPolygonTreeNodes(polygontreenodes);
      }
      clear() {
        this.polygonTree.clear();
      }
      toString() {
        const result = "Tree: " + this.polygonTree.toString("");
        return result;
      }
    };
    module.exports = Tree;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/trees/index.js
var require_trees = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/trees/index.js"(exports, module) {
    module.exports = {
      Tree: require_Tree()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/intersectGeom3Sub.js
var require_intersectGeom3Sub = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/intersectGeom3Sub.js"(exports, module) {
    var geom3 = require_geom3();
    var mayOverlap = require_mayOverlap();
    var { Tree } = require_trees();
    var intersectGeom3Sub = (geometry1, geometry2) => {
      if (!mayOverlap(geometry1, geometry2)) {
        return geom3.create();
      }
      const a = new Tree(geom3.toPolygons(geometry1));
      const b = new Tree(geom3.toPolygons(geometry2));
      a.invert();
      b.clipTo(a);
      b.invert();
      a.clipTo(b);
      b.clipTo(a);
      a.addPolygons(b.allPolygons());
      a.invert();
      const newpolygons = a.allPolygons();
      return geom3.create(newpolygons);
    };
    module.exports = intersectGeom3Sub;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/intersectGeom3.js
var require_intersectGeom3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/intersectGeom3.js"(exports, module) {
    var flatten2 = require_flatten();
    var retessellate = require_retessellate();
    var intersectSub = require_intersectGeom3Sub();
    var intersect = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      let newgeometry = geometries2.shift();
      geometries2.forEach((geometry) => {
        newgeometry = intersectSub(newgeometry, geometry);
      });
      newgeometry = retessellate(newgeometry);
      return newgeometry;
    };
    module.exports = intersect;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/intersectGeom2.js
var require_intersectGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/intersectGeom2.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom3 = require_geom3();
    var measureEpsilon = require_measureEpsilon();
    var fromFakePolygons = require_fromFakePolygons();
    var to3DWalls = require_to3DWalls();
    var intersectGeom3 = require_intersectGeom3();
    var intersect = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const newgeometries = geometries2.map((geometry) => to3DWalls({ z0: -1, z1: 1 }, geometry));
      const newgeom3 = intersectGeom3(newgeometries);
      const epsilon = measureEpsilon(newgeom3);
      return fromFakePolygons(epsilon, geom3.toPolygons(newgeom3));
    };
    module.exports = intersect;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/intersect.js
var require_intersect2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/intersect.js"(exports, module) {
    var flatten2 = require_flatten();
    var areAllShapesTheSameType = require_areAllShapesTheSameType();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var intersectGeom2 = require_intersectGeom2();
    var intersectGeom3 = require_intersectGeom3();
    var intersect = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      if (!areAllShapesTheSameType(geometries2)) {
        throw new Error("only intersect of the types are supported");
      }
      const geometry = geometries2[0];
      if (geom2.isA(geometry))
        return intersectGeom2(geometries2);
      if (geom3.isA(geometry))
        return intersectGeom3(geometries2);
      return geometry;
    };
    module.exports = intersect;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/scissionGeom3.js
var require_scissionGeom3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/scissionGeom3.js"(exports, module) {
    var vec3 = require_vec3();
    var measureEpsilon = require_measureEpsilon();
    var geom3 = require_geom3();
    var sortNb = (array) => array.sort((a, b) => a - b).filter((item, pos, ary) => !pos || item !== ary[pos - 1]);
    var insertMapping = (map, point, index) => {
      const key = `${point}`;
      const mapping = map.get(key);
      if (mapping === void 0) {
        map.set(key, [index]);
      } else {
        mapping.push(index);
      }
    };
    var findMapping = (map, point) => {
      const key = `${point}`;
      return map.get(key);
    };
    var scissionGeom3 = (geometry) => {
      const eps = measureEpsilon(geometry);
      const polygons = geom3.toPolygons(geometry);
      const pl = polygons.length;
      const indexesPerPoint = /* @__PURE__ */ new Map();
      const temp5 = vec3.create();
      polygons.forEach((polygon, index) => {
        polygon.vertices.forEach((point) => {
          insertMapping(indexesPerPoint, vec3.snap(temp5, point, eps), index);
        });
      });
      const indexesPerPolygon = polygons.map((polygon) => {
        let indexes = [];
        polygon.vertices.forEach((point) => {
          indexes = indexes.concat(findMapping(indexesPerPoint, vec3.snap(temp5, point, eps)));
        });
        return { e: 1, d: sortNb(indexes) };
      });
      indexesPerPoint.clear();
      let merges = 0;
      const ippl = indexesPerPolygon.length;
      for (let i = 0; i < ippl; i++) {
        const mapi = indexesPerPolygon[i];
        if (mapi.e > 0) {
          const indexes = new Array(pl);
          indexes[i] = true;
          do {
            merges = 0;
            indexes.forEach((e, j) => {
              const mapj = indexesPerPolygon[j];
              if (mapj.e > 0) {
                mapj.e = -1;
                for (let d = 0; d < mapj.d.length; d++) {
                  indexes[mapj.d[d]] = true;
                }
                merges++;
              }
            });
          } while (merges > 0);
          mapi.indexes = indexes;
        }
      }
      const newgeometries = [];
      for (let i = 0; i < ippl; i++) {
        if (indexesPerPolygon[i].indexes) {
          const newpolygons = [];
          indexesPerPolygon[i].indexes.forEach((e, p) => newpolygons.push(polygons[p]));
          newgeometries.push(geom3.create(newpolygons));
        }
      }
      return newgeometries;
    };
    module.exports = scissionGeom3;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/scission.js
var require_scission = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/scission.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom3 = require_geom3();
    var scissionGeom3 = require_scissionGeom3();
    var scission = (...objects) => {
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      const results = objects.map((object) => {
        if (geom3.isA(object))
          return scissionGeom3(object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = scission;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/subtractGeom3Sub.js
var require_subtractGeom3Sub = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/subtractGeom3Sub.js"(exports, module) {
    var geom3 = require_geom3();
    var mayOverlap = require_mayOverlap();
    var { Tree } = require_trees();
    var subtractGeom3Sub = (geometry1, geometry2) => {
      if (!mayOverlap(geometry1, geometry2)) {
        return geom3.clone(geometry1);
      }
      const a = new Tree(geom3.toPolygons(geometry1));
      const b = new Tree(geom3.toPolygons(geometry2));
      a.invert();
      a.clipTo(b);
      b.clipTo(a, true);
      a.addPolygons(b.allPolygons());
      a.invert();
      const newpolygons = a.allPolygons();
      return geom3.create(newpolygons);
    };
    module.exports = subtractGeom3Sub;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/subtractGeom3.js
var require_subtractGeom3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/subtractGeom3.js"(exports, module) {
    var flatten2 = require_flatten();
    var retessellate = require_retessellate();
    var subtractSub = require_subtractGeom3Sub();
    var subtract = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      let newgeometry = geometries2.shift();
      geometries2.forEach((geometry) => {
        newgeometry = subtractSub(newgeometry, geometry);
      });
      newgeometry = retessellate(newgeometry);
      return newgeometry;
    };
    module.exports = subtract;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/subtractGeom2.js
var require_subtractGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/subtractGeom2.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom3 = require_geom3();
    var measureEpsilon = require_measureEpsilon();
    var fromFakePolygons = require_fromFakePolygons();
    var to3DWalls = require_to3DWalls();
    var subtractGeom3 = require_subtractGeom3();
    var subtract = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const newgeometries = geometries2.map((geometry) => to3DWalls({ z0: -1, z1: 1 }, geometry));
      const newgeom3 = subtractGeom3(newgeometries);
      const epsilon = measureEpsilon(newgeom3);
      return fromFakePolygons(epsilon, geom3.toPolygons(newgeom3));
    };
    module.exports = subtract;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/subtract.js
var require_subtract4 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/subtract.js"(exports, module) {
    var flatten2 = require_flatten();
    var areAllShapesTheSameType = require_areAllShapesTheSameType();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var subtractGeom2 = require_subtractGeom2();
    var subtractGeom3 = require_subtractGeom3();
    var subtract = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      if (!areAllShapesTheSameType(geometries2)) {
        throw new Error("only subtract of the types are supported");
      }
      const geometry = geometries2[0];
      if (geom2.isA(geometry))
        return subtractGeom2(geometries2);
      if (geom3.isA(geometry))
        return subtractGeom3(geometries2);
      return geometry;
    };
    module.exports = subtract;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/unionGeom3Sub.js
var require_unionGeom3Sub = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/unionGeom3Sub.js"(exports, module) {
    var geom3 = require_geom3();
    var mayOverlap = require_mayOverlap();
    var { Tree } = require_trees();
    var unionSub = (geometry1, geometry2) => {
      if (!mayOverlap(geometry1, geometry2)) {
        return unionForNonIntersecting(geometry1, geometry2);
      }
      const a = new Tree(geom3.toPolygons(geometry1));
      const b = new Tree(geom3.toPolygons(geometry2));
      a.clipTo(b, false);
      b.clipTo(a);
      b.invert();
      b.clipTo(a);
      b.invert();
      const newpolygons = a.allPolygons().concat(b.allPolygons());
      const result = geom3.create(newpolygons);
      return result;
    };
    var unionForNonIntersecting = (geometry1, geometry2) => {
      let newpolygons = geom3.toPolygons(geometry1);
      newpolygons = newpolygons.concat(geom3.toPolygons(geometry2));
      return geom3.create(newpolygons);
    };
    module.exports = unionSub;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/unionGeom3.js
var require_unionGeom3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/unionGeom3.js"(exports, module) {
    var flatten2 = require_flatten();
    var retessellate = require_retessellate();
    var unionSub = require_unionGeom3Sub();
    var union = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      let i;
      for (i = 1; i < geometries2.length; i += 2) {
        geometries2.push(unionSub(geometries2[i - 1], geometries2[i]));
      }
      let newgeometry = geometries2[i - 1];
      newgeometry = retessellate(newgeometry);
      return newgeometry;
    };
    module.exports = union;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/unionGeom2.js
var require_unionGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/unionGeom2.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom3 = require_geom3();
    var measureEpsilon = require_measureEpsilon();
    var fromFakePolygons = require_fromFakePolygons();
    var to3DWalls = require_to3DWalls();
    var unionGeom3 = require_unionGeom3();
    var union = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const newgeometries = geometries2.map((geometry) => to3DWalls({ z0: -1, z1: 1 }, geometry));
      const newgeom3 = unionGeom3(newgeometries);
      const epsilon = measureEpsilon(newgeom3);
      return fromFakePolygons(epsilon, geom3.toPolygons(newgeom3));
    };
    module.exports = union;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/union.js
var require_union = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/union.js"(exports, module) {
    var flatten2 = require_flatten();
    var areAllShapesTheSameType = require_areAllShapesTheSameType();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var unionGeom2 = require_unionGeom2();
    var unionGeom3 = require_unionGeom3();
    var union = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      if (!areAllShapesTheSameType(geometries2)) {
        throw new Error("only unions of the same type are supported");
      }
      const geometry = geometries2[0];
      if (geom2.isA(geometry))
        return unionGeom2(geometries2);
      if (geom3.isA(geometry))
        return unionGeom3(geometries2);
      return geometry;
    };
    module.exports = union;
  }
});

// node_modules/@jscad/modeling/src/operations/booleans/index.js
var require_booleans = __commonJS({
  "node_modules/@jscad/modeling/src/operations/booleans/index.js"(exports, module) {
    module.exports = {
      intersect: require_intersect2(),
      scission: require_scission(),
      subtract: require_subtract4(),
      union: require_union()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/offsetFromPoints.js
var require_offsetFromPoints = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/offsetFromPoints.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var intersect = require_intersect();
    var line2 = require_line2();
    var vec2 = require_vec2();
    var area2 = require_area();
    var offsetFromPoints = (options, points) => {
      const defaults = {
        delta: 1,
        corners: "edge",
        closed: false,
        segments: 16
      };
      let { delta, corners, closed, segments } = Object.assign({}, defaults, options);
      if (Math.abs(delta) < EPS)
        return points;
      let rotation = options.closed ? area2(points) : 1;
      if (rotation === 0)
        rotation = 1;
      const orientation = rotation > 0 && delta >= 0 || rotation < 0 && delta < 0;
      delta = Math.abs(delta);
      let previousSegment = null;
      let newPoints = [];
      const newCorners = [];
      const of = vec2.create();
      const n = points.length;
      for (let i = 0; i < n; i++) {
        const j = (i + 1) % n;
        const p0 = points[i];
        const p1 = points[j];
        orientation ? vec2.subtract(of, p0, p1) : vec2.subtract(of, p1, p0);
        vec2.normal(of, of);
        vec2.normalize(of, of);
        vec2.scale(of, of, delta);
        const n0 = vec2.add(vec2.create(), p0, of);
        const n1 = vec2.add(vec2.create(), p1, of);
        const currentSegment = [n0, n1];
        if (previousSegment != null) {
          if (closed || !closed && j !== 0) {
            const ip = intersect(previousSegment[0], previousSegment[1], currentSegment[0], currentSegment[1]);
            if (ip) {
              newPoints.pop();
              currentSegment[0] = ip;
            } else {
              newCorners.push({ c: p0, s0: previousSegment, s1: currentSegment });
            }
          }
        }
        previousSegment = [n0, n1];
        if (j === 0 && !closed)
          continue;
        newPoints.push(currentSegment[0]);
        newPoints.push(currentSegment[1]);
      }
      if (closed && previousSegment != null) {
        const n0 = newPoints[0];
        const n1 = newPoints[1];
        const ip = intersect(previousSegment[0], previousSegment[1], n0, n1);
        if (ip) {
          newPoints[0] = ip;
          newPoints.pop();
        } else {
          const p0 = points[0];
          const cursegment = [n0, n1];
          newCorners.push({ c: p0, s0: previousSegment, s1: cursegment });
        }
      }
      if (corners === "edge") {
        const pointIndex = /* @__PURE__ */ new Map();
        newPoints.forEach((point, index) => pointIndex.set(point, index));
        const line0 = line2.create();
        const line1 = line2.create();
        newCorners.forEach((corner) => {
          line2.fromPoints(line0, corner.s0[0], corner.s0[1]);
          line2.fromPoints(line1, corner.s1[0], corner.s1[1]);
          const ip = line2.intersectPointOfLines(line0, line1);
          if (Number.isFinite(ip[0]) && Number.isFinite(ip[1])) {
            const p0 = corner.s0[1];
            const i = pointIndex.get(p0);
            newPoints[i] = ip;
            newPoints[(i + 1) % newPoints.length] = void 0;
          } else {
            const p0 = corner.s1[0];
            const i = pointIndex.get(p0);
            newPoints[i] = void 0;
          }
        });
        newPoints = newPoints.filter((p) => p !== void 0);
      }
      if (corners === "round") {
        let cornersegments = Math.floor(segments / 4);
        const v0 = vec2.create();
        newCorners.forEach((corner) => {
          let rotation2 = vec2.angle(vec2.subtract(v0, corner.s1[0], corner.c));
          rotation2 -= vec2.angle(vec2.subtract(v0, corner.s0[1], corner.c));
          if (orientation && rotation2 < 0) {
            rotation2 = rotation2 + Math.PI;
            if (rotation2 < 0)
              rotation2 = rotation2 + Math.PI;
          }
          if (!orientation && rotation2 > 0) {
            rotation2 = rotation2 - Math.PI;
            if (rotation2 > 0)
              rotation2 = rotation2 - Math.PI;
          }
          if (rotation2 !== 0) {
            cornersegments = Math.floor(segments * (Math.abs(rotation2) / TAU));
            const step = rotation2 / cornersegments;
            const start = vec2.angle(vec2.subtract(v0, corner.s0[1], corner.c));
            const cornerpoints = [];
            for (let i = 1; i < cornersegments; i++) {
              const radians = start + step * i;
              const point = vec2.fromAngleRadians(vec2.create(), radians);
              vec2.scale(point, point, delta);
              vec2.add(point, point, corner.c);
              cornerpoints.push(point);
            }
            if (cornerpoints.length > 0) {
              const p0 = corner.s0[1];
              let i = newPoints.findIndex((point) => vec2.equals(p0, point));
              i = (i + 1) % newPoints.length;
              newPoints.splice(i, 0, ...cornerpoints);
            }
          } else {
            const p0 = corner.s1[0];
            const i = newPoints.findIndex((point) => vec2.equals(p0, point));
            newPoints.splice(i, 1);
          }
        });
      }
      return newPoints;
    };
    module.exports = offsetFromPoints;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/expandGeom2.js
var require_expandGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/expandGeom2.js"(exports, module) {
    var geom2 = require_geom2();
    var offsetFromPoints = require_offsetFromPoints();
    var expandGeom2 = (options, geometry) => {
      const defaults = {
        delta: 1,
        corners: "edge",
        segments: 16
      };
      const { delta, corners, segments } = Object.assign({}, defaults, options);
      if (!(corners === "edge" || corners === "chamfer" || corners === "round")) {
        throw new Error('corners must be "edge", "chamfer", or "round"');
      }
      const outlines = geom2.toOutlines(geometry);
      const newoutlines = outlines.map((outline) => {
        options = {
          delta,
          corners,
          closed: true,
          segments
        };
        return offsetFromPoints(options, outline);
      });
      const allsides = newoutlines.reduce((sides, newoutline) => sides.concat(geom2.toSides(geom2.fromPoints(newoutline))), []);
      return geom2.create(allsides);
    };
    module.exports = expandGeom2;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/extrudePolygon.js
var require_extrudePolygon = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/extrudePolygon.js"(exports, module) {
    var mat4 = require_mat4();
    var vec3 = require_vec3();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var extrudePolygon = (offsetvector, polygon1) => {
      const direction = vec3.dot(poly3.plane(polygon1), offsetvector);
      if (direction > 0) {
        polygon1 = poly3.invert(polygon1);
      }
      const newpolygons = [polygon1];
      const polygon2 = poly3.transform(mat4.fromTranslation(mat4.create(), offsetvector), polygon1);
      const numvertices = polygon1.vertices.length;
      for (let i = 0; i < numvertices; i++) {
        const nexti = i < numvertices - 1 ? i + 1 : 0;
        const sideFacePolygon = poly3.create([
          polygon1.vertices[i],
          polygon2.vertices[i],
          polygon2.vertices[nexti],
          polygon1.vertices[nexti]
        ]);
        newpolygons.push(sideFacePolygon);
      }
      newpolygons.push(poly3.invert(polygon2));
      return geom3.create(newpolygons);
    };
    module.exports = extrudePolygon;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/expandShell.js
var require_expandShell = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/expandShell.js"(exports, module) {
    var { EPS, TAU } = require_constants();
    var mat4 = require_mat4();
    var vec3 = require_vec3();
    var fnNumberSort = require_fnNumberSort();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var sphere = require_sphere();
    var retessellate = require_retessellate();
    var unionGeom3Sub = require_unionGeom3Sub();
    var extrudePolygon = require_extrudePolygon();
    var mapPlaneToVertex = (map, vertex2, plane) => {
      const key = vertex2.toString();
      if (!map.has(key)) {
        const entry = [vertex2, [plane]];
        map.set(key, entry);
      } else {
        const planes = map.get(key)[1];
        planes.push(plane);
      }
    };
    var mapPlaneToEdge = (map, edge, plane) => {
      const key0 = edge[0].toString();
      const key1 = edge[1].toString();
      const key = key0 < key1 ? `${key0},${key1}` : `${key1},${key0}`;
      if (!map.has(key)) {
        const entry = [edge, [plane]];
        map.set(key, entry);
      } else {
        const planes = map.get(key)[1];
        planes.push(plane);
      }
    };
    var addUniqueAngle = (map, angle) => {
      const i = map.findIndex((item) => item === angle);
      if (i < 0) {
        map.push(angle);
      }
    };
    var expandShell = (options, geometry) => {
      const defaults = {
        delta: 1,
        segments: 12
      };
      const { delta, segments } = Object.assign({}, defaults, options);
      let result = geom3.create();
      const vertices2planes = /* @__PURE__ */ new Map();
      const edges2planes = /* @__PURE__ */ new Map();
      const v1 = vec3.create();
      const v2 = vec3.create();
      const polygons = geom3.toPolygons(geometry);
      polygons.forEach((polygon, index) => {
        const extrudevector = vec3.scale(vec3.create(), poly3.plane(polygon), 2 * delta);
        const translatedpolygon = poly3.transform(mat4.fromTranslation(mat4.create(), vec3.scale(vec3.create(), extrudevector, -0.5)), polygon);
        const extrudedface = extrudePolygon(extrudevector, translatedpolygon);
        result = unionGeom3Sub(result, extrudedface);
        const vertices = polygon.vertices;
        for (let i = 0; i < vertices.length; i++) {
          mapPlaneToVertex(vertices2planes, vertices[i], poly3.plane(polygon));
          const j = (i + 1) % vertices.length;
          const edge = [vertices[i], vertices[j]];
          mapPlaneToEdge(edges2planes, edge, poly3.plane(polygon));
        }
      });
      edges2planes.forEach((item) => {
        const edge = item[0];
        const planes = item[1];
        const startpoint = edge[0];
        const endpoint = edge[1];
        const zbase = vec3.subtract(vec3.create(), endpoint, startpoint);
        vec3.normalize(zbase, zbase);
        const xbase = planes[0];
        const ybase = vec3.cross(vec3.create(), xbase, zbase);
        let angles = [];
        for (let i = 0; i < segments; i++) {
          addUniqueAngle(angles, i * TAU / segments);
        }
        for (let i = 0, iMax = planes.length; i < iMax; i++) {
          const planenormal = planes[i];
          const si = vec3.dot(ybase, planenormal);
          const co = vec3.dot(xbase, planenormal);
          let angle = Math.atan2(si, co);
          if (angle < 0)
            angle += TAU;
          addUniqueAngle(angles, angle);
          angle = Math.atan2(-si, -co);
          if (angle < 0)
            angle += TAU;
          addUniqueAngle(angles, angle);
        }
        angles = angles.sort(fnNumberSort);
        const numangles = angles.length;
        let prevp1;
        let prevp2;
        const startfacevertices = [];
        const endfacevertices = [];
        const polygons2 = [];
        for (let i = -1; i < numangles; i++) {
          const angle = angles[i < 0 ? i + numangles : i];
          const si = Math.sin(angle);
          const co = Math.cos(angle);
          vec3.scale(v1, xbase, co * delta);
          vec3.scale(v2, ybase, si * delta);
          vec3.add(v1, v1, v2);
          const p1 = vec3.add(vec3.create(), startpoint, v1);
          const p2 = vec3.add(vec3.create(), endpoint, v1);
          let skip = false;
          if (i >= 0) {
            if (vec3.distance(p1, prevp1) < EPS) {
              skip = true;
            }
          }
          if (!skip) {
            if (i >= 0) {
              startfacevertices.push(p1);
              endfacevertices.push(p2);
              const points = [prevp2, p2, p1, prevp1];
              const polygon = poly3.create(points);
              polygons2.push(polygon);
            }
            prevp1 = p1;
            prevp2 = p2;
          }
        }
        endfacevertices.reverse();
        polygons2.push(poly3.create(startfacevertices));
        polygons2.push(poly3.create(endfacevertices));
        const cylinder = geom3.create(polygons2);
        result = unionGeom3Sub(result, cylinder);
      });
      vertices2planes.forEach((item) => {
        const vertex2 = item[0];
        const planes = item[1];
        const xaxis = planes[0];
        let bestzaxis = null;
        let bestzaxisorthogonality = 0;
        for (let i = 1; i < planes.length; i++) {
          const normal = planes[i];
          const cross = vec3.cross(v1, xaxis, normal);
          const crosslength = vec3.length(cross);
          if (crosslength > 0.05) {
            if (crosslength > bestzaxisorthogonality) {
              bestzaxisorthogonality = crosslength;
              bestzaxis = normal;
            }
          }
        }
        if (!bestzaxis) {
          bestzaxis = vec3.orthogonal(v1, xaxis);
        }
        const yaxis = vec3.cross(v1, xaxis, bestzaxis);
        vec3.normalize(yaxis, yaxis);
        const zaxis = vec3.cross(v2, yaxis, xaxis);
        const corner = sphere({
          center: [vertex2[0], vertex2[1], vertex2[2]],
          radius: delta,
          segments,
          axes: [xaxis, yaxis, zaxis]
        });
        result = unionGeom3Sub(result, corner);
      });
      return retessellate(result);
    };
    module.exports = expandShell;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/expandGeom3.js
var require_expandGeom3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/expandGeom3.js"(exports, module) {
    var geom3 = require_geom3();
    var union = require_union();
    var expandShell = require_expandShell();
    var expandGeom3 = (options, geometry) => {
      const defaults = {
        delta: 1,
        corners: "round",
        segments: 12
      };
      const { delta, corners, segments } = Object.assign({}, defaults, options);
      if (!(corners === "round")) {
        throw new Error('corners must be "round" for 3D geometries');
      }
      const polygons = geom3.toPolygons(geometry);
      if (polygons.length === 0)
        throw new Error("the given geometry cannot be empty");
      options = { delta, corners, segments };
      const expanded = expandShell(options, geometry);
      return union(geometry, expanded);
    };
    module.exports = expandGeom3;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/expandPath2.js
var require_expandPath2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/expandPath2.js"(exports, module) {
    var area2 = require_area();
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var path2 = require_path2();
    var offsetFromPoints = require_offsetFromPoints();
    var createGeometryFromClosedOffsets = (paths) => {
      let { external, internal } = paths;
      if (area2(external) < 0) {
        external = external.reverse();
      } else {
        internal = internal.reverse();
      }
      const externalPath = path2.fromPoints({ closed: true }, external);
      const internalPath = path2.fromPoints({ closed: true }, internal);
      const externalSides = geom2.toSides(geom2.fromPoints(path2.toPoints(externalPath)));
      const internalSides = geom2.toSides(geom2.fromPoints(path2.toPoints(internalPath)));
      externalSides.push(...internalSides);
      return geom2.create(externalSides);
    };
    var createGeometryFromExpandedOpenPath = (paths, segments, corners, delta) => {
      const { points, external, internal } = paths;
      const capSegments = Math.floor(segments / 2);
      const e2iCap = [];
      const i2eCap = [];
      if (corners === "round" && capSegments > 0) {
        const step = Math.PI / capSegments;
        const eCorner = points[points.length - 1];
        const e2iStart = vec2.angle(vec2.subtract(vec2.create(), external[external.length - 1], eCorner));
        const iCorner = points[0];
        const i2eStart = vec2.angle(vec2.subtract(vec2.create(), internal[0], iCorner));
        for (let i = 1; i < capSegments; i++) {
          let radians = e2iStart + step * i;
          let point = vec2.fromAngleRadians(vec2.create(), radians);
          vec2.scale(point, point, delta);
          vec2.add(point, point, eCorner);
          e2iCap.push(point);
          radians = i2eStart + step * i;
          point = vec2.fromAngleRadians(vec2.create(), radians);
          vec2.scale(point, point, delta);
          vec2.add(point, point, iCorner);
          i2eCap.push(point);
        }
      }
      const allPoints = [];
      allPoints.push(...external, ...e2iCap, ...internal.reverse(), ...i2eCap);
      return geom2.fromPoints(allPoints);
    };
    var expandPath2 = (options, geometry) => {
      const defaults = {
        delta: 1,
        corners: "edge",
        segments: 16
      };
      options = Object.assign({}, defaults, options);
      const { delta, corners, segments } = options;
      if (delta <= 0)
        throw new Error("the given delta must be positive for paths");
      if (!(corners === "edge" || corners === "chamfer" || corners === "round")) {
        throw new Error('corners must be "edge", "chamfer", or "round"');
      }
      const closed = geometry.isClosed;
      const points = path2.toPoints(geometry);
      if (points.length === 0)
        throw new Error("the given geometry cannot be empty");
      const paths = {
        points,
        external: offsetFromPoints({ delta, corners, segments, closed }, points),
        internal: offsetFromPoints({ delta: -delta, corners, segments, closed }, points)
      };
      if (geometry.isClosed) {
        return createGeometryFromClosedOffsets(paths);
      } else {
        return createGeometryFromExpandedOpenPath(paths, segments, corners, delta);
      }
    };
    module.exports = expandPath2;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/expand.js
var require_expand = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/expand.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var expandGeom2 = require_expandGeom2();
    var expandGeom3 = require_expandGeom3();
    var expandPath2 = require_expandPath2();
    var expand = (options, ...objects) => {
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      const results = objects.map((object) => {
        if (path2.isA(object))
          return expandPath2(options, object);
        if (geom2.isA(object))
          return expandGeom2(options, object);
        if (geom3.isA(object))
          return expandGeom3(options, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = expand;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/offsetGeom2.js
var require_offsetGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/offsetGeom2.js"(exports, module) {
    var geom2 = require_geom2();
    var poly2 = require_poly2();
    var offsetFromPoints = require_offsetFromPoints();
    var offsetGeom2 = (options, geometry) => {
      const defaults = {
        delta: 1,
        corners: "edge",
        segments: 0
      };
      const { delta, corners, segments } = Object.assign({}, defaults, options);
      if (!(corners === "edge" || corners === "chamfer" || corners === "round")) {
        throw new Error('corners must be "edge", "chamfer", or "round"');
      }
      const outlines = geom2.toOutlines(geometry);
      const newoutlines = outlines.map((outline) => {
        const level = outlines.reduce((acc, polygon) => acc + poly2.arePointsInside(outline, poly2.create(polygon)), 0);
        const outside = level % 2 === 0;
        options = {
          delta: outside ? delta : -delta,
          corners,
          closed: true,
          segments
        };
        return offsetFromPoints(options, outline);
      });
      const allsides = newoutlines.reduce((sides, newoutline) => sides.concat(geom2.toSides(geom2.fromPoints(newoutline))), []);
      return geom2.create(allsides);
    };
    module.exports = offsetGeom2;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/offsetPath2.js
var require_offsetPath2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/offsetPath2.js"(exports, module) {
    var path2 = require_path2();
    var offsetFromPoints = require_offsetFromPoints();
    var offsetPath2 = (options, geometry) => {
      const defaults = {
        delta: 1,
        corners: "edge",
        closed: geometry.isClosed,
        segments: 16
      };
      const { delta, corners, closed, segments } = Object.assign({}, defaults, options);
      if (!(corners === "edge" || corners === "chamfer" || corners === "round")) {
        throw new Error('corners must be "edge", "chamfer", or "round"');
      }
      options = { delta, corners, closed, segments };
      const newpoints = offsetFromPoints(options, path2.toPoints(geometry));
      return path2.fromPoints({ closed }, newpoints);
    };
    module.exports = offsetPath2;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/offset.js
var require_offset = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/offset.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var path2 = require_path2();
    var offsetGeom2 = require_offsetGeom2();
    var offsetPath2 = require_offsetPath2();
    var offset = (options, ...objects) => {
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      const results = objects.map((object) => {
        if (path2.isA(object))
          return offsetPath2(options, object);
        if (geom2.isA(object))
          return offsetGeom2(options, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = offset;
  }
});

// node_modules/@jscad/modeling/src/operations/expansions/index.js
var require_expansions = __commonJS({
  "node_modules/@jscad/modeling/src/operations/expansions/index.js"(exports, module) {
    module.exports = {
      expand: require_expand(),
      offset: require_offset()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeLinearGeom2.js
var require_extrudeLinearGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeLinearGeom2.js"(exports, module) {
    var mat4 = require_mat4();
    var vec3 = require_vec3();
    var geom2 = require_geom2();
    var slice = require_slice();
    var extrudeFromSlices = require_extrudeFromSlices();
    var extrudeGeom2 = (options, geometry) => {
      const defaults = {
        offset: [0, 0, 1],
        twistAngle: 0,
        twistSteps: 12,
        repair: true
      };
      let { offset, twistAngle, twistSteps, repair } = Object.assign({}, defaults, options);
      if (twistSteps < 1)
        throw new Error("twistSteps must be 1 or more");
      if (twistAngle === 0) {
        twistSteps = 1;
      }
      const offsetv = vec3.clone(offset);
      const baseSides = geom2.toSides(geometry);
      if (baseSides.length === 0)
        throw new Error("the given geometry cannot be empty");
      const baseSlice = slice.fromSides(baseSides);
      if (offsetv[2] < 0)
        slice.reverse(baseSlice, baseSlice);
      const matrix = mat4.create();
      const createTwist = (progress, index, base) => {
        const Zrotation = index / twistSteps * twistAngle;
        const Zoffset = vec3.scale(vec3.create(), offsetv, index / twistSteps);
        mat4.multiply(matrix, mat4.fromZRotation(matrix, Zrotation), mat4.fromTranslation(mat4.create(), Zoffset));
        return slice.transform(matrix, base);
      };
      options = {
        numberOfSlices: twistSteps + 1,
        capStart: true,
        capEnd: true,
        repair,
        callback: createTwist
      };
      return extrudeFromSlices(options, baseSlice);
    };
    module.exports = extrudeGeom2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeLinearPath2.js
var require_extrudeLinearPath2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeLinearPath2.js"(exports, module) {
    var geom2 = require_geom2();
    var path2 = require_path2();
    var extrudeLinearGeom2 = require_extrudeLinearGeom2();
    var extrudePath2 = (options, geometry) => {
      if (!geometry.isClosed)
        throw new Error("extruded path must be closed");
      const points = path2.toPoints(geometry);
      const geometry2 = geom2.fromPoints(points);
      return extrudeLinearGeom2(options, geometry2);
    };
    module.exports = extrudePath2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeLinear.js
var require_extrudeLinear = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeLinear.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var path2 = require_path2();
    var extrudeLinearGeom2 = require_extrudeLinearGeom2();
    var extrudeLinearPath2 = require_extrudeLinearPath2();
    var extrudeLinear = (options, ...objects) => {
      const defaults = {
        height: 1,
        twistAngle: 0,
        twistSteps: 1,
        repair: true
      };
      const { height, twistAngle, twistSteps, repair } = Object.assign({}, defaults, options);
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      options = { offset: [0, 0, height], twistAngle, twistSteps, repair };
      const results = objects.map((object) => {
        if (path2.isA(object))
          return extrudeLinearPath2(options, object);
        if (geom2.isA(object))
          return extrudeLinearGeom2(options, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = extrudeLinear;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeRectangularPath2.js
var require_extrudeRectangularPath2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeRectangularPath2.js"(exports, module) {
    var path2 = require_path2();
    var expand = require_expand();
    var extrudeLinearGeom2 = require_extrudeLinearGeom2();
    var extrudeRectangularPath2 = (options, geometry) => {
      const defaults = {
        size: 1,
        height: 1
      };
      const { size, height } = Object.assign({}, defaults, options);
      options.delta = size;
      options.offset = [0, 0, height];
      const points = path2.toPoints(geometry);
      if (points.length === 0)
        throw new Error("the given geometry cannot be empty");
      const newgeometry = expand(options, geometry);
      return extrudeLinearGeom2(options, newgeometry);
    };
    module.exports = extrudeRectangularPath2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeRectangularGeom2.js
var require_extrudeRectangularGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeRectangularGeom2.js"(exports, module) {
    var { area: area2 } = require_utils();
    var geom2 = require_geom2();
    var path2 = require_path2();
    var expand = require_expand();
    var extrudeLinearGeom2 = require_extrudeLinearGeom2();
    var extrudeRectangularGeom2 = (options, geometry) => {
      const defaults = {
        size: 1,
        height: 1
      };
      const { size, height } = Object.assign({}, defaults, options);
      options.delta = size;
      options.offset = [0, 0, height];
      const outlines = geom2.toOutlines(geometry);
      if (outlines.length === 0)
        throw new Error("the given geometry cannot be empty");
      const newparts = outlines.map((outline) => {
        if (area2(outline) < 0)
          outline.reverse();
        return expand(options, path2.fromPoints({ closed: true }, outline));
      });
      const allsides = newparts.reduce((sides, part) => sides.concat(geom2.toSides(part)), []);
      const newgeometry = geom2.create(allsides);
      return extrudeLinearGeom2(options, newgeometry);
    };
    module.exports = extrudeRectangularGeom2;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeRectangular.js
var require_extrudeRectangular = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeRectangular.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var path2 = require_path2();
    var extrudeRectangularPath2 = require_extrudeRectangularPath2();
    var extrudeRectangularGeom2 = require_extrudeRectangularGeom2();
    var extrudeRectangular = (options, ...objects) => {
      const defaults = {
        size: 1,
        height: 1
      };
      const { size, height } = Object.assign({}, defaults, options);
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      if (size <= 0)
        throw new Error("size must be positive");
      if (height <= 0)
        throw new Error("height must be positive");
      const results = objects.map((object) => {
        if (path2.isA(object))
          return extrudeRectangularPath2(options, object);
        if (geom2.isA(object))
          return extrudeRectangularGeom2(options, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = extrudeRectangular;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/extrudeHelical.js
var require_extrudeHelical = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/extrudeHelical.js"(exports, module) {
    var { TAU } = require_constants();
    var slice = require_slice();
    var mat4 = require_mat4();
    var extrudeFromSlices = require_extrudeFromSlices();
    var geom2 = require_geom2();
    var extrudeHelical = (options, geometry) => {
      const defaults = {
        angle: TAU,
        startAngle: 0,
        pitch: 10,
        endOffset: 0,
        segmentsPerRotation: 32
      };
      const { angle, endOffset, segmentsPerRotation, startAngle } = Object.assign({}, defaults, options);
      let pitch;
      if (!options.pitch && options.height) {
        pitch = options.height / (angle / TAU);
      } else {
        pitch = options.pitch ? options.pitch : defaults.pitch;
      }
      const minNumberOfSegments = 3;
      if (segmentsPerRotation < minNumberOfSegments)
        throw new Error(`The number of segments per rotation needs to be at least 3.`);
      let shapeSides = geom2.toSides(geometry);
      if (shapeSides.length === 0)
        throw new Error("the given geometry cannot be empty");
      const pointsWithPositiveX = shapeSides.filter((s) => s[0][0] >= 0);
      let baseSlice = slice.fromSides(shapeSides);
      if (pointsWithPositiveX.length === 0) {
        baseSlice = slice.reverse(baseSlice);
      }
      const calculatedSegments = Math.round(segmentsPerRotation / TAU * Math.abs(angle));
      const segments = calculatedSegments >= 2 ? calculatedSegments : 2;
      const step1 = mat4.create();
      let matrix;
      const sliceCallback = (progress, index, base) => {
        const zRotation = startAngle + angle / segments * index;
        const xOffset = endOffset / segments * index;
        const zOffset = (zRotation - startAngle) / TAU * pitch;
        mat4.multiply(
          step1,
          // then apply offsets
          mat4.fromTranslation(mat4.create(), [xOffset, 0, zOffset * Math.sign(angle)]),
          // first rotate "flat" 2D shape from XY to XZ plane
          mat4.fromXRotation(mat4.create(), -TAU / 4 * Math.sign(angle))
          // rotate the slice correctly to not create inside-out polygon
        );
        matrix = mat4.create();
        mat4.multiply(
          matrix,
          // finally rotate around Z axis
          mat4.fromZRotation(mat4.create(), zRotation),
          step1
        );
        return slice.transform(matrix, base);
      };
      return extrudeFromSlices(
        {
          // "base" slice is counted as segment, so add one for complete final rotation
          numberOfSlices: segments + 1,
          callback: sliceCallback
        },
        baseSlice
      );
    };
    module.exports = extrudeHelical;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/project.js
var require_project = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/project.js"(exports, module) {
    var flatten2 = require_flatten();
    var aboutEqualNormals = require_aboutEqualNormals();
    var plane = require_plane();
    var mat4 = require_mat4();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var measureEpsilon = require_measureEpsilon();
    var unionGeom2 = require_unionGeom2();
    var projectGeom3 = (options, geometry) => {
      const projplane = plane.fromNormalAndPoint(plane.create(), options.axis, options.origin);
      if (Number.isNaN(projplane[0]) || Number.isNaN(projplane[1]) || Number.isNaN(projplane[2]) || Number.isNaN(projplane[3])) {
        throw new Error("project: invalid axis or origin");
      }
      const epsilon = measureEpsilon(geometry);
      const epsilonArea = epsilon * epsilon * Math.sqrt(3) / 4;
      if (epsilon === 0)
        return geom2.create();
      const polygons = geom3.toPolygons(geometry);
      let projpolys = [];
      for (let i = 0; i < polygons.length; i++) {
        const newpoints = polygons[i].vertices.map((v) => plane.projectionOfPoint(projplane, v));
        const newpoly = poly3.create(newpoints);
        const newplane = poly3.plane(newpoly);
        if (!aboutEqualNormals(projplane, newplane))
          continue;
        if (poly3.measureArea(newpoly) < epsilonArea)
          continue;
        projpolys.push(newpoly);
      }
      if (!aboutEqualNormals(projplane, [0, 0, 1])) {
        const rotation = mat4.fromVectorRotation(mat4.create(), projplane, [0, 0, 1]);
        projpolys = projpolys.map((p) => poly3.transform(rotation, p));
      }
      projpolys = projpolys.sort((a, b) => poly3.measureArea(b) - poly3.measureArea(a));
      const projgeoms = projpolys.map((p) => geom2.fromPoints(p.vertices));
      return unionGeom2(projgeoms);
    };
    var project = (options, ...objects) => {
      const defaults = {
        axis: [0, 0, 1],
        // Z axis
        origin: [0, 0, 0]
      };
      const { axis, origin } = Object.assign({}, defaults, options);
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      options = { axis, origin };
      const results = objects.map((object) => {
        if (geom3.isA(object))
          return projectGeom3(options, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = project;
  }
});

// node_modules/@jscad/modeling/src/operations/extrusions/index.js
var require_extrusions = __commonJS({
  "node_modules/@jscad/modeling/src/operations/extrusions/index.js"(exports, module) {
    module.exports = {
      extrudeFromSlices: require_extrudeFromSlices(),
      extrudeLinear: require_extrudeLinear(),
      extrudeRectangular: require_extrudeRectangular(),
      extrudeRotate: require_extrudeRotate(),
      extrudeHelical: require_extrudeHelical(),
      project: require_project(),
      slice: require_slice()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/hullPoints2.js
var require_hullPoints2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/hullPoints2.js"(exports, module) {
    var vec2 = require_vec2();
    var hullPoints2 = (uniquePoints) => {
      let min = vec2.fromValues(Infinity, Infinity);
      uniquePoints.forEach((point) => {
        if (point[1] < min[1] || point[1] === min[1] && point[0] < min[0]) {
          min = point;
        }
      });
      const points = [];
      uniquePoints.forEach((point) => {
        const angle = fakeAtan2(point[1] - min[1], point[0] - min[0]);
        const distSq = vec2.squaredDistance(point, min);
        points.push({ point, angle, distSq });
      });
      points.sort((pt1, pt2) => pt1.angle < pt2.angle ? -1 : pt1.angle > pt2.angle ? 1 : pt1.distSq < pt2.distSq ? -1 : pt1.distSq > pt2.distSq ? 1 : 0);
      const stack = [];
      points.forEach((point) => {
        let cnt = stack.length;
        while (cnt > 1 && ccw(stack[cnt - 2], stack[cnt - 1], point.point) <= Number.EPSILON) {
          stack.pop();
          cnt = stack.length;
        }
        stack.push(point.point);
      });
      return stack;
    };
    var ccw = (v1, v2, v3) => (v2[0] - v1[0]) * (v3[1] - v1[1]) - (v2[1] - v1[1]) * (v3[0] - v1[0]);
    var fakeAtan2 = (y, x) => {
      if (y === 0 && x === 0) {
        return -Infinity;
      } else {
        return -x / y;
      }
    };
    module.exports = hullPoints2;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/toUniquePoints.js
var require_toUniquePoints = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/toUniquePoints.js"(exports, module) {
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var toUniquePoints = (geometries2) => {
      const found = /* @__PURE__ */ new Set();
      const uniquePoints = [];
      const addPoint = (point) => {
        const key = point.toString();
        if (!found.has(key)) {
          uniquePoints.push(point);
          found.add(key);
        }
      };
      geometries2.forEach((geometry) => {
        if (geom2.isA(geometry)) {
          geom2.toPoints(geometry).forEach(addPoint);
        } else if (geom3.isA(geometry)) {
          geom3.toPoints(geometry).forEach((points) => points.forEach(addPoint));
        } else if (path2.isA(geometry)) {
          path2.toPoints(geometry).forEach(addPoint);
        }
      });
      return uniquePoints;
    };
    module.exports = toUniquePoints;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/hullPath2.js
var require_hullPath2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/hullPath2.js"(exports, module) {
    var flatten2 = require_flatten();
    var path2 = require_path2();
    var hullPoints2 = require_hullPoints2();
    var toUniquePoints = require_toUniquePoints();
    var hullPath2 = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const unique = toUniquePoints(geometries2);
      const hullPoints = hullPoints2(unique);
      return path2.fromPoints({ closed: true }, hullPoints);
    };
    module.exports = hullPath2;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/hullGeom2.js
var require_hullGeom2 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/hullGeom2.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var hullPoints2 = require_hullPoints2();
    var toUniquePoints = require_toUniquePoints();
    var hullGeom2 = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      const unique = toUniquePoints(geometries2);
      const hullPoints = hullPoints2(unique);
      if (hullPoints.length < 3)
        return geom2.create();
      return geom2.fromPoints(hullPoints);
    };
    module.exports = hullGeom2;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/point-line-distance.js
var require_point_line_distance = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/point-line-distance.js"(exports, module) {
    var cross = require_cross();
    var subtract = require_subtract();
    var squaredLength = require_squaredLength();
    var distanceSquared = (p, a, b) => {
      const ab = [];
      const ap = [];
      const cr = [];
      subtract(ab, b, a);
      subtract(ap, p, a);
      const area2 = squaredLength(cross(cr, ap, ab));
      const s = squaredLength(ab);
      if (s === 0) {
        throw Error("a and b are the same point");
      }
      return area2 / s;
    };
    var pointLineDistance = (point, a, b) => Math.sqrt(distanceSquared(point, a, b));
    module.exports = pointLineDistance;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/get-plane-normal.js
var require_get_plane_normal = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/get-plane-normal.js"(exports, module) {
    var cross = require_cross();
    var normalize2 = require_normalize();
    var subtract = require_subtract();
    var planeNormal = (out, point1, point2, point3) => {
      const tmp6 = [0, 0, 0];
      subtract(out, point1, point2);
      subtract(tmp6, point2, point3);
      cross(out, out, tmp6);
      return normalize2(out, out);
    };
    module.exports = planeNormal;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/VertexList.js
var require_VertexList = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/VertexList.js"(exports, module) {
    var VertexList = class {
      constructor() {
        this.head = null;
        this.tail = null;
      }
      clear() {
        this.head = this.tail = null;
      }
      /**
       * Inserts a `node` before `target`, it's assumed that
       * `target` belongs to this doubly linked list
       *
       * @param {*} target
       * @param {*} node
       */
      insertBefore(target4, node) {
        node.prev = target4.prev;
        node.next = target4;
        if (!node.prev) {
          this.head = node;
        } else {
          node.prev.next = node;
        }
        target4.prev = node;
      }
      /**
       * Inserts a `node` after `target`, it's assumed that
       * `target` belongs to this doubly linked list
       *
       * @param {Vertex} target
       * @param {Vertex} node
       */
      insertAfter(target4, node) {
        node.prev = target4;
        node.next = target4.next;
        if (!node.next) {
          this.tail = node;
        } else {
          node.next.prev = node;
        }
        target4.next = node;
      }
      /**
       * Appends a `node` to the end of this doubly linked list
       * Note: `node.next` will be unlinked from `node`
       * Note: if `node` is part of another linked list call `addAll` instead
       *
       * @param {*} node
       */
      add(node) {
        if (!this.head) {
          this.head = node;
        } else {
          this.tail.next = node;
        }
        node.prev = this.tail;
        node.next = null;
        this.tail = node;
      }
      /**
       * Appends a chain of nodes where `node` is the head,
       * the difference with `add` is that it correctly sets the position
       * of the node list `tail` property
       *
       * @param {*} node
       */
      addAll(node) {
        if (!this.head) {
          this.head = node;
        } else {
          this.tail.next = node;
        }
        node.prev = this.tail;
        while (node.next) {
          node = node.next;
        }
        this.tail = node;
      }
      /**
       * Deletes a `node` from this linked list, it's assumed that `node` is a
       * member of this linked list
       *
       * @param {*} node
       */
      remove(node) {
        if (!node.prev) {
          this.head = node.next;
        } else {
          node.prev.next = node.next;
        }
        if (!node.next) {
          this.tail = node.prev;
        } else {
          node.next.prev = node.prev;
        }
      }
      /**
       * Removes a chain of nodes whose head is `a` and whose tail is `b`,
       * it's assumed that `a` and `b` belong to this list and also that `a`
       * comes before `b` in the linked list
       *
       * @param {*} a
       * @param {*} b
       */
      removeChain(a, b) {
        if (!a.prev) {
          this.head = b.next;
        } else {
          a.prev.next = b.next;
        }
        if (!b.next) {
          this.tail = a.prev;
        } else {
          b.next.prev = a.prev;
        }
      }
      first() {
        return this.head;
      }
      isEmpty() {
        return !this.head;
      }
    };
    module.exports = VertexList;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/Vertex.js
var require_Vertex = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/Vertex.js"(exports, module) {
    var Vertex = class {
      constructor(point, index) {
        this.point = point;
        this.index = index;
        this.next = null;
        this.prev = null;
        this.face = null;
      }
    };
    module.exports = Vertex;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/HalfEdge.js
var require_HalfEdge = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/HalfEdge.js"(exports, module) {
    var distance = require_distance();
    var squaredDistance = require_squaredDistance();
    var HalfEdge = class {
      constructor(vertex2, face) {
        this.vertex = vertex2;
        this.face = face;
        this.next = null;
        this.prev = null;
        this.opposite = null;
      }
      head() {
        return this.vertex;
      }
      tail() {
        return this.prev ? this.prev.vertex : null;
      }
      length() {
        if (this.tail()) {
          return distance(
            this.tail().point,
            this.head().point
          );
        }
        return -1;
      }
      lengthSquared() {
        if (this.tail()) {
          return squaredDistance(
            this.tail().point,
            this.head().point
          );
        }
        return -1;
      }
      setOpposite(edge) {
        this.opposite = edge;
        edge.opposite = this;
      }
    };
    module.exports = HalfEdge;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/Face.js
var require_Face = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/Face.js"(exports, module) {
    var add = require_add2();
    var copy = require_copy2();
    var cross = require_cross();
    var dot = require_dot();
    var length = require_length();
    var normalize2 = require_normalize();
    var scale = require_scale();
    var subtract = require_subtract();
    var HalfEdge = require_HalfEdge();
    var VISIBLE = 0;
    var NON_CONVEX = 1;
    var DELETED = 2;
    var Face = class _Face {
      constructor() {
        this.normal = [];
        this.centroid = [];
        this.offset = 0;
        this.outside = null;
        this.mark = VISIBLE;
        this.edge = null;
        this.nVertices = 0;
      }
      getEdge(i) {
        if (typeof i !== "number") {
          throw Error("requires a number");
        }
        let it = this.edge;
        while (i > 0) {
          it = it.next;
          i -= 1;
        }
        while (i < 0) {
          it = it.prev;
          i += 1;
        }
        return it;
      }
      computeNormal() {
        const e0 = this.edge;
        const e1 = e0.next;
        let e2 = e1.next;
        const v2 = subtract([], e1.head().point, e0.head().point);
        const t = [];
        const v1 = [];
        this.nVertices = 2;
        this.normal = [0, 0, 0];
        while (e2 !== e0) {
          copy(v1, v2);
          subtract(v2, e2.head().point, e0.head().point);
          add(this.normal, this.normal, cross(t, v1, v2));
          e2 = e2.next;
          this.nVertices += 1;
        }
        this.area = length(this.normal);
        this.normal = scale(this.normal, this.normal, 1 / this.area);
      }
      computeNormalMinArea(minArea) {
        this.computeNormal();
        if (this.area < minArea) {
          let maxEdge;
          let maxSquaredLength = 0;
          let edge = this.edge;
          do {
            const lengthSquared = edge.lengthSquared();
            if (lengthSquared > maxSquaredLength) {
              maxEdge = edge;
              maxSquaredLength = lengthSquared;
            }
            edge = edge.next;
          } while (edge !== this.edge);
          const p1 = maxEdge.tail().point;
          const p2 = maxEdge.head().point;
          const maxVector = subtract([], p2, p1);
          const maxLength = Math.sqrt(maxSquaredLength);
          scale(maxVector, maxVector, 1 / maxLength);
          const maxProjection = dot(this.normal, maxVector);
          scale(maxVector, maxVector, -maxProjection);
          add(this.normal, this.normal, maxVector);
          normalize2(this.normal, this.normal);
        }
      }
      computeCentroid() {
        this.centroid = [0, 0, 0];
        let edge = this.edge;
        do {
          add(this.centroid, this.centroid, edge.head().point);
          edge = edge.next;
        } while (edge !== this.edge);
        scale(this.centroid, this.centroid, 1 / this.nVertices);
      }
      computeNormalAndCentroid(minArea) {
        if (typeof minArea !== "undefined") {
          this.computeNormalMinArea(minArea);
        } else {
          this.computeNormal();
        }
        this.computeCentroid();
        this.offset = dot(this.normal, this.centroid);
      }
      distanceToPlane(point) {
        return dot(this.normal, point) - this.offset;
      }
      /**
       * @private
       *
       * Connects two edges assuming that prev.head().point === next.tail().point
       *
       * @param {HalfEdge} prev
       * @param {HalfEdge} next
       */
      connectHalfEdges(prev, next) {
        let discardedFace;
        if (prev.opposite.face === next.opposite.face) {
          const oppositeFace = next.opposite.face;
          let oppositeEdge;
          if (prev === this.edge) {
            this.edge = next;
          }
          if (oppositeFace.nVertices === 3) {
            oppositeEdge = next.opposite.prev.opposite;
            oppositeFace.mark = DELETED;
            discardedFace = oppositeFace;
          } else {
            oppositeEdge = next.opposite.next;
            if (oppositeFace.edge === oppositeEdge.prev) {
              oppositeFace.edge = oppositeEdge;
            }
            oppositeEdge.prev = oppositeEdge.prev.prev;
            oppositeEdge.prev.next = oppositeEdge;
          }
          next.prev = prev.prev;
          next.prev.next = next;
          next.setOpposite(oppositeEdge);
          oppositeFace.computeNormalAndCentroid();
        } else {
          prev.next = next;
          next.prev = prev;
        }
        return discardedFace;
      }
      mergeAdjacentFaces(adjacentEdge, discardedFaces) {
        const oppositeEdge = adjacentEdge.opposite;
        const oppositeFace = oppositeEdge.face;
        discardedFaces.push(oppositeFace);
        oppositeFace.mark = DELETED;
        let adjacentEdgePrev = adjacentEdge.prev;
        let adjacentEdgeNext = adjacentEdge.next;
        let oppositeEdgePrev = oppositeEdge.prev;
        let oppositeEdgeNext = oppositeEdge.next;
        while (adjacentEdgePrev.opposite.face === oppositeFace) {
          adjacentEdgePrev = adjacentEdgePrev.prev;
          oppositeEdgeNext = oppositeEdgeNext.next;
        }
        while (adjacentEdgeNext.opposite.face === oppositeFace) {
          adjacentEdgeNext = adjacentEdgeNext.next;
          oppositeEdgePrev = oppositeEdgePrev.prev;
        }
        let edge;
        for (edge = oppositeEdgeNext; edge !== oppositeEdgePrev.next; edge = edge.next) {
          edge.face = this;
        }
        this.edge = adjacentEdgeNext;
        let discardedFace;
        discardedFace = this.connectHalfEdges(oppositeEdgePrev, adjacentEdgeNext);
        if (discardedFace) {
          discardedFaces.push(discardedFace);
        }
        discardedFace = this.connectHalfEdges(adjacentEdgePrev, oppositeEdgeNext);
        if (discardedFace) {
          discardedFaces.push(discardedFace);
        }
        this.computeNormalAndCentroid();
        return discardedFaces;
      }
      collectIndices() {
        const indices = [];
        let edge = this.edge;
        do {
          indices.push(edge.head().index);
          edge = edge.next;
        } while (edge !== this.edge);
        return indices;
      }
      static createTriangle(v0, v1, v2, minArea = 0) {
        const face = new _Face();
        const e0 = new HalfEdge(v0, face);
        const e1 = new HalfEdge(v1, face);
        const e2 = new HalfEdge(v2, face);
        e0.next = e2.prev = e1;
        e1.next = e0.prev = e2;
        e2.next = e1.prev = e0;
        face.edge = e0;
        face.computeNormalAndCentroid(minArea);
        return face;
      }
    };
    module.exports = {
      VISIBLE,
      NON_CONVEX,
      DELETED,
      Face
    };
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/QuickHull.js
var require_QuickHull = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/QuickHull.js"(exports, module) {
    var dot = require_dot();
    var pointLineDistance = require_point_line_distance();
    var getPlaneNormal = require_get_plane_normal();
    var VertexList = require_VertexList();
    var Vertex = require_Vertex();
    var { Face, VISIBLE, NON_CONVEX, DELETED } = require_Face();
    var MERGE_NON_CONVEX_WRT_LARGER_FACE = 1;
    var MERGE_NON_CONVEX = 2;
    var QuickHull = class {
      constructor(points) {
        if (!Array.isArray(points)) {
          throw TypeError("input is not a valid array");
        }
        if (points.length < 4) {
          throw Error("cannot build a simplex out of <4 points");
        }
        this.tolerance = -1;
        this.nFaces = 0;
        this.nPoints = points.length;
        this.faces = [];
        this.newFaces = [];
        this.claimed = new VertexList();
        this.unclaimed = new VertexList();
        this.vertices = [];
        for (let i = 0; i < points.length; i += 1) {
          this.vertices.push(new Vertex(points[i], i));
        }
        this.discardedFaces = [];
        this.vertexPointIndices = [];
      }
      addVertexToFace(vertex2, face) {
        vertex2.face = face;
        if (!face.outside) {
          this.claimed.add(vertex2);
        } else {
          this.claimed.insertBefore(face.outside, vertex2);
        }
        face.outside = vertex2;
      }
      /**
       * Removes `vertex` for the `claimed` list of vertices, it also makes sure
       * that the link from `face` to the first vertex it sees in `claimed` is
       * linked correctly after the removal
       *
       * @param {Vertex} vertex
       * @param {Face} face
       */
      removeVertexFromFace(vertex2, face) {
        if (vertex2 === face.outside) {
          if (vertex2.next && vertex2.next.face === face) {
            face.outside = vertex2.next;
          } else {
            face.outside = null;
          }
        }
        this.claimed.remove(vertex2);
      }
      /**
       * Removes all the visible vertices that `face` is able to see which are
       * stored in the `claimed` vertext list
       *
       * @param {Face} face
       * @return {Vertex|undefined} If face had visible vertices returns
       * `face.outside`, otherwise undefined
       */
      removeAllVerticesFromFace(face) {
        if (face.outside) {
          let end = face.outside;
          while (end.next && end.next.face === face) {
            end = end.next;
          }
          this.claimed.removeChain(face.outside, end);
          end.next = null;
          return face.outside;
        }
      }
      /**
       * Removes all the visible vertices that `face` is able to see, additionally
       * checking the following:
       *
       * If `absorbingFace` doesn't exist then all the removed vertices will be
       * added to the `unclaimed` vertex list
       *
       * If `absorbingFace` exists then this method will assign all the vertices of
       * `face` that can see `absorbingFace`, if a vertex cannot see `absorbingFace`
       * it's added to the `unclaimed` vertex list
       *
       * @param {Face} face
       * @param {Face} [absorbingFace]
       */
      deleteFaceVertices(face, absorbingFace) {
        const faceVertices = this.removeAllVerticesFromFace(face);
        if (faceVertices) {
          if (!absorbingFace) {
            this.unclaimed.addAll(faceVertices);
          } else {
            let nextVertex;
            for (let vertex2 = faceVertices; vertex2; vertex2 = nextVertex) {
              nextVertex = vertex2.next;
              const distance = absorbingFace.distanceToPlane(vertex2.point);
              if (distance > this.tolerance) {
                this.addVertexToFace(vertex2, absorbingFace);
              } else {
                this.unclaimed.add(vertex2);
              }
            }
          }
        }
      }
      /**
       * Reassigns as many vertices as possible from the unclaimed list to the new
       * faces
       *
       * @param {Faces[]} newFaces
       */
      resolveUnclaimedPoints(newFaces) {
        let vertexNext = this.unclaimed.first();
        for (let vertex2 = vertexNext; vertex2; vertex2 = vertexNext) {
          vertexNext = vertex2.next;
          let maxDistance = this.tolerance;
          let maxFace;
          for (let i = 0; i < newFaces.length; i += 1) {
            const face = newFaces[i];
            if (face.mark === VISIBLE) {
              const dist = face.distanceToPlane(vertex2.point);
              if (dist > maxDistance) {
                maxDistance = dist;
                maxFace = face;
              }
              if (maxDistance > 1e3 * this.tolerance) {
                break;
              }
            }
          }
          if (maxFace) {
            this.addVertexToFace(vertex2, maxFace);
          }
        }
      }
      /**
       * Computes the extremes of a tetrahedron which will be the initial hull
       *
       * @return {number[]} The min/max vertices in the x,y,z directions
       */
      computeExtremes() {
        const min = [];
        const max = [];
        const minVertices = [];
        const maxVertices = [];
        let i, j;
        for (i = 0; i < 3; i += 1) {
          minVertices[i] = maxVertices[i] = this.vertices[0];
        }
        for (i = 0; i < 3; i += 1) {
          min[i] = max[i] = this.vertices[0].point[i];
        }
        for (i = 1; i < this.vertices.length; i += 1) {
          const vertex2 = this.vertices[i];
          const point = vertex2.point;
          for (j = 0; j < 3; j += 1) {
            if (point[j] < min[j]) {
              min[j] = point[j];
              minVertices[j] = vertex2;
            }
          }
          for (j = 0; j < 3; j += 1) {
            if (point[j] > max[j]) {
              max[j] = point[j];
              maxVertices[j] = vertex2;
            }
          }
        }
        this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min[0]), Math.abs(max[0])) + Math.max(Math.abs(min[1]), Math.abs(max[1])) + Math.max(Math.abs(min[2]), Math.abs(max[2])));
        return [minVertices, maxVertices];
      }
      /**
       * Compues the initial tetrahedron assigning to its faces all the points that
       * are candidates to form part of the hull
       */
      createInitialSimplex() {
        const vertices = this.vertices;
        const [min, max] = this.computeExtremes();
        let v2, v3;
        let i, j;
        let maxDistance = 0;
        let indexMax = 0;
        for (i = 0; i < 3; i += 1) {
          const distance = max[i].point[i] - min[i].point[i];
          if (distance > maxDistance) {
            maxDistance = distance;
            indexMax = i;
          }
        }
        const v0 = min[indexMax];
        const v1 = max[indexMax];
        maxDistance = 0;
        for (i = 0; i < this.vertices.length; i += 1) {
          const vertex2 = this.vertices[i];
          if (vertex2 !== v0 && vertex2 !== v1) {
            const distance = pointLineDistance(
              vertex2.point,
              v0.point,
              v1.point
            );
            if (distance > maxDistance) {
              maxDistance = distance;
              v2 = vertex2;
            }
          }
        }
        const normal = getPlaneNormal([], v0.point, v1.point, v2.point);
        const distPO = dot(v0.point, normal);
        maxDistance = -1;
        for (i = 0; i < this.vertices.length; i += 1) {
          const vertex2 = this.vertices[i];
          if (vertex2 !== v0 && vertex2 !== v1 && vertex2 !== v2) {
            const distance = Math.abs(dot(normal, vertex2.point) - distPO);
            if (distance > maxDistance) {
              maxDistance = distance;
              v3 = vertex2;
            }
          }
        }
        const faces = [];
        if (dot(v3.point, normal) - distPO < 0) {
          faces.push(
            Face.createTriangle(v0, v1, v2),
            Face.createTriangle(v3, v1, v0),
            Face.createTriangle(v3, v2, v1),
            Face.createTriangle(v3, v0, v2)
          );
          for (i = 0; i < 3; i += 1) {
            const j2 = (i + 1) % 3;
            faces[i + 1].getEdge(2).setOpposite(faces[0].getEdge(j2));
            faces[i + 1].getEdge(1).setOpposite(faces[j2 + 1].getEdge(0));
          }
        } else {
          faces.push(
            Face.createTriangle(v0, v2, v1),
            Face.createTriangle(v3, v0, v1),
            Face.createTriangle(v3, v1, v2),
            Face.createTriangle(v3, v2, v0)
          );
          for (i = 0; i < 3; i += 1) {
            const j2 = (i + 1) % 3;
            faces[i + 1].getEdge(2).setOpposite(faces[0].getEdge((3 - i) % 3));
            faces[i + 1].getEdge(0).setOpposite(faces[j2 + 1].getEdge(1));
          }
        }
        for (i = 0; i < 4; i += 1) {
          this.faces.push(faces[i]);
        }
        for (i = 0; i < vertices.length; i += 1) {
          const vertex2 = vertices[i];
          if (vertex2 !== v0 && vertex2 !== v1 && vertex2 !== v2 && vertex2 !== v3) {
            maxDistance = this.tolerance;
            let maxFace;
            for (j = 0; j < 4; j += 1) {
              const distance = faces[j].distanceToPlane(vertex2.point);
              if (distance > maxDistance) {
                maxDistance = distance;
                maxFace = faces[j];
              }
            }
            if (maxFace) {
              this.addVertexToFace(vertex2, maxFace);
            }
          }
        }
      }
      reindexFaceAndVertices() {
        const activeFaces = [];
        for (let i = 0; i < this.faces.length; i += 1) {
          const face = this.faces[i];
          if (face.mark === VISIBLE) {
            activeFaces.push(face);
          }
        }
        this.faces = activeFaces;
      }
      collectFaces(skipTriangulation) {
        const faceIndices = [];
        for (let i = 0; i < this.faces.length; i += 1) {
          if (this.faces[i].mark !== VISIBLE) {
            throw Error("attempt to include a destroyed face in the hull");
          }
          const indices = this.faces[i].collectIndices();
          if (skipTriangulation) {
            faceIndices.push(indices);
          } else {
            for (let j = 0; j < indices.length - 2; j += 1) {
              faceIndices.push(
                [indices[0], indices[j + 1], indices[j + 2]]
              );
            }
          }
        }
        return faceIndices;
      }
      /**
       * Finds the next vertex to make faces with the current hull
       *
       * - let `face` be the first face existing in the `claimed` vertex list
       *  - if `face` doesn't exist then return since there're no vertices left
       *  - otherwise for each `vertex` that face sees find the one furthest away
       *  from `face`
       *
       * @return {Vertex|undefined} Returns undefined when there're no more
       * visible vertices
       */
      nextVertexToAdd() {
        if (!this.claimed.isEmpty()) {
          let eyeVertex, vertex2;
          let maxDistance = 0;
          const eyeFace = this.claimed.first().face;
          for (vertex2 = eyeFace.outside; vertex2 && vertex2.face === eyeFace; vertex2 = vertex2.next) {
            const distance = eyeFace.distanceToPlane(vertex2.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              eyeVertex = vertex2;
            }
          }
          return eyeVertex;
        }
      }
      /**
       * Computes a chain of half edges in ccw order called the `horizon`, for an
       * edge to be part of the horizon it must join a face that can see
       * `eyePoint` and a face that cannot see `eyePoint`
       *
       * @param {number[]} eyePoint - The coordinates of a point
       * @param {HalfEdge} crossEdge - The edge used to jump to the current `face`
       * @param {Face} face - The current face being tested
       * @param {HalfEdge[]} horizon - The edges that form part of the horizon in
       * ccw order
       */
      computeHorizon(eyePoint, crossEdge, face, horizon) {
        this.deleteFaceVertices(face);
        face.mark = DELETED;
        let edge;
        if (!crossEdge) {
          edge = crossEdge = face.getEdge(0);
        } else {
          edge = crossEdge.next;
        }
        do {
          const oppositeEdge = edge.opposite;
          const oppositeFace = oppositeEdge.face;
          if (oppositeFace.mark === VISIBLE) {
            if (oppositeFace.distanceToPlane(eyePoint) > this.tolerance) {
              this.computeHorizon(eyePoint, oppositeEdge, oppositeFace, horizon);
            } else {
              horizon.push(edge);
            }
          }
          edge = edge.next;
        } while (edge !== crossEdge);
      }
      /**
       * Creates a face with the points `eyeVertex.point`, `horizonEdge.tail` and
       * `horizonEdge.tail` in ccw order
       *
       * @param {Vertex} eyeVertex
       * @param {HalfEdge} horizonEdge
       * @return {HalfEdge} The half edge whose vertex is the eyeVertex
       */
      addAdjoiningFace(eyeVertex, horizonEdge) {
        const face = Face.createTriangle(
          eyeVertex,
          horizonEdge.tail(),
          horizonEdge.head()
        );
        this.faces.push(face);
        face.getEdge(-1).setOpposite(horizonEdge.opposite);
        return face.getEdge(0);
      }
      /**
       * Adds horizon.length faces to the hull, each face will be 'linked' with the
       * horizon opposite face and the face on the left/right
       *
       * @param {Vertex} eyeVertex
       * @param {HalfEdge[]} horizon - A chain of half edges in ccw order
       */
      addNewFaces(eyeVertex, horizon) {
        this.newFaces = [];
        let firstSideEdge, previousSideEdge;
        for (let i = 0; i < horizon.length; i += 1) {
          const horizonEdge = horizon[i];
          const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
          if (!firstSideEdge) {
            firstSideEdge = sideEdge;
          } else {
            sideEdge.next.setOpposite(previousSideEdge);
          }
          this.newFaces.push(sideEdge.face);
          previousSideEdge = sideEdge;
        }
        firstSideEdge.next.setOpposite(previousSideEdge);
      }
      /**
       * Computes the distance from `edge` opposite face's centroid to
       * `edge.face`
       *
       * @param {HalfEdge} edge
       * @return {number}
       * - A positive number when the centroid of the opposite face is above the
       *   face i.e. when the faces are concave
       * - A negative number when the centroid of the opposite face is below the
       *   face i.e. when the faces are convex
       */
      oppositeFaceDistance(edge) {
        return edge.face.distanceToPlane(edge.opposite.face.centroid);
      }
      /**
       * Merges a face with none/any/all its neighbors according to the strategy
       * used
       *
       * if `mergeType` is MERGE_NON_CONVEX_WRT_LARGER_FACE then the merge will be
       * decided based on the face with the larger area, the centroid of the face
       * with the smaller area will be checked against the one with the larger area
       * to see if it's in the merge range [tolerance, -tolerance] i.e.
       *
       *    dot(centroid smaller face, larger face normal) - larger face offset > -tolerance
       *
       * Note that the first check (with +tolerance) was done on `computeHorizon`
       *
       * If the above is not true then the check is done with respect to the smaller
       * face i.e.
       *
       *    dot(centroid larger face, smaller face normal) - smaller face offset > -tolerance
       *
       * If true then it means that two faces are non convex (concave), even if the
       * dot(...) - offset value is > 0 (that's the point of doing the merge in the
       * first place)
       *
       * If two faces are concave then the check must also be done on the other face
       * but this is done in another merge pass, for this to happen the face is
       * marked in a temporal NON_CONVEX state
       *
       * if `mergeType` is MERGE_NON_CONVEX then two faces will be merged only if
       * they pass the following conditions
       *
       *    dot(centroid smaller face, larger face normal) - larger face offset > -tolerance
       *    dot(centroid larger face, smaller face normal) - smaller face offset > -tolerance
       *
       * @param {Face} face
       * @param {number} mergeType - Either MERGE_NON_CONVEX_WRT_LARGER_FACE or
       * MERGE_NON_CONVEX
       */
      doAdjacentMerge(face, mergeType) {
        let edge = face.edge;
        let convex = true;
        let it = 0;
        do {
          if (it >= face.nVertices) {
            throw Error("merge recursion limit exceeded");
          }
          const oppositeFace = edge.opposite.face;
          let merge = false;
          if (mergeType === MERGE_NON_CONVEX) {
            if (this.oppositeFaceDistance(edge) > -this.tolerance || this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
              merge = true;
            }
          } else {
            if (face.area > oppositeFace.area) {
              if (this.oppositeFaceDistance(edge) > -this.tolerance) {
                merge = true;
              } else if (this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                convex = false;
              }
            } else {
              if (this.oppositeFaceDistance(edge.opposite) > -this.tolerance) {
                merge = true;
              } else if (this.oppositeFaceDistance(edge) > -this.tolerance) {
                convex = false;
              }
            }
          }
          if (merge) {
            const discardedFaces = face.mergeAdjacentFaces(edge, []);
            for (let i = 0; i < discardedFaces.length; i += 1) {
              this.deleteFaceVertices(discardedFaces[i], face);
            }
            return true;
          }
          edge = edge.next;
          it += 1;
        } while (edge !== face.edge);
        if (!convex) {
          face.mark = NON_CONVEX;
        }
        return false;
      }
      /**
       * Adds a vertex to the hull with the following algorithm
       *
       * - Compute the `horizon` which is a chain of half edges, for an edge to
       *   belong to this group it must be the edge connecting a face that can
       *   see `eyeVertex` and a face which cannot see `eyeVertex`
       * - All the faces that can see `eyeVertex` have its visible vertices removed
       *   from the claimed VertexList
       * - A new set of faces is created with each edge of the `horizon` and
       *   `eyeVertex`, each face is connected with the opposite horizon face and
       *   the face on the left/right
       * - The new faces are merged if possible with the opposite horizon face first
       *   and then the faces on the right/left
       * - The vertices removed from all the visible faces are assigned to the new
       *   faces if possible
       *
       * @param {Vertex} eyeVertex
       */
      addVertexToHull(eyeVertex) {
        const horizon = [];
        this.unclaimed.clear();
        this.removeVertexFromFace(eyeVertex, eyeVertex.face);
        this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
        this.addNewFaces(eyeVertex, horizon);
        for (let i = 0; i < this.newFaces.length; i += 1) {
          const face = this.newFaces[i];
          if (face.mark === VISIBLE) {
            while (this.doAdjacentMerge(face, MERGE_NON_CONVEX_WRT_LARGER_FACE)) {
            }
          }
        }
        for (let i = 0; i < this.newFaces.length; i += 1) {
          const face = this.newFaces[i];
          if (face.mark === NON_CONVEX) {
            face.mark = VISIBLE;
            while (this.doAdjacentMerge(face, MERGE_NON_CONVEX)) {
            }
          }
        }
        this.resolveUnclaimedPoints(this.newFaces);
      }
      build() {
        let eyeVertex;
        this.createInitialSimplex();
        while (eyeVertex = this.nextVertexToAdd()) {
          this.addVertexToHull(eyeVertex);
        }
        this.reindexFaceAndVertices();
      }
    };
    module.exports = QuickHull;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/quickhull/index.js
var require_quickhull = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/quickhull/index.js"(exports, module) {
    var QuickHull = require_QuickHull();
    var runner = (points, options = {}) => {
      const instance = new QuickHull(points);
      instance.build();
      return instance.collectFaces(options.skipTriangulation);
    };
    module.exports = runner;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/hullGeom3.js
var require_hullGeom3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/hullGeom3.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom3 = require_geom3();
    var poly3 = require_poly3();
    var quickhull = require_quickhull();
    var toUniquePoints = require_toUniquePoints();
    var hullGeom3 = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 1)
        return geometries2[0];
      const unique = toUniquePoints(geometries2);
      const faces = quickhull(unique, { skipTriangulation: true });
      const polygons = faces.map((face) => {
        const vertices = face.map((index) => unique[index]);
        return poly3.create(vertices);
      });
      return geom3.create(polygons);
    };
    module.exports = hullGeom3;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/hull.js
var require_hull = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/hull.js"(exports, module) {
    var flatten2 = require_flatten();
    var areAllShapesTheSameType = require_areAllShapesTheSameType();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var hullPath2 = require_hullPath2();
    var hullGeom2 = require_hullGeom2();
    var hullGeom3 = require_hullGeom3();
    var hull = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      if (!areAllShapesTheSameType(geometries2)) {
        throw new Error("only hulls of the same type are supported");
      }
      const geometry = geometries2[0];
      if (path2.isA(geometry))
        return hullPath2(geometries2);
      if (geom2.isA(geometry))
        return hullGeom2(geometries2);
      if (geom3.isA(geometry))
        return hullGeom3(geometries2);
      return geometry;
    };
    module.exports = hull;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/hullChain.js
var require_hullChain = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/hullChain.js"(exports, module) {
    var flatten2 = require_flatten();
    var union = require_union();
    var hull = require_hull();
    var hullChain = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length < 2)
        throw new Error("wrong number of arguments");
      const hulls = [];
      for (let i = 1; i < geometries2.length; i++) {
        hulls.push(hull(geometries2[i - 1], geometries2[i]));
      }
      return union(hulls);
    };
    module.exports = hullChain;
  }
});

// node_modules/@jscad/modeling/src/operations/hulls/index.js
var require_hulls = __commonJS({
  "node_modules/@jscad/modeling/src/operations/hulls/index.js"(exports, module) {
    module.exports = {
      hull: require_hull(),
      hullChain: require_hullChain()
    };
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/snapPolygons.js
var require_snapPolygons = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/snapPolygons.js"(exports, module) {
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var isValidPoly3 = (epsilon, polygon) => {
      const area2 = Math.abs(poly3.measureArea(polygon));
      return Number.isFinite(area2) && area2 > epsilon;
    };
    var snapPolygons = (epsilon, polygons) => {
      let newpolygons = polygons.map((polygon) => {
        const snapvertices = polygon.vertices.map((vertice) => vec3.snap(vec3.create(), vertice, epsilon));
        const newvertices = [];
        for (let i = 0; i < snapvertices.length; i++) {
          const j = (i + 1) % snapvertices.length;
          if (!vec3.equals(snapvertices[i], snapvertices[j]))
            newvertices.push(snapvertices[i]);
        }
        const newpolygon = poly3.create(newvertices);
        if (polygon.color)
          newpolygon.color = polygon.color;
        return newpolygon;
      });
      const epsilonArea = epsilon * epsilon * Math.sqrt(3) / 4;
      newpolygons = newpolygons.filter((polygon) => isValidPoly3(epsilonArea, polygon));
      return newpolygons;
    };
    module.exports = snapPolygons;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/mergePolygons.js
var require_mergePolygons = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/mergePolygons.js"(exports, module) {
    var aboutEqualNormals = require_aboutEqualNormals();
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var createEdges = (polygon) => {
      const points = poly3.toPoints(polygon);
      const edges = [];
      for (let i = 0; i < points.length; i++) {
        const j = (i + 1) % points.length;
        const edge = {
          v1: points[i],
          v2: points[j]
        };
        edges.push(edge);
      }
      for (let i = 0; i < edges.length; i++) {
        const j = (i + 1) % points.length;
        edges[i].next = edges[j];
        edges[j].prev = edges[i];
      }
      return edges;
    };
    var insertEdge = (edges, edge) => {
      const key = `${edge.v1}:${edge.v2}`;
      edges.set(key, edge);
    };
    var deleteEdge = (edges, edge) => {
      const key = `${edge.v1}:${edge.v2}`;
      edges.delete(key);
    };
    var findOppositeEdge = (edges, edge) => {
      const key = `${edge.v2}:${edge.v1}`;
      return edges.get(key);
    };
    var calculateAnglesBetween = (current, opposite, normal) => {
      let v0 = current.prev.v1;
      let v12 = current.prev.v2;
      let v22 = opposite.next.v2;
      const angle1 = calculateAngle(v0, v12, v22, normal);
      v0 = opposite.prev.v1;
      v12 = opposite.prev.v2;
      v22 = current.next.v2;
      const angle2 = calculateAngle(v0, v12, v22, normal);
      return [angle1, angle2];
    };
    var v1 = vec3.create();
    var v2 = vec3.create();
    var calculateAngle = (prevpoint, point, nextpoint, normal) => {
      const d0 = vec3.subtract(v1, point, prevpoint);
      const d1 = vec3.subtract(v2, nextpoint, point);
      vec3.cross(d0, d0, d1);
      return vec3.dot(d0, normal);
    };
    var createPolygonAnd = (edge) => {
      let polygon;
      const points = [];
      while (edge.next) {
        const next = edge.next;
        points.push(edge.v1);
        edge.v1 = null;
        edge.v2 = null;
        edge.next = null;
        edge.prev = null;
        edge = next;
      }
      if (points.length > 0)
        polygon = poly3.create(points);
      return polygon;
    };
    var mergeCoplanarPolygons = (sourcepolygons) => {
      if (sourcepolygons.length < 2)
        return sourcepolygons;
      const normal = sourcepolygons[0].plane;
      const polygons = sourcepolygons.slice();
      const edgeList = /* @__PURE__ */ new Map();
      while (polygons.length > 0) {
        const polygon = polygons.shift();
        const edges = createEdges(polygon);
        for (let i = 0; i < edges.length; i++) {
          const current = edges[i];
          const opposite = findOppositeEdge(edgeList, current);
          if (opposite) {
            const angles = calculateAnglesBetween(current, opposite, normal);
            if (angles[0] >= 0 && angles[1] >= 0) {
              const edge1 = opposite.next;
              const edge2 = current.next;
              current.prev.next = opposite.next;
              current.next.prev = opposite.prev;
              opposite.prev.next = current.next;
              opposite.next.prev = current.prev;
              current.v1 = null;
              current.v2 = null;
              current.next = null;
              current.prev = null;
              deleteEdge(edgeList, opposite);
              opposite.v1 = null;
              opposite.v2 = null;
              opposite.next = null;
              opposite.prev = null;
              const mergeEdges = (list, e1, e2) => {
                const newedge = {
                  v1: e2.v1,
                  v2: e1.v2,
                  next: e1.next,
                  prev: e2.prev
                };
                e2.prev.next = newedge;
                e1.next.prev = newedge;
                deleteEdge(list, e1);
                e1.v1 = null;
                e1.v2 = null;
                e1.next = null;
                e1.prev = null;
                deleteEdge(list, e2);
                e2.v1 = null;
                e2.v2 = null;
                e2.next = null;
                e2.prev = null;
              };
              if (angles[0] === 0) {
                mergeEdges(edgeList, edge1, edge1.prev);
              }
              if (angles[1] === 0) {
                mergeEdges(edgeList, edge2, edge2.prev);
              }
            }
          } else {
            if (current.next)
              insertEdge(edgeList, current);
          }
        }
      }
      const destpolygons = [];
      edgeList.forEach((edge) => {
        const polygon = createPolygonAnd(edge);
        if (polygon)
          destpolygons.push(polygon);
      });
      edgeList.clear();
      return destpolygons;
    };
    var coplanar = (plane1, plane2) => {
      if (Math.abs(plane1[3] - plane2[3]) < 15e-8) {
        return aboutEqualNormals(plane1, plane2);
      }
      return false;
    };
    var mergePolygons = (epsilon, polygons) => {
      const polygonsPerPlane = [];
      polygons.forEach((polygon) => {
        const mapping = polygonsPerPlane.find((element) => coplanar(element[0], poly3.plane(polygon)));
        if (mapping) {
          const polygons2 = mapping[1];
          polygons2.push(polygon);
        } else {
          polygonsPerPlane.push([poly3.plane(polygon), [polygon]]);
        }
      });
      let destpolygons = [];
      polygonsPerPlane.forEach((mapping) => {
        const sourcepolygons = mapping[1];
        const retesselayedpolygons = mergeCoplanarPolygons(sourcepolygons);
        destpolygons = destpolygons.concat(retesselayedpolygons);
      });
      return destpolygons;
    };
    module.exports = mergePolygons;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/insertTjunctions.js
var require_insertTjunctions = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/insertTjunctions.js"(exports, module) {
    var constants = require_constants();
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var assert = false;
    var getTag = (vertex2) => `${vertex2}`;
    var addSide = (sidemap, vertextag2sidestart, vertextag2sideend, vertex0, vertex1, polygonindex) => {
      const starttag = getTag(vertex0);
      const endtag = getTag(vertex1);
      if (assert && starttag === endtag)
        throw new Error("assert failed");
      const newsidetag = `${starttag}/${endtag}`;
      const reversesidetag = `${endtag}/${starttag}`;
      if (sidemap.has(reversesidetag)) {
        deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, vertex1, vertex0, null);
        return null;
      }
      const newsideobj = {
        vertex0,
        vertex1,
        polygonindex
      };
      if (!sidemap.has(newsidetag)) {
        sidemap.set(newsidetag, [newsideobj]);
      } else {
        sidemap.get(newsidetag).push(newsideobj);
      }
      if (vertextag2sidestart.has(starttag)) {
        vertextag2sidestart.get(starttag).push(newsidetag);
      } else {
        vertextag2sidestart.set(starttag, [newsidetag]);
      }
      if (vertextag2sideend.has(endtag)) {
        vertextag2sideend.get(endtag).push(newsidetag);
      } else {
        vertextag2sideend.set(endtag, [newsidetag]);
      }
      return newsidetag;
    };
    var deleteSide = (sidemap, vertextag2sidestart, vertextag2sideend, vertex0, vertex1, polygonindex) => {
      const starttag = getTag(vertex0);
      const endtag = getTag(vertex1);
      const sidetag = `${starttag}/${endtag}`;
      if (assert && !sidemap.has(sidetag))
        throw new Error("assert failed");
      let idx = -1;
      const sideobjs = sidemap.get(sidetag);
      for (let i = 0; i < sideobjs.length; i++) {
        const sideobj = sideobjs[i];
        let sidetag2 = getTag(sideobj.vertex0);
        if (sidetag2 !== starttag)
          continue;
        sidetag2 = getTag(sideobj.vertex1);
        if (sidetag2 !== endtag)
          continue;
        if (polygonindex !== null) {
          if (sideobj.polygonindex !== polygonindex)
            continue;
        }
        idx = i;
        break;
      }
      if (assert && idx < 0)
        throw new Error("assert failed");
      sideobjs.splice(idx, 1);
      if (sideobjs.length === 0) {
        sidemap.delete(sidetag);
      }
      idx = vertextag2sidestart.get(starttag).indexOf(sidetag);
      if (assert && idx < 0)
        throw new Error("assert failed");
      vertextag2sidestart.get(starttag).splice(idx, 1);
      if (vertextag2sidestart.get(starttag).length === 0) {
        vertextag2sidestart.delete(starttag);
      }
      idx = vertextag2sideend.get(endtag).indexOf(sidetag);
      if (assert && idx < 0)
        throw new Error("assert failed");
      vertextag2sideend.get(endtag).splice(idx, 1);
      if (vertextag2sideend.get(endtag).length === 0) {
        vertextag2sideend.delete(endtag);
      }
    };
    var insertTjunctions = (polygons) => {
      const sidemap = /* @__PURE__ */ new Map();
      for (let polygonindex = 0; polygonindex < polygons.length; polygonindex++) {
        const polygon = polygons[polygonindex];
        const numvertices = polygon.vertices.length;
        if (numvertices >= 3) {
          let vertex2 = polygon.vertices[0];
          let vertextag = getTag(vertex2);
          for (let vertexindex = 0; vertexindex < numvertices; vertexindex++) {
            let nextvertexindex = vertexindex + 1;
            if (nextvertexindex === numvertices)
              nextvertexindex = 0;
            const nextvertex = polygon.vertices[nextvertexindex];
            const nextvertextag = getTag(nextvertex);
            const sidetag = `${vertextag}/${nextvertextag}`;
            const reversesidetag = `${nextvertextag}/${vertextag}`;
            if (sidemap.has(reversesidetag)) {
              const ar = sidemap.get(reversesidetag);
              ar.splice(-1, 1);
              if (ar.length === 0) {
                sidemap.delete(reversesidetag);
              }
            } else {
              const sideobj = {
                vertex0: vertex2,
                vertex1: nextvertex,
                polygonindex
              };
              if (!sidemap.has(sidetag)) {
                sidemap.set(sidetag, [sideobj]);
              } else {
                sidemap.get(sidetag).push(sideobj);
              }
            }
            vertex2 = nextvertex;
            vertextag = nextvertextag;
          }
        } else {
          console.warn("warning: invalid polygon found during insertTjunctions");
        }
      }
      if (sidemap.size > 0) {
        const vertextag2sidestart = /* @__PURE__ */ new Map();
        const vertextag2sideend = /* @__PURE__ */ new Map();
        const sidesToCheck = /* @__PURE__ */ new Map();
        for (const [sidetag, sideobjs] of sidemap) {
          sidesToCheck.set(sidetag, true);
          sideobjs.forEach((sideobj) => {
            const starttag = getTag(sideobj.vertex0);
            const endtag = getTag(sideobj.vertex1);
            if (vertextag2sidestart.has(starttag)) {
              vertextag2sidestart.get(starttag).push(sidetag);
            } else {
              vertextag2sidestart.set(starttag, [sidetag]);
            }
            if (vertextag2sideend.has(endtag)) {
              vertextag2sideend.get(endtag).push(sidetag);
            } else {
              vertextag2sideend.set(endtag, [sidetag]);
            }
          });
        }
        const newpolygons = polygons.slice(0);
        while (true) {
          if (sidemap.size === 0)
            break;
          for (const sidetag of sidemap.keys()) {
            sidesToCheck.set(sidetag, true);
          }
          let donesomething = false;
          while (true) {
            const sidetags = Array.from(sidesToCheck.keys());
            if (sidetags.length === 0)
              break;
            const sidetagtocheck = sidetags[0];
            let donewithside = true;
            if (sidemap.has(sidetagtocheck)) {
              const sideobjs = sidemap.get(sidetagtocheck);
              if (assert && sideobjs.length === 0)
                throw new Error("assert failed");
              const sideobj = sideobjs[0];
              for (let directionindex = 0; directionindex < 2; directionindex++) {
                const startvertex = directionindex === 0 ? sideobj.vertex0 : sideobj.vertex1;
                const endvertex = directionindex === 0 ? sideobj.vertex1 : sideobj.vertex0;
                const startvertextag = getTag(startvertex);
                const endvertextag = getTag(endvertex);
                let matchingsides = [];
                if (directionindex === 0) {
                  if (vertextag2sideend.has(startvertextag)) {
                    matchingsides = vertextag2sideend.get(startvertextag);
                  }
                } else {
                  if (vertextag2sidestart.has(startvertextag)) {
                    matchingsides = vertextag2sidestart.get(startvertextag);
                  }
                }
                for (let matchingsideindex = 0; matchingsideindex < matchingsides.length; matchingsideindex++) {
                  const matchingsidetag = matchingsides[matchingsideindex];
                  const matchingside = sidemap.get(matchingsidetag)[0];
                  const matchingsidestartvertex = directionindex === 0 ? matchingside.vertex0 : matchingside.vertex1;
                  const matchingsideendvertex = directionindex === 0 ? matchingside.vertex1 : matchingside.vertex0;
                  const matchingsidestartvertextag = getTag(matchingsidestartvertex);
                  const matchingsideendvertextag = getTag(matchingsideendvertex);
                  if (assert && matchingsideendvertextag !== startvertextag)
                    throw new Error("assert failed");
                  if (matchingsidestartvertextag === endvertextag) {
                    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, startvertex, endvertex, null);
                    deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, startvertex, null);
                    donewithside = false;
                    directionindex = 2;
                    donesomething = true;
                    break;
                  } else {
                    const startpos = startvertex;
                    const endpos = endvertex;
                    const checkpos = matchingsidestartvertex;
                    const direction = vec3.subtract(vec3.create(), checkpos, startpos);
                    const t = vec3.dot(vec3.subtract(vec3.create(), endpos, startpos), direction) / vec3.dot(direction, direction);
                    if (t > 0 && t < 1) {
                      const closestpoint = vec3.scale(vec3.create(), direction, t);
                      vec3.add(closestpoint, closestpoint, startpos);
                      const distancesquared = vec3.squaredDistance(closestpoint, endpos);
                      if (distancesquared < constants.EPS * constants.EPS) {
                        const polygonindex = matchingside.polygonindex;
                        const polygon = newpolygons[polygonindex];
                        const insertionvertextag = getTag(matchingside.vertex1);
                        let insertionvertextagindex = -1;
                        for (let i = 0; i < polygon.vertices.length; i++) {
                          if (getTag(polygon.vertices[i]) === insertionvertextag) {
                            insertionvertextagindex = i;
                            break;
                          }
                        }
                        if (assert && insertionvertextagindex < 0)
                          throw new Error("assert failed");
                        const newvertices = polygon.vertices.slice(0);
                        newvertices.splice(insertionvertextagindex, 0, endvertex);
                        const newpolygon = poly3.create(newvertices);
                        newpolygons[polygonindex] = newpolygon;
                        deleteSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, matchingside.vertex1, polygonindex);
                        const newsidetag1 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, matchingside.vertex0, endvertex, polygonindex);
                        const newsidetag2 = addSide(sidemap, vertextag2sidestart, vertextag2sideend, endvertex, matchingside.vertex1, polygonindex);
                        if (newsidetag1 !== null)
                          sidesToCheck.set(newsidetag1, true);
                        if (newsidetag2 !== null)
                          sidesToCheck.set(newsidetag2, true);
                        donewithside = false;
                        directionindex = 2;
                        donesomething = true;
                        break;
                      }
                    }
                  }
                }
              }
            }
            if (donewithside) {
              sidesToCheck.delete(sidetagtocheck);
            }
          }
          if (!donesomething)
            break;
        }
        polygons = newpolygons;
      }
      sidemap.clear();
      return polygons;
    };
    module.exports = insertTjunctions;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/triangulatePolygons.js
var require_triangulatePolygons = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/triangulatePolygons.js"(exports, module) {
    var vec3 = require_vec3();
    var poly3 = require_poly3();
    var triangulatePolygon = (epsilon, polygon, triangles) => {
      const nv = polygon.vertices.length;
      if (nv > 3) {
        if (nv > 4) {
          const midpoint = [0, 0, 0];
          polygon.vertices.forEach((vertice) => vec3.add(midpoint, midpoint, vertice));
          vec3.snap(midpoint, vec3.divide(midpoint, midpoint, [nv, nv, nv]), epsilon);
          for (let i = 0; i < nv; i++) {
            const poly = poly3.create([midpoint, polygon.vertices[i], polygon.vertices[(i + 1) % nv]]);
            if (polygon.color)
              poly.color = polygon.color;
            triangles.push(poly);
          }
          return;
        }
        const poly0 = poly3.create([polygon.vertices[0], polygon.vertices[1], polygon.vertices[2]]);
        const poly1 = poly3.create([polygon.vertices[0], polygon.vertices[2], polygon.vertices[3]]);
        if (polygon.color) {
          poly0.color = polygon.color;
          poly1.color = polygon.color;
        }
        triangles.push(poly0, poly1);
        return;
      }
      triangles.push(polygon);
    };
    var triangulatePolygons = (epsilon, polygons) => {
      const triangles = [];
      polygons.forEach((polygon) => {
        triangulatePolygon(epsilon, polygon, triangles);
      });
      return triangles;
    };
    module.exports = triangulatePolygons;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/generalize.js
var require_generalize = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/generalize.js"(exports, module) {
    var flatten2 = require_flatten();
    var measureEpsilon = require_measureEpsilon();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var snapPolygons = require_snapPolygons();
    var mergePolygons = require_mergePolygons();
    var insertTjunctions = require_insertTjunctions();
    var triangulatePolygons = require_triangulatePolygons();
    var generalizePath2 = (options, geometry) => geometry;
    var generalizeGeom2 = (options, geometry) => geometry;
    var generalizeGeom3 = (options, geometry) => {
      const defaults = {
        snap: false,
        simplify: false,
        triangulate: false
      };
      const { snap, simplify, triangulate } = Object.assign({}, defaults, options);
      const epsilon = measureEpsilon(geometry);
      let polygons = geom3.toPolygons(geometry);
      if (snap) {
        polygons = snapPolygons(epsilon, polygons);
      }
      if (simplify) {
        polygons = mergePolygons(epsilon, polygons);
      }
      if (triangulate) {
        polygons = insertTjunctions(polygons);
        polygons = triangulatePolygons(epsilon, polygons);
      }
      const clone = Object.assign({}, geometry);
      clone.polygons = polygons;
      return clone;
    };
    var generalize = (options, ...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return generalizePath2(options, geometry);
        if (geom2.isA(geometry))
          return generalizeGeom2(options, geometry);
        if (geom3.isA(geometry))
          return generalizeGeom3(options, geometry);
        throw new Error("invalid geometry");
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = generalize;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/snap.js
var require_snap3 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/snap.js"(exports, module) {
    var flatten2 = require_flatten();
    var vec2 = require_vec2();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var measureEpsilon = require_measureEpsilon();
    var snapPolygons = require_snapPolygons();
    var snapPath2 = (geometry) => {
      const epsilon = measureEpsilon(geometry);
      const points = path2.toPoints(geometry);
      const newpoints = points.map((point) => vec2.snap(vec2.create(), point, epsilon));
      return path2.create(newpoints);
    };
    var snapGeom2 = (geometry) => {
      const epsilon = measureEpsilon(geometry);
      const sides = geom2.toSides(geometry);
      let newsides = sides.map((side) => [vec2.snap(vec2.create(), side[0], epsilon), vec2.snap(vec2.create(), side[1], epsilon)]);
      newsides = newsides.filter((side) => !vec2.equals(side[0], side[1]));
      return geom2.create(newsides);
    };
    var snapGeom3 = (geometry) => {
      const epsilon = measureEpsilon(geometry);
      const polygons = geom3.toPolygons(geometry);
      const newpolygons = snapPolygons(epsilon, polygons);
      return geom3.create(newpolygons);
    };
    var snap = (...geometries2) => {
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("wrong number of arguments");
      const results = geometries2.map((geometry) => {
        if (path2.isA(geometry))
          return snapPath2(geometry);
        if (geom2.isA(geometry))
          return snapGeom2(geometry);
        if (geom3.isA(geometry))
          return snapGeom3(geometry);
        return geometry;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = snap;
  }
});

// node_modules/@jscad/modeling/src/operations/modifiers/index.js
var require_modifiers = __commonJS({
  "node_modules/@jscad/modeling/src/operations/modifiers/index.js"(exports, module) {
    module.exports = {
      generalize: require_generalize(),
      snap: require_snap3()
    };
  }
});

// node_modules/@jscad/modeling/src/utils/padArrayToLength.js
var require_padArrayToLength = __commonJS({
  "node_modules/@jscad/modeling/src/utils/padArrayToLength.js"(exports, module) {
    var padArrayToLength = (anArray, padding, targetLength) => {
      anArray = anArray.slice();
      while (anArray.length < targetLength) {
        anArray.push(padding);
      }
      return anArray;
    };
    module.exports = padArrayToLength;
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/align.js
var require_align = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/align.js"(exports, module) {
    var flatten2 = require_flatten();
    var padArrayToLength = require_padArrayToLength();
    var measureAggregateBoundingBox = require_measureAggregateBoundingBox();
    var { translate } = require_translate2();
    var validateOptions = (options) => {
      if (!Array.isArray(options.modes) || options.modes.length > 3)
        throw new Error("align(): modes must be an array of length <= 3");
      options.modes = padArrayToLength(options.modes, "none", 3);
      if (options.modes.filter((mode) => ["center", "max", "min", "none"].includes(mode)).length !== 3)
        throw new Error('align(): all modes must be one of "center", "max" or "min"');
      if (!Array.isArray(options.relativeTo) || options.relativeTo.length > 3)
        throw new Error("align(): relativeTo must be an array of length <= 3");
      options.relativeTo = padArrayToLength(options.relativeTo, 0, 3);
      if (options.relativeTo.filter((alignVal) => Number.isFinite(alignVal) || alignVal == null).length !== 3)
        throw new Error("align(): all relativeTo values must be a number, or null.");
      if (typeof options.grouped !== "boolean")
        throw new Error("align(): grouped must be a boolean value.");
      return options;
    };
    var populateRelativeToFromBounds = (relativeTo, modes, bounds) => {
      for (let i = 0; i < 3; i++) {
        if (relativeTo[i] == null) {
          if (modes[i] === "center") {
            relativeTo[i] = (bounds[0][i] + bounds[1][i]) / 2;
          } else if (modes[i] === "max") {
            relativeTo[i] = bounds[1][i];
          } else if (modes[i] === "min") {
            relativeTo[i] = bounds[0][i];
          }
        }
      }
      return relativeTo;
    };
    var alignGeometries = (geometry, modes, relativeTo) => {
      const bounds = measureAggregateBoundingBox(geometry);
      const translation = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        if (modes[i] === "center") {
          translation[i] = relativeTo[i] - (bounds[0][i] + bounds[1][i]) / 2;
        } else if (modes[i] === "max") {
          translation[i] = relativeTo[i] - bounds[1][i];
        } else if (modes[i] === "min") {
          translation[i] = relativeTo[i] - bounds[0][i];
        }
      }
      return translate(translation, geometry);
    };
    var align = (options, ...geometries2) => {
      const defaults = {
        modes: ["center", "center", "min"],
        relativeTo: [0, 0, 0],
        grouped: false
      };
      options = Object.assign({}, defaults, options);
      options = validateOptions(options);
      let { modes, relativeTo, grouped } = options;
      geometries2 = flatten2(geometries2);
      if (geometries2.length === 0)
        throw new Error("align(): No geometries were provided to act upon");
      if (relativeTo.filter((val) => val == null).length) {
        const bounds = measureAggregateBoundingBox(geometries2);
        relativeTo = populateRelativeToFromBounds(relativeTo, modes, bounds);
      }
      if (grouped) {
        geometries2 = alignGeometries(geometries2, modes, relativeTo);
      } else {
        geometries2 = geometries2.map((geometry) => alignGeometries(geometry, modes, relativeTo));
      }
      return geometries2.length === 1 ? geometries2[0] : geometries2;
    };
    module.exports = align;
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/center.js
var require_center = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/center.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var measureBoundingBox = require_measureBoundingBox2();
    var { translate } = require_translate2();
    var centerGeometry = (options, object) => {
      const defaults = {
        axes: [true, true, true],
        relativeTo: [0, 0, 0]
      };
      const { axes, relativeTo } = Object.assign({}, defaults, options);
      const bounds = measureBoundingBox(object);
      const offset = [0, 0, 0];
      if (axes[0])
        offset[0] = relativeTo[0] - (bounds[0][0] + (bounds[1][0] - bounds[0][0]) / 2);
      if (axes[1])
        offset[1] = relativeTo[1] - (bounds[0][1] + (bounds[1][1] - bounds[0][1]) / 2);
      if (axes[2])
        offset[2] = relativeTo[2] - (bounds[0][2] + (bounds[1][2] - bounds[0][2]) / 2);
      return translate(offset, object);
    };
    var center = (options, ...objects) => {
      const defaults = {
        axes: [true, true, true],
        relativeTo: [0, 0, 0]
        // TODO: Add additional 'methods' of centering: midpoint, centroid
      };
      const { axes, relativeTo } = Object.assign({}, defaults, options);
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      if (relativeTo.length !== 3)
        throw new Error("relativeTo must be an array of length 3");
      options = { axes, relativeTo };
      const results = objects.map((object) => {
        if (path2.isA(object))
          return centerGeometry(options, object);
        if (geom2.isA(object))
          return centerGeometry(options, object);
        if (geom3.isA(object))
          return centerGeometry(options, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    var centerX = (...objects) => center({ axes: [true, false, false] }, objects);
    var centerY = (...objects) => center({ axes: [false, true, false] }, objects);
    var centerZ = (...objects) => center({ axes: [false, false, true] }, objects);
    module.exports = {
      center,
      centerX,
      centerY,
      centerZ
    };
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/scale.js
var require_scale4 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/scale.js"(exports, module) {
    var flatten2 = require_flatten();
    var mat4 = require_mat4();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var scale = (factors, ...objects) => {
      if (!Array.isArray(factors))
        throw new Error("factors must be an array");
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      factors = factors.slice();
      while (factors.length < 3)
        factors.push(1);
      if (factors[0] <= 0 || factors[1] <= 0 || factors[2] <= 0)
        throw new Error("factors must be positive");
      const matrix = mat4.fromScaling(mat4.create(), factors);
      const results = objects.map((object) => {
        if (path2.isA(object))
          return path2.transform(matrix, object);
        if (geom2.isA(object))
          return geom2.transform(matrix, object);
        if (geom3.isA(object))
          return geom3.transform(matrix, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    var scaleX = (factor, ...objects) => scale([factor, 1, 1], objects);
    var scaleY = (factor, ...objects) => scale([1, factor, 1], objects);
    var scaleZ = (factor, ...objects) => scale([1, 1, factor], objects);
    module.exports = {
      scale,
      scaleX,
      scaleY,
      scaleZ
    };
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/transform.js
var require_transform12 = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/transform.js"(exports, module) {
    var flatten2 = require_flatten();
    var geom2 = require_geom2();
    var geom3 = require_geom3();
    var path2 = require_path2();
    var transform = (matrix, ...objects) => {
      objects = flatten2(objects);
      if (objects.length === 0)
        throw new Error("wrong number of arguments");
      const results = objects.map((object) => {
        if (path2.isA(object))
          return path2.transform(matrix, object);
        if (geom2.isA(object))
          return geom2.transform(matrix, object);
        if (geom3.isA(object))
          return geom3.transform(matrix, object);
        return object;
      });
      return results.length === 1 ? results[0] : results;
    };
    module.exports = transform;
  }
});

// node_modules/@jscad/modeling/src/operations/transforms/index.js
var require_transforms = __commonJS({
  "node_modules/@jscad/modeling/src/operations/transforms/index.js"(exports, module) {
    module.exports = {
      align: require_align(),
      center: require_center().center,
      centerX: require_center().centerX,
      centerY: require_center().centerY,
      centerZ: require_center().centerZ,
      mirror: require_mirror().mirror,
      mirrorX: require_mirror().mirrorX,
      mirrorY: require_mirror().mirrorY,
      mirrorZ: require_mirror().mirrorZ,
      rotate: require_rotate3().rotate,
      rotateX: require_rotate3().rotateX,
      rotateY: require_rotate3().rotateY,
      rotateZ: require_rotate3().rotateZ,
      scale: require_scale4().scale,
      scaleX: require_scale4().scaleX,
      scaleY: require_scale4().scaleY,
      scaleZ: require_scale4().scaleZ,
      transform: require_transform12(),
      translate: require_translate2().translate,
      translateX: require_translate2().translateX,
      translateY: require_translate2().translateY,
      translateZ: require_translate2().translateZ
    };
  }
});

// node_modules/@jscad/modeling/src/index.js
var require_src = __commonJS({
  "node_modules/@jscad/modeling/src/index.js"(exports, module) {
    module.exports = {
      colors: require_colors(),
      curves: require_curves(),
      geometries: require_geometries(),
      maths: require_maths(),
      measurements: require_measurements(),
      primitives: require_primitives(),
      text: require_text(),
      utils: require_utils2(),
      booleans: require_booleans(),
      expansions: require_expansions(),
      extrusions: require_extrusions(),
      hulls: require_hulls(),
      modifiers: require_modifiers(),
      transforms: require_transforms()
    };
  }
});

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/ParamType.js
var ParamType = ((ParamType2) => {
  ParamType2["BOOLEAN"] = "boolean";
  ParamType2["BUTTON"] = "button";
  ParamType2["COLOR"] = "color";
  ParamType2["FLOAT"] = "float";
  ParamType2["FOLDER"] = "folder";
  ParamType2["INTEGER"] = "integer";
  ParamType2["PARAM_PATH"] = "param_path";
  ParamType2["NODE_PATH"] = "node_path";
  ParamType2["RAMP"] = "ramp";
  ParamType2["STRING"] = "string";
  ParamType2["VECTOR2"] = "vector2";
  ParamType2["VECTOR3"] = "vector3";
  ParamType2["VECTOR4"] = "vector4";
  return ParamType2;
})(ParamType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/ParamEvent.js
var ParamEvent = ((ParamEvent2) => {
  ParamEvent2["VISIBLE_UPDATED"] = "param_visible_updated";
  ParamEvent2["EDITABLE_UPDATED"] = "param_editable_updated";
  ParamEvent2["RAW_INPUT_UPDATED"] = "raw_input_updated";
  ParamEvent2["VALUE_UPDATED"] = "param_value_updated";
  ParamEvent2["EXPRESSION_UPDATED"] = "param_expression_update";
  ParamEvent2["ERROR_UPDATED"] = "param_error_updated";
  ParamEvent2["DELETED"] = "param_deleted";
  ParamEvent2["ASSET_RELOAD_REQUEST"] = "param_asset_reload_request";
  return ParamEvent2;
})(ParamEvent || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/Color.js
var ColorConversion = ((ColorConversion2) => {
  ColorConversion2["NONE"] = "no conversion";
  ColorConversion2["SRGB_TO_LINEAR"] = "sRGB -> linear";
  ColorConversion2["LINEAR_TO_SRGB"] = "linear -> sRGB";
  return ColorConversion2;
})(ColorConversion || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/utils/OptionsController.js
var CALLBACK_OPTION = "callback";
var CALLBACK_STRING_OPTION = "callbackString";
var COMPUTE_ON_DIRTY = "computeOnDirty";
var COOK_OPTION = "cook";
var FILE_BROWSE_OPTION = "fileBrowse";
var FILE_BROWSE_EXTENSIONS = "extensions";
var EXPRESSION = "expression";
var FOR_ENTITIES = "forEntities";
var LABEL = "label";
var HIDE_LABEL = "hideLabel";
var LEVEL = "level";
var MENU = "menu";
var MENU_STRING = "menuString";
var ENTRIES = "entries";
var MULTILINE_OPTION = "multiline";
var LANGUAGE_OPTION = "language";
var NODE_SELECTION = "nodeSelection";
var NODE_SELECTION_CONTEXT = "context";
var NODE_SELECTION_TYPES = "types";
var OBJECT_MASK = "objectMask";
var OBJECT_MASK_INPUT_INDEX = "inputIndex";
var DEPENDENT_ON_FOUND_NODE = "dependentOnFoundNode";
var DEPENDENT_ON_FOUND_PARAM = "dependentOnFoundParam";
var RANGE_OPTION = "range";
var RANGE_LOCKED_OPTION = "rangeLocked";
var STEP_OPTION = "step";
var SPARE_OPTION = "spare";
var TEXTURE_OPTION = "texture";
var ENV_OPTION = "env";
var HIDDEN_OPTION = "hidden";
var FIELD_OPTION = "field";
var VISIBLE_IF_OPTION = "visibleIf";
var COLOR_CONVERSION = "conversion";
var SEPARATOR_BEFORE_OPTION = "separatorBefore";
var SEPARATOR_AFTER_OPTION = "separatorAfter";
var JOIN_TO_PREVIOUS_PARAM = "joinToPreviousParam";
var AS_QUATERNION = "asQuaternion";
var EDITABLE = "editable";
var StringParamLanguage = ((StringParamLanguage2) => {
  StringParamLanguage2["CSS"] = "css";
  StringParamLanguage2["GLSL"] = "glsl";
  StringParamLanguage2["HTML"] = "html";
  StringParamLanguage2["TYPESCRIPT"] = "typescript";
  StringParamLanguage2["JSON"] = "json";
  return StringParamLanguage2;
})(StringParamLanguage || {});
var FileType = ((FileType2) => {
  FileType2["AUDIO"] = "audio";
  FileType2["TEXTURE_IMAGE"] = "texture_image";
  FileType2["TEXTURE_VIDEO"] = "texture_video";
  FileType2["GEOMETRY"] = "geometry";
  FileType2["FONT"] = "font";
  FileType2["SVG"] = "svg";
  FileType2["JSON"] = "json";
  return FileType2;
})(FileType || {});
var NON_OVERRIDABLE_OPTIONS = [EDITABLE];
var OptionsController = class {
  constructor(_param) {
    this._param = _param;
    this._programaticVisibleState = true;
    this._callbackAllowed = false;
    this._updateVisibilityAndRemoveDirtyBound = this.updateVisibilityAndRemoveDirty.bind(this);
    this._ui_data_dependency_set = false;
  }
  dispose() {
    var _a;
    try {
      this._options[CALLBACK_OPTION] = void 0;
      this._options[CALLBACK_STRING_OPTION] = void 0;
    } catch (err) {
    }
    (_a = this._visibility_graph_node) == null ? void 0 : _a.dispose();
  }
  set(options) {
    if (CoreType.isString(options)) {
      console.warn("options input invalid", options, typeof options);
    }
    this._default_options = options;
    this._options = objectCloneDeep(this._default_options);
    this.postSetOptions();
  }
  copy(options_controller) {
    this._default_options = objectCloneDeep(options_controller.default());
    this._options = objectCloneDeep(options_controller.current());
    this.postSetOptions();
  }
  setOption(optionName, value) {
    if (!this._validateOption(optionName, value)) {
      return;
    }
    this._options[optionName] = value;
    if (this._param.components) {
      for (const component of this._param.components) {
        component.options.setOption(optionName, value);
      }
    }
  }
  _validateOption(optionName, value) {
    if (optionName == CALLBACK_OPTION) {
      return isFunction(value);
    }
    return true;
  }
  postSetOptions() {
    this._handleComputeOnDirty();
  }
  param() {
    return this._param;
  }
  node() {
    return this._param.node;
  }
  default() {
    return this._default_options;
  }
  current() {
    return this._options;
  }
  // utils
  hasOptionsOverridden() {
    return !objectIsEqual(this._options, this._default_options);
  }
  overriddenOptions() {
    const overriden = {};
    const optionNames = Object.keys(this._options);
    const optionNamesToCheck = [];
    arrayDifference(optionNames, NON_OVERRIDABLE_OPTIONS, optionNamesToCheck);
    for (const optionName of optionNamesToCheck) {
      if (!objectIsEqual(this._options[optionName], this._default_options[optionName])) {
        const cloned_option = objectCloneDeep(this._options[optionName]);
        Object.assign(overriden, { [optionName]: cloned_option });
      }
    }
    return overriden;
  }
  overriddenOptionNames() {
    return Object.keys(this.overriddenOptions());
  }
  // compute on dirty
  computeOnDirty() {
    return this._options[COMPUTE_ON_DIRTY] || false;
  }
  _handleComputeOnDirty() {
    if (this.computeOnDirty()) {
      if (!this._computeOnDirtyCallbackAdded) {
        this.param().addPostDirtyHook("computeOnDirty", this._computeParam.bind(this));
        this._computeOnDirtyCallbackAdded = true;
      }
    }
  }
  async _computeParam() {
    await this.param().compute();
  }
  // callback
  hasCallback() {
    return this._options[CALLBACK_OPTION] != null || this._options[CALLBACK_STRING_OPTION] != null;
  }
  allowCallback() {
    this._callbackAllowed = true;
  }
  async executeCallback() {
    if (!this._callbackAllowed) {
      return;
    }
    const node = this.node();
    if (!node) {
      return;
    }
    const scene = node.scene();
    if (!scene) {
      return;
    }
    const callback = this.getCallback(node, scene);
    if (!callback) {
      return;
    }
    if (!scene.loadingController.loaded()) {
      return;
    }
    const parentParam = this.param().parentParam();
    if (parentParam) {
      parentParam.options.executeCallback();
    } else {
      await callback(node, this.param());
    }
  }
  getCallback(node, scene) {
    if (this.hasCallback()) {
      return this._options[CALLBACK_OPTION] = this._options[CALLBACK_OPTION] || this.createCallbackFromString(node, scene);
    }
  }
  createCallbackFromString(node, scene) {
    const callbackString = this._options[CALLBACK_STRING_OPTION];
    if (callbackString) {
      const callbackFunction = new Function("node", "scene", "window", "location", callbackString);
      return () => {
        callbackFunction(node, scene, null, null);
      };
    }
  }
  // color
  colorConversion() {
    return this._options[COLOR_CONVERSION] || ColorConversion.NONE;
  }
  // cook
  makesNodeDirtyWhenDirty() {
    if (this.param().parentParam() != null) {
      return false;
    }
    const cookOptions = this._options[COOK_OPTION];
    if (cookOptions != null) {
      return cookOptions;
    }
    return true;
  }
  // desktop
  fileBrowseOption() {
    return this._options[FILE_BROWSE_OPTION];
  }
  fileBrowseAllowed() {
    return this.fileBrowseOption() != null;
  }
  fileBrowseExtensions() {
    const option = this.fileBrowseOption();
    if (option) {
      return option[FILE_BROWSE_EXTENSIONS];
    } else {
      return null;
    }
  }
  // separator
  separatorBefore() {
    return this._options[SEPARATOR_BEFORE_OPTION];
  }
  separatorAfter() {
    return this._options[SEPARATOR_AFTER_OPTION];
  }
  joinToPreviousParam() {
    return this._options[JOIN_TO_PREVIOUS_PARAM];
  }
  // editable
  setEditableState(state) {
    const currentState = this._options[EDITABLE];
    const param = this.param();
    if (currentState != state) {
      this._options[EDITABLE] = state;
      param.emit(ParamEvent.EDITABLE_UPDATED);
    }
    if (param.components) {
      for (const component of param.components) {
        component.options.setEditableState(state);
      }
    }
  }
  editable() {
    const state = this._options[EDITABLE];
    if (state != null) {
      return state;
    }
    return true;
  }
  // expression
  // get displays_expression_only() {
  // 	return this._options[EXPRESSION_ONLY_OPTION] === true;
  // }
  isExpressionForEntities() {
    const expr_option = this._options[EXPRESSION];
    if (expr_option) {
      return expr_option[FOR_ENTITIES] || false;
    }
    return false;
  }
  // folder
  level() {
    return this._options[LEVEL] || 0;
  }
  // menu
  hasMenu() {
    return this.menuOptions() != null || this.menuStringOptions() != null;
  }
  menuOptions() {
    return this._options[MENU];
  }
  menuStringOptions() {
    return this._options[MENU_STRING];
  }
  menuEntries() {
    const options = this.menuOptions() || this.menuStringOptions();
    if (options) {
      return options[ENTRIES];
    } else {
      return [];
    }
  }
  ensureValueInMenuEntries(value) {
    const options = this.menuOptions();
    if (!options) {
      return value;
    }
    const entries = options[ENTRIES];
    if (entries.length == 0) {
      return value;
    }
    for (const entry of entries) {
      if (value == entry.value) {
        return value;
      }
    }
    return entries[0].value;
  }
  // multiline
  isMultiline() {
    return this._options[MULTILINE_OPTION] === true;
  }
  language() {
    return this._options[LANGUAGE_OPTION];
  }
  isCode() {
    return this.language() != null;
  }
  // node selection
  nodeSelectionOptions() {
    return this._options[NODE_SELECTION];
  }
  nodeSelectionContext() {
    const options = this.nodeSelectionOptions();
    if (options) {
      return options[NODE_SELECTION_CONTEXT];
    }
  }
  nodeSelectionTypes() {
    const options = this.nodeSelectionOptions();
    if (options) {
      return options[NODE_SELECTION_TYPES];
    }
  }
  displayObjectMaskSelection() {
    const value = this._options[OBJECT_MASK];
    return value != null && value != false;
  }
  objectMaskInputIndex() {
    const value = this._options[OBJECT_MASK];
    const input = value != null ? value[OBJECT_MASK_INPUT_INDEX] : 0;
    return input || 0;
  }
  objectMaskFromInputOnly() {
    const value = this._options[OBJECT_MASK];
    const fromInputOnly = value.fromInputOnly;
    return fromInputOnly != false;
  }
  dependentOnFoundNode() {
    if (DEPENDENT_ON_FOUND_NODE in this._options) {
      return this._options[DEPENDENT_ON_FOUND_NODE];
    } else {
      return true;
    }
  }
  dependentOnFoundParam() {
    if (DEPENDENT_ON_FOUND_PARAM in this._options) {
      return this._options[DEPENDENT_ON_FOUND_PARAM];
    } else {
      return true;
    }
  }
  // param selection
  isSelectingParam() {
    return this.param().type() == ParamType.PARAM_PATH;
  }
  // paramSelectionOptions() {
  // 	return this._options[PARAM_SELECTION];
  // }
  // paramSelectionType() {
  // 	const options = this.paramSelectionOptions();
  // 	if (options) {
  // 		const type_or_boolean = options;
  // 		if (!CoreType.isBoolean(type_or_boolean)) {
  // 			return type_or_boolean;
  // 		}
  // 	}
  // }
  // range
  range() {
    return this._options[RANGE_OPTION] || [0, 1];
  }
  step() {
    return this._options[STEP_OPTION];
  }
  asQuaternion() {
    return this._options[AS_QUATERNION] == true;
  }
  rangeLocked() {
    return this._options[RANGE_LOCKED_OPTION] || [false, false];
  }
  ensureInRange(value) {
    const range = this.range();
    if (value >= range[0] && value <= range[1]) {
      return value;
    } else {
      if (value < range[0]) {
        return this.rangeLocked()[0] === true ? range[0] : value;
      } else {
        return this.rangeLocked()[1] === true ? range[1] : value;
      }
    }
  }
  // spare
  isSpare() {
    return this._options[SPARE_OPTION] || false;
  }
  // texture
  textureOptions() {
    return this._options[TEXTURE_OPTION];
  }
  textureAsEnv() {
    const texture_options = this.textureOptions();
    if (texture_options != null) {
      return texture_options[ENV_OPTION] === true;
    }
    return false;
  }
  // visible
  isHidden() {
    return this._options[HIDDEN_OPTION] === true || this._programaticVisibleState === false;
  }
  isVisible() {
    return !this.isHidden();
  }
  setVisibleState(state) {
    this._options[HIDDEN_OPTION] = !state;
    this.param().emit(ParamEvent.VISIBLE_UPDATED);
  }
  // label
  label() {
    return this._options[LABEL];
  }
  isLabelHidden() {
    const type = this.param().type();
    switch (type) {
      case ParamType.BUTTON: {
        return true;
      }
      case ParamType.BOOLEAN: {
        return this.isFieldHidden();
      }
      case ParamType.RAMP: {
        return this._options[HIDE_LABEL] || false;
      }
      case ParamType.STRING: {
        return this.isCode() && this._options[HIDE_LABEL] || false;
      }
    }
    return false;
  }
  isFieldHidden() {
    return this._options[FIELD_OPTION] === false;
  }
  // programatic visibility
  uiDataDependsOnOtherParams() {
    return VISIBLE_IF_OPTION in this._options;
  }
  visibilityPredecessors() {
    const visibilityOptions = this._options[VISIBLE_IF_OPTION];
    if (!visibilityOptions) {
      return [];
    }
    let predecessorNames = [];
    if (CoreType.isArray(visibilityOptions)) {
      arrayUniq(visibilityOptions.map((options) => Object.keys(options)).flat(), predecessorNames);
    } else {
      predecessorNames = Object.keys(visibilityOptions);
    }
    const node = this.param().node;
    const params = [];
    arrayCompact(
      predecessorNames.map((name) => {
        const param = node.params.get(name);
        if (param) {
          return param;
        } else {
          console.error(
            `param ${name} not found as visibility condition for ${this.param().name()} in node ${this.param().node.type()}`
          );
        }
      }),
      params
    );
    return params;
  }
  setUiDataDependency() {
    if (this._ui_data_dependency_set) {
      return;
    }
    this._ui_data_dependency_set = true;
    const predecessors = this.visibilityPredecessors();
    if (predecessors.length > 0) {
      this._visibility_graph_node = new CoreGraphNode(this.param().scene(), "param_visibility");
      for (const predecessor of predecessors) {
        this._visibility_graph_node.addGraphInput(predecessor);
      }
      this._visibility_graph_node.addPostDirtyHook(
        "_update_visibility_and_remove_dirty",
        this._updateVisibilityAndRemoveDirtyBound
      );
    }
  }
  updateVisibilityAndRemoveDirty() {
    this.updateVisibility();
    this.param().removeDirtyState();
  }
  async updateVisibility() {
    const options = this._options[VISIBLE_IF_OPTION];
    if (options) {
      const node = this.param().node;
      const params = this.visibilityPredecessors();
      const promises = params.map((p) => {
        if (p.isDirty()) {
          return p.compute();
        }
      });
      this._programaticVisibleState = false;
      await Promise.all(promises);
      if (CoreType.isArray(options)) {
        for (const optionsSet of options) {
          const optionSetParamNames = Object.keys(optionsSet);
          const optionSetParams = [];
          arrayCompact(
            optionSetParamNames.map((paramName) => node.params.get(paramName)),
            optionSetParams
          );
          const satisfiedValues = optionSetParams.filter((param) => param.value == optionsSet[param.name()]);
          if (satisfiedValues.length == optionSetParams.length) {
            this._programaticVisibleState = true;
          }
        }
      } else {
        const satisfiedValues = params.filter((param) => param.value == options[param.name()]);
        this._programaticVisibleState = satisfiedValues.length == params.length;
      }
      this.param().emit(ParamEvent.VISIBLE_UPDATED);
    }
  }
  /*
   *
   *
   *
   */
  // private _callbacksByOptionName: Map<keyof ParamOptions, OptionChangeCallback> | undefined;
  // onOptionChange<K extends keyof ParamOptions>(optionName: K, callback: OptionChangeCallback) {
  // 	this._callbacksByOptionName = this._callbacksByOptionName || new Map();
  // 	this._callbacksByOptionName.set(optionName, callback);
  // }
  // private _runOptionCallback(optionName: keyof ParamOptions) {
  // 	if (!this._callbacksByOptionName) {
  // 		return;
  // 	}
  // 	const callback = this._callbacksByOptionName.get(optionName);
  // 	if (!callback) {
  // 		return;
  // 	}
  // 	callback();
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/utils/EmitController.js
var EmitController = class {
  constructor(param) {
    this.param = param;
    this._blockedEmit = false;
    this._blockedParentEmit = false;
    this._countByEventName = /* @__PURE__ */ new Map();
  }
  emitAllowed() {
    if (this._blockedEmit === true) {
      return false;
    }
    if (this.param.scene().loadingController.isLoading()) {
      return false;
    }
    return this.param.scene().dispatchController.emitAllowed();
  }
  blockEmit() {
    this._blockedEmit = true;
    if (this.param.isMultiple() && this.param.components) {
      for (const component of this.param.components) {
        component.emitController.blockEmit();
      }
    }
    return true;
  }
  unblockEmit() {
    this._blockedEmit = false;
    if (this.param.isMultiple() && this.param.components) {
      for (const component of this.param.components) {
        component.emitController.unblockEmit();
      }
    }
    return true;
  }
  blockParentEmit() {
    this._blockedParentEmit = true;
    return true;
  }
  unblockParentEmit() {
    this._blockedParentEmit = false;
    return true;
  }
  incrementCount(eventName) {
    const count = (this._countByEventName.get(eventName) || 0) + 1;
    this._countByEventName.set(eventName, count);
  }
  eventsCount(eventName) {
    return this._countByEventName.get(eventName) || 0;
  }
  emit(event) {
    if (this.emitAllowed()) {
      this.param.emit(event);
      const parentParam = this.param.parentParam();
      if (parentParam != null && this._blockedParentEmit !== true) {
        parentParam.emit(event);
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/utils/states/TimeDependent.js
var ParamTimeDependentState = class {
  constructor(param) {
    this.param = param;
  }
  active() {
    var _a;
    const frameGraphNodeId = this.param.scene().timeController.graphNode.graphNodeId();
    return ((_a = this.param.graphPredecessorIds()) == null ? void 0 : _a.includes(frameGraphNodeId)) || false;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/utils/states/Error.js
var ParamErrorState = class {
  constructor(param) {
    this.param = param;
  }
  set(message) {
    if (this._message != message) {
      if (message) {
        Poly.error(`[${this.param.path()}] error: '${message}'`);
      } else {
        Poly.warn(`[${this.param.path()}] clear error`);
      }
      this._message = message;
      this.param.emitController.emit(ParamEvent.ERROR_UPDATED);
    }
  }
  message() {
    return this._message;
  }
  clear() {
    this.set(void 0);
  }
  active() {
    return this._message != null;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/utils/StatesController.js
var ParamStatesController = class {
  constructor(param) {
    this.param = param;
    this.timeDependent = new ParamTimeDependentState(this.param);
    this.error = new ParamErrorState(this.param);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/_Base.js
var TYPED_PARAM_DEFAULT_COMPONENT_NAMES = [];
var TypedParam = class _TypedParam extends CoreGraphNode {
  // private _ui_data: UIData | undefined;
  // get ui_data(): UIData {
  // 	return (this._ui_data = this._ui_data || new UIData(this.scene, this));
  // }
  constructor(scene, node, options) {
    super(scene, "BaseParam");
    this._options = new OptionsController(this);
    this._emitController = new EmitController(this);
    this._isComputing = false;
    if (options.serializerClass) {
      this._serializer = new options.serializerClass(this);
    }
    this._node = node;
    this._initializeParam();
  }
  get options() {
    return this._options = this._options || new OptionsController(this);
  }
  get emitController() {
    return this._emitController = this._emitController || new EmitController(this);
  }
  get expressionController() {
    return this._expression_controller;
  }
  expressionParsedAsString() {
    return false;
  }
  get serializer() {
    return this._serializer;
  }
  get states() {
    return this._states = this._states || new ParamStatesController(this);
  }
  dispose() {
    var _a, _b;
    if (this.expressionController && this.hasExpression()) {
      this.set(this.rawInputSerialized());
    }
    const _tmpCoreGraphNodes = [];
    const predecessors = this.graphPredecessors();
    if (predecessors) {
      arrayCopy(predecessors, _tmpCoreGraphNodes);
      for (const predecessor of _tmpCoreGraphNodes) {
        if (predecessor instanceof MethodDependency) {
          predecessor.dispose();
        }
      }
    }
    const successors = this.graphSuccessors();
    if (successors) {
      arrayCopy(successors, _tmpCoreGraphNodes);
      for (const successor of _tmpCoreGraphNodes) {
        if (successor instanceof _TypedParam) {
          const input = successor.rawInputSerialized();
          successor.set(successor.defaultValue());
          successor.set(input);
        } else {
          successor.setDirty();
        }
      }
    }
    this.scene().missingExpressionReferencesController.deregisterParam(this);
    (_a = this._expression_controller) == null ? void 0 : _a.dispose();
    super.dispose();
    (_b = this._options) == null ? void 0 : _b.dispose();
    this._node = void 0;
    this._parent_param = void 0;
    this._runOnDisposeCallbacks();
  }
  _initializeParam() {
  }
  postOptionsInitialize() {
  }
  // 	// this.addPostDirtyHook(this._remove_node_param_cache.bind(this))
  // }
  // initialize() {
  // 	this.initComponents();
  // 	// this.init_expression()
  // 	// this._init_ui_data()
  // }
  // accepts_visitor<T extends ParamVisitor>(visitor: T): ReturnType<T['visit_param']> {
  // 	return visitor.visit_param(this);
  // }
  //
  // init_expression() {}
  // type
  static type() {
    return ParamType.FLOAT;
  }
  type() {
    return this.constructor.type();
  }
  isNumeric() {
    return false;
  }
  // name
  setName(name) {
    super.setName(name);
  }
  get value() {
    return this._value;
  }
  copyValue(param) {
    if (param.type() == this.type()) {
      this._copyValue(param);
    } else {
      console.warn(`cannot copy value from ${param.type()} to ${this.type()}`);
    }
  }
  _copyValue(param) {
    throw "abstract method param._copy_value";
  }
  valuePreConversionSerialized() {
    return void 0;
  }
  convert(rawVal) {
    return null;
  }
  static areRawInputEqual(val1, val2) {
    return false;
  }
  isRawInputEqual(other_raw_input) {
    return this.constructor.areRawInputEqual(this._raw_input, other_raw_input);
  }
  isDefaultValueEqual(other_default_value) {
    return this.constructor.areRawInputEqual(this._default_value, other_default_value);
  }
  static areValuesEqual(val1, val2) {
    return false;
  }
  isValueEqual(other_val) {
    return this.constructor.areValuesEqual(this.value, other_val);
  }
  _cloneRawInput(raw_input) {
    return raw_input;
  }
  set(raw_input) {
    this._raw_input = this._cloneRawInput(this._prefilterInvalidRawInput(raw_input));
    this.emitController.emit(ParamEvent.RAW_INPUT_UPDATED);
    this.processRawInput();
  }
  _prefilterInvalidRawInput(raw_input) {
    return raw_input;
  }
  defaultValue() {
    return this._default_value;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  rawInput() {
    return this._raw_input;
  }
  processRawInput() {
  }
  isComputing() {
    return this._isComputing;
  }
  async compute() {
    if (this.scene().loadingController.isLoading()) {
      Poly.warn(`param attempt to compute ${this.path()} while scene is loading`);
    }
    if (this.isDirty()) {
      if (!this._isComputing) {
        this._isComputing = true;
        await this.processComputation();
        this._isComputing = false;
        if (this._computeResolves) {
          const resolves = [...this._computeResolves];
          this._computeResolves = void 0;
          for (const resolve of resolves) {
            resolve();
          }
        }
      } else {
        return new Promise((resolve, reject) => {
          this._computeResolves = this._computeResolves || [];
          this._computeResolves.push(resolve);
        });
      }
    }
  }
  async processComputation() {
  }
  // set_default_value(default_value: ParamValuesTypeMap[T]) {
  // 	this._default_value = default_value;
  // }
  setInitValue(init_value) {
    this._default_value = this._cloneRawInput(this._prefilterInvalidRawInput(init_value));
  }
  // eval_p(): Promise<ParamValuesTypeMap[T]> {
  // 	return new Promise((resolve, reject) => {
  // 		resolve();
  // 	});
  // }
  // node
  _setupNodeDependencies(node) {
    var _a, _b;
    if (!node) {
      if (this._node) {
        (_a = this._node.params.params_node) == null ? void 0 : _a.removeGraphInput(this);
      }
    } else {
      this.options.allowCallback();
      if (!this.parentParam()) {
        if (this.options.makesNodeDirtyWhenDirty()) {
          (_b = node.params.params_node) == null ? void 0 : _b.addGraphInput(this, false);
        } else {
          this.dirtyController.addPostDirtyHook("run callback", async () => {
            await this.compute();
            await this.options.executeCallback();
          });
        }
      }
    }
    if (this.components) {
      for (const c of this.components) {
        c._setupNodeDependencies(node);
      }
    }
  }
  get node() {
    return this._node;
  }
  parent() {
    return this.node;
  }
  // hierarchy
  set_parent_param(param) {
    param.addGraphInput(this, false);
    this._parent_param = param;
  }
  parentParam() {
    return this._parent_param;
  }
  has_parent_param() {
    return this._parent_param != null;
  }
  path() {
    var _a;
    return ((_a = this.node) == null ? void 0 : _a.path()) + "/" + this.name();
  }
  pathRelativeTo(node) {
    if (!this._node) {
      return this.name();
    }
    const nodeRelativePath = CoreWalker.relativePath(node, this._node);
    if (nodeRelativePath.length > 0) {
      return CoreWalker.sanitizePath(`${nodeRelativePath}${CoreWalker.SEPARATOR}${this.name()}`);
    } else {
      return this.name();
    }
  }
  // emit
  emit(eventName) {
    if (this.emitController.emitAllowed()) {
      this.emitController.incrementCount(eventName);
      this.scene().dispatchController.dispatch(this, eventName);
    }
  }
  // multiple
  get components() {
    return this._components;
  }
  componentNames() {
    return TYPED_PARAM_DEFAULT_COMPONENT_NAMES;
  }
  isMultiple() {
    return this.componentNames().length > 0;
  }
  initComponents() {
  }
  hasExpression() {
    return this.expressionController != null && this.expressionController.active();
  }
  // serialize
  toJSON() {
    if (!this._serializer) {
      return;
    }
    return this._serializer.toJSON();
  }
  onDispose(callback) {
    this._onDisposeCallbacks = this._onDisposeCallbacks || /* @__PURE__ */ new Set();
    this._onDisposeCallbacks.add(callback);
  }
  deregisterOnDispose(callback) {
    if (this._onDisposeCallbacks) {
      this._onDisposeCallbacks.delete(callback);
    }
  }
  _runOnDisposeCallbacks() {
    if (this._onDisposeCallbacks) {
      this._onDisposeCallbacks.forEach((callback) => {
        callback();
      });
      this._onDisposeCallbacks.clear();
      this._onDisposeCallbacks = void 0;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/ramp/RampValue.js
var RampPoint = class _RampPoint {
  constructor(_position3 = 0, _value = 0) {
    this._position = _position3;
    this._value = _value;
  }
  toJSON() {
    return {
      position: this._position,
      value: this._value
    };
  }
  position() {
    return this._position;
  }
  value() {
    return this._value;
  }
  copy(point) {
    this._position = point.position();
    this._value = point.value();
  }
  clone() {
    const point = new _RampPoint();
    point.copy(this);
    return point;
  }
  isEqual(other_point) {
    return this._position == other_point.position() && this._value == other_point.value();
  }
  isEqualJSON(json) {
    return this._position == json.position && this._value == json.value;
  }
  fromJSON(json) {
    this._position = json.position;
    this._value = json.value;
  }
  static areEqualJSON(json1, json2) {
    return json1.position == json2.position && json1.value == json2.value;
  }
  static fromJSON(json) {
    return new _RampPoint(json.position, json.value);
  }
};
var RampInterpolation = ((RampInterpolation2) => {
  RampInterpolation2["CUBIC"] = "cubic";
  return RampInterpolation2;
})(RampInterpolation || {});
var RampValue = class _RampValue {
  constructor(_interpolation = "cubic", _points3 = []) {
    this._interpolation = _interpolation;
    this._points = _points3;
    this._uuid = MathUtils.generateUUID();
  }
  uuid() {
    return this._uuid;
  }
  interpolation() {
    return this._interpolation;
  }
  points() {
    return this._points;
  }
  static createInterpolantFromValues(positions, values) {
    const valuesCount = 1;
    const interpolatedValues = new Float32Array(valuesCount);
    return new CubicInterpolant(positions, values, valuesCount, interpolatedValues);
  }
  createInterpolant() {
    return _RampValue.createInterpolant(this);
  }
  static createInterpolant(rampValue) {
    const points = rampValue.points();
    const sortedPoints = arraySortBy(points, (point) => point.position());
    const positions = new Float32Array(sortedPoints.length);
    const values = new Float32Array(sortedPoints.length);
    let i = 0;
    for (const sortedPoint of sortedPoints) {
      positions[i] = sortedPoint.position();
      values[i] = sortedPoint.value();
      i++;
    }
    return this.createInterpolantFromValues(positions, values);
  }
  static fromJSON(json) {
    const points = [];
    for (const jsonPoint of json.points) {
      points.push(RampPoint.fromJSON(jsonPoint));
    }
    let interpolation = json.interpolation;
    if (interpolation == null || interpolation == "") {
      interpolation = "cubic";
    }
    return new _RampValue(interpolation, points);
  }
  toJSON() {
    return {
      interpolation: this._interpolation,
      points: this._points.map((p) => p.toJSON())
    };
  }
  clone() {
    const ramp = new _RampValue();
    ramp.copy(this);
    return ramp;
  }
  copy(ramp) {
    this._interpolation = ramp.interpolation();
    const newPointsCount = ramp.points().length;
    const currentPointsCount = this._points.length;
    if (currentPointsCount > newPointsCount) {
      const pointsCountToRemove = currentPointsCount - newPointsCount;
      const spliceStart = currentPointsCount - pointsCountToRemove;
      this._points.splice(spliceStart, pointsCountToRemove);
    }
    let index = 0;
    for (const point of ramp.points()) {
      const currentPoint = this._points[index];
      if (currentPoint) {
        currentPoint.copy(point);
      } else {
        this._points.push(point.clone());
      }
      index += 1;
    }
  }
  isEqual(other_ramp_value) {
    if (this._interpolation != other_ramp_value.interpolation()) {
      return false;
    }
    const other_points = other_ramp_value.points();
    if (this._points.length != other_points.length) {
      return false;
    }
    let index = 0;
    for (const point of this._points) {
      const other_point = other_points[index];
      if (!point.isEqual(other_point)) {
        return false;
      }
      index += 1;
    }
    return true;
  }
  isEqualJSON(json) {
    if (this._interpolation != json.interpolation) {
      return false;
    }
    if (this._points.length != json.points.length) {
      return false;
    }
    let index = 0;
    for (const point of this._points) {
      const other_point = json.points[index];
      if (!point.isEqualJSON(other_point)) {
        return false;
      }
      index += 1;
    }
    return true;
  }
  static are_json_equal(json1, json2) {
    if (json1.interpolation != json2.interpolation) {
      return false;
    }
    if (json1.points.length != json2.points.length) {
      return false;
    }
    let index = 0;
    for (const point1 of json1.points) {
      const point2 = json2.points[index];
      if (!RampPoint.areEqualJSON(point1, point2)) {
        return false;
      }
      index += 1;
    }
    return true;
  }
  fromJSON(json) {
    this._interpolation = json.interpolation;
    const newPointsCount = json.points.length;
    const currentPointsCount = this._points.length;
    if (currentPointsCount > newPointsCount) {
      const pointsCountToRemove = currentPointsCount - newPointsCount;
      const spliceStart = currentPointsCount - pointsCountToRemove;
      this._points.splice(spliceStart, pointsCountToRemove);
    }
    let index = 0;
    for (const json_point of json.points) {
      const currentPoint = this._points[index];
      if (currentPoint) {
        currentPoint.fromJSON(json_point);
      } else {
        this._points.push(RampPoint.fromJSON(json_point));
      }
      index += 1;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Ramp.js
var STRIDE = 4;
var TEXTURE_WIDTH = 1024;
var TEXTURE_HEIGHT = 1;
var TEXTURE_SIZE = TEXTURE_WIDTH * TEXTURE_HEIGHT;
var TEXTURE_BYTES_MULT = 1;
var _RampParam = class extends TypedParam {
  constructor() {
    super(...arguments);
    this._textureData = new Float32Array(STRIDE * TEXTURE_SIZE);
    this._rampTexture = new DataTexture(this._textureData, TEXTURE_WIDTH, TEXTURE_HEIGHT, RGBAFormat, FloatType);
  }
  static type() {
    return ParamType.RAMP;
  }
  defaultValueSerialized() {
    if (this._default_value instanceof RampValue) {
      return this._default_value.toJSON();
    } else {
      return this._default_value;
    }
  }
  _cloneRawInput(raw_input) {
    if (raw_input instanceof RampValue) {
      return raw_input.clone();
    } else {
      return RampValue.fromJSON(raw_input).toJSON();
    }
  }
  rawInputSerialized() {
    if (this._raw_input instanceof RampValue) {
      return this._raw_input.toJSON();
    } else {
      return RampValue.fromJSON(this._raw_input).toJSON();
    }
  }
  valueSerialized() {
    return this.value.toJSON();
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    if (raw_input1 instanceof RampValue) {
      if (raw_input2 instanceof RampValue) {
        return raw_input1.isEqual(raw_input2);
      } else {
        return raw_input1.isEqualJSON(raw_input2);
      }
    } else {
      if (raw_input2 instanceof RampValue) {
        return raw_input2.isEqualJSON(raw_input1);
      } else {
        return RampValue.are_json_equal(raw_input1, raw_input2);
      }
    }
  }
  static areValuesEqual(val1, val2) {
    return val1.isEqual(val2);
  }
  // initialize_param() {
  // 	this.addPostDirtyHook(
  // 		'_reset_ramp_interpolant_and_texture',
  // 		this.reset_ramp_interpolant.bind(this)
  // 	);
  // }
  // accepts_visitor(visitor: RampParamVisitor) {
  // 	return visitor.visit_ramp_param(this);
  // }
  isDefault() {
    if (this._default_value instanceof RampValue) {
      return this.value.isEqual(this._default_value);
    } else {
      return this.value.isEqualJSON(this._default_value);
    }
  }
  processRawInput() {
    if (this._raw_input instanceof RampValue) {
      if (!this._value) {
        this._value = this._raw_input;
      } else {
        this._value.copy(this._raw_input);
      }
    } else {
      if (!this._value) {
        this._value = RampValue.fromJSON(this._raw_input);
      } else {
        this._value.fromJSON(this._raw_input);
      }
    }
    this._resetRampInterpolant();
    this._updateRampTexture();
    this.options.executeCallback();
    this.emitController.emit(ParamEvent.VALUE_UPDATED);
    this.setSuccessorsDirty(this);
  }
  // convert_value(v) {
  // 	let is_json = false
  // 	if (CoreType.isString(v)) {
  // 		v = JSON.parse(v)
  // 		is_json = true
  // 	}
  // 	if (!is_json) {
  // 		if (v.interpolation && v.points) {
  // 			if (CoreType.isArray(v.points)) {
  // 				is_json = true
  // 			}
  // 		}
  // 	}
  // 	if (is_json) {
  // 		v = RampValue.from_json(v)
  // 	}
  // 	return v
  // }
  // convert_default_value(v) {
  // 	return this.convert_value(v)
  // }
  hasExpression() {
    return false;
  }
  _resetRampInterpolant() {
    this._rampInterpolant = void 0;
  }
  rampTexture() {
    return this._rampTexture;
  }
  _updateRampTexture() {
    this._updateRampTextureData();
    this.rampTexture().needsUpdate = true;
  }
  _updateRampTextureData() {
    let stride = 0;
    let position = 0;
    let value = 0;
    for (var i = 0; i < TEXTURE_SIZE; i++) {
      stride = i * STRIDE;
      position = i / TEXTURE_WIDTH;
      value = this.valueAtPosition(position);
      this._textureData[stride + 0] = value * TEXTURE_BYTES_MULT;
      this._textureData[stride + 1] = 0;
      this._textureData[stride + 2] = 0;
    }
  }
  interpolant() {
    return this._rampInterpolant = this._rampInterpolant || this._createInterpolant();
  }
  _createInterpolant() {
    return this.value.createInterpolant();
  }
  valueAtPosition(position) {
    return this.interpolant().evaluate(position)[0];
  }
};
var RampParam = _RampParam;
RampParam.DEFAULT_VALUE = new RampValue(RampInterpolation.CUBIC, [new RampPoint(0, 0), new RampPoint(1, 1)]);
RampParam.DEFAULT_VALUE_JSON = _RampParam.DEFAULT_VALUE.toJSON();

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/params/ParamsConfig.js
var ParamTemplate = class {
  constructor(type, init_value, options) {
    this.type = type;
    this.init_value = init_value;
    this.options = options;
  }
};
var ParamConfig = class {
  static BUTTON(init_value, options) {
    return new ParamTemplate(ParamType.BUTTON, init_value, options);
  }
  static BOOLEAN(init_value, options) {
    return new ParamTemplate(ParamType.BOOLEAN, init_value, options);
  }
  static COLOR(init_value, options) {
    if (init_value instanceof Color) {
      init_value = init_value.toArray();
    }
    return new ParamTemplate(ParamType.COLOR, init_value, options);
  }
  static FLOAT(init_value, options) {
    return new ParamTemplate(ParamType.FLOAT, init_value, options);
  }
  static FOLDER(init_value = null, options) {
    return new ParamTemplate(ParamType.FOLDER, init_value, options);
  }
  static INTEGER(init_value, options) {
    return new ParamTemplate(ParamType.INTEGER, init_value, options);
  }
  static RAMP(init_value = RampParam.DEFAULT_VALUE, options) {
    return new ParamTemplate(ParamType.RAMP, init_value, options);
  }
  static STRING(init_value = "", options) {
    return new ParamTemplate(ParamType.STRING, init_value, options);
  }
  static VECTOR2(init_value, options) {
    if (init_value instanceof Vector2) {
      init_value = init_value.toArray();
    }
    return new ParamTemplate(ParamType.VECTOR2, init_value, options);
  }
  static VECTOR3(init_value, options) {
    if (init_value instanceof Vector3) {
      init_value = init_value.toArray();
    }
    return new ParamTemplate(ParamType.VECTOR3, init_value, options);
  }
  static VECTOR4(init_value, options) {
    if (init_value instanceof Vector4) {
      init_value = init_value.toArray();
    }
    return new ParamTemplate(ParamType.VECTOR4, init_value, options);
  }
  //
  //
  // PATH PARAMS
  //
  //
  // static OPERATOR_PATH(
  // 	init_value: ParamInitValuesTypeMap[ParamType.OPERATOR_PATH],
  // 	options?: ParamOptionsByTypeMap[ParamType.OPERATOR_PATH]
  // ) {
  // 	return new ParamTemplate<ParamType.OPERATOR_PATH>(ParamType.OPERATOR_PATH, init_value, options);
  // }
  static NODE_PATH(init_value, options) {
    return new ParamTemplate(ParamType.NODE_PATH, init_value, options);
  }
  static PARAM_PATH(init_value, options) {
    return new ParamTemplate(ParamType.PARAM_PATH, init_value, options);
  }
};
var NodeParamsConfig = class {
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/NodeEvent.js
var NodeEvent = ((NodeEvent2) => {
  NodeEvent2["CREATED"] = "node_created";
  NodeEvent2["DELETED"] = "node_deleted";
  NodeEvent2["NAME_UPDATED"] = "node_name_update";
  NodeEvent2["OVERRIDE_CLONABLE_STATE_UPDATE"] = "node_override_clonable_state_update";
  NodeEvent2["NAMED_OUTPUTS_UPDATED"] = "node_named_outputs_updated";
  NodeEvent2["NAMED_INPUTS_UPDATED"] = "node_named_inputs_updated";
  NodeEvent2["INPUTS_UPDATED"] = "node_inputs_updated";
  NodeEvent2["PARAMS_UPDATED"] = "node_params_updated";
  NodeEvent2["UI_DATA_POSITION_UPDATED"] = "node_ui_data_position_updated";
  NodeEvent2["UI_DATA_COMMENT_UPDATED"] = "node_ui_data_comment_updated";
  NodeEvent2["ERROR_UPDATED"] = "node_error_updated";
  NodeEvent2["FLAG_BYPASS_UPDATED"] = "bypass_flag_updated";
  NodeEvent2["FLAG_DISPLAY_UPDATED"] = "display_flag_updated";
  NodeEvent2["FLAG_OPTIMIZE_UPDATED"] = "optimize_flag_updated";
  NodeEvent2["SELECTION_UPDATED"] = "selection_updated";
  NodeEvent2["POLY_NODE_LOCK_STATE_UPDATED"] = "lock_state_updated";
  return NodeEvent2;
})(NodeEvent || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Constant.js
var ObjectType = ((ObjectType2) => {
  ObjectType2["AMBIENT_LIGHT"] = "AmbientLight";
  ObjectType2["AREA_LIGHT"] = "AreaLight";
  ObjectType2["CUBE_CAMERA"] = "CubeCamera";
  ObjectType2["DIRECTIONAL_LIGHT"] = "DirectionalLight";
  ObjectType2["GROUP"] = "Group";
  ObjectType2["HEMISPHERE_LIGHT"] = "HemisphereLight";
  ObjectType2["INSTANCED_MESH"] = "InstancedMesh";
  ObjectType2["LIGHT_PROBE"] = "LightProbe";
  ObjectType2["LINE_SEGMENTS"] = "LineSegments";
  ObjectType2["LOD"] = "LOD";
  ObjectType2["MESH"] = "Mesh";
  ObjectType2["OBJECT3D"] = "Object3D";
  ObjectType2["ORTHOGRAPHIC_CAMERA"] = "OrthographicCamera";
  ObjectType2["PERSPECTIVE_CAMERA"] = "PerspectiveCamera";
  ObjectType2["PHYSICAL_CAMERA"] = "PhysicalCamera";
  ObjectType2["PHYSICAL_SPOT_LIGHT"] = "PhysicalSpotLight";
  ObjectType2["POINT_LIGHT"] = "PointLight";
  ObjectType2["POINTS"] = "Points";
  ObjectType2["SCENE"] = "Scene";
  ObjectType2["SHAPED_AREA_LIGHT"] = "ShapedAreaLight";
  ObjectType2["SPOT_LIGHT"] = "SpotLight";
  ObjectType2["UNKNOWN"] = "Unknown";
  ObjectType2["QUAD"] = "Quad";
  return ObjectType2;
})(ObjectType || {});
var UNKNOWN_OBJECT_TYPE = {
  type: "Unknown",
  checkFunc: (o) => "Unknown",
  humanName: "Unknown",
  ctor: null
};
function _initializeObjectTypeFromConstructor() {
  const objectTypeCheckFunctions2 = [];
  const dataByObjectType2 = /* @__PURE__ */ new Map();
  const maps = { objectTypeCheckFunctions: objectTypeCheckFunctions2, dataByObjectType: dataByObjectType2 };
  function _register(type, checkFunc, ctor, humanName) {
    _registerObjectType_(maps, {
      type,
      checkFunc,
      ctor,
      humanName: humanName || type
    });
  }
  _register(
    "Object3D",
    (o) => o.isObject3D ? "Object3D" : void 0,
    Object3D,
    "Object3D"
  );
  _register("Mesh", (o) => o.isMesh ? "Mesh" : void 0, Mesh, "Mesh");
  _register("Group", (o) => o.isGroup ? "Group" : void 0, Group, "Group");
  _register(
    "LineSegments",
    (o) => o.isLineSegments ? "LineSegments" : void 0,
    LineSegments,
    "LineSegments"
  );
  _register(
    "InstancedMesh",
    (o) => o.isInstancedMesh ? "InstancedMesh" : void 0,
    InstancedMesh,
    "InstancedMesh"
  );
  _register("Points", (o) => o.isPoints ? "Points" : void 0, Points, "Points");
  _register("Scene", (o) => o.isScene ? "Scene" : void 0, Scene, "Scene");
  return maps;
}
var { objectTypeCheckFunctions, dataByObjectType } = _initializeObjectTypeFromConstructor();
function _registerObjectType_(maps, data) {
  maps.objectTypeCheckFunctions.unshift(data.checkFunc);
  maps.dataByObjectType.set(data.type, data);
}
function registerObjectType(data) {
  _registerObjectType_({ objectTypeCheckFunctions, dataByObjectType }, data);
}
function objectTypeFromObject(object) {
  return dataFromObject(object).type;
}
function dataFromObject(object) {
  for (const checkFunc of objectTypeCheckFunctions) {
    const objectType = checkFunc(object);
    if (objectType) {
      return dataByObjectType.get(objectType);
    }
  }
  return UNKNOWN_OBJECT_TYPE;
}
function objectConstructorByObjectType(objectType) {
  const data = dataByObjectType.get(objectType);
  if (data) {
    return data.ctor;
  } else {
    console.warn(`no constructor found for type '${objectType}'`);
    return dataByObjectType.get(
      "Mesh"
      /* MESH */
    );
  }
}
var DEFAULT_MATERIALS = {
  MeshStandard: new MeshStandardMaterial({
    color: 16777215,
    side: FrontSide,
    metalness: 0.5,
    roughness: 0.9
  }),
  // [ObjectType.MESH]: new MeshLambertMaterial({
  // 	color: new Color(1, 1, 1),
  // 	side: FrontSide,
  // 	vertexColors: false,
  // 	transparent: true,
  // 	depthTest: true,
  // }),
  [
    "Mesh"
    /* MESH */
  ]: new MeshStandardMaterial({
    color: 16777215,
    side: FrontSide,
    metalness: 0,
    roughness: 0.9
  }),
  [
    "Points"
    /* POINTS */
  ]: new PointsMaterial({
    color: 16777215,
    size: 0.1,
    //blending: AdditiveBlending
    depthTest: true
  }),
  [
    "LineSegments"
    /* LINE_SEGMENTS */
  ]: new LineBasicMaterial({
    color: 16777215,
    linewidth: 1
  })
};
var AttribClass = ((AttribClass2) => {
  AttribClass2["POINT"] = "point";
  AttribClass2["VERTEX"] = "vertex";
  AttribClass2["PRIMITIVE"] = "primitive";
  AttribClass2["OBJECT"] = "object";
  AttribClass2["CORE_GROUP"] = "coreGroup";
  return AttribClass2;
})(AttribClass || {});
var ATTRIBUTE_CLASSES = [
  "point",
  "vertex",
  "primitive",
  "object",
  "coreGroup"
  /* CORE_GROUP */
];
var ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP = [
  "point",
  "vertex",
  "primitive",
  "object"
  /* OBJECT */
];
var AttribClassMenuEntries = ATTRIBUTE_CLASSES.map((name, value) => ({ name, value }));
var AttribClassMenuEntriesWithoutCoreGroup = ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.map((name, value) => ({
  name,
  value
}));
var AttribType = ((AttribType2) => {
  AttribType2["NUMERIC"] = "numeric";
  AttribType2["STRING"] = "string";
  return AttribType2;
})(AttribType || {});
var ATTRIBUTE_TYPES = [
  "numeric",
  "string"
  /* STRING */
];
var AttribTypeMenuEntries = ATTRIBUTE_TYPES.map((name, value) => ({ name, value }));
var AttribSize = ((AttribSize2) => {
  AttribSize2[AttribSize2["FLOAT"] = 1] = "FLOAT";
  AttribSize2[AttribSize2["VECTOR2"] = 2] = "VECTOR2";
  AttribSize2[AttribSize2["VECTOR3"] = 3] = "VECTOR3";
  AttribSize2[AttribSize2["VECTOR4"] = 4] = "VECTOR4";
  return AttribSize2;
})(AttribSize || {});
var ComponentName = ((ComponentName2) => {
  ComponentName2["x"] = "x";
  ComponentName2["y"] = "y";
  ComponentName2["z"] = "z";
  ComponentName2["w"] = "w";
  ComponentName2["r"] = "r";
  ComponentName2["g"] = "g";
  ComponentName2["b"] = "b";
  return ComponentName2;
})(ComponentName || {});
var COMPONENT_INDICES = {
  x: 0,
  y: 1,
  z: 2,
  w: 3,
  r: 0,
  g: 1,
  b: 2
};
var DOT = ".";

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Attribute.js
var Attribute = ((Attribute2) => {
  Attribute2["POINT_INDEX"] = "ptnum";
  Attribute2["VERTEX_INDEX"] = "vtxnum";
  Attribute2["PRIMITIVE_INDEX"] = "primnum";
  Attribute2["OBJECT_INDEX"] = "objnum";
  Attribute2["OBJECT_NAME"] = "objname";
  Attribute2["COLOR"] = "color";
  Attribute2["NORMAL"] = "normal";
  Attribute2["POSITION"] = "position";
  Attribute2["PSCALE"] = "pscale";
  Attribute2["UP"] = "up";
  Attribute2["UV"] = "uv";
  Attribute2["SCALE"] = "scale";
  Attribute2["TANGENT"] = "tangent";
  Attribute2["ID"] = "id";
  return Attribute2;
})(Attribute || {});
var ObjectAttribute = ((ObjectAttribute2) => {
  ObjectAttribute2["HOVERED"] = "hovered";
  return ObjectAttribute2;
})(ObjectAttribute || {});
var ATTRIB_NAME_MAP = {
  P: "position",
  N: "normal",
  Cd: "color"
  /* COLOR */
};
var _matchingAttribNames = [];
var _masks = [];
var CoreAttribute = class _CoreAttribute {
  static remapName(name) {
    return ATTRIB_NAME_MAP[name] || name;
  }
  static arrayToIndexedArrays(array) {
    const index_by_value = {};
    let current_index = 0;
    const indices = [];
    const values = [];
    let i = 0;
    while (i < array.length) {
      const value = array[i];
      const index = index_by_value[value];
      if (index != null) {
        indices.push(index);
      } else {
        values.push(value);
        indices.push(current_index);
        index_by_value[value] = current_index;
        current_index += 1;
      }
      i++;
    }
    return {
      indices,
      values
    };
  }
  static defaultValue(size) {
    switch (size) {
      case 1:
        return 0;
      case 2:
        return new Vector2(0, 0);
      case 3:
        return new Vector3(0, 0, 0);
      default:
        throw `size ${size} not yet implemented`;
    }
  }
  static copy(src, dest, markAsNeedsUpdate = true) {
    const srcArray = src == null ? void 0 : src.array;
    const destArray = dest == null ? void 0 : dest.array;
    if (srcArray && destArray) {
      const min_length = Math.min(srcArray.length, destArray.length);
      for (let i = 0; i < min_length; i++) {
        destArray[i] = srcArray[i];
      }
      if (markAsNeedsUpdate) {
        dest.needsUpdate = true;
      }
    }
  }
  static attribSizeFromValue(val) {
    if (CoreType.isString(val) || CoreType.isNumber(val)) {
      return AttribSize.FLOAT;
    }
    if (CoreType.isArray(val)) {
      return val.length;
    }
    switch (val.constructor) {
      case Color:
        return AttribSize.VECTOR3;
      case Vector2:
        return AttribSize.VECTOR2;
      case Vector3:
        return AttribSize.VECTOR3;
      case Vector4:
        return AttribSize.VECTOR4;
    }
    return null;
  }
  static attribNamesMatchingMask(masksString, existingAttribNames) {
    stringToAttribNames(masksString, _masks);
    _matchingAttribNames.length = 0;
    for (const mask of _masks) {
      for (const attribName of existingAttribNames) {
        if (stringMatchMask(attribName, mask)) {
          _matchingAttribNames.push(attribName);
        } else {
          const remapped = _CoreAttribute.remapName(mask);
          if (attribName == remapped) {
            _matchingAttribNames.push(attribName);
          }
        }
      }
    }
    const uniqAttributeNames = [];
    return arrayUniq(_matchingAttribNames, uniqAttributeNames);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Instancer.js
var DEFAULT = {
  SCALE: new Vector3(1, 1, 1),
  PSCALE: 1,
  EYE: new Vector3(0, 0, 0),
  UP: new Vector3(0, 1, 0)
};
var DEFAULT_COLOR = new Vector3(1, 1, 1);
var DEFAULT_UV = new Vector2(0, 0);
var _position = new Vector3();
var _instancePts = [];
var InstanceAttrib = ((InstanceAttrib2) => {
  InstanceAttrib2["POSITION"] = "instancePosition";
  InstanceAttrib2["SCALE"] = "instanceScale";
  InstanceAttrib2["QUATERNION"] = "instanceQuaternion";
  InstanceAttrib2["COLOR"] = "instanceColor";
  InstanceAttrib2["UV"] = "instanceUv";
  return InstanceAttrib2;
})(InstanceAttrib || {});
var ATTRIB_NAME_MAP2 = {
  P: "instancePosition",
  N: "instanceQuaternion",
  up: "instanceQuaternion",
  Cd: "instanceColor",
  [Attribute.COLOR]: "instanceColor",
  [Attribute.NORMAL]: "instanceQuaternion",
  [Attribute.POSITION]: "instancePosition",
  [Attribute.PSCALE]: "instanceScale",
  [Attribute.SCALE]: "instanceScale"
  /* SCALE */
};
var _CoreInstancer = class {
  constructor(_coreGroup) {
    this._coreGroup = _coreGroup;
    this._is_pscale_present = false;
    this._is_scale_present = false;
    this._is_normal_present = false;
    this._is_up_present = false;
    this._do_rotate_matrices = false;
    this._matrixT = new Matrix4();
    this._matrixR = new Matrix4();
    this._matrixS = new Matrix4();
    this._pointScale = new Vector3();
    this._pointNormal = new Vector3();
    this._pointUp = new Vector3();
    if (_coreGroup) {
      this.setCoreGroup(_coreGroup);
    }
  }
  static remapName(name) {
    return ATTRIB_NAME_MAP2[name] || name;
  }
  setCoreGroup(coreGroup) {
    this._coreGroup = coreGroup;
    this._is_pscale_present = this._coreGroup.hasPointAttrib(Attribute.PSCALE);
    this._is_scale_present = this._coreGroup.hasPointAttrib(Attribute.SCALE);
    this._is_normal_present = this._coreGroup.hasPointAttrib(Attribute.NORMAL);
    this._is_up_present = this._coreGroup.hasPointAttrib(Attribute.UP);
    this._do_rotate_matrices = this._is_normal_present;
  }
  // private _point_m = new Matrix4()
  matrixFromPoint(point, targetMatrix) {
    targetMatrix.identity();
    point.position(_position);
    if (this._is_scale_present) {
      point.attribValue(Attribute.SCALE, this._pointScale);
    } else {
      this._pointScale.copy(DEFAULT.SCALE);
    }
    const pscale = this._is_pscale_present ? point.attribValue(Attribute.PSCALE) : DEFAULT.PSCALE;
    this._pointScale.multiplyScalar(pscale);
    const scale_matrix = this._matrixS;
    scale_matrix.makeScale(this._pointScale.x, this._pointScale.y, this._pointScale.z);
    const translate_matrix = this._matrixT;
    translate_matrix.makeTranslation(_position.x, _position.y, _position.z);
    targetMatrix.multiply(translate_matrix);
    if (this._do_rotate_matrices) {
      const rotate_matrix = this._matrixR;
      const eye = DEFAULT.EYE;
      point.attribValue(Attribute.NORMAL, this._pointNormal);
      this._pointNormal.multiplyScalar(-1);
      if (this._is_up_present) {
        point.attribValue(Attribute.UP, this._pointUp);
      } else {
        this._pointUp.copy(DEFAULT.UP);
      }
      this._pointUp.normalize();
      rotate_matrix.lookAt(eye, this._pointNormal, this._pointUp);
      targetMatrix.multiply(rotate_matrix);
    }
    targetMatrix.multiply(scale_matrix);
  }
  static updateTransformInstanceAttributes(instancePts, templateCoreGroup, geometry) {
    const instancesCount = instancePts.length;
    const positions = new Float32Array(instancesCount * 3);
    const scales = new Float32Array(instancesCount * 3);
    const quaternions = new Float32Array(instancesCount * 4);
    const instancer = new _CoreInstancer(templateCoreGroup);
    let i = 0;
    for (const instancePt of instancePts) {
      instancer.matrixFromPoint(instancePt, this._tmpMatrix);
      const index3 = i * 3;
      const index4 = i * 4;
      this._tmpMatrix.decompose(this._position, this._quaternion, this._scale);
      this._position.toArray(positions, index3);
      this._quaternion.toArray(quaternions, index4);
      this._scale.toArray(scales, index3);
      i++;
    }
    const instancePosition = new InstancedBufferAttribute(positions, 3);
    const instanceQuaternion = new InstancedBufferAttribute(quaternions, 4);
    const instanceScale = new InstancedBufferAttribute(scales, 3);
    geometry.setAttribute("instancePosition", instancePosition);
    geometry.setAttribute("instanceQuaternion", instanceQuaternion);
    geometry.setAttribute("instanceScale", instanceScale);
  }
  static updateColorInstanceAttribute(instancePts, templateCoreGroup, geometry) {
    const instancesCount = instancePts.length;
    const colors = new Float32Array(instancesCount * 3);
    const hasColor = templateCoreGroup.hasPointAttrib(Attribute.COLOR);
    let i = 0;
    for (const instancePt of instancePts) {
      const color = hasColor ? instancePt.attribValue(Attribute.COLOR, this._point_color) : DEFAULT_COLOR;
      color.toArray(colors, i * 3);
      i++;
    }
    geometry.setAttribute("instanceColor", new InstancedBufferAttribute(colors, 3));
  }
  static createInstanceBufferGeometry(geometryToInstance, templateCoreGroup, attributesToCopy) {
    templateCoreGroup.points(_instancePts);
    const geometry = new InstancedBufferGeometry();
    geometry.copy(geometryToInstance);
    geometry.instanceCount = Infinity;
    const instancesCount = _instancePts.length;
    const hasUV = templateCoreGroup.hasPointAttrib(Attribute.UV);
    if (hasUV) {
      const uvs = new Float32Array(instancesCount * 2);
      let i = 0;
      for (const instancePt of _instancePts) {
        const index2 = i * 2;
        const uv = hasUV ? instancePt.attribValue(Attribute.UV, this._point_uv) : DEFAULT_UV;
        uv.toArray(uvs, index2);
        i++;
      }
      geometry.setAttribute("instanceUv", new InstancedBufferAttribute(uvs, 2));
    }
    this.updateTransformInstanceAttributes(_instancePts, templateCoreGroup, geometry);
    this.updateColorInstanceAttribute(_instancePts, templateCoreGroup, geometry);
    const attribNames = templateCoreGroup.pointAttribNamesMatchingMask(attributesToCopy);
    for (const attribName of attribNames) {
      const attribSize = templateCoreGroup.pointAttribSize(attribName);
      const values = new Float32Array(instancesCount * attribSize);
      let i = 0;
      for (const pt of _instancePts) {
        const value = pt.attribValue(attribName);
        if (CoreType.isNumber(value)) {
          values[i] = value;
        } else {
          value.toArray(values, i * attribSize);
        }
        i++;
      }
      geometry.setAttribute(attribName, new InstancedBufferAttribute(values, attribSize));
    }
    return geometry;
  }
};
var CoreInstancer = _CoreInstancer;
CoreInstancer.transformAttributeNames = [
  "instancePosition",
  "instanceQuaternion",
  "instanceScale"
  /* SCALE */
];
CoreInstancer._point_color = new Vector3();
CoreInstancer._point_uv = new Vector2();
CoreInstancer._position = new Vector3(0, 0, 0);
CoreInstancer._quaternion = new Quaternion();
CoreInstancer._scale = new Vector3(1, 1, 1);
CoreInstancer._tmpMatrix = new Matrix4();

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/Assert.js
var TypeAssert = class {
  static unreachable(_) {
    throw new Error("Didn't expect to get here");
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/CoreEntity.js
var _relatedPointIds = [];
var _relatedVertexIds = [];
var _relatedPrimitiveIds = [];
var CoreEntity = class {
  constructor(content, index) {
    this._index = 0;
    if (index != null) {
      this._index = index;
    }
  }
  index() {
    return this._index;
  }
  setIndex(index) {
    this._index = index;
    return this;
  }
};
var CoreEntityWithObject = class extends CoreEntity {
  constructor(object, index) {
    super(object, index);
    this._object = object;
  }
  object() {
    return this._object;
  }
  static relatedPrimitiveIds(object, index, target4, traversedRelatedEntityData) {
    target4.length = 0;
  }
  static relatedVertexIds(object, index, target4, traversedRelatedEntityData) {
    target4.length = 0;
  }
  static relatedPointIds(object, index, target4, traversedRelatedEntityData) {
    target4.length = 0;
  }
  relatedPrimitiveIds(target4, traversedRelatedEntityData) {
    this.constructor.relatedPrimitiveIds(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
  relatedVertexIds(target4, traversedRelatedEntityData) {
    this.constructor.relatedVertexIds(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
  relatedPointIds(target4, traversedRelatedEntityData) {
    this.constructor.relatedPointIds(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
  static relatedPointClass(object) {
    return this.constructor;
  }
  static relatedVertexClass(object) {
    return this.constructor;
  }
  static relatedPrimitiveClass(object) {
    return this.constructor;
  }
  static relatedObjectClass(object) {
    return this.constructor;
  }
  static relatedEntityClass(object, entityClass) {
    switch (entityClass) {
      case AttribClass.POINT: {
        return this.relatedPointClass(object);
      }
      case AttribClass.VERTEX: {
        return this.relatedVertexClass(object);
      }
      case AttribClass.PRIMITIVE: {
        return this.relatedPrimitiveClass(object);
      }
      case AttribClass.OBJECT: {
        return this.relatedObjectClass(object);
      }
    }
    TypeAssert.unreachable(entityClass);
  }
  //
  static relatedPoints(object, entityIndex, target4, traversedRelatedEntityData) {
    this.relatedPointIds(object, entityIndex, _relatedPointIds, traversedRelatedEntityData);
    target4.length = _relatedPointIds.length;
    let i = 0;
    const entityClass = this.relatedPointClass(object);
    for (const id of _relatedPointIds) {
      target4[i] = new entityClass(object, id);
      i++;
    }
  }
  static relatedVertices(object, entityIndex, target4, traversedRelatedEntityData) {
    this.relatedVertexIds(object, entityIndex, _relatedVertexIds, traversedRelatedEntityData);
    target4.length = _relatedVertexIds.length;
    let i = 0;
    const entityClass = this.relatedVertexClass(object);
    for (const id of _relatedVertexIds) {
      target4[i] = new entityClass(object, id);
      i++;
    }
  }
  static relatedPrimitives(object, entityIndex, target4, traversedRelatedEntityData) {
    this.relatedPrimitiveIds(object, entityIndex, _relatedPrimitiveIds, traversedRelatedEntityData);
    target4.length = _relatedPrimitiveIds.length;
    let i = 0;
    const entityClass = this.relatedPrimitiveClass(object);
    for (const id of _relatedPrimitiveIds) {
      target4[i] = new entityClass(object, id);
      i++;
    }
  }
  static relatedObjects(object, entityIndex, target4, traversedRelatedEntityData) {
    target4.length = 1;
    const entityClass = this.relatedObjectClass(object);
    target4[0] = new entityClass(object);
  }
  relatedPoints(target4, traversedRelatedEntityData) {
    this.constructor.relatedPoints(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
  relatedVertices(target4, traversedRelatedEntityData) {
    this.constructor.relatedVertices(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
  relatedPrimitives(target4, traversedRelatedEntityData) {
    this.constructor.relatedPrimitives(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
  relatedObjects(target4, traversedRelatedEntityData) {
    this.constructor.relatedObjects(
      this._object,
      this._index,
      target4,
      traversedRelatedEntityData
    );
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/utils/group/GroupCommon.js
function selectedIndicesFromSelectionStates(selectionStates, selectedIndices, invert) {
  selectionStates.forEach((state, entity) => {
    const selected = !invert && state || invert && !state;
    if (selected) {
      selectedIndices.add(entity.index());
    }
  });
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/EntityGroupCollection.js
var _currentIndicesSet = /* @__PURE__ */ new Set();
var _newIndicesSet = /* @__PURE__ */ new Set();
var GroupOperation = ((GroupOperation2) => {
  GroupOperation2["SET"] = "replace existing";
  GroupOperation2["UNION"] = "add to existing";
  GroupOperation2["SUBTRACT"] = "subtract from existing";
  GroupOperation2["INTERSECT"] = "intersect with existing";
  return GroupOperation2;
})(GroupOperation || {});
var EntityGroupType = ((EntityGroupType2) => {
  EntityGroupType2["POINT"] = "point";
  EntityGroupType2["OBJECT"] = "object";
  EntityGroupType2["EDGE"] = "edge";
  EntityGroupType2["FACE"] = "face";
  return EntityGroupType2;
})(EntityGroupType || {});
var USER_DATA_KEY_GROUPS = "groups";
var EntityGroupCollection = class _EntityGroupCollection {
  // private _groupsByNameByType: Map<GroupType, Map<string, EntityGroup>> = new Map();
  constructor(_object) {
    this._object = _object;
    this.selectedIndices = /* @__PURE__ */ new Set();
  }
  attributesDictionary() {
    return _EntityGroupCollection.attributesDictionary(this._object);
  }
  static attributesDictionary(object) {
    return object.userData[USER_DATA_KEY_GROUPS] || this._createAttributesDictionaryIfNone(object);
  }
  static _createAttributesDictionaryIfNone(object) {
    if (!object.userData[USER_DATA_KEY_GROUPS]) {
      return object.userData[USER_DATA_KEY_GROUPS] = {};
    }
  }
  findOrCreateGroup(type, groupName) {
    const dict = this.attributesDictionary();
    let groupsByName = dict[type];
    if (!groupsByName) {
      groupsByName = {};
      dict[type] = groupsByName;
    }
    let group = groupsByName[groupName];
    if (!group) {
      group = [];
      groupsByName[groupName] = group;
    }
    return group;
  }
  deleteGroup(type, groupName) {
    const dict = this.attributesDictionary();
    const groupsByName = dict[type];
    if (groupsByName) {
      delete groupsByName[groupName];
      if (Object.keys(groupsByName).length == 0) {
        delete dict[type];
      }
    }
  }
  static data(object) {
    const dict = this.attributesDictionary(object);
    const types = Object.keys(dict);
    const data = {};
    for (const type of types) {
      const dataForType = [];
      data[type] = dataForType;
      const groupsForType = dict[type];
      const groupNames = Object.keys(groupsForType);
      for (const groupName of groupNames) {
        const indices = groupsForType[groupName];
        const groupData = {
          name: groupName,
          entitiesCount: indices.length
        };
        dataForType.push(groupData);
      }
    }
    return data;
  }
  indicesSet(type, groupName, target4) {
    const dict = this.attributesDictionary();
    const groupsByName = dict[type];
    target4.clear();
    if (groupsByName) {
      const indices = groupsByName[groupName];
      if (indices) {
        arrayToSet(indices, target4);
      }
    }
  }
  updateGroup(options, selectionStates) {
    const { type, groupName, operation, invert } = options;
    const currentIndices = this.findOrCreateGroup(type, groupName);
    const _updateGroup = (newIndicesSet) => {
      const dict = this.attributesDictionary();
      let groupsByName = dict[type];
      if (!groupsByName) {
        groupsByName = {};
        dict[type] = groupsByName;
      }
      const newIndices = [];
      groupsByName[groupName] = setToArray(newIndicesSet, newIndices);
    };
    this.selectedIndices.clear();
    selectedIndicesFromSelectionStates(selectionStates, this.selectedIndices, invert);
    switch (operation) {
      case "replace existing": {
        _updateGroup(this.selectedIndices);
        return;
      }
      case "add to existing": {
        arrayToSet(currentIndices, _currentIndicesSet);
        setUnion(_currentIndicesSet, this.selectedIndices, _newIndicesSet);
        _updateGroup(_newIndicesSet);
        return;
      }
      case "subtract from existing": {
        arrayToSet(currentIndices, _currentIndicesSet);
        setDifference(_currentIndicesSet, this.selectedIndices, _newIndicesSet);
        _updateGroup(_newIndicesSet);
        return;
      }
      case "intersect with existing": {
        arrayToSet(currentIndices, _currentIndicesSet);
        setIntersection(_currentIndicesSet, this.selectedIndices, _newIndicesSet);
        _updateGroup(_newIndicesSet);
        return;
      }
    }
    TypeAssert.unreachable(operation);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/utils/Common.js
function uniqRelatedEntities(entities, callback, target4) {
  target4.length = 0;
  const entityByIndex = /* @__PURE__ */ new Map();
  for (const entity of entities) {
    const relatedEntities = callback(entity);
    for (const relatedEntity of relatedEntities) {
      let newEntity = entityByIndex.get(relatedEntity.index());
      if (!newEntity) {
        newEntity = relatedEntity;
        entityByIndex.set(newEntity.index(), newEntity);
      }
    }
  }
  entityByIndex.forEach((entity) => {
    target4.push(entity);
  });
}
var _relatedEntityIds = [];
var _entityIndices = /* @__PURE__ */ new Set();
function uniqRelatedEntityIds(entityIds, callback, target4) {
  target4.length = 0;
  _entityIndices.clear();
  for (const entityId of entityIds) {
    callback(entityId, _relatedEntityIds);
    for (const _relatedEntityId of _relatedEntityIds) {
      _entityIndices.add(_relatedEntityId);
    }
  }
  _entityIndices.forEach((entityId) => {
    target4.push(entityId);
  });
}
function attribValueNonPrimitive(src) {
  return src instanceof Color || src instanceof Vector2 || src instanceof Vector3 || src instanceof Vector4;
}
function copyAttribValue(src, target4) {
  if (target4 instanceof Color && src instanceof Color) {
    target4.copy(src);
  }
  if (target4 instanceof Vector2 && src instanceof Vector2) {
    target4.copy(src);
  }
  if (target4 instanceof Vector3 && src instanceof Vector3) {
    target4.copy(src);
  }
  if (target4 instanceof Vector4 && src instanceof Vector4) {
    target4.copy(src);
  }
}
function cloneAttribValue(src) {
  if (src instanceof Color) {
    return src.clone();
  }
  if (src instanceof Vector2) {
    return src.clone();
  }
  if (src instanceof Vector3) {
    return src.clone();
  }
  if (src instanceof Vector4) {
    return src.clone();
  }
}
function attributeNumericValues(object, entitiesCountFunction, attribSize = 1, defaultValue2 = 0, target4) {
  target4.values.length = 0;
  const values = target4.values;
  const entitiesCount = entitiesCountFunction(object);
  if (isNumber(defaultValue2)) {
    for (let i = 0; i < entitiesCount; i++) {
      for (let j = 0; j < attribSize; j++) {
        values.push(defaultValue2);
      }
    }
    target4.attributeAdded = true;
  } else {
    if (attribSize > 1) {
      if (isArray(defaultValue2)) {
        for (let i = 0; i < entitiesCount; i++) {
          for (let j = 0; j < attribSize; j++) {
            values.push(defaultValue2[j]);
          }
        }
        target4.attributeAdded = true;
      } else {
        const vec2 = defaultValue2;
        if (attribSize == 2 && vec2.x != null && vec2.y != null) {
          for (let i = 0; i < entitiesCount; i++) {
            values.push(vec2.x);
            values.push(vec2.y);
          }
          target4.attributeAdded = true;
        }
        const vec3 = defaultValue2;
        if (attribSize == 3 && vec3.x != null && vec3.y != null && vec3.z != null) {
          for (let i = 0; i < entitiesCount; i++) {
            values.push(vec3.x);
            values.push(vec3.y);
            values.push(vec3.z);
          }
          target4.attributeAdded = true;
        }
        const col = defaultValue2;
        if (attribSize == 3 && col.r != null && col.g != null && col.b != null) {
          for (let i = 0; i < entitiesCount; i++) {
            values.push(col.r);
            values.push(col.g);
            values.push(col.b);
          }
          target4.attributeAdded = true;
        }
        const vec4 = defaultValue2;
        if (attribSize == 4 && vec4.x != null && vec4.y != null && vec4.z != null && vec4.w != null) {
          for (let i = 0; i < entitiesCount; i++) {
            values.push(vec4.x);
            values.push(vec4.y);
            values.push(vec4.z);
            values.push(vec4.w);
          }
          target4.attributeAdded = true;
        }
      }
    }
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/reactivity/ObjectAttributeReactivity.js
var refByObjectUuidByAttribName = /* @__PURE__ */ new WeakMap();
function _getObjectAttributeRef_(object3D, attribName) {
  var _a;
  return (_a = refByObjectUuidByAttribName.get(object3D)) == null ? void 0 : _a.get(attribName);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/reactivity/ObjectAttributeReactivityUpdateRef.js
function _copyObjectAttribToRef(attribValue, targetRef) {
  if (attribValueNonPrimitive(attribValue) && attribValueNonPrimitive(targetRef.value)) {
    copyAttribValue(attribValue, targetRef.value);
  } else {
    targetRef.value = attribValue;
  }
}
function _updateObjectAttribRef(object3D, attribName, newValue) {
  const _ref = _getObjectAttributeRef_(object3D, attribName);
  if (!_ref) {
    return;
  }
  _copyObjectAttribToRef(_ref.current.value, _ref.previous);
  _copyObjectAttribToRef(newValue, _ref.current);
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/connections/_Base.js
var BaseConnectionPoint = class {
  constructor(_name, _type, _init_value) {
    this._name = _name;
    this._type = _type;
    this._init_value = _init_value;
    this._inNodeDefinition = false;
  }
  get init_value() {
    return this._init_value;
  }
  name() {
    return this._name;
  }
  type() {
    return this._type;
  }
  are_types_matched(src_type, dest_type) {
    return true;
  }
  inNodeDefinition() {
    return this._inNodeDefinition;
  }
  // get param_type(): IConnectionPointTypeToParamTypeMap[T] {
  // 	return ConnectionPointTypeToParamTypeMap[this._type];
  // }
  // get init_value() {
  // 	return this._init_value;
  // }
  toJSON() {
    return this._json = this._json || this._createJSON();
  }
  _createJSON() {
    return {
      name: this._name,
      type: this._type
      // isArray: false,
    };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/connections/Js.js
var JsConnectionPointType = ((JsConnectionPointType2) => {
  JsConnectionPointType2["ANIMATION_MIXER"] = "AnimationMixer";
  JsConnectionPointType2["ANIMATION_ACTION"] = "AnimationAction";
  JsConnectionPointType2["BOOLEAN"] = "boolean";
  JsConnectionPointType2["BOOLEAN_ARRAY"] = "boolean[]";
  JsConnectionPointType2["BOX3"] = "Box3";
  JsConnectionPointType2["CAMERA"] = "Camera";
  JsConnectionPointType2["CATMULL_ROM_CURVE3"] = "CatmullRomCurve3";
  JsConnectionPointType2["COLOR"] = "Color";
  JsConnectionPointType2["COLOR_ARRAY"] = "Color[]";
  JsConnectionPointType2["EULER"] = "Euler";
  JsConnectionPointType2["EULER_ARRAY"] = "Euler[]";
  JsConnectionPointType2["FLOAT"] = "float";
  JsConnectionPointType2["FLOAT_ARRAY"] = "float[]";
  JsConnectionPointType2["INT"] = "int";
  JsConnectionPointType2["INT_ARRAY"] = "int[]";
  JsConnectionPointType2["INTERSECTION"] = "Intersection";
  JsConnectionPointType2["INTERSECTION_ARRAY"] = "Intersection[]";
  JsConnectionPointType2["MATERIAL"] = "Material";
  JsConnectionPointType2["MATRIX4"] = "Matrix4";
  JsConnectionPointType2["MATRIX4_ARRAY"] = "Matrix4[]";
  JsConnectionPointType2["NODE"] = "Node";
  JsConnectionPointType2["OBJECT_3D"] = "Object3D";
  JsConnectionPointType2["OBJECT_3D_ARRAY"] = "Object3D[]";
  JsConnectionPointType2["PARAM"] = "Param";
  JsConnectionPointType2["PLANE"] = "Plane";
  JsConnectionPointType2["QUATERNION"] = "Quaternion";
  JsConnectionPointType2["QUATERNION_ARRAY"] = "Quaternion[]";
  JsConnectionPointType2["RAY"] = "Ray";
  JsConnectionPointType2["SPHERE"] = "Sphere";
  JsConnectionPointType2["STRING"] = "string";
  JsConnectionPointType2["STRING_ARRAY"] = "string[]";
  JsConnectionPointType2["TEXTURE"] = "Texture";
  JsConnectionPointType2["TEXTURE_ARRAY"] = "Texture[]";
  JsConnectionPointType2["TRIGGER"] = "trigger";
  JsConnectionPointType2["VECTOR2"] = "Vector2";
  JsConnectionPointType2["VECTOR2_ARRAY"] = "Vector2[]";
  JsConnectionPointType2["VECTOR3"] = "Vector3";
  JsConnectionPointType2["VECTOR3_ARRAY"] = "Vector3[]";
  JsConnectionPointType2["VECTOR4"] = "Vector4";
  JsConnectionPointType2["VECTOR4_ARRAY"] = "Vector4[]";
  return JsConnectionPointType2;
})(JsConnectionPointType || {});
var ARRAY_JS_CONNECTION_TYPES = [
  "boolean[]",
  "Color[]",
  "float[]",
  "int[]",
  "Intersection[]",
  "Matrix4[]",
  "Object3D[]",
  "Quaternion[]",
  "string[]",
  "Texture[]",
  "Vector2[]",
  "Vector3[]",
  "Vector4[]"
  /* VECTOR4_ARRAY */
];
var ARRAY_JS_CONNECTION_TYPES_SET = new Set(ARRAY_JS_CONNECTION_TYPES);
var JsConnectionPointTypeToParamTypeMap = {
  [
    "AnimationMixer"
    /* ANIMATION_MIXER */
  ]: ParamType.BUTTON,
  [
    "AnimationAction"
    /* ANIMATION_ACTION */
  ]: ParamType.BUTTON,
  [
    "boolean"
    /* BOOLEAN */
  ]: ParamType.BOOLEAN,
  [
    "boolean[]"
    /* BOOLEAN_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Box3"
    /* BOX3 */
  ]: ParamType.BUTTON,
  [
    "Camera"
    /* CAMERA */
  ]: ParamType.BUTTON,
  [
    "CatmullRomCurve3"
    /* CATMULL_ROM_CURVE3 */
  ]: ParamType.BUTTON,
  [
    "Color"
    /* COLOR */
  ]: ParamType.COLOR,
  [
    "Color[]"
    /* COLOR_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Euler"
    /* EULER */
  ]: ParamType.BUTTON,
  [
    "Euler[]"
    /* EULER_ARRAY */
  ]: ParamType.BUTTON,
  [
    "float"
    /* FLOAT */
  ]: ParamType.FLOAT,
  [
    "float[]"
    /* FLOAT_ARRAY */
  ]: ParamType.BUTTON,
  [
    "int"
    /* INT */
  ]: ParamType.INTEGER,
  [
    "int[]"
    /* INT_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Intersection"
    /* INTERSECTION */
  ]: ParamType.BUTTON,
  [
    "Intersection[]"
    /* INTERSECTION_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Material"
    /* MATERIAL */
  ]: ParamType.BUTTON,
  [
    "Matrix4"
    /* MATRIX4 */
  ]: ParamType.BUTTON,
  [
    "Matrix4[]"
    /* MATRIX4_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Node"
    /* NODE */
  ]: ParamType.NODE_PATH,
  [
    "Object3D"
    /* OBJECT_3D */
  ]: ParamType.BUTTON,
  [
    "Object3D[]"
    /* OBJECT_3D_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Param"
    /* PARAM */
  ]: ParamType.PARAM_PATH,
  [
    "Plane"
    /* PLANE */
  ]: ParamType.BUTTON,
  [
    "Quaternion"
    /* QUATERNION */
  ]: ParamType.BUTTON,
  [
    "Quaternion[]"
    /* QUATERNION_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Ray"
    /* RAY */
  ]: ParamType.BUTTON,
  [
    "Sphere"
    /* SPHERE */
  ]: ParamType.BUTTON,
  [
    "string"
    /* STRING */
  ]: ParamType.STRING,
  [
    "string[]"
    /* STRING_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Texture"
    /* TEXTURE */
  ]: ParamType.BUTTON,
  [
    "Texture[]"
    /* TEXTURE_ARRAY */
  ]: ParamType.BUTTON,
  [
    "trigger"
    /* TRIGGER */
  ]: ParamType.BUTTON,
  [
    "Vector2"
    /* VECTOR2 */
  ]: ParamType.VECTOR2,
  [
    "Vector2[]"
    /* VECTOR2_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Vector3"
    /* VECTOR3 */
  ]: ParamType.VECTOR3,
  [
    "Vector3[]"
    /* VECTOR3_ARRAY */
  ]: ParamType.BUTTON,
  [
    "Vector4"
    /* VECTOR4 */
  ]: ParamType.VECTOR4,
  [
    "Vector4[]"
    /* VECTOR4_ARRAY */
  ]: ParamType.BUTTON
  // [JsConnectionPointType.MAT3]: undefined,
  // [JsConnectionPointType.MAT4]: undefined,
};
var JsParamTypeToConnectionPointTypeMap = {
  [ParamType.BOOLEAN]: "boolean",
  [ParamType.COLOR]: "Color",
  [ParamType.FLOAT]: "float",
  [ParamType.INTEGER]: "int",
  [ParamType.FOLDER]: void 0,
  [ParamType.VECTOR2]: "Vector2",
  [ParamType.VECTOR3]: "Vector3",
  [ParamType.VECTOR4]: "Vector4",
  [ParamType.BUTTON]: void 0,
  [ParamType.NODE_PATH]: "Node",
  [ParamType.PARAM_PATH]: "Param",
  [ParamType.RAMP]: void 0,
  [ParamType.STRING]: "string"
  /* STRING */
};
var JsConnectionPointInitValueMap = {
  [
    "AnimationAction"
    /* ANIMATION_ACTION */
  ]: null,
  [
    "AnimationMixer"
    /* ANIMATION_MIXER */
  ]: null,
  [
    "boolean"
    /* BOOLEAN */
  ]: false,
  [
    "boolean[]"
    /* BOOLEAN_ARRAY */
  ]: null,
  [
    "Box3"
    /* BOX3 */
  ]: null,
  [
    "Camera"
    /* CAMERA */
  ]: null,
  [
    "CatmullRomCurve3"
    /* CATMULL_ROM_CURVE3 */
  ]: null,
  [
    "Color"
    /* COLOR */
  ]: [1, 1, 1],
  [
    "Color[]"
    /* COLOR_ARRAY */
  ]: null,
  [
    "Euler"
    /* EULER */
  ]: null,
  [
    "Euler[]"
    /* EULER_ARRAY */
  ]: null,
  [
    "float"
    /* FLOAT */
  ]: 0,
  [
    "float[]"
    /* FLOAT_ARRAY */
  ]: null,
  [
    "int"
    /* INT */
  ]: 0,
  [
    "int[]"
    /* INT_ARRAY */
  ]: null,
  [
    "Intersection"
    /* INTERSECTION */
  ]: null,
  [
    "Intersection[]"
    /* INTERSECTION_ARRAY */
  ]: null,
  [
    "Material"
    /* MATERIAL */
  ]: null,
  [
    "Matrix4"
    /* MATRIX4 */
  ]: null,
  [
    "Matrix4[]"
    /* MATRIX4_ARRAY */
  ]: null,
  [
    "Node"
    /* NODE */
  ]: "",
  [
    "Object3D"
    /* OBJECT_3D */
  ]: null,
  [
    "Object3D[]"
    /* OBJECT_3D_ARRAY */
  ]: null,
  [
    "Param"
    /* PARAM */
  ]: "",
  [
    "Plane"
    /* PLANE */
  ]: null,
  [
    "Quaternion"
    /* QUATERNION */
  ]: null,
  [
    "Quaternion[]"
    /* QUATERNION_ARRAY */
  ]: null,
  [
    "Ray"
    /* RAY */
  ]: null,
  [
    "Sphere"
    /* SPHERE */
  ]: null,
  [
    "string"
    /* STRING */
  ]: "",
  [
    "string[]"
    /* STRING_ARRAY */
  ]: null,
  [
    "Texture"
    /* TEXTURE */
  ]: null,
  [
    "Texture[]"
    /* TEXTURE_ARRAY */
  ]: null,
  [
    "trigger"
    /* TRIGGER */
  ]: null,
  [
    "Vector2"
    /* VECTOR2 */
  ]: [0, 0],
  [
    "Vector2[]"
    /* VECTOR2_ARRAY */
  ]: null,
  [
    "Vector3"
    /* VECTOR3 */
  ]: [0, 0, 0],
  [
    "Vector3[]"
    /* VECTOR3_ARRAY */
  ]: null,
  [
    "Vector4"
    /* VECTOR4 */
  ]: [0, 0, 0, 0],
  [
    "Vector4[]"
    /* VECTOR4_ARRAY */
  ]: null
  // [JsConnectionPointType.MAT3]: [0],
  // [JsConnectionPointType.MAT4]: [0],
};
var JsConnectionPoint = class extends BaseConnectionPoint {
  constructor(_name, _type, _options) {
    super(_name, _type);
    this._type = _type;
    this._options = _options;
    this._isArray = ARRAY_JS_CONNECTION_TYPES_SET.has(_type);
    this._init_value = JsConnectionPointInitValueMap[this._type];
    if (_options) {
      this._inNodeDefinition = _options.inNodeDefinition == true;
      if (_options.init_value != null) {
        this._init_value = _options.init_value;
      }
    }
  }
  type() {
    return this._type;
  }
  are_types_matched(src_type, dest_type) {
    return src_type == dest_type;
  }
  get param_type() {
    return JsConnectionPointTypeToParamTypeMap[this._type];
  }
  get init_value() {
    return this._init_value;
  }
  toJSON() {
    return this._json = this._json || this._createJSON();
  }
  _createJSON() {
    return {
      name: this._name,
      type: this._type,
      isArray: this._isArray
    };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/reactivity/ObjectAttributeReactivityCreateRef.js
function defaultValue(type) {
  switch (type) {
    case JsConnectionPointType.BOOLEAN: {
      return false;
    }
    case JsConnectionPointType.COLOR: {
      return new Color();
    }
    case JsConnectionPointType.FLOAT: {
      return 0;
    }
    case JsConnectionPointType.INT: {
      return 0;
    }
    case JsConnectionPointType.STRING: {
      return "";
    }
    case JsConnectionPointType.VECTOR2: {
      return new Vector2();
    }
    case JsConnectionPointType.VECTOR3: {
      return new Vector3();
    }
    case JsConnectionPointType.VECTOR4: {
      return new Vector4();
    }
  }
  TypeAssert.unreachable(type);
}
function cloneDefaultValue(value, type) {
  switch (type) {
    case JsConnectionPointType.BOOLEAN: {
      return value;
    }
    case JsConnectionPointType.COLOR: {
      return value.clone();
    }
    case JsConnectionPointType.FLOAT: {
      return value;
    }
    case JsConnectionPointType.INT: {
      return value;
    }
    case JsConnectionPointType.STRING: {
      return value;
    }
    case JsConnectionPointType.VECTOR2: {
      return value.clone();
    }
    case JsConnectionPointType.VECTOR3: {
      return value.clone();
    }
    case JsConnectionPointType.VECTOR4: {
      return value.clone();
    }
  }
  TypeAssert.unreachable(type);
}
function getOrCreateObjectAttributeRef(object3D, attribName, type, defaultAttribValue) {
  let mapForObject = refByObjectUuidByAttribName.get(object3D);
  if (!mapForObject) {
    mapForObject = /* @__PURE__ */ new Map();
    refByObjectUuidByAttribName.set(object3D, mapForObject);
  }
  let refForAttribName = mapForObject.get(attribName);
  if (!refForAttribName) {
    let _defaultValue = defaultAttribValue != null ? defaultAttribValue : defaultValue(type);
    let _previousValue = cloneDefaultValue(_defaultValue, type);
    const currentValue = BaseCoreObject.attribValue(
      object3D,
      attribName,
      0,
      _defaultValue
    );
    const previousValue = BaseCoreObject.attribValue(object3D, attribName, 0, _previousValue);
    if (currentValue == null || previousValue == null) {
      refForAttribName = {
        current: ref(_defaultValue),
        previous: ref(_previousValue)
      };
    } else {
      refForAttribName = {
        current: ref(currentValue),
        previous: ref(previousValue)
      };
    }
    mapForObject.set(attribName, refForAttribName);
  }
  return refForAttribName;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/ObjectContent.js
var CoreObjectType = ((CoreObjectType2) => {
  CoreObjectType2["THREEJS"] = "Object3D";
  CoreObjectType2["CAD"] = "CADObject";
  CoreObjectType2["CSG"] = "CSGObject";
  CoreObjectType2["QUAD"] = "QUADObject";
  CoreObjectType2["SDF"] = "SDFObject";
  CoreObjectType2["TET"] = "TetObject";
  return CoreObjectType2;
})(CoreObjectType || {});
function isObject3D(o) {
  return o instanceof Object3D || o.isObject3D == true;
}
function objectContentCopyProperties(src, target4, options) {
  target4.visible = src.visible;
  target4.name = src.name;
  if (options == null || options.castShadow == null || options.castShadow == true) {
    target4.castShadow = src.castShadow;
  }
  if (options == null || options.receiveShadow == null || options.receiveShadow == true) {
    target4.receiveShadow = src.receiveShadow;
  }
  target4.renderOrder = src.renderOrder;
  target4.frustumCulled = src.frustumCulled;
  target4.matrixAutoUpdate = src.matrixAutoUpdate;
  if (src.material) {
    target4.material = src.material;
  }
  target4.userData = objectCloneDeep(src.userData);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/object/BaseCoreObjectUtils.js
function objectData(object) {
  const childrenCount = isObject3D(object) ? object.children.length : 0;
  const objectType = isObject3D(object) ? objectTypeFromObject(object) : object.type;
  const groupData = EntityGroupCollection.data(object);
  return {
    type: objectType,
    name: object.name,
    childrenCount,
    groupData,
    verticesCount: 0,
    pointsCount: 0,
    primitivesCount: 0,
    primitiveName: "no name"
  };
}
function coreObjectsAttribSizesByName(coreObjects) {
  const _sizesByName = /* @__PURE__ */ new Map();
  for (const coreObject of coreObjects) {
    const objectAttriNames = coreObject.attribNames();
    for (const attribName of objectAttriNames) {
      const attribSize = coreObject.attribSize(attribName);
      addToSetAtEntry(_sizesByName, attribName, attribSize);
    }
  }
  const sizesByName = {};
  _sizesByName.forEach((attribSizes, attribName) => {
    sizesByName[attribName] = setToArray(attribSizes, []);
  });
  return sizesByName;
}
function coreObjectAttributeTypesByName(coreObjects) {
  const _typesByName = /* @__PURE__ */ new Map();
  for (const coreObject of coreObjects) {
    const objectAttriNames = coreObject.attribNames();
    for (const attribName of objectAttriNames) {
      const attribType = coreObject.attribType(attribName);
      addToSetAtEntry(_typesByName, attribName, attribType);
    }
  }
  const typesByName = {};
  _typesByName.forEach((attribTypes, attribName) => {
    typesByName[attribName] = setToArray(attribTypes, []);
  });
  return typesByName;
}
function coreObjectsAttribNames(coreObjects) {
  const names = /* @__PURE__ */ new Set();
  for (const coreObject of coreObjects) {
    const objectAttriNames = coreObject.attribNames();
    for (const attribName of objectAttriNames) {
      names.add(attribName);
    }
  }
  return setToArray(names, []);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/object/BaseCoreObject.js
var PropertyName = ((PropertyName2) => {
  PropertyName2["NAME"] = "name";
  PropertyName2["POSITION"] = "position";
  return PropertyName2;
})(PropertyName || {});
var ATTRIBUTES = "attributes";
var ORIGIN = new Vector3(0, 0, 0);
function _convertArrayToVector(value) {
  switch (value.length) {
    case 1:
      return value[0];
    case 2:
      return new Vector2(value[0], value[1]);
    case 3:
      return new Vector3(value[0], value[1], value[2]);
    case 4:
      return new Vector4(value[0], value[1], value[2], value[3]);
  }
}
var tmpVec3 = new Vector3();
var tmpN3 = [0, 0, 0];
var _relatedPrimitiveIds2 = [];
var _relatedVertexIds2 = [];
var BaseCoreObject = class extends CoreEntityWithObject {
  dispose() {
  }
  // set_index(i: number) {
  // 	this._index = i;
  // }
  geometry() {
    var _a;
    return ((_a = this._object) == null ? void 0 : _a.geometry) || null;
  }
  builder() {
    return void 0;
  }
  static attributeRef(object, attribName, type, defaultValue2) {
    return getOrCreateObjectAttributeRef(object, attribName, type, defaultValue2);
  }
  attributeRef(attribName, type, defaultValue2) {
    if (!this._object) {
      return;
    }
    return this.constructor.attributeRef(
      this._object,
      attribName,
      type,
      defaultValue2
    );
  }
  static onAttribChange(object, attribName, type, defaultValue2, callback) {
    const ref2 = this.attributeRef(object, attribName, type, defaultValue2);
    return watch(ref2.current, callback);
  }
  onAttribChange(attribName, type, defaultValue2, callback) {
    if (!this._object) {
      return;
    }
    return this.constructor.onAttribChange(
      this._object,
      attribName,
      type,
      defaultValue2,
      callback
    );
  }
  static setAttribute(object, attribName, value) {
    this.addAttribute(object, attribName, value);
  }
  static addAttribute(object, attribName, value) {
    if (CoreType.isArray(value)) {
      const convertedValue = _convertArrayToVector(value);
      if (!convertedValue) {
        const message = `value invalid`;
        console.error(message, value);
        throw new Error(message);
      }
    }
    const dict = this._attributesDictionary(object);
    const currentValue = dict[attribName];
    if (attribValueNonPrimitive(value)) {
      if (currentValue == null) {
        const cloned = cloneAttribValue(value);
        if (cloned) {
          dict[attribName] = cloned;
        }
      } else {
        if (attribValueNonPrimitive(currentValue)) {
          copyAttribValue(value, currentValue);
        }
      }
    } else {
      dict[attribName] = value;
    }
    _updateObjectAttribRef(object, attribName, value);
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    this.addAttribute(object, attribName, defaultValue2);
  }
  addAttribute(name, value) {
    if (!this._object) {
      return;
    }
    this.constructor.addAttribute(this._object, name, value);
  }
  addNumericAttrib(name, value) {
    if (!this._object) {
      return;
    }
    this.constructor.addNumericAttribute(
      this._object,
      name,
      1,
      value
    );
  }
  setAttribValue(name, value) {
    this.addAttribute(name, value);
  }
  // addNumericVertexAttrib(name: string, size: number, defaultValue: NumericAttribValue) {
  // 	// if (defaultValue == null) {
  // 	// 	defaultValue = CoreAttribute.default_value(size);
  // 	// }
  // 	// this.coreGeometry()?.addNumericAttrib(name, size, defaultValue);
  // }
  static _attributesDictionary(object) {
    return object.userData[ATTRIBUTES] || this._createAttributesDictionaryIfNone(object);
  }
  static attributesDictionaryEntry(object, attribName, defaultValue2) {
    const dict = object.userData[ATTRIBUTES] || this._createAttributesDictionaryIfNone(object);
    let entry = dict[attribName];
    if (entry == null && defaultValue2 != null) {
      entry = defaultValue2;
      dict[attribName] = entry;
    }
    return entry;
  }
  // static attributesPreviousValuesDictionary<T extends CoreObjectType>(object: ObjectContent<T>) {
  // 	return (
  // 		(object.userData[ATTRIBUTES_PREVIOUS_VALUES] as AttributeDictionary) ||
  // 		this._createAttributesPreviousValuesDictionaryIfNone(object)
  // 	);
  // }
  static _createAttributesDictionaryIfNone(object) {
    if (!object.userData[ATTRIBUTES]) {
      return object.userData[ATTRIBUTES] = {};
    }
  }
  // private static _createAttributesPreviousValuesDictionaryIfNone<T extends CoreObjectType>(object: ObjectContent<T>) {
  // 	if (!object.userData[ATTRIBUTES_PREVIOUS_VALUES]) {
  // 		return (object.userData[ATTRIBUTES_PREVIOUS_VALUES] = {});
  // 	}
  // }
  _attributesDictionary() {
    return this.constructor._attributesDictionary(this._object);
  }
  static attributes(object) {
    return this._attributesDictionary(object);
  }
  attributes() {
    if (!this._object) {
      return;
    }
    return this.constructor.attributes(this._object);
  }
  attributeNames() {
    return this.attribNames();
  }
  static attribNames(object) {
    return Object.keys(this._attributesDictionary(object));
  }
  attribNames() {
    return this.constructor.attribNames(this._object);
  }
  // static objectsAttribNames<T extends CoreObjectType>(objects: ObjectContent<T>[]) {
  // 	const names: Set<string> = new Set();
  // 	for (let object of objects) {
  // 		const objectAttriNames = this.attribNames(object);
  // 		for (let attribName of objectAttriNames) {
  // 			names.add(attribName);
  // 		}
  // 	}
  // 	return SetUtils.toArray(names);
  // }
  static hasAttribute(object, attribName) {
    return attribName in this._attributesDictionary(object);
  }
  hasAttribute(attribName) {
    return this.constructor.hasAttribute(
      this._object,
      attribName
    );
  }
  static attributeNames(object) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return [];
    }
    return Object.keys(attributes);
  }
  static attributeNamesMatchingMask(object, masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.attributeNames(object));
  }
  renameAttribute(oldName, newName) {
    return this.constructor.renameAttribute(
      this._object,
      oldName,
      newName
    );
  }
  static renameAttribute(object, oldName, newName) {
    const currentValue = this.attribValue(object, oldName);
    if (currentValue != null) {
      this.addAttribute(object, newName, currentValue);
      this.deleteAttribute(object, oldName);
    } else {
      console.warn(`attribute ${oldName} not found`);
    }
  }
  deleteAttribute(name) {
    delete this._attributesDictionary()[name];
  }
  static deleteAttribute(object, attribName) {
    delete this._attributesDictionary(object)[attribName];
  }
  // static position:PositionStaticMethod<CoreObjectType> = DEFAULT_POSITION_STATIC_METHOD
  static position(object, target4) {
    target4.copy(ORIGIN);
  }
  position(target4) {
    this.constructor.position(this._object, target4);
    return target4;
  }
  static boundingBox(object, target4) {
    target4.makeEmpty();
  }
  boundingBox(target4) {
    this.constructor.boundingBox(this._object, target4);
  }
  static geometryBoundingBox(object, target4) {
    this.boundingBox(object, target4);
  }
  geometryBoundingBox(target4) {
    this.constructor.geometryBoundingBox(this._object, target4);
  }
  static boundingSphere(object, target4) {
    target4.makeEmpty();
  }
  boundingSphere(target4) {
    this.constructor.boundingSphere(this._object, target4);
  }
  static geometryBoundingSphere(object, target4) {
    target4.makeEmpty();
  }
  geometryBoundingSphere(target4) {
    this.constructor.geometryBoundingSphere(this._object, target4);
  }
  static attribValue(object, attribName, index = 0, target4) {
    const _attribFromProperty = () => {
      if (attribName == "name") {
        return object.name;
      }
      if (attribName == "position") {
        const _target3 = target4 instanceof Vector3 ? target4 : tmpVec3;
        this.position(object, _target3);
        _target3.toArray(tmpN3);
        return tmpN3;
      }
    };
    if (attribName === Attribute.OBJECT_INDEX) {
      return index;
    }
    if (attribName === Attribute.OBJECT_NAME) {
      return object.name;
    }
    if (object.userData) {
      const val = this.attributesDictionaryEntry(object, attribName);
      if (val == null) {
        return _attribFromProperty();
      } else {
        if (CoreType.isVector(val) && target4) {
          if (val instanceof Vector2 && target4 instanceof Vector2) {
            return target4.copy(val);
          }
          if (val instanceof Vector3 && target4 instanceof Vector3) {
            return target4.copy(val);
          }
          if (val instanceof Vector4 && target4 instanceof Vector4) {
            return target4.copy(val);
          }
        }
        if (CoreType.isColor(val) && target4) {
          if (val instanceof Color && target4 instanceof Color) {
            return target4.copy(val);
          }
        }
        if (CoreType.isArray(val) && target4) {
          target4.fromArray(val);
          return target4;
        }
      }
      return val;
    }
    return _attribFromProperty();
  }
  // static previousAttribValue<T extends CoreObjectType>(
  // 	object: ObjectContent<T>,
  // 	attribName: string
  // ): AttribValue | undefined {
  // 	const dict = this.attributesPreviousValuesDictionary(object);
  // 	return dict[attribName];
  // }
  static stringAttribValue(object, attribName, index = 0) {
    const str = this.attribValue(object, attribName, index);
    if (str != null) {
      if (CoreType.isString(str)) {
        return str;
      } else {
        return `${str}`;
      }
    }
    return null;
  }
  // static makeAttribReactive<V extends AttribValue, T extends CoreObjectType>(
  // 	object: ObjectContent<T>,
  // 	attribName: string,
  // 	callback: AttributeReactiveCallback<V>
  // ) {
  // 	const attributesDict = this.attributesDictionary(object);
  // 	// const attributesPreviousValuesDict = this.attributesPreviousValuesDictionary(object);
  // 	const currentValue = attributesDict[attribName];
  // 	if (currentValue instanceof Vector4) {
  // 		return makeAttribReactiveVector4(
  // 			object,
  // 			attribName,
  // 			(<unknown>callback) as AttributeReactiveCallback<Vector4>
  // 		);
  // 	}
  // 	if (currentValue instanceof Vector3) {
  // 		return makeAttribReactiveVector3(
  // 			object,
  // 			attribName,
  // 			(<unknown>callback) as AttributeReactiveCallback<Vector3>
  // 		);
  // 	}
  // 	if (currentValue instanceof Vector2) {
  // 		return makeAttribReactiveVector2(
  // 			object,
  // 			attribName,
  // 			(<unknown>callback) as AttributeReactiveCallback<Vector2>
  // 		);
  // 	}
  // 	return makeAttribReactiveSimple(
  // 		object,
  // 		attribName,
  // 		(<unknown>callback) as AttributeReactiveCallback<string | number>
  // 	);
  // 	// // create a dummy val in case there is no attribute yet
  // 	// if (attributesDict[attribName] == null) {
  // 	// 	attributesDict[attribName] = 0;
  // 	// }
  // 	// const proxy: AttributeProxy<V> = {
  // 	// 	value: attributesDict[attribName] as V,
  // 	// 	previousValue: attributesDict[attribName] as V,
  // 	// };
  // 	// Object.defineProperties(attributesDict, {
  // 	// 	[attribName]: {
  // 	// 		get: function () {
  // 	// 			return proxy.value;
  // 	// 		},
  // 	// 		set: function (x) {
  // 	// 			if (x != proxy.value) {
  // 	// 				proxy.previousValue = proxy.value;
  // 	// 				proxy.value = x;
  // 	// 				callback(proxy.value, proxy.previousValue);
  // 	// 			}
  // 	// 			return proxy.value;
  // 	// 		},
  // 	// 		configurable: true,
  // 	// 	},
  // 	// });
  // 	// Object.defineProperties(attributesPreviousValuesDict, {
  // 	// 	[attribName]: {
  // 	// 		get: function () {
  // 	// 			return proxy.previousValue;
  // 	// 		},
  // 	// 		configurable: true,
  // 	// 	},
  // 	// });
  // }
  attribValue(attribName, target4) {
    return this.constructor.attribValue(
      this._object,
      attribName,
      this._index,
      target4
    );
  }
  stringAttribValue(name) {
    return this.constructor.stringAttribValue(
      this._object,
      name,
      this._index
    );
  }
  name() {
    return this.attribValue(
      "name"
      /* NAME */
    );
  }
  humanType() {
    return this._object.type;
  }
  attribTypes() {
    const h = {};
    for (const attrib_name of this.attribNames()) {
      const type = this.attribType(attrib_name);
      if (type != null) {
        h[attrib_name] = type;
      }
    }
    return h;
  }
  static attribType(object, attribName) {
    const val = this.attribValue(object, attribName);
    if (CoreType.isString(val)) {
      return AttribType.STRING;
    } else {
      return AttribType.NUMERIC;
    }
  }
  attribType(attribName) {
    return this.constructor.attribType(this._object, attribName);
  }
  attribSizes() {
    const h = {};
    const attribNames = this.attribNames();
    for (const attribName of attribNames) {
      const size = this.attribSize(attribName);
      if (size != null) {
        h[attribName] = size;
      }
    }
    return h;
  }
  static attribSize(object, attribName) {
    const val = this.attribValue(object, attribName);
    if (val == null) {
      return null;
    }
    return CoreAttribute.attribSizeFromValue(val);
  }
  attribSize(attribName) {
    return this.constructor.attribSize(this._object, attribName);
  }
  static objectData(object) {
    return objectData(object);
  }
  clone() {
    const clonedObject = this.constructor.clone(this._object);
    const cloned = new this.constructor(clonedObject, this._index);
    return cloned;
  }
  static clone(srcObject) {
    return srcObject.clone();
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    console.warn("applyMatrix.override required", this);
  }
  static mergeCompact(options) {
    console.warn("mergeCompact.override required", this);
  }
  //
  //
  // ENTITY GROUPS
  //
  //
  groupCollection() {
    return new EntityGroupCollection(this._object);
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedVertexIds(object, objectIndex, target4, traversedRelatedEntityData) {
    const ids = traversedRelatedEntityData ? traversedRelatedEntityData[AttribClass.PRIMITIVE].ids : _relatedPrimitiveIds2;
    this.relatedPrimitiveIds(object, objectIndex, ids, traversedRelatedEntityData);
    uniqRelatedEntityIds(
      ids,
      (primitiveId, relatedEntityIds) => {
        this.relatedPrimitiveClass(object).relatedVertexIds(object, primitiveId, relatedEntityIds);
      },
      target4
    );
  }
  static relatedPointIds(object, objectIndex, target4, traversedRelatedEntityData) {
    const ids = traversedRelatedEntityData ? traversedRelatedEntityData[AttribClass.VERTEX].ids : _relatedVertexIds2;
    this.relatedVertexIds(object, objectIndex, ids, traversedRelatedEntityData);
    uniqRelatedEntityIds(
      ids,
      (vertexId, relatedEntityIds) => {
        this.relatedVertexClass(object).relatedPointIds(object, vertexId, relatedEntityIds);
      },
      target4
    );
  }
  relatedEntities(attribClass, coreGroup, target4, traversedRelatedEntityData) {
    switch (attribClass) {
      case AttribClass.POINT: {
        this.relatedPoints(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.VERTEX: {
        this.relatedVertices(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.PRIMITIVE: {
        this.relatedPrimitives(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.OBJECT: {
        target4.length = 1;
        target4[0] = this;
        return;
      }
      case AttribClass.CORE_GROUP: {
        target4.length = 1;
        target4[0] = coreGroup;
        return;
      }
    }
    TypeAssert.unreachable(attribClass);
  }
  static relatedPointClass(object) {
    return this.relatedVertexClass(object).relatedPointClass(object);
  }
  static relatedVertexClass(object) {
    return this.relatedPrimitiveClass(object).relatedVertexClass(object);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/Transform.js
var TransformTargetType = ((TransformTargetType2) => {
  TransformTargetType2["OBJECT"] = "object";
  TransformTargetType2["GEOMETRY"] = "geometry";
  return TransformTargetType2;
})(TransformTargetType || {});
var TRANSFORM_TARGET_TYPES = [
  "geometry",
  "object"
  /* OBJECT */
];
var RotationOrder = ((RotationOrder2) => {
  RotationOrder2["XYZ"] = "XYZ";
  RotationOrder2["XZY"] = "XZY";
  RotationOrder2["YXZ"] = "YXZ";
  RotationOrder2["YZX"] = "YZX";
  RotationOrder2["ZYX"] = "ZYX";
  RotationOrder2["ZXY"] = "ZXY";
  return RotationOrder2;
})(RotationOrder || {});
var ROTATION_ORDERS = [
  "XYZ",
  "XZY",
  "YXZ",
  "YZX",
  "ZXY",
  "ZYX"
  /* ZYX */
];
var eulerArray = [0, 0, 0];
var _m = new Matrix4();
var _q = new Quaternion();
var _rotateDirOrigin = new Vector3();
var _rotateDirDest = new Vector3();
function rotateGeometry(geometry, dirOrigin, dirDest) {
  _rotateDirDest.copy(dirDest).normalize();
  _rotateDirOrigin.copy(dirOrigin).normalize();
  _q.setFromUnitVectors(_rotateDirOrigin, _rotateDirDest);
  _m.makeRotationFromQuaternion(_q);
  geometry.applyMatrix4(_m);
}
var CoreTransform = class {
  constructor() {
    this._translation_matrix = new Matrix4();
    this._translation_matrix_q = new Quaternion();
    this._translation_matrix_s = new Vector3(1, 1, 1);
    this._matrix = new Matrix4().identity();
    this._matrixQ = new Quaternion();
    this._matrixEuler = new Euler();
    this._matrixS = new Vector3();
  }
  static setParamsFromMatrix(matrix, node, options = {}) {
    let update_scale = options["scale"];
    if (update_scale == null) {
      update_scale = true;
    }
    matrix.decompose(
      this.set_params_from_matrix_position,
      this.set_params_from_matrix_quaternion,
      this.set_params_from_matrix_scale
    );
    this.set_params_from_matrix_euler.setFromQuaternion(this.set_params_from_matrix_quaternion);
    this.set_params_from_matrix_euler.toArray(eulerArray);
    this.set_params_from_matrix_rotation.fromArray(eulerArray);
    this.set_params_from_matrix_rotation.divideScalar(Math.PI / 180);
    this.set_params_from_matrix_position.toArray(this.set_params_from_matrix_t);
    this.set_params_from_matrix_rotation.toArray(this.set_params_from_matrix_r);
    this.set_params_from_matrix_scale.toArray(this.set_params_from_matrix_s);
    node.scene().batchUpdates(() => {
      node.params.set_vector3("t", this.set_params_from_matrix_t);
      node.params.set_vector3("r", this.set_params_from_matrix_r);
      node.params.set_vector3("s", this.set_params_from_matrix_s);
      if (update_scale) {
        node.params.set_float("scale", 1);
      }
    });
  }
  static setParamsFromObject(object, node) {
    object.position.toArray(this.set_params_from_object_position_array);
    object.rotation.toArray(this.set_params_from_object_rotation_array);
    this.set_params_from_object_rotation_deg.fromArray(this.set_params_from_object_rotation_array);
    this.set_params_from_object_rotation_deg.multiplyScalar(180 / Math.PI);
    this.set_params_from_object_rotation_deg.toArray(this.set_params_from_object_rotation_array);
    node.scene().batchUpdates(() => {
      node.params.set_vector3("t", this.set_params_from_object_position_array);
      node.params.set_vector3("r", this.set_params_from_object_rotation_array);
    });
  }
  translationMatrix(t) {
    this._translation_matrix.compose(t, this._translation_matrix_q, this._translation_matrix_s);
    return this._translation_matrix;
  }
  matrix(t, r, s, scale, rotationOrder) {
    this._matrixEuler.set(MathUtils.degToRad(r.x), MathUtils.degToRad(r.y), MathUtils.degToRad(r.z), rotationOrder);
    this._matrixQ.setFromEuler(this._matrixEuler);
    this._matrixS.copy(s).multiplyScalar(scale);
    this._matrix.compose(t, this._matrixQ, this._matrixS);
    return this._matrix;
  }
  static rotateObject(object, dirOrigin, dirDest) {
    _rotateDirDest.copy(dirDest).normalize();
    _rotateDirOrigin.copy(dirOrigin).normalize();
    _q.setFromUnitVectors(_rotateDirOrigin, _rotateDirDest);
    _m.makeRotationFromQuaternion(_q);
    object.matrix.multiply(_m);
    object.matrix.decompose(object.position, object.quaternion, object.scale);
  }
  static decomposeMatrix(object) {
    object.matrix.decompose(object.position, object.quaternion, object.scale);
  }
};
CoreTransform.set_params_from_matrix_position = new Vector3();
CoreTransform.set_params_from_matrix_quaternion = new Quaternion();
CoreTransform.set_params_from_matrix_scale = new Vector3();
CoreTransform.set_params_from_matrix_euler = new Euler();
CoreTransform.set_params_from_matrix_rotation = new Vector3();
CoreTransform.set_params_from_matrix_t = [0, 0, 0];
CoreTransform.set_params_from_matrix_r = [0, 0, 0];
CoreTransform.set_params_from_matrix_s = [0, 0, 0];
CoreTransform.set_params_from_object_position_array = [0, 0, 0];
CoreTransform.set_params_from_object_rotation_deg = new Vector3();
CoreTransform.set_params_from_object_rotation_array = [0, 0, 0];

// node_modules/@polygonjs/polygonjs/dist/src/core/TransformSpace.js
var ObjectTransformSpace = ((ObjectTransformSpace2) => {
  ObjectTransformSpace2["PARENT"] = "parent";
  ObjectTransformSpace2["LOCAL"] = "local";
  return ObjectTransformSpace2;
})(ObjectTransformSpace || {});
var ObjectTransformMode = ((ObjectTransformMode2) => {
  ObjectTransformMode2["SET"] = "set matrix";
  ObjectTransformMode2["MULT"] = "multiply matrix";
  return ObjectTransformMode2;
})(ObjectTransformMode || {});
var OBJECT_TRANSFORM_SPACES = [
  "parent",
  "local"
  /* LOCAL */
];
var OBJECT_TRANSFORM_MODES = [
  "set matrix",
  "multiply matrix"
  /* MULT */
];
var OBJECT_TRANSFORM_SPACE_MENU_ENTRIES = [
  { name: "parent", value: OBJECT_TRANSFORM_SPACES.indexOf(
    "parent"
    /* PARENT */
  ) },
  { name: "local", value: OBJECT_TRANSFORM_SPACES.indexOf(
    "local"
    /* LOCAL */
  ) }
];
function applyTransformWithSpaceToObject(object, matrix, transformSpace, transformMode) {
  switch (transformSpace) {
    case "parent": {
      if (isObject3D(object)) {
        object.updateMatrix();
        object.applyMatrix4(matrix);
        object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        object.applyMatrix4(matrix);
      }
      return;
    }
    case "local": {
      if (isObject3D(object)) {
        object.updateMatrix();
        if (transformMode == "set matrix") {
          object.matrix.copy(matrix);
        } else {
          object.matrix.multiply(matrix);
        }
        object.matrix.decompose(object.position, object.quaternion, object.scale);
      } else {
        object.applyMatrix4(matrix);
      }
      return;
    }
  }
  TypeAssert.unreachable(transformSpace);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/point/CorePoint.js
var _relatedPrimitiveIds3 = [];
function _warnOverloadRequired(functionName) {
  console.warn(`CorePoint.${functionName} needs to be overloaded`);
}
var CorePoint = class extends CoreEntityWithObject {
  // protected _object?: ObjectContent<T>;
  // constructor(object?: ObjectContent<T>, index?: number) {
  // 	super(object, index);
  // 	this._object = object;
  // }
  builder() {
    return void 0;
  }
  static addAttribute(object, attribName, attribute) {
    _warnOverloadRequired("addAttribute");
  }
  static entitiesCount(object) {
    return 0;
  }
  static attributes(object) {
    _warnOverloadRequired("attributes");
    return;
  }
  attributes() {
    return this.constructor.attributes(this._object);
  }
  static attribute(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    return attributes[attribName];
  }
  attribute(attribName) {
    return this.constructor.attribute(this._object, attribName);
  }
  static attribSize(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return -1;
    }
    attribName = CoreAttribute.remapName(attribName);
    return attributes[attribName].itemSize || 0;
  }
  attribSize(attribName) {
    return this.constructor.attribSize(this._object, attribName);
  }
  static hasAttribute(object, attribName) {
    const remappedName = CoreAttribute.remapName(attribName);
    return this.attributes(object) ? this.attributes(object)[remappedName] != null : false;
  }
  hasAttribute(attribName) {
    return this.constructor.hasAttribute(this._object, attribName);
  }
  //
  //
  // INDEXED ATTRIBUTES
  //
  //
  static userDataAttribs(object) {
    _warnOverloadRequired("userDataAttribs");
    return {};
  }
  userDataAttribs() {
    return this._object ? this.constructor.userDataAttribs(this._object) : {};
  }
  static userDataAttrib(object, attribName) {
    attribName = CoreAttribute.remapName(attribName);
    return this.userDataAttribs(object)[attribName];
  }
  userDataAttrib(name) {
    name = CoreAttribute.remapName(name);
    return this.userDataAttribs()[name];
  }
  static attributeNames(object) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return [];
    }
    return Object.keys(attributes);
  }
  static attributeNamesMatchingMask(object, masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.attributeNames(object));
  }
  static indexedAttributeNames(object) {
    return object ? Object.keys(this.userDataAttribs(object) || {}) : [];
  }
  indexedAttributeNames() {
    return this._object ? this.constructor.indexedAttributeNames(this._object) : [];
  }
  static isAttribIndexed(object, attribName) {
    attribName = CoreAttribute.remapName(attribName);
    return this.userDataAttrib(object, attribName) != null;
  }
  isAttribIndexed(name) {
    name = CoreAttribute.remapName(name);
    return this.userDataAttrib(name) != null;
  }
  static setIndexedAttributeValues(object, attribName, values) {
    this.userDataAttribs(object)[attribName] = values;
  }
  setIndexedAttributeValues(attribName, values) {
    return this.constructor.setIndexedAttributeValues(this._object, attribName, values);
  }
  static setIndexedAttribute(object, attribName, values, indices) {
    _warnOverloadRequired("setIndexedAttribute");
  }
  setIndexedAttribute(attribName, values, indices) {
    return this.constructor.setIndexedAttribute(this._object, attribName, values, indices);
  }
  //
  static indexedAttribValue(object, index, attribName) {
    const valueIndex = this.attribValueIndex(object, index, attribName);
    const values = this.userDataAttrib(object, attribName);
    return values ? values[valueIndex] : null;
  }
  indexedAttribValue(attribName) {
    return this.constructor.indexedAttribValue(this._object, this._index, attribName);
  }
  static stringAttribValue(object, index, attribName) {
    return this.indexedAttribValue(object, index, attribName);
  }
  stringAttribValue(attribName) {
    return this.indexedAttribValue(attribName);
  }
  static attribValueIndex(object, index, attribName) {
    _warnOverloadRequired("attribValueIndex");
    return 0;
  }
  attribValueIndex(attribName) {
    return this.constructor.attribValueIndex(this._object, this._index, attribName);
  }
  static attribType(object, attribName) {
    if (this.isAttribIndexed(object, attribName)) {
      return AttribType.STRING;
    } else {
      return AttribType.NUMERIC;
    }
  }
  attribType(attribName) {
    return this.constructor.attribType(this._object, attribName);
  }
  isStringAttribute(attribName) {
    return this.attribType(attribName) == AttribType.STRING;
  }
  setAttribIndex(attribName, newValueIndex) {
    const attribute = this.attribute(attribName);
    if (!attribute) {
      return;
    }
    const array = attribute.array;
    return array[this._index] = newValueIndex;
  }
  //
  //
  //
  //
  //
  static renameAttribute(object, oldName, newName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    const attribute = this.attribute(object, oldName);
    if (!attribute) {
      return;
    }
    attributes[newName] = attribute;
    delete attributes[oldName];
  }
  static deleteAttribute(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    delete attributes[attribName];
  }
  //
  //
  //
  //
  //
  static attribValue(object, index, attribName, target4) {
    if (attribName === Attribute.POINT_INDEX) {
      return index;
    } else {
      let componentName = null;
      let componentIndex = null;
      if (attribName[attribName.length - 2] === DOT) {
        componentName = attribName[attribName.length - 1];
        componentIndex = COMPONENT_INDICES[componentName];
        attribName = attribName.substring(0, attribName.length - 2);
      }
      const remapedName = CoreAttribute.remapName(attribName);
      const attrib = this.attribute(object, remapedName);
      if (attrib) {
        const { array } = attrib;
        if (this.isAttribIndexed(object, remapedName)) {
          return this.indexedAttribValue(object, index, remapedName);
        } else {
          const itemSize = attrib.itemSize;
          const startIndex = index * itemSize;
          if (componentIndex == null) {
            switch (itemSize) {
              case 1:
                return array[startIndex];
                break;
              case 2:
                target4 = target4 || new Vector2();
                target4.fromArray(array, startIndex);
                return target4;
                break;
              case 3:
                target4 = target4 || new Vector3();
                target4.fromArray(array, startIndex);
                return target4;
                break;
              case 4:
                target4 = target4 || new Vector4();
                target4.fromArray(array, startIndex);
                return target4;
                break;
              default:
                throw `size not valid (${itemSize})`;
            }
          } else {
            switch (itemSize) {
              case 1:
                return array[startIndex];
                break;
              default:
                return array[startIndex + componentIndex];
            }
          }
        }
      } else {
        const attributesDict = this.attributes() || {};
        const attribNames = Object.keys(attributesDict);
        const message = `attrib ${attribName} not found. availables are: ${attribNames.join(",")}`;
        console.warn(message);
        throw message;
      }
    }
  }
  attribValue(attribName, target4) {
    return this.constructor.attribValue(this._object, this._index, attribName, target4);
  }
  attribValueNumber(attribName) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return 0;
    }
    return attrib.array[this._index];
  }
  attribValueVector2(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 2);
    return target4;
  }
  attribValueVector3(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 3);
    return target4;
  }
  attribValueVector4(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 4);
    return target4;
  }
  position(target4) {
    _warnOverloadRequired("position");
    return target4;
  }
  setPosition(newPosition) {
    this.setAttribValueFromVector3(Attribute.POSITION, newPosition);
  }
  normal(target4) {
    _warnOverloadRequired("normal");
    return target4;
  }
  setNormal(newNormal) {
    return this.setAttribValueFromVector3(Attribute.NORMAL, newNormal);
  }
  static computeNormals(object) {
    _warnOverloadRequired("computeNormals");
  }
  setAttribValue(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    const array = attrib.array;
    const attribSize = attrib.itemSize;
    if (isArray(value)) {
      for (let i = 0; i < attribSize; i++) {
        array[this._index * attribSize + i] = value[i];
      }
      return;
    }
    switch (attribSize) {
      case 1:
        array[this._index] = value;
        break;
      case 2:
        const v2 = value;
        const i2 = this._index * 2;
        array[i2 + 0] = v2.x;
        array[i2 + 1] = v2.y;
        break;
      case 3:
        const isColor2 = value.r != null;
        const i3 = this._index * 3;
        if (isColor2) {
          const col = value;
          array[i3 + 0] = col.r;
          array[i3 + 1] = col.g;
          array[i3 + 2] = col.b;
        } else {
          const v3 = value;
          array[i3 + 0] = v3.x;
          array[i3 + 1] = v3.y;
          array[i3 + 2] = v3.z;
        }
        break;
      case 4:
        const v4 = value;
        const i4 = this._index * 4;
        array[i4 + 0] = v4.x;
        array[i4 + 1] = v4.y;
        array[i4 + 2] = v4.z;
        array[i4 + 3] = v4.w;
        break;
      default:
        console.warn(`CorePoint.setAttribValue does not yet allow attrib size ${attribSize}`);
        throw `attrib size ${attribSize} not implemented`;
    }
  }
  setAttribValueFromNumber(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    const array = attrib.array;
    array[this._index] = value;
  }
  setAttribValueFromVector2(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || this.isStringAttribute(attribName)) {
      return;
    }
    value.toArray(attrib.array, this._index * 2);
  }
  setAttribValueFromVector3(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || this.isStringAttribute(attribName)) {
      return;
    }
    value.toArray(attrib.array, this._index * 3);
  }
  setAttribValueFromVector4(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || this.isStringAttribute(attribName)) {
      return;
    }
    value.toArray(attrib.array, this._index * 4);
  }
  //
  static addAttributeFromAttribData(object, attribName, attribData) {
    switch (attribData.type()) {
      case AttribType.STRING:
        return console.log("TODO: to implement");
      case AttribType.NUMERIC:
        return this.addNumericAttribute(object, attribName, attribData.size());
    }
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    _warnOverloadRequired("addNumericAttribute");
  }
  //
  static markAttribAsNeedsUpdate(object, attribName) {
    _warnOverloadRequired("markAttribAsNeedsUpdate");
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedPrimitiveIds(object, pointIndex, target4, traversedRelatedEntityData) {
    const ids = traversedRelatedEntityData ? traversedRelatedEntityData[AttribClass.VERTEX].ids : _relatedPrimitiveIds3;
    this.relatedVertexIds(object, pointIndex, ids);
    uniqRelatedEntityIds(
      ids,
      (vertexId, relatedEntityIds) => {
        this.relatedVertexClass(object).relatedPrimitiveIds(object, vertexId, relatedEntityIds);
      },
      target4
    );
  }
  static relatedPrimitiveClass(object) {
    return this.relatedVertexClass(object).relatedPrimitiveClass(object);
  }
  static relatedObjectClass(object) {
    return this.relatedPrimitiveClass(object).relatedObjectClass(object);
  }
  relatedEntities(attribClass, coreGroup, target4, traversedRelatedEntityData) {
    switch (attribClass) {
      case AttribClass.POINT: {
        target4.length = 1;
        target4[0] = this;
        return;
      }
      case AttribClass.VERTEX: {
        return this.relatedVertices(target4, traversedRelatedEntityData);
      }
      case AttribClass.PRIMITIVE: {
        return this.relatedPrimitives(target4, traversedRelatedEntityData);
      }
      case AttribClass.OBJECT: {
        if (this._object) {
          target4.length = 1;
          target4[0] = coreObjectInstanceFactory(this._object);
        } else {
          target4.length = 0;
        }
        return;
      }
      case AttribClass.CORE_GROUP: {
        target4.length = 1;
        target4[0] = coreGroup;
        return;
      }
    }
    TypeAssert.unreachable(attribClass);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/quad/QuadCommon.js
var QUADObjectType = ((QUADObjectType2) => {
  QUADObjectType2["DEFAULT"] = "Quad";
  return QUADObjectType2;
})(QUADObjectType || {});
var QUAD_OBJECT_TYPES = [
  "Quad"
  /* DEFAULT */
];
var QUAD_OBJECT_TYPES_SET = new Set(QUAD_OBJECT_TYPES);
var QuadTriangulationAttribute = ((QuadTriangulationAttribute2) => {
  QuadTriangulationAttribute2["INNER_RADIUS"] = "innerRadius";
  QuadTriangulationAttribute2["OUTER_RADIUS"] = "outerRadius";
  return QuadTriangulationAttribute2;
})(QuadTriangulationAttribute || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/quad/QuadCoreType.js
function isQuadObject(o) {
  return QUAD_OBJECT_TYPES_SET.has(o.type);
}
function isQuadOrThreejsObject(o) {
  return isQuadObject(o) || isObject3D(o);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/GeometryUtils.js
function object3DHasGeometry(o) {
  return o.geometry != null;
}
function markedAsInstance(geometry) {
  return geometry.getAttribute(InstanceAttrib.POSITION) != null;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/CoreThreejsPointUtils.js
var dummyMesh = new Mesh();
function positionAttributeNameFromBufferGeometry(geometry) {
  return markedAsInstance(geometry) ? InstanceAttrib.POSITION : Attribute.POSITION;
}
function pointsCountFromBufferGeometry(geometry) {
  const attribName = positionAttributeNameFromBufferGeometry(geometry);
  if (!attribName) {
    return 0;
  }
  const positionAttribute = geometry.getAttribute(attribName);
  if (!positionAttribute) {
    return 0;
  }
  return positionAttribute.count;
}
function pointsFromBufferGeometry(geometry) {
  dummyMesh.geometry = geometry;
  const pointsCount = pointsCountFromBufferGeometry(geometry);
  const points = new Array(pointsCount);
  for (let i = 0; i < pointsCount; i++) {
    points[i] = new ThreejsPoint(dummyMesh, i);
  }
  return points;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/vertex/CoreVertex.js
function _warnOverloadRequired2(functionName) {
  console.warn(`CoreVertex.${functionName} needs to be overloaded`);
}
var CoreVertex = class extends CoreEntityWithObject {
  builder() {
    return void 0;
  }
  static addAttribute(object, attribName, attribute) {
    _warnOverloadRequired2("addAttribute");
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    _warnOverloadRequired2("addNumericAttribute");
  }
  static entitiesCount(object) {
    return 0;
  }
  static attributes(object) {
    _warnOverloadRequired2("attributes");
    return;
  }
  attributes() {
    return this.constructor.attributes(this._object);
  }
  static attribute(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    return attributes[attribName];
  }
  attribute(attribName) {
    return this.constructor.attribute(this._object, attribName);
  }
  static indexAttribute(object) {
    _warnOverloadRequired2("indexAttribute");
    return;
  }
  static setIndexAttribute(object, index) {
    console.warn("CoreVertex.setIndexAttribute needs to be overloaded");
    return;
  }
  static renameAttribute(object, oldName, newName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    const attribute = this.attribute(object, oldName);
    if (!attribute) {
      return;
    }
    attributes[newName] = attribute;
    delete attributes[oldName];
  }
  static deleteAttribute(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    delete attributes[attribName];
  }
  static attribSize(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return -1;
    }
    attribName = CoreAttribute.remapName(attribName);
    return attributes[attribName].itemSize || 0;
  }
  attribSize(attribName) {
    return this.constructor.attribSize(this._object, attribName);
  }
  static hasAttribute(object, attribName) {
    return this.attribute(object, attribName) != null;
  }
  hasAttribute(attribName) {
    return this.constructor.hasAttribute(this._object, attribName);
  }
  static attributeNames(object) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return [];
    }
    return Object.keys(attributes);
  }
  static attributeNamesMatchingMask(object, masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.attributeNames(object));
  }
  static attribValue(object, index, attribName, target4) {
    if (attribName === Attribute.VERTEX_INDEX) {
      return index;
    } else {
      let componentName = null;
      let componentIndex = null;
      if (attribName[attribName.length - 2] === DOT) {
        componentName = attribName[attribName.length - 1];
        componentIndex = COMPONENT_INDICES[componentName];
        attribName = attribName.substring(0, attribName.length - 2);
      }
      const remapedName = CoreAttribute.remapName(attribName);
      const attrib = this.attribute(object, remapedName);
      if (attrib) {
        const { array } = attrib;
        const itemSize = attrib.itemSize;
        const startIndex = index * itemSize;
        if (componentIndex == null) {
          switch (itemSize) {
            case 1:
              return array[startIndex];
              break;
            case 2:
              target4 = target4 || new Vector2();
              target4.fromArray(array, startIndex);
              return target4;
              break;
            case 3:
              target4 = target4 || new Vector3();
              target4.fromArray(array, startIndex);
              return target4;
              break;
            case 4:
              target4 = target4 || new Vector4();
              target4.fromArray(array, startIndex);
              return target4;
              break;
            default:
              throw `size not valid (${itemSize})`;
          }
        } else {
          switch (itemSize) {
            case 1:
              return array[startIndex];
              break;
            default:
              return array[startIndex + componentIndex];
          }
        }
      } else {
        const attributesDict = this.attributes() || {};
        const attribNames = Object.keys(attributesDict);
        const message = `attrib ${attribName} not found. availables are: ${attribNames.join(",")}`;
        console.warn(message);
        throw message;
      }
    }
  }
  attribValue(attribName, target4) {
    return this.constructor.attribValue(this._object, this._index, attribName, target4);
  }
  attribValueNumber(attribName) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return 0;
    }
    return attrib.array[this._index];
  }
  attribValueVector2(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 2);
    return target4;
  }
  attribValueVector3(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 3);
    return target4;
  }
  attribValueVector4(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 4);
    return target4;
  }
  static attribType(object, attribName) {
    const attribute = object ? this.attribute(object, attribName) : null;
    if (attribute && (attribute == null ? void 0 : attribute.isString) == true) {
      return AttribType.STRING;
    } else {
      return AttribType.NUMERIC;
    }
  }
  attribType(attribName) {
    return this.constructor.attribType(this._object, attribName);
  }
  static stringAttribValue(object, index, attribName) {
    return this.attribValue(object, index, attribName);
  }
  stringAttribValue(attribName) {
    return this.attribValue(attribName);
  }
  position(target4) {
    _warnOverloadRequired2("position");
    return target4;
  }
  setPosition(newPosition) {
    this.setAttribValueFromVector3(Attribute.POSITION, newPosition);
  }
  normal(target4) {
    _warnOverloadRequired2("normal");
    return target4;
  }
  setNormal(newNormal) {
    return this.setAttribValueFromVector3(Attribute.NORMAL, newNormal);
  }
  setAttribValue(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      console.warn(`no attribute ${attribName}`);
      return;
    }
    const array = attrib.array;
    const attribSize = attrib.itemSize;
    if (CoreType.isArray(value)) {
      for (let i = 0; i < attribSize; i++) {
        array[this._index * attribSize + i] = value[i];
      }
      return;
    }
    switch (attribSize) {
      case 1:
        array[this._index] = value;
        break;
      case 2:
        const v2 = value;
        const i2 = this._index * 2;
        array[i2 + 0] = v2.x;
        array[i2 + 1] = v2.y;
        break;
      case 3:
        const isColor2 = value.r != null;
        const i3 = this._index * 3;
        if (isColor2) {
          const col = value;
          array[i3 + 0] = col.r;
          array[i3 + 1] = col.g;
          array[i3 + 2] = col.b;
        } else {
          const v3 = value;
          array[i3 + 0] = v3.x;
          array[i3 + 1] = v3.y;
          array[i3 + 2] = v3.z;
        }
        break;
      case 4:
        const v4 = value;
        const i4 = this._index * 4;
        array[i4 + 0] = v4.x;
        array[i4 + 1] = v4.y;
        array[i4 + 2] = v4.z;
        array[i4 + 3] = v4.w;
        break;
      default:
        console.warn(`CoreVertex.setAttribValue does not yet allow attrib size ${attribSize}`);
        throw `attrib size ${attribSize} not implemented`;
    }
  }
  setAttribValueFromNumber(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    const array = attrib.array;
    array[this._index] = value;
  }
  setAttribValueFromVector2(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || attrib.isString == true) {
      return;
    }
    value.toArray(attrib.array, this._index * 2);
  }
  setAttribValueFromVector3(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || attrib.isString == true) {
      return;
    }
    value.toArray(attrib.array, this._index * 3);
  }
  setAttribValueFromVector4(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || attrib.isString == true) {
      return;
    }
    value.toArray(attrib.array, this._index * 4);
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedObjectClass(object) {
    return this.relatedPrimitiveClass(object).relatedObjectClass(object);
  }
  relatedEntities(attribClass, coreGroup, target4, traversedRelatedEntityData) {
    switch (attribClass) {
      case AttribClass.POINT: {
        this.relatedPoints(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.VERTEX: {
        target4.length = 1;
        target4[0] = this;
        return;
      }
      case AttribClass.PRIMITIVE: {
        this.relatedPrimitives(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.OBJECT: {
        this.relatedObjects(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.CORE_GROUP: {
        target4.length = 1;
        target4[0] = coreGroup;
        return;
      }
    }
    TypeAssert.unreachable(attribClass);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/vertex/CoreVertexUtils.js
function verticesCountFromObject(object) {
  const vertexClass = coreVertexClassFactory(object);
  return vertexClass.entitiesCount(object);
}
function verticesFromObject(object, target4) {
  const vertexClass = coreVertexClassFactory(object);
  const verticesCount = vertexClass.entitiesCount(object);
  target4.length = verticesCount;
  for (let i = 0; i < verticesCount; i++) {
    target4[i] = coreVertexInstanceFactory(object, i);
  }
  return target4;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsVertex.js
var target = {
  attributeAdded: false,
  values: []
};
var ThreejsVertex = class extends CoreVertex {
  constructor(object, index) {
    super(object, index);
    this._updateGeometry();
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    attributes[attribName] = attribute;
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    const verticesCount = this.entitiesCount(object);
    target.values = new Array(verticesCount * size);
    attributeNumericValues(object, verticesCountFromObject, size, defaultValue2, target);
    const attribute = {
      isString: false,
      array: target.values,
      itemSize: size
    };
    this.addAttribute(object, attribName, attribute);
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    if (!geometry.userData.vertexAttributes) {
      geometry.userData.vertexAttributes = {};
    }
    return geometry.userData.vertexAttributes;
  }
  static indexAttribute(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    return geometry.getIndex();
  }
  static setIndexAttribute(object, index) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    geometry.setIndex(index);
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count;
  }
  position(target22) {
    console.warn("CoreThreejsVertex.position not implemented");
    return target22;
  }
  normal(target22) {
    console.warn("CoreThreejsVertex.normal not implemented");
    return target22;
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedPrimitiveIds(object, pointIndex, target22) {
    target22.length = 1;
    const index = Math.floor(pointIndex / primitiveVerticesCountFactory(object));
    target22[0] = index;
  }
  // static override  relatedPrimitives<T extends CoreObjectType>(object:BaseCoreObject<T>,vertexIndex:number,target: CorePrimitive<T>[]): void {
  // 	this.relatedPrimitiveIds(object,vertexIndex,_ids)
  // 	target.length = _ids.length;
  // 	let i=0
  // 	for(const id of _ids){
  // 		target[i]=(primitiveInstanceFactory(object as any as Mesh,id)) as CorePrimitive<T>
  // 		i++
  // 	}
  // }
  // override relatedPrimitives<T extends CoreObjectType>(target: CorePrimitive<T>[]): void {
  // 	target.length = 0;
  // 	if (!this._object) {
  // 		return;
  // 	}
  // 	const index = Math.floor(this._index / primitiveVerticesCountFactory(this._object));
  // 	const primitive = primitiveInstanceFactory(this._object, index) as CorePrimitive<T> | undefined;
  // 	if (!primitive) {
  // 		return;
  // 	}
  // 	target.push(primitive);
  // }
  static relatedPointIds(object, pointIndex, target22) {
    target22.length = 0;
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const indexArray = index.array;
    const indexValue = indexArray[pointIndex];
    target22[0] = indexValue;
  }
  static relatedPointClass(object) {
    return ThreejsPoint;
  }
  static relatedPrimitiveClass(object) {
    return primitiveClassFactoryNonAbstract(object);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsPoint.js
var INDEX_ATTRIB_VALUES = "indexedAttribValues";
var target2 = {
  attributeAdded: false,
  values: []
};
var ThreejsPoint = class extends CorePoint {
  constructor(object, index) {
    super(object, index);
    this._updateGeometry();
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    geometry.setAttribute(attribName, attribute);
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    return geometry.attributes;
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    return pointsCountFromBufferGeometry(geometry);
  }
  static positionAttributeName(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return null;
    }
    return positionAttributeNameFromBufferGeometry(geometry);
  }
  static position(object, index, target22) {
    const geometry = object.geometry;
    if (!geometry) {
      return null;
    }
    const { array } = geometry.getAttribute(Attribute.POSITION);
    return target22.fromArray(array, index * 3);
  }
  position(target22) {
    if (!this._geometry) {
      return target22;
    }
    const { array } = this._geometry.getAttribute(Attribute.POSITION);
    return target22.fromArray(array, this._index * 3);
  }
  normal(target22) {
    if (!this._geometry) {
      return target22;
    }
    const { array } = this._geometry.getAttribute(Attribute.NORMAL);
    return target22.fromArray(array, this._index * 3);
  }
  static computeNormals(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return null;
    }
    geometry.computeVertexNormals();
  }
  static markAttribAsNeedsUpdate(object, attribName) {
    const geometry = object.geometry;
    if (!geometry) {
      return null;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return;
    }
    attribute.needsUpdate = true;
  }
  //
  //
  //
  //
  //
  static userDataAttribs(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return {};
    }
    return geometry.userData[INDEX_ATTRIB_VALUES] = geometry.userData[INDEX_ATTRIB_VALUES] || {};
  }
  static setIndexedAttribute(object, attribName, values, indices) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    this.setIndexedAttributeValues(object, attribName, values);
    geometry.setAttribute(attribName, new Int32BufferAttribute(indices, 1));
    geometry.getAttribute(attribName).needsUpdate = true;
  }
  static attribValueIndex(object, index, attribName) {
    if (this.isAttribIndexed(object, attribName)) {
      const geometry = object.geometry;
      if (geometry) {
        return geometry.getAttribute(attribName).array[index];
      }
    }
    return -1;
  }
  //
  //
  //
  //
  //
  static renameAttribute(object, oldName, newName) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    if (this.isAttribIndexed(object, oldName)) {
      this.userDataAttribs(object)[newName] = objectCloneDeep(this.userDataAttribs(object)[oldName]);
      delete this.userDataAttribs(object)[oldName];
    }
    const oldAttrib = geometry.getAttribute(oldName);
    geometry.setAttribute(newName, new Float32BufferAttribute(oldAttrib.array, oldAttrib.itemSize));
    return geometry.deleteAttribute(oldName);
  }
  static deleteAttribute(object, attribName) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    if (this.isAttribIndexed(object, attribName)) {
      delete this.userDataAttribs(object)[attribName];
    }
    return geometry.deleteAttribute(attribName);
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    attributeNumericValues(object, pointsCountFromObject, size, defaultValue2, target2);
    if (target2.attributeAdded) {
      if (markedAsInstance(geometry)) {
        const valuesAsTypedArray = new Float32Array(target2.values);
        geometry.setAttribute(attribName.trim(), new InstancedBufferAttribute(valuesAsTypedArray, size));
      } else {
        geometry.setAttribute(attribName.trim(), new Float32BufferAttribute(target2.values, size));
      }
    } else {
      console.warn(defaultValue2);
      throw `CoreThreejsPoint.addNumericAttrib error: no other default value allowed for now (default given: ${defaultValue2})`;
    }
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedVertexIds(object, pointIndex, target22, traversedRelatedEntityData) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const index = geometry.getIndex();
    if (!index) {
      return;
    }
    const indexArray = index.array;
    let i = 0;
    for (const indexValue of indexArray) {
      if (indexValue == pointIndex) {
        target22.push(i);
      }
      i++;
    }
  }
  static relatedVertexClass(object) {
    return ThreejsVertex;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Geometry.js
function cloneBufferGeometry(srcGeometry) {
  const clonedGeometry = srcGeometry.clone();
  if (srcGeometry.userData) {
    clonedGeometry.userData = objectCloneDeep(srcGeometry.userData);
  }
  return clonedGeometry;
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/code/configs/BaseParamConfig.js
var BaseParamConfig = class _BaseParamConfig {
  // private _texture_loader: CoreTextureLoader
  constructor(_type, _name, _defaultValue) {
    this._type = _type;
    this._name = _name;
    this._defaultValue = _defaultValue;
    if (_name == "" || _name == null) {
      throw new Error(`name must not be an empty string`);
    }
  }
  static fromParam(param) {
    return new _BaseParamConfig(param.type(), param.name(), param.defaultValue());
  }
  type() {
    return this._type;
  }
  name() {
    return this._name;
  }
  defaultValue() {
    return this._defaultValue;
  }
  paramOptions() {
    const callbackBound = this._callback.bind(this);
    switch (this._type) {
      case ParamType.NODE_PATH:
        return { callback: callbackBound, nodeSelection: { context: NodeContext.COP } };
      default:
        return { callback: callbackBound };
    }
  }
  applyToNode(node) {
    if (!node.params.has(this._name)) {
      return;
    }
    const param = node.params.get(this._name);
    if (!param) {
      return;
    }
    const additionalOptions = this.paramOptions();
    const additionalOptionNames = Object.keys(additionalOptions);
    for (const optionName of additionalOptionNames) {
      param.options.setOption(optionName, additionalOptions[optionName]);
    }
    this.executeCallback(node, param);
    if (param.type() == ParamType.NODE_PATH) {
      setTimeout(async () => {
        if (param.isDirty()) {
          await param.compute();
        }
        param.options.executeCallback();
      }, 200);
    }
  }
  executeCallback(node, param) {
    this._callback(node, param);
  }
  _callback(node, param) {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/utils/GLParamConfig.js
var GlParamConfig = class _GlParamConfig extends BaseParamConfig {
  constructor(_type, _name, _defaultValue, _uniformName) {
    super(_type, _name, _defaultValue);
    this._uniformName = _uniformName;
  }
  toJSON() {
    return {
      type: this._type,
      name: this._name,
      defaultValue: this._defaultValue,
      uniformName: this._uniformName
    };
  }
  static fromJSON(json) {
    return new _GlParamConfig(json.type, json.name, json.defaultValue, json.uniformName);
  }
  uniformName() {
    return this._uniformName;
  }
  uniform() {
    return this._uniform = this._uniform || this._createUniform();
  }
  _createUniform() {
    return _GlParamConfig.uniformByType(this._type);
  }
  _callback(node, param) {
    _GlParamConfig.callback(param, this.uniform());
  }
  static callback(param, uniform) {
    switch (param.type()) {
      case ParamType.RAMP:
        uniform.value = param.rampTexture();
        return;
      case ParamType.NODE_PATH:
        _GlParamConfig.setUniformValueFromTextureFromNodePathParam(param, uniform);
        return;
      default:
        uniform.value = param.value;
    }
  }
  // TODO: refactor that to use the default values map?
  static uniformByType(type) {
    switch (type) {
      case ParamType.BOOLEAN:
        return { value: 0 };
      case ParamType.BUTTON:
        return { value: 0 };
      case ParamType.COLOR:
        return { value: new Color(0, 0, 0) };
      case ParamType.FLOAT:
        return { value: 0 };
      case ParamType.FOLDER:
        return { value: 0 };
      case ParamType.INTEGER:
        return { value: 0 };
      case ParamType.NODE_PATH:
        return { value: 0 };
      case ParamType.PARAM_PATH:
        return { value: 0 };
      case ParamType.RAMP:
        return { value: null };
      case ParamType.STRING:
        return { value: null };
      case ParamType.VECTOR2:
        return { value: new Vector2(0, 0) };
      case ParamType.VECTOR3:
        return { value: new Vector3(0, 0, 0) };
      case ParamType.VECTOR4:
        return { value: new Vector4(0, 0, 0, 0) };
    }
    TypeAssert.unreachable(type);
  }
  // private static set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {
  // 	const found_node = param.found_node();
  // 	if (found_node) {
  // 		if (found_node.isDirty()) {
  // 			found_node.compute().then((container) => {
  // 				const texture = container.texture();
  // 				uniform.value = texture;
  // 			});
  // 		} else {
  // 			const container = found_node.containerController.container();
  // 			const texture = container.texture();
  // 			uniform.value = texture;
  // 		}
  // 	} else {
  // 		uniform.value = null;
  // 	}
  // }
  static async setUniformValueFromTextureFromNodePathParam(param, uniform) {
    if (param.isDirty()) {
      await param.compute();
    }
    const node = param.value.nodeWithContext(NodeContext.COP);
    if (node) {
      if (node.isDirty()) {
        await node.compute();
      }
      const container = node.containerController.container();
      const texture = container.texture();
      uniform.value = texture;
    } else {
      uniform.value = null;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/assemblers/materials/OnBeforeCompile.js
function assignUniformViaUserData(material, uniformName, newUniform) {
  const uniforms = MaterialUserDataUniforms.getUniforms(material);
  if (uniforms) {
    const currentUniform = uniforms[uniformName];
    if (currentUniform) {
      currentUniform.value = newUniform.value;
    } else {
      uniforms[uniformName] = newUniform;
    }
  } else {
    OnBeforeCompileDataHandler.addAdditionalTexture(material, uniformName, newUniform);
  }
}
var MaterialUserDataUniforms = class {
  static getUniforms(material) {
    var _a;
    return ((_a = material.userData) == null ? void 0 : _a.uniforms) || material.uniforms;
  }
  static setUniforms(material, uniforms) {
    material.userData.uniforms = uniforms;
  }
  static removeUniforms(material) {
    const uniforms = this.getUniforms(material);
    if (uniforms) {
      const userData = material.userData;
      delete userData["uniforms"];
    }
    return uniforms;
  }
};
function assignOnBeforeCompileDataAndFunction(scene, material, data) {
  OnBeforeCompileDataHandler.setData(material, data);
  material.onBeforeCompile = _createOnBeforeCompile(scene, material);
  const key = `${material.uuid}:${performance.now()}`;
  material.customProgramCacheKey = () => key;
}
function copyOnBeforeCompileData(scene, params) {
  const { src, dest, shareCustomUniforms } = params;
  const data = OnBeforeCompileDataHandler.getData(src);
  if (data) {
    let cloneData2 = function(data2) {
      const json = OnBeforeCompileDataConverter.toJSON(data2);
      return OnBeforeCompileDataConverter.fromJSON(json);
    };
    var cloneData = cloneData2;
    const newData = shareCustomUniforms ? data : cloneData2(data);
    assignOnBeforeCompileDataAndFunction(scene, dest, newData);
  }
}
function _createOnBeforeCompile(scene, material) {
  const onBeforeCompile = (shader) => {
    const data = OnBeforeCompileDataHandler.getData(material);
    if (!data) {
      return;
    }
    const {
      vertexShader,
      fragmentShader,
      paramConfigs,
      additionalTextureUniforms,
      timeDependent,
      resolutionDependent,
      raymarchingLightsWorldCoordsDependent
    } = data;
    shader.vertexShader = vertexShader;
    shader.fragmentShader = fragmentShader;
    scene.uniformsController.addUniforms(shader.uniforms, {
      paramConfigs,
      additionalTextureUniforms,
      timeDependent,
      resolutionDependent,
      raymarchingLightsWorldCoordsDependent
    });
    const shaderMaterial = material;
    shaderMaterial.vertexShader = shader.vertexShader;
    shaderMaterial.fragmentShader = shader.fragmentShader;
    MaterialUserDataUniforms.setUniforms(material, shader.uniforms);
  };
  return onBeforeCompile;
}
var OnBeforeCompileDataHandler = class {
  static setData(material, data) {
    material.userData.onBeforeCompileData = data;
  }
  static addAdditionalTexture(material, uniformName, newUniform) {
    const data = this.getData(material);
    if (data) {
      const currentUniform = data.additionalTextureUniforms[uniformName];
      if (currentUniform == null) {
        data.additionalTextureUniforms[uniformName] = newUniform;
      }
    } else {
      console.warn("no data found on material", material);
    }
  }
  static getData(material) {
    return material.userData.onBeforeCompileData;
  }
  static removeData(material) {
    const data = this.getData(material);
    if (data) {
      const userData = material.userData;
      delete userData["onBeforeCompileData"];
    }
    return data;
  }
};
var OnBeforeCompileDataConverter = class {
  static toJSON(onBeforeCompileData) {
    const onBeforeCompileDataJSON = {
      vertexShader: onBeforeCompileData.vertexShader,
      fragmentShader: onBeforeCompileData.fragmentShader,
      timeDependent: onBeforeCompileData.timeDependent,
      resolutionDependent: onBeforeCompileData.resolutionDependent,
      raymarchingLightsWorldCoordsDependent: onBeforeCompileData.raymarchingLightsWorldCoordsDependent,
      paramConfigs: onBeforeCompileData.paramConfigs.map((pc) => pc.toJSON())
    };
    return onBeforeCompileDataJSON;
  }
  static fromJSON(json) {
    const onBeforeCompileData = {
      ...json,
      additionalTextureUniforms: {},
      paramConfigs: json.paramConfigs.map((json2) => GlParamConfig.fromJSON(json2))
    };
    return onBeforeCompileData;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Material.js
var CustomMaterialName = ((CustomMaterialName2) => {
  CustomMaterialName2["DISTANCE"] = "customDistanceMaterial";
  CustomMaterialName2["DEPTH"] = "customDepthMaterial";
  CustomMaterialName2["DEPTH_DOF"] = "customDepthDOFMaterial";
  return CustomMaterialName2;
})(CustomMaterialName || {});
var RENDER_HOOK_USER_DATA_KEY = "POLY_render_hook";
var EMPTY_RENDER_HOOK = (renderer, scene, camera, geometry, material, group) => {
};
function cloneMaterial(scene, srcMaterial, options) {
  const clonedMaterial = srcMaterial.clone();
  const srcUniforms = srcMaterial.uniforms;
  if (srcUniforms) {
    clonedMaterial.uniforms = UniformsUtils.clone(srcUniforms);
  }
  copyOnBeforeCompileData(scene, {
    src: srcMaterial,
    dest: clonedMaterial,
    shareCustomUniforms: options.shareCustomUniforms
  });
  if (srcMaterial.customMaterials && options.addCustomMaterials) {
    const customNames = Object.keys(srcMaterial.customMaterials);
    if (customNames.length > 0) {
      clonedMaterial.customMaterials = {};
    }
    for (const customName of customNames) {
      const matName = customName;
      const customMaterial = srcMaterial.customMaterials[matName];
      if (customMaterial) {
        const clonedCustomMaterial = cloneMaterial(scene, customMaterial, {
          ...options,
          addCustomMaterials: false
        });
        clonedMaterial.customMaterials[matName] = clonedCustomMaterial;
      }
    }
  }
  return clonedMaterial;
}
function applyCustomMaterials(object, material) {
  const materialWithCustom = material;
  if (materialWithCustom.customMaterials) {
    for (const customName of Object.keys(materialWithCustom.customMaterials)) {
      const matName = customName;
      const customMaterial = materialWithCustom.customMaterials[matName];
      if (customMaterial) {
        object[matName] = customMaterial;
        customMaterial.needsUpdate = true;
      }
    }
  }
}
function applyRenderHook(object, material) {
  if (material.userData) {
    const renderHook = material.userData[RENDER_HOOK_USER_DATA_KEY];
    if (renderHook) {
      object.onBeforeRender = (renderer, scene, camera, geometry, material2, group) => {
        renderHook(renderer, scene, camera, geometry, material2, group, object);
      };
      return;
    }
  }
  object.onBeforeRender = EMPTY_RENDER_HOOK;
}
function assignUniforms(mat, uniformName, uniform, assembler) {
  assignUniformViaUserData(mat, uniformName, uniform);
  if (assembler) {
    assignUniformForOnBeforeCompile(mat, uniformName, uniform, assembler);
  }
}
function assignUniformForOnBeforeCompile(mat, uniformName, uniform, assembler) {
  assembler.addAdditionalTextureUniforms(uniformName, uniform);
}
var CoreMaterial = class {
  static node(scene, material) {
    return scene.node(material.name);
  }
};
CoreMaterial.clone = cloneMaterial;
CoreMaterial.applyCustomMaterials = applyCustomMaterials;
CoreMaterial.assignUniforms = assignUniforms;
CoreMaterial.assignUniformForOnBeforeCompile = assignUniformForOnBeforeCompile;

// node_modules/three/build/three.module.js
var REVISION = "158";
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide2 = 0;
var BackSide = 1;
var DoubleSide = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var ConstantColorFactor = 211;
var OneMinusConstantColorFactor = 212;
var ConstantAlphaFactor = 213;
var OneMinusConstantAlphaFactor = 214;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType2 = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBAFormat2 = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var RGB_BPTC_SIGNED_Format = 36494;
var RGB_BPTC_UNSIGNED_Format = 36495;
var RED_RGTC1_Format = 36283;
var SIGNED_RED_RGTC1_Format = 36284;
var RED_GREEN_RGTC2_Format = 36285;
var SIGNED_RED_GREEN_RGTC2_Format = 36286;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var LinearEncoding = 3e3;
var sRGBEncoding = 3001;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var NoColorSpace = "";
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var DisplayP3ColorSpace = "display-p3";
var LinearDisplayP3ColorSpace = "display-p3-linear";
var LinearTransfer = "linear";
var SRGBTransfer = "srgb";
var Rec709Primaries = "rec709";
var P3Primaries = "p3";
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var NeverCompare = 512;
var LessCompare = 513;
var EqualCompare = 514;
var LessEqualCompare = 515;
var GreaterCompare = 516;
var NotEqualCompare = 517;
var GreaterEqualCompare = 518;
var AlwaysCompare = 519;
var StaticDrawUsage = 35044;
var GLSL3 = "300 es";
var _SRGBAFormat = 1035;
var WebGLCoordinateSystem = 2e3;
var WebGPUCoordinateSystem = 2001;
var EventDispatcher2 = class {
  addEventListener(type, listener) {
    if (this._listeners === void 0)
      this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0)
      return false;
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0)
      return;
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n, m) {
  return (n % m + m) % m;
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var Vector22 = class _Vector2 {
  constructor(x = 0, y = 0) {
    _Vector2.prototype.isVector2 = true;
    this.x = x;
    this.y = y;
  }
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  set(x, y) {
    this.x = x;
    this.y = y;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6];
    this.y = e[1] * x + e[4] * y + e[7];
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y;
  }
  cross(v) {
    return this.x * v.y - this.y * v.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y;
    return dx * dx + dy * dy;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle), s = Math.sin(angle);
    const x = this.x - center.x;
    const y = this.y - center.y;
    this.x = x * c - y * s + center.x;
    this.y = x * s + y * c + center.y;
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
var Matrix3 = class _Matrix3 {
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    _Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements;
    te[0] = n11;
    te[1] = n21;
    te[2] = n31;
    te[3] = n12;
    te[4] = n22;
    te[5] = n32;
    te[6] = n13;
    te[7] = n23;
    te[8] = n33;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  setFromMatrix4(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[4],
      me[8],
      me[1],
      me[5],
      me[9],
      me[2],
      me[6],
      me[10]
    );
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[3], a13 = ae[6];
    const a21 = ae[1], a22 = ae[4], a23 = ae[7];
    const a31 = ae[2], a32 = ae[5], a33 = ae[8];
    const b11 = be[0], b12 = be[3], b13 = be[6];
    const b21 = be[1], b22 = be[4], b23 = be[7];
    const b31 = be[2], b32 = be[5], b33 = be[8];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[3] *= s;
    te[6] *= s;
    te[1] *= s;
    te[4] *= s;
    te[7] *= s;
    te[2] *= s;
    te[5] *= s;
    te[8] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n31 * n23 - n33 * n21) * detInv;
    te[2] = (n32 * n21 - n31 * n22) * detInv;
    te[3] = t12 * detInv;
    te[4] = (n33 * n11 - n31 * n13) * detInv;
    te[5] = (n31 * n12 - n32 * n11) * detInv;
    te[6] = t13 * detInv;
    te[7] = (n21 * n13 - n23 * n11) * detInv;
    te[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  transpose() {
    let tmp6;
    const m = this.elements;
    tmp6 = m[1];
    m[1] = m[3];
    m[3] = tmp6;
    tmp6 = m[2];
    m[2] = m[6];
    m[6] = tmp6;
    tmp6 = m[5];
    m[5] = m[7];
    m[7] = tmp6;
    return this;
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  transposeIntoArray(r) {
    const m = this.elements;
    r[0] = m[0];
    r[1] = m[3];
    r[2] = m[6];
    r[3] = m[1];
    r[4] = m[4];
    r[5] = m[7];
    r[6] = m[2];
    r[7] = m[5];
    r[8] = m[8];
    return this;
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation);
    const s = Math.sin(rotation);
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  //
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  makeTranslation(x, y) {
    if (x.isVector2) {
      this.set(
        1,
        0,
        x.x,
        0,
        1,
        x.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x,
        0,
        1,
        y,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotation(theta) {
    const c = Math.cos(theta);
    const s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      s,
      c,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y) {
    this.set(
      x,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      1
    );
    return this;
  }
  //
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    return array;
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var _m3 = new Matrix3();
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] >= 65535)
      return true;
  }
  return false;
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
var _cache = {};
function warnOnce(message) {
  if (message in _cache)
    return;
  _cache[message] = true;
  console.warn(message);
}
var LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = new Matrix3().set(
  0.8224621,
  0.177538,
  0,
  0.0331941,
  0.9668058,
  0,
  0.0170827,
  0.0723974,
  0.9105199
);
var LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = new Matrix3().set(
  1.2249401,
  -0.2249404,
  0,
  -0.0420569,
  1.0420571,
  0,
  -0.0196376,
  -0.0786361,
  1.0982735
);
var COLOR_SPACES = {
  [LinearSRGBColorSpace]: {
    transfer: LinearTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color,
    fromReference: (color) => color
  },
  [SRGBColorSpace]: {
    transfer: SRGBTransfer,
    primaries: Rec709Primaries,
    toReference: (color) => color.convertSRGBToLinear(),
    fromReference: (color) => color.convertLinearToSRGB()
  },
  [LinearDisplayP3ColorSpace]: {
    transfer: LinearTransfer,
    primaries: P3Primaries,
    toReference: (color) => color.applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3)
  },
  [DisplayP3ColorSpace]: {
    transfer: SRGBTransfer,
    primaries: P3Primaries,
    toReference: (color) => color.convertSRGBToLinear().applyMatrix3(LINEAR_DISPLAY_P3_TO_LINEAR_SRGB),
    fromReference: (color) => color.applyMatrix3(LINEAR_SRGB_TO_LINEAR_DISPLAY_P3).convertLinearToSRGB()
  }
};
var SUPPORTED_WORKING_COLOR_SPACES = /* @__PURE__ */ new Set([LinearSRGBColorSpace, LinearDisplayP3ColorSpace]);
var ColorManagement = {
  enabled: true,
  _workingColorSpace: LinearSRGBColorSpace,
  get legacyMode() {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    return !this.enabled;
  },
  set legacyMode(legacyMode) {
    console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150.");
    this.enabled = !legacyMode;
  },
  get workingColorSpace() {
    return this._workingColorSpace;
  },
  set workingColorSpace(colorSpace) {
    if (!SUPPORTED_WORKING_COLOR_SPACES.has(colorSpace)) {
      throw new Error(`Unsupported working color space, "${colorSpace}".`);
    }
    this._workingColorSpace = colorSpace;
  },
  convert: function(color, sourceColorSpace, targetColorSpace) {
    if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
      return color;
    }
    const sourceToReference = COLOR_SPACES[sourceColorSpace].toReference;
    const targetFromReference = COLOR_SPACES[targetColorSpace].fromReference;
    return targetFromReference(sourceToReference(color));
  },
  fromWorkingColorSpace: function(color, targetColorSpace) {
    return this.convert(color, this._workingColorSpace, targetColorSpace);
  },
  toWorkingColorSpace: function(color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this._workingColorSpace);
  },
  getPrimaries: function(colorSpace) {
    return COLOR_SPACES[colorSpace].primaries;
  },
  getTransfer: function(colorSpace) {
    if (colorSpace === NoColorSpace)
      return LinearTransfer;
    return COLOR_SPACES[colorSpace].transfer;
  }
};
function SRGBToLinear(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
var _canvas;
var ImageUtils = class {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0)
        _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    if (canvas.width > 2048 || canvas.height > 2048) {
      console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image);
      return canvas.toDataURL("image/jpeg", 0.6);
    } else {
      return canvas.toDataURL("image/png");
    }
  }
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data = imageData.data;
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data = image.data.slice(0);
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255);
        } else {
          data[i] = SRGBToLinear(data[i]);
        }
      }
      return {
        data,
        width: image.width,
        height: image.height
      };
    } else {
      console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
};
var _sourceId = 0;
var Source = class {
  constructor(data = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data;
    this.version = 0;
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data = this.data;
    if (data !== null) {
      let url;
      if (Array.isArray(data)) {
        url = [];
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image));
          } else {
            url.push(serializeImage(data[i]));
          }
        }
      } else {
        url = serializeImage(data);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
};
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      console.warn("THREE.Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var _textureId = 0;
var Texture2 = class _Texture extends EventDispatcher2 {
  constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat2, type = UnsignedByteType, anisotropy = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector22(0, 0);
    this.repeat = new Vector22(1, 1);
    this.center = new Vector22(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    if (typeof colorSpace === "string") {
      this.colorSpace = colorSpace;
    } else {
      warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
      this.colorSpace = colorSpace === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.userData = {};
    this.version = 0;
    this.onUpdate = null;
    this.isRenderTargetTexture = false;
    this.needsPMREMUpdate = false;
  }
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.6,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0)
      output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping)
      return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  get encoding() {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    return this.colorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set encoding(encoding) {
    warnOnce("THREE.Texture: Property .encoding has been replaced by .colorSpace.");
    this.colorSpace = encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
  }
};
Texture2.DEFAULT_IMAGE = null;
Texture2.DEFAULT_MAPPING = UVMapping;
Texture2.DEFAULT_ANISOTROPY = 1;
var Vector42 = class _Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    _Vector4.prototype.isVector4 = true;
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
  }
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  set(x, y, z, w) {
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setW(w) {
    this.w = w;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    this.w = v.w !== void 0 ? v.w : 1;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    this.w += v.w;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    this.w += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    this.w = a.w + b.w;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    this.w += v.w * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    this.w -= v.w;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    this.w -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    this.w = a.w - b.w;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    this.w *= v.w;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z, w = this.w;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w);
    const s = Math.sqrt(1 - q.w * q.w);
    if (s < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q.x / s;
      this.y = q.y / s;
      this.z = q.z / s;
    }
    return this;
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z;
    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0;
          y = 0.707106781;
          z = 0.707106781;
        } else {
          x = Math.sqrt(xx);
          y = xy / x;
          z = xz / x;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781;
          y = 0;
          z = 0.707106781;
        } else {
          y = Math.sqrt(yy);
          x = xy / y;
          z = yz / y;
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781;
          y = 0.707106781;
          z = 0;
        } else {
          z = Math.sqrt(zz);
          x = xz / z;
          y = yz / z;
        }
      }
      this.set(x, y, z, angle);
      return this;
    }
    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s) < 1e-3)
      s = 1;
    this.x = (m32 - m23) / s;
    this.y = (m13 - m31) / s;
    this.z = (m21 - m12) / s;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    this.w = Math.min(this.w, v.w);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    this.w = Math.max(this.w, v.w);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    this.w = Math.max(min.w, Math.min(max.w, this.w));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    this.w = Math.max(minVal, Math.min(maxVal, this.w));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    this.w += (v.w - this.w) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
var RenderTarget = class extends EventDispatcher2 {
  constructor(width = 1, height = 1, options = {}) {
    super();
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = 1;
    this.scissor = new Vector42(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector42(0, 0, width, height);
    const image = { width, height, depth: 1 };
    if (options.encoding !== void 0) {
      warnOnce("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      depthTexture: null,
      samples: 0
    }, options);
    this.texture = new Texture2(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.flipY = false;
    this.texture.generateMipmaps = options.generateMipmaps;
    this.texture.internalFormat = options.internalFormat;
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
  }
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      this.texture.image.width = width;
      this.texture.image.height = height;
      this.texture.image.depth = depth;
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.texture = source.texture.clone();
    this.texture.isRenderTargetTexture = true;
    const image = Object.assign({}, source.texture.image);
    this.texture.source = new Source(image);
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var WebGLRenderTarget = class extends RenderTarget {
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
};
var DataArrayTexture = class extends Texture2 {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Data3DTexture = class extends Texture2 {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Quaternion2 = class {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t === 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t;
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
        s = Math.sin(s * len) / sin;
        t = Math.sin(t * len) / sin;
      }
      const tDir = t * dir;
      x0 = x0 * s + x1 * tDir;
      y0 = y0 * s + y1 * tDir;
      z0 = z0 * s + z1 * tDir;
      w0 = w0 * s + w1 * tDir;
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f;
        y0 *= f;
        z0 *= f;
        w0 *= f;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  set(x, y, z, w) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._w = w;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  setFromEuler(euler, update) {
    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x / 2);
    const c2 = cos(y / 2);
    const c3 = cos(z / 2);
    const s1 = sin(x / 2);
    const s2 = sin(y / 2);
    const s3 = sin(z / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update !== false)
      this._onChangeCallback();
    return this;
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s = Math.sin(halfAngle);
    this._x = axis.x * s;
    this._y = axis.y * s;
    this._z = axis.z * s;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m) {
    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s;
      this._x = (m32 - m23) * s;
      this._y = (m13 - m31) * s;
      this._z = (m21 - m12) * s;
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s;
      this._x = 0.25 * s;
      this._y = (m12 + m21) / s;
      this._z = (m13 + m31) / s;
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s;
      this._x = (m12 + m21) / s;
      this._y = 0.25 * s;
      this._z = (m23 + m32) / s;
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s;
      this._x = (m13 + m31) / s;
      this._y = (m23 + m32) / s;
      this._z = 0.25 * s;
    }
    this._onChangeCallback();
    return this;
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1;
    if (r < Number.EPSILON) {
      r = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r;
    }
    return this.normalize();
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q);
    if (angle === 0)
      return this;
    const t = Math.min(1, step / angle);
    this.slerp(q, t);
    return this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
  }
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  normalize() {
    let l = this.length();
    if (l === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l = 1 / l;
      this._x = this._x * l;
      this._y = this._y * l;
      this._z = this._z * l;
      this._w = this._w * l;
    }
    this._onChangeCallback();
    return this;
  }
  multiply(q) {
    return this.multiplyQuaternions(this, q);
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this);
  }
  multiplyQuaternions(a, b) {
    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  slerp(qb, t) {
    if (t === 0)
      return this;
    if (t === 1)
      return this.copy(qb);
    const x = this._x, y = this._y, z = this._z, w = this._w;
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
    if (cosHalfTheta < 0) {
      this._w = -qb._w;
      this._x = -qb._x;
      this._y = -qb._y;
      this._z = -qb._z;
      cosHalfTheta = -cosHalfTheta;
    } else {
      this.copy(qb);
    }
    if (cosHalfTheta >= 1) {
      this._w = w;
      this._x = x;
      this._y = y;
      this._z = z;
      return this;
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t;
      this._w = s * w + t * this._w;
      this._x = s * x + t * this._x;
      this._y = s * y + t * this._y;
      this._z = s * z + t * this._z;
      this.normalize();
      this._onChangeCallback();
      return this;
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
    this._w = w * ratioA + this._w * ratioB;
    this._x = x * ratioA + this._x * ratioB;
    this._y = y * ratioA + this._y * ratioB;
    this._z = z * ratioA + this._z * ratioB;
    this._onChangeCallback();
    return this;
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t);
  }
  random() {
    const u1 = Math.random();
    const sqrt1u1 = Math.sqrt(1 - u1);
    const sqrtu1 = Math.sqrt(u1);
    const u2 = 2 * Math.PI * Math.random();
    const u3 = 2 * Math.PI * Math.random();
    return this.set(
      sqrt1u1 * Math.cos(u2),
      sqrtu1 * Math.sin(u3),
      sqrtu1 * Math.cos(u3),
      sqrt1u1 * Math.sin(u2)
    );
  }
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    return this;
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector32 = class _Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    _Vector3.prototype.isVector3 = true;
    this.x = x;
    this.y = y;
    this.z = z;
  }
  set(x, y, z) {
    if (z === void 0)
      z = this.z;
    this.x = x;
    this.y = y;
    this.z = z;
    return this;
  }
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  setX(x) {
    this.x = x;
    return this;
  }
  setY(y) {
    this.y = y;
    return this;
  }
  setZ(z) {
    this.z = z;
    return this;
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(v) {
    this.x = v.x;
    this.y = v.y;
    this.z = v.z;
    return this;
  }
  add(v) {
    this.x += v.x;
    this.y += v.y;
    this.z += v.z;
    return this;
  }
  addScalar(s) {
    this.x += s;
    this.y += s;
    this.z += s;
    return this;
  }
  addVectors(a, b) {
    this.x = a.x + b.x;
    this.y = a.y + b.y;
    this.z = a.z + b.z;
    return this;
  }
  addScaledVector(v, s) {
    this.x += v.x * s;
    this.y += v.y * s;
    this.z += v.z * s;
    return this;
  }
  sub(v) {
    this.x -= v.x;
    this.y -= v.y;
    this.z -= v.z;
    return this;
  }
  subScalar(s) {
    this.x -= s;
    this.y -= s;
    this.z -= s;
    return this;
  }
  subVectors(a, b) {
    this.x = a.x - b.x;
    this.y = a.y - b.y;
    this.z = a.z - b.z;
    return this;
  }
  multiply(v) {
    this.x *= v.x;
    this.y *= v.y;
    this.z *= v.z;
    return this;
  }
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x;
    this.y = a.y * b.y;
    this.z = a.z * b.z;
    return this;
  }
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  applyMatrix3(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[3] * y + e[6] * z;
    this.y = e[1] * x + e[4] * y + e[7] * z;
    this.z = e[2] * x + e[5] * y + e[8] * z;
    return this;
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize();
  }
  applyMatrix4(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
    return this;
  }
  applyQuaternion(q) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  transformDirection(m) {
    const x = this.x, y = this.y, z = this.z;
    const e = m.elements;
    this.x = e[0] * x + e[4] * y + e[8] * z;
    this.y = e[1] * x + e[5] * y + e[9] * z;
    this.z = e[2] * x + e[6] * y + e[10] * z;
    return this.normalize();
  }
  divide(v) {
    this.x /= v.x;
    this.y /= v.y;
    this.z /= v.z;
    return this;
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  min(v) {
    this.x = Math.min(this.x, v.x);
    this.y = Math.min(this.y, v.y);
    this.z = Math.min(this.z, v.z);
    return this;
  }
  max(v) {
    this.x = Math.max(this.x, v.x);
    this.y = Math.max(this.y, v.y);
    this.z = Math.max(this.z, v.z);
    return this;
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x));
    this.y = Math.max(min.y, Math.min(max.y, this.y));
    this.z = Math.max(min.z, Math.min(max.z, this.z));
    return this;
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x));
    this.y = Math.max(minVal, Math.min(maxVal, this.y));
    this.z = Math.max(minVal, Math.min(maxVal, this.z));
    return this;
  }
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
  }
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
  }
  // TODO lengthSquared?
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha;
    this.y += (v.y - this.y) * alpha;
    this.z += (v.z - this.z) * alpha;
    return this;
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  cross(v) {
    return this.crossVectors(this, v);
  }
  crossVectors(a, b) {
    const ax = a.x, ay = a.y, az = a.z;
    const bx = b.x, by = b.y, bz = b.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  projectOnVector(v) {
    const denominator = v.lengthSq();
    if (denominator === 0)
      return this.set(0, 0, 0);
    const scalar = v.dot(this) / denominator;
    return this.copy(v).multiplyScalar(scalar);
  }
  projectOnPlane(planeNormal) {
    _vector$b.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$b);
  }
  reflect(normal) {
    return this.sub(_vector$b.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
    if (denominator === 0)
      return Math.PI / 2;
    const theta = this.dot(v) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v));
  }
  distanceToSquared(v) {
    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
    return dx * dx + dy * dy + dz * dz;
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta);
    this.y = y;
    this.z = radius * Math.cos(theta);
    return this;
  }
  setFromMatrixPosition(m) {
    const e = m.elements;
    this.x = e[12];
    this.y = e[13];
    this.z = e[14];
    return this;
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length();
    const sy = this.setFromMatrixColumn(m, 1).length();
    const sz = this.setFromMatrixColumn(m, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4);
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3);
  }
  setFromEuler(e) {
    this.x = e._x;
    this.y = e._y;
    this.z = e._z;
    return this;
  }
  setFromColor(c) {
    this.x = c.r;
    this.y = c.g;
    this.z = c.b;
    return this;
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z;
  }
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  randomDirection() {
    const u = (Math.random() - 0.5) * 2;
    const t = Math.random() * Math.PI * 2;
    const f = Math.sqrt(1 - u ** 2);
    this.x = f * Math.cos(t);
    this.y = f * Math.sin(t);
    this.z = u;
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector$b = new Vector32();
var _quaternion$4 = new Quaternion2();
var Box32 = class {
  constructor(min = new Vector32(Infinity, Infinity, Infinity), max = new Vector32(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  setFromArray(array) {
    this.makeEmpty();
    for (let i = 0, il = array.length; i < il; i += 3) {
      this.expandByPoint(_vector$a.fromArray(array, i));
    }
    return this;
  }
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i = 0, il = attribute.count; i < il; i++) {
      this.expandByPoint(_vector$a.fromBufferAttribute(attribute, i));
    }
    return this;
  }
  setFromPoints(points) {
    this.makeEmpty();
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i]);
    }
    return this;
  }
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$a.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  getCenter(target4) {
    return this.isEmpty() ? target4.set(0, 0, 0) : target4.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(target4) {
    return this.isEmpty() ? target4.set(0, 0, 0) : target4.subVectors(this.max, this.min);
  }
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i = 0, l = positionAttribute.count; i < l; i++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i, _vector$a);
          } else {
            _vector$a.fromBufferAttribute(positionAttribute, i);
          }
          _vector$a.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$a);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$3.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$3.copy(geometry.boundingBox);
        }
        _box$3.applyMatrix4(object.matrixWorld);
        this.union(_box$3);
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise);
    }
    return this;
  }
  containsPoint(point) {
    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
  }
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  getParameter(point, target4) {
    return target4.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(box) {
    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$a);
    return _vector$a.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  intersectsTriangle(triangle4) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle4.a, _center);
    _v1$7.subVectors(triangle4.b, _center);
    _v2$4.subVectors(triangle4.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  clampPoint(point, target4) {
    return target4.copy(point).clamp(this.min, this.max);
  }
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$a).distanceTo(point);
  }
  getBoundingSphere(target4) {
    if (this.isEmpty()) {
      target4.makeEmpty();
    } else {
      this.getCenter(target4.center);
      target4.radius = this.getSize(_vector$a).length() * 0.5;
    }
    return target4;
  }
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty())
      this.makeEmpty();
    return this;
  }
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  applyMatrix4(matrix) {
    if (this.isEmpty())
      return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
};
var _points = [
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32(),
  new Vector32()
];
var _vector$a = new Vector32();
var _box$3 = new Box32();
var _v0$2 = new Vector32();
var _v1$7 = new Vector32();
var _v2$4 = new Vector32();
var _f0 = new Vector32();
var _f1 = new Vector32();
var _f2 = new Vector32();
var _center = new Vector32();
var _extents = new Vector32();
var _triangleNormal = new Vector32();
var _testAxis = new Vector32();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i);
    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false;
    }
  }
  return true;
}
var _box$2 = new Box32();
var _v1$6 = new Vector32();
var _v2$3 = new Vector32();
var Sphere2 = class {
  constructor(center = new Vector32(), radius = -1) {
    this.center = center;
    this.radius = radius;
  }
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$2.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(point, target4) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target4.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target4.sub(this.center).normalize();
      target4.multiplyScalar(this.radius).add(this.center);
    }
    return target4;
  }
  getBoundingBox(target4) {
    if (this.isEmpty()) {
      target4.makeEmpty();
      return target4;
    }
    target4.set(this.center, this.center);
    target4.expandByScalar(this.radius);
    return target4;
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$9 = new Vector32();
var _segCenter = new Vector32();
var _segDir = new Vector32();
var _diff = new Vector32();
var _edge1 = new Vector32();
var _edge2 = new Vector32();
var _normal$1 = new Vector32();
var Ray = class {
  constructor(origin = new Vector32(), direction = new Vector32(0, 0, -1)) {
    this.origin = origin;
    this.direction = direction;
  }
  set(origin, direction) {
    this.origin.copy(origin);
    this.direction.copy(direction);
    return this;
  }
  copy(ray2) {
    this.origin.copy(ray2.origin);
    this.direction.copy(ray2.direction);
    return this;
  }
  at(t, target4) {
    return target4.copy(this.origin).addScaledVector(this.direction, t);
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize();
    return this;
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$9));
    return this;
  }
  closestPointToPoint(point, target4) {
    target4.subVectors(point, this.origin);
    const directionDistance = target4.dot(this.direction);
    if (directionDistance < 0) {
      return target4.copy(this.origin);
    }
    return target4.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$9.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$9.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$9.distanceToSquared(point);
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  intersectSphere(sphere, target4) {
    _vector$9.subVectors(sphere.center, this.origin);
    const tca = _vector$9.dot(this.direction);
    const d2 = _vector$9.dot(_vector$9) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2)
      return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0)
      return null;
    if (t0 < 0)
      return this.at(t1, target4);
    return this.at(t0, target4);
  }
  intersectsSphere(sphere) {
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t >= 0 ? t : null;
  }
  intersectPlane(plane, target4) {
    const t = this.distanceToPlane(plane);
    if (t === null) {
      return null;
    }
    return this.at(t, target4);
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  intersectBox(box, target4) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx;
      tmax = (box.max.x - origin.x) * invdirx;
    } else {
      tmin = (box.max.x - origin.x) * invdirx;
      tmax = (box.min.x - origin.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry;
      tymax = (box.max.y - origin.y) * invdiry;
    } else {
      tymin = (box.max.y - origin.y) * invdiry;
      tymax = (box.min.y - origin.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax)
      return null;
    if (tymin > tmin || isNaN(tmin))
      tmin = tymin;
    if (tymax < tmax || isNaN(tmax))
      tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz;
      tzmax = (box.max.z - origin.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin.z) * invdirz;
      tzmax = (box.min.z - origin.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax)
      return null;
    if (tzmin > tmin || tmin !== tmin)
      tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax)
      tmax = tzmax;
    if (tmax < 0)
      return null;
    return this.at(tmin >= 0 ? tmin : tmax, target4);
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$9) !== null;
  }
  intersectTriangle(a, b, c, backfaceCulling, target4) {
    _edge1.subVectors(b, a);
    _edge2.subVectors(c, a);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign2;
    if (DdN > 0) {
      if (backfaceCulling)
        return null;
      sign2 = 1;
    } else if (DdN < 0) {
      sign2 = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a);
    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign2 * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target4);
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  equals(ray2) {
    return ray2.origin.equals(this.origin) && ray2.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix42 = class _Matrix4 {
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    _Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te = this.elements;
    te[0] = n11;
    te[4] = n12;
    te[8] = n13;
    te[12] = n14;
    te[1] = n21;
    te[5] = n22;
    te[9] = n23;
    te[13] = n24;
    te[2] = n31;
    te[6] = n32;
    te[10] = n33;
    te[14] = n34;
    te[3] = n41;
    te[7] = n42;
    te[11] = n43;
    te[15] = n44;
    return this;
  }
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  copy(m) {
    const te = this.elements;
    const me = m.elements;
    te[0] = me[0];
    te[1] = me[1];
    te[2] = me[2];
    te[3] = me[3];
    te[4] = me[4];
    te[5] = me[5];
    te[6] = me[6];
    te[7] = me[7];
    te[8] = me[8];
    te[9] = me[9];
    te[10] = me[10];
    te[11] = me[11];
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    te[15] = me[15];
    return this;
  }
  copyPosition(m) {
    const te = this.elements, me = m.elements;
    te[12] = me[12];
    te[13] = me[13];
    te[14] = me[14];
    return this;
  }
  setFromMatrix3(m) {
    const me = m.elements;
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  extractRotation(m) {
    const te = this.elements;
    const me = m.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
    te[0] = me[0] * scaleX;
    te[1] = me[1] * scaleX;
    te[2] = me[2] * scaleX;
    te[3] = 0;
    te[4] = me[4] * scaleY;
    te[5] = me[5] * scaleY;
    te[6] = me[6] * scaleY;
    te[7] = 0;
    te[8] = me[8] * scaleZ;
    te[9] = me[9] * scaleZ;
    te[10] = me[10] * scaleZ;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromEuler(euler) {
    const te = this.elements;
    const x = euler.x, y = euler.y, z = euler.z;
    const a = Math.cos(x), b = Math.sin(x);
    const c = Math.cos(y), d = Math.sin(y);
    const e = Math.cos(z), f = Math.sin(z);
    if (euler.order === "XYZ") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = -c * f;
      te[8] = d;
      te[1] = af + be * d;
      te[5] = ae - bf * d;
      te[9] = -b * c;
      te[2] = bf - ae * d;
      te[6] = be + af * d;
      te[10] = a * c;
    } else if (euler.order === "YXZ") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce + df * b;
      te[4] = de * b - cf;
      te[8] = a * d;
      te[1] = a * f;
      te[5] = a * e;
      te[9] = -b;
      te[2] = cf * b - de;
      te[6] = df + ce * b;
      te[10] = a * c;
    } else if (euler.order === "ZXY") {
      const ce = c * e, cf = c * f, de = d * e, df = d * f;
      te[0] = ce - df * b;
      te[4] = -a * f;
      te[8] = de + cf * b;
      te[1] = cf + de * b;
      te[5] = a * e;
      te[9] = df - ce * b;
      te[2] = -a * d;
      te[6] = b;
      te[10] = a * c;
    } else if (euler.order === "ZYX") {
      const ae = a * e, af = a * f, be = b * e, bf = b * f;
      te[0] = c * e;
      te[4] = be * d - af;
      te[8] = ae * d + bf;
      te[1] = c * f;
      te[5] = bf * d + ae;
      te[9] = af * d - be;
      te[2] = -d;
      te[6] = b * c;
      te[10] = a * c;
    } else if (euler.order === "YZX") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = bd - ac * f;
      te[8] = bc * f + ad;
      te[1] = f;
      te[5] = a * e;
      te[9] = -b * e;
      te[2] = -d * e;
      te[6] = ad * f + bc;
      te[10] = ac - bd * f;
    } else if (euler.order === "XZY") {
      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
      te[0] = c * e;
      te[4] = -f;
      te[8] = d * e;
      te[1] = ac * f + bd;
      te[5] = a * e;
      te[9] = ad * f - bc;
      te[2] = bc * f - ad;
      te[6] = b * e;
      te[10] = bd * f + ac;
    }
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[12] = 0;
    te[13] = 0;
    te[14] = 0;
    te[15] = 1;
    return this;
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one);
  }
  lookAt(eye, target4, up) {
    const te = this.elements;
    _z.subVectors(eye, target4);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te[0] = _x.x;
    te[4] = _y.x;
    te[8] = _z.x;
    te[1] = _x.y;
    te[5] = _y.y;
    te[9] = _z.y;
    te[2] = _x.z;
    te[6] = _y.z;
    te[10] = _z.z;
    return this;
  }
  multiply(m) {
    return this.multiplyMatrices(this, m);
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this);
  }
  multiplyMatrices(a, b) {
    const ae = a.elements;
    const be = b.elements;
    const te = this.elements;
    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  multiplyScalar(s) {
    const te = this.elements;
    te[0] *= s;
    te[4] *= s;
    te[8] *= s;
    te[12] *= s;
    te[1] *= s;
    te[5] *= s;
    te[9] *= s;
    te[13] *= s;
    te[2] *= s;
    te[6] *= s;
    te[10] *= s;
    te[14] *= s;
    te[3] *= s;
    te[7] *= s;
    te[11] *= s;
    te[15] *= s;
    return this;
  }
  determinant() {
    const te = this.elements;
    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
  }
  transpose() {
    const te = this.elements;
    let tmp6;
    tmp6 = te[1];
    te[1] = te[4];
    te[4] = tmp6;
    tmp6 = te[2];
    te[2] = te[8];
    te[8] = tmp6;
    tmp6 = te[6];
    te[6] = te[9];
    te[9] = tmp6;
    tmp6 = te[3];
    te[3] = te[12];
    te[12] = tmp6;
    tmp6 = te[7];
    te[7] = te[13];
    te[13] = tmp6;
    tmp6 = te[11];
    te[11] = te[14];
    te[14] = tmp6;
    return this;
  }
  setPosition(x, y, z) {
    const te = this.elements;
    if (x.isVector3) {
      te[12] = x.x;
      te[13] = x.y;
      te[14] = x.z;
    } else {
      te[12] = x;
      te[13] = y;
      te[14] = z;
    }
    return this;
  }
  invert() {
    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te[0] = t11 * detInv;
    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te[4] = t12 * detInv;
    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te[8] = t13 * detInv;
    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te[12] = t14 * detInv;
    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  scale(v) {
    const te = this.elements;
    const x = v.x, y = v.y, z = v.z;
    te[0] *= x;
    te[4] *= y;
    te[8] *= z;
    te[1] *= x;
    te[5] *= y;
    te[9] *= z;
    te[2] *= x;
    te[6] *= y;
    te[10] *= z;
    te[3] *= x;
    te[7] *= y;
    te[11] *= z;
    return this;
  }
  getMaxScaleOnAxis() {
    const te = this.elements;
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  makeTranslation(x, y, z) {
    if (x.isVector3) {
      this.set(
        1,
        0,
        0,
        x.x,
        0,
        1,
        0,
        x.y,
        0,
        0,
        1,
        x.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x,
        0,
        1,
        0,
        y,
        0,
        0,
        1,
        z,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  makeRotationX(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationY(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      0,
      s,
      0,
      0,
      1,
      0,
      0,
      -s,
      0,
      c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta), s = Math.sin(theta);
    this.set(
      c,
      -s,
      0,
      0,
      s,
      c,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle);
    const s = Math.sin(angle);
    const t = 1 - c;
    const x = axis.x, y = axis.y, z = axis.z;
    const tx = t * x, ty = t * y;
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeScale(x, y, z) {
    this.set(
      x,
      0,
      0,
      0,
      0,
      y,
      0,
      0,
      0,
      0,
      z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  compose(position, quaternion, scale) {
    const te = this.elements;
    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
    const x2 = x + x, y2 = y + y, z2 = z + z;
    const xx = x * x2, xy = x * y2, xz = x * z2;
    const yy = y * y2, yz = y * z2, zz = z * z2;
    const wx = w * x2, wy = w * y2, wz = w * z2;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te[0] = (1 - (yy + zz)) * sx;
    te[1] = (xy + wz) * sx;
    te[2] = (xz - wy) * sx;
    te[3] = 0;
    te[4] = (xy - wz) * sy;
    te[5] = (1 - (xx + zz)) * sy;
    te[6] = (yz + wx) * sy;
    te[7] = 0;
    te[8] = (xz + wy) * sz;
    te[9] = (yz - wx) * sz;
    te[10] = (1 - (xx + yy)) * sz;
    te[11] = 0;
    te[12] = position.x;
    te[13] = position.y;
    te[14] = position.z;
    te[15] = 1;
    return this;
  }
  decompose(position, quaternion, scale) {
    const te = this.elements;
    let sx = _v1$5.set(te[0], te[1], te[2]).length();
    const sy = _v1$5.set(te[4], te[5], te[6]).length();
    const sz = _v1$5.set(te[8], te[9], te[10]).length();
    const det = this.determinant();
    if (det < 0)
      sx = -sx;
    position.x = te[12];
    position.y = te[13];
    position.z = te[14];
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const x = 2 * near / (right - left);
    const y = 2 * near / (top - bottom);
    const a = (right + left) / (right - left);
    const b = (top + bottom) / (top - bottom);
    let c, d;
    if (coordinateSystem === WebGLCoordinateSystem) {
      c = -(far + near) / (far - near);
      d = -2 * far * near / (far - near);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      c = -far / (far - near);
      d = -far * near / (far - near);
    } else {
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = x;
    te[4] = 0;
    te[8] = a;
    te[12] = 0;
    te[1] = 0;
    te[5] = y;
    te[9] = b;
    te[13] = 0;
    te[2] = 0;
    te[6] = 0;
    te[10] = c;
    te[14] = d;
    te[3] = 0;
    te[7] = 0;
    te[11] = -1;
    te[15] = 0;
    return this;
  }
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {
    const te = this.elements;
    const w = 1 / (right - left);
    const h = 1 / (top - bottom);
    const p = 1 / (far - near);
    const x = (right + left) * w;
    const y = (top + bottom) * h;
    let z, zInv;
    if (coordinateSystem === WebGLCoordinateSystem) {
      z = (far + near) * p;
      zInv = -2 * p;
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      z = near * p;
      zInv = -1 * p;
    } else {
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
    }
    te[0] = 2 * w;
    te[4] = 0;
    te[8] = 0;
    te[12] = -x;
    te[1] = 0;
    te[5] = 2 * h;
    te[9] = 0;
    te[13] = -y;
    te[2] = 0;
    te[6] = 0;
    te[10] = zInv;
    te[14] = -z;
    te[3] = 0;
    te[7] = 0;
    te[11] = 0;
    te[15] = 1;
    return this;
  }
  equals(matrix) {
    const te = this.elements;
    const me = matrix.elements;
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i])
        return false;
    }
    return true;
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset];
    }
    return this;
  }
  toArray(array = [], offset = 0) {
    const te = this.elements;
    array[offset] = te[0];
    array[offset + 1] = te[1];
    array[offset + 2] = te[2];
    array[offset + 3] = te[3];
    array[offset + 4] = te[4];
    array[offset + 5] = te[5];
    array[offset + 6] = te[6];
    array[offset + 7] = te[7];
    array[offset + 8] = te[8];
    array[offset + 9] = te[9];
    array[offset + 10] = te[10];
    array[offset + 11] = te[11];
    array[offset + 12] = te[12];
    array[offset + 13] = te[13];
    array[offset + 14] = te[14];
    array[offset + 15] = te[15];
    return array;
  }
};
var _v1$5 = new Vector32();
var _m1$2 = new Matrix42();
var _zero = new Vector32(0, 0, 0);
var _one = new Vector32(1, 1, 1);
var _x = new Vector32();
var _y = new Vector32();
var _z = new Vector32();
var _matrix = new Matrix42();
var _quaternion$3 = new Quaternion2();
var Euler2 = class _Euler {
  constructor(x = 0, y = 0, z = 0, order = _Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
  }
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  set(x, y, z, order = this._order) {
    this._x = x;
    this._y = y;
    this._z = z;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements;
    const m11 = te[0], m12 = te[4], m13 = te[8];
    const m21 = te[1], m22 = te[5], m23 = te[9];
    const m31 = te[2], m32 = te[6], m33 = te[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true)
      this._onChangeCallback();
    return this;
  }
  setFromQuaternion(q, order, update) {
    _matrix.makeRotationFromQuaternion(q);
    return this.setFromRotationMatrix(_matrix, order, update);
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order);
  }
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0)
      this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
};
Euler2.DEFAULT_ORDER = "XYZ";
var Layers = class {
  constructor() {
    this.mask = 1 | 0;
  }
  set(channel) {
    this.mask = (1 << channel | 0) >>> 0;
  }
  enable(channel) {
    this.mask |= 1 << channel | 0;
  }
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  toggle(channel) {
    this.mask ^= 1 << channel | 0;
  }
  disable(channel) {
    this.mask &= ~(1 << channel | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  isEnabled(channel) {
    return (this.mask & (1 << channel | 0)) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = new Vector32();
var _q1 = new Quaternion2();
var _m1$1 = new Matrix42();
var _target = new Vector32();
var _position$3 = new Vector32();
var _scale$2 = new Vector32();
var _quaternion$2 = new Quaternion2();
var _xAxis = new Vector32(1, 0, 0);
var _yAxis = new Vector32(0, 1, 0);
var _zAxis = new Vector32(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var Object3D2 = class _Object3D extends EventDispatcher2 {
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = _Object3D.DEFAULT_UP.clone();
    const position = new Vector32();
    const rotation = new Euler2();
    const quaternion = new Quaternion2();
    const scale = new Vector32(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      modelViewMatrix: {
        value: new Matrix42()
      },
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix42();
    this.matrixWorld = new Matrix42();
    this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.userData = {};
  }
  onBeforeRender() {
  }
  onAfterRender() {
  }
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q);
    return this;
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m);
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q);
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x);
    } else {
      _target.set(x, y, z);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i]);
      }
      return this;
    }
    if (object === this) {
      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object);
      }
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
    } else {
      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
    }
    return this;
  }
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    this.add(object);
    object.updateWorldMatrix(false, true);
    return this;
  }
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  getObjectByProperty(name, value) {
    if (this[name] === value)
      return this;
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  getObjectsByProperty(name, value) {
    let result = [];
    if (this[name] === value)
      result.push(this);
    for (let i = 0, l = this.children.length; i < l; i++) {
      const childResult = this.children[i].getObjectsByProperty(name, value);
      if (childResult.length > 0) {
        result = result.concat(childResult);
      }
    }
    return result;
  }
  getWorldPosition(target4) {
    this.updateWorldMatrix(true, false);
    return target4.setFromMatrixPosition(this.matrixWorld);
  }
  getWorldQuaternion(target4) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target4, _scale$2);
    return target4;
  }
  getWorldScale(target4) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target4);
    return target4;
  }
  getWorldDirection(target4) {
    this.updateWorldMatrix(true, false);
    const e = this.matrixWorld.elements;
    return target4.set(e[8], e[9], e[10]).normalize();
  }
  raycast() {
  }
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback);
    }
  }
  traverseVisible(callback) {
    if (this.visible === false)
      return;
    callback(this);
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback);
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i = 0, l = children.length; i < l; i++) {
      const child = children[i];
      if (child.matrixWorldAutoUpdate === true || force === true) {
        child.updateMatrixWorld(force);
      }
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null && parent.matrixWorldAutoUpdate === true) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate)
      this.updateMatrix();
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix);
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i = 0, l = children.length; i < l; i++) {
        const child = children[i];
        if (child.matrixWorldAutoUpdate === true) {
          child.updateWorldMatrix(false, true);
        }
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "")
      object.name = this.name;
    if (this.castShadow === true)
      object.castShadow = true;
    if (this.receiveShadow === true)
      object.receiveShadow = true;
    if (this.visible === false)
      object.visible = false;
    if (this.frustumCulled === false)
      object.frustumCulled = false;
    if (this.renderOrder !== 0)
      object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0)
      object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false)
      object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON();
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries2 = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries2.length > 0)
        output.geometries = geometries2;
      if (materials.length > 0)
        output.materials = materials;
      if (textures.length > 0)
        output.textures = textures;
      if (images.length > 0)
        output.images = images;
      if (shapes.length > 0)
        output.shapes = shapes;
      if (skeletons.length > 0)
        output.skeletons = skeletons;
      if (animations.length > 0)
        output.animations = animations;
      if (nodes.length > 0)
        output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data = cache[key];
        delete data.metadata;
        values.push(data);
      }
      return values;
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D2.DEFAULT_UP = new Vector32(0, 1, 0);
Object3D2.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D2.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = new Vector32();
var _v1$3 = new Vector32();
var _v2$2 = new Vector32();
var _v3$1 = new Vector32();
var _vab = new Vector32();
var _vac = new Vector32();
var _vbc = new Vector32();
var _vap = new Vector32();
var _vbp = new Vector32();
var _vcp = new Vector32();
var warnedGetUV = false;
var Triangle2 = class _Triangle {
  constructor(a = new Vector32(), b = new Vector32(), c = new Vector32()) {
    this.a = a;
    this.b = b;
    this.c = c;
  }
  static getNormal(a, b, c, target4) {
    target4.subVectors(c, b);
    _v0$1.subVectors(a, b);
    target4.cross(_v0$1);
    const targetLengthSq = target4.lengthSq();
    if (targetLengthSq > 0) {
      return target4.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target4.set(0, 0, 0);
  }
  // static/instance method to calculate barycentric coordinates
  // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
  static getBarycoord(point, a, b, c, target4) {
    _v0$1.subVectors(c, a);
    _v1$3.subVectors(b, a);
    _v2$2.subVectors(point, a);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      return target4.set(-2, -1, -1);
    }
    const invDenom = 1 / denom;
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target4.set(1 - u - v, v, u);
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3$1);
    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target4) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return this.getInterpolation(point, p1, p2, p3, uv1, uv2, uv3, target4);
  }
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target4) {
    this.getBarycoord(point, p1, p2, p3, _v3$1);
    target4.setScalar(0);
    target4.addScaledVector(v1, _v3$1.x);
    target4.addScaledVector(v2, _v3$1.y);
    target4.addScaledVector(v3, _v3$1.z);
    return target4;
  }
  static isFrontFacing(a, b, c, direction) {
    _v0$1.subVectors(c, b);
    _v1$3.subVectors(a, b);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  set(a, b, c) {
    this.a.copy(a);
    this.b.copy(b);
    this.c.copy(c);
    return this;
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(triangle4) {
    this.a.copy(triangle4.a);
    this.b.copy(triangle4.b);
    this.c.copy(triangle4.c);
    return this;
  }
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  getMidpoint(target4) {
    return target4.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  getNormal(target4) {
    return _Triangle.getNormal(this.a, this.b, this.c, target4);
  }
  getPlane(target4) {
    return target4.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(point, target4) {
    return _Triangle.getBarycoord(point, this.a, this.b, this.c, target4);
  }
  getUV(point, uv1, uv2, uv3, target4) {
    if (warnedGetUV === false) {
      console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation().");
      warnedGetUV = true;
    }
    return _Triangle.getInterpolation(point, this.a, this.b, this.c, uv1, uv2, uv3, target4);
  }
  getInterpolation(point, v1, v2, v3, target4) {
    return _Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target4);
  }
  containsPoint(point) {
    return _Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  isFrontFacing(direction) {
    return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  closestPointToPoint(p, target4) {
    const a = this.a, b = this.b, c = this.c;
    let v, w;
    _vab.subVectors(b, a);
    _vac.subVectors(c, a);
    _vap.subVectors(p, a);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target4.copy(a);
    }
    _vbp.subVectors(p, b);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target4.copy(b);
    }
    const vc = d1 * d4 - d3 * d2;
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3);
      return target4.copy(a).addScaledVector(_vab, v);
    }
    _vcp.subVectors(p, c);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target4.copy(c);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6);
      return target4.copy(a).addScaledVector(_vac, w);
    }
    const va = d3 * d6 - d5 * d4;
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b);
      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target4.copy(b).addScaledVector(_vbc, w);
    }
    const denom = 1 / (va + vb + vc);
    v = vb * denom;
    w = vc * denom;
    return target4.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
  }
  equals(triangle4) {
    return triangle4.a.equals(this.a) && triangle4.b.equals(this.b) && triangle4.c.equals(this.c);
  }
};
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p, q, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p + (q - p) * 6 * t;
  if (t < 1 / 2)
    return q;
  if (t < 2 / 3)
    return p + (q - p) * 6 * (2 / 3 - t);
  return p;
}
var Color2 = class {
  constructor(r, g, b) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r, g, b);
  }
  set(r, g, b) {
    if (g === void 0 && b === void 0) {
      const value = r;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r, g, b);
    }
    return this;
  }
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r;
    this.g = g;
    this.b = b;
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {
    h = euclideanModulo(h, 1);
    s = clamp(s, 0, 1);
    l = clamp(l, 0, 1);
    if (s === 0) {
      this.r = this.g = this.b = l;
    } else {
      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
      const q = 2 * l - p;
      this.r = hue2rgb(q, p, h + 1 / 3);
      this.g = hue2rgb(q, p, h);
      this.b = hue2rgb(q, p, h - 1 / 3);
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace);
    return this;
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0)
        return;
      if (parseFloat(string) < 1) {
        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m;
    if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m[1];
      const components = m[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + style);
      }
    } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        console.warn("THREE.Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      console.warn("THREE.Color: Unknown color " + style);
    }
    return this;
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  getHSL(target4, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0);
          break;
        case g:
          hue = (b - r) / delta + 2;
          break;
        case b:
          hue = (r - g) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target4.h = hue;
    target4.s = saturation;
    target4.l = lightness;
    return target4;
  }
  getRGB(target4, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    target4.r = _color.r;
    target4.g = _color.g;
    target4.b = _color.b;
    return target4;
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
    const r = _color.r, g = _color.g, b = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
    }
    return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
  }
  offsetHSL(h, s, l) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
  }
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  addScalar(s) {
    this.r += s;
    this.g += s;
    this.b += s;
    return this;
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  multiplyScalar(s) {
    this.r *= s;
    this.g *= s;
    this.b *= s;
    return this;
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h = lerp(_hslA.h, _hslB.h, alpha);
    const s = lerp(_hslA.s, _hslB.s, alpha);
    const l = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h, s, l);
    return this;
  }
  setFromVector3(v) {
    this.r = v.x;
    this.g = v.y;
    this.b = v.z;
    return this;
  }
  applyMatrix3(m) {
    const r = this.r, g = this.g, b = this.b;
    const e = m.elements;
    this.r = e[0] * r + e[3] * g + e[6] * b;
    this.g = e[1] * r + e[4] * g + e[7] * b;
    this.b = e[2] * r + e[5] * g + e[8] * b;
    return this;
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b;
  }
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
var _color = new Color2();
Color2.NAMES = _colorKeywords;
var _materialId = 0;
var Material2 = class extends EventDispatcher2 {
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide2;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color2(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  onBuild() {
  }
  onBeforeRender() {
  }
  onBeforeCompile() {
  }
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(values) {
    if (values === void 0)
      return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data = {
      metadata: {
        version: 4.6,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (this.color && this.color.isColor)
      data.color = this.color.getHex();
    if (this.roughness !== void 0)
      data.roughness = this.roughness;
    if (this.metalness !== void 0)
      data.metalness = this.metalness;
    if (this.sheen !== void 0)
      data.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex();
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0)
      data.shininess = this.shininess;
    if (this.clearcoat !== void 0)
      data.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.iridescence !== void 0)
      data.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0)
      data.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0)
      data.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0)
      data.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture)
      data.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid;
      data.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid;
      data.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid;
      data.normalMapType = this.normalMapType;
      data.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data.displacementScale = this.displacementScale;
      data.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0)
        data.combine = this.combine;
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0)
      data.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0)
      data.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0)
      data.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity)
      data.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0)
      data.size = this.size;
    if (this.shadowSide !== null)
      data.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending)
      data.blending = this.blending;
    if (this.side !== FrontSide2)
      data.side = this.side;
    if (this.vertexColors === true)
      data.vertexColors = true;
    if (this.opacity < 1)
      data.opacity = this.opacity;
    if (this.transparent === true)
      data.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor)
      data.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor)
      data.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation)
      data.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null)
      data.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null)
      data.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null)
      data.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor)
      data.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0)
      data.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth)
      data.depthFunc = this.depthFunc;
    if (this.depthTest === false)
      data.depthTest = this.depthTest;
    if (this.depthWrite === false)
      data.depthWrite = this.depthWrite;
    if (this.colorWrite === false)
      data.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255)
      data.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc)
      data.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0)
      data.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255)
      data.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp)
      data.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp)
      data.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp)
      data.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true)
      data.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation;
    if (this.polygonOffset === true)
      data.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth;
    if (this.dashSize !== void 0)
      data.dashSize = this.dashSize;
    if (this.gapSize !== void 0)
      data.gapSize = this.gapSize;
    if (this.scale !== void 0)
      data.scale = this.scale;
    if (this.dithering === true)
      data.dithering = true;
    if (this.alphaTest > 0)
      data.alphaTest = this.alphaTest;
    if (this.alphaHash === true)
      data.alphaHash = true;
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = true;
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = true;
    if (this.forceSinglePass === true)
      data.forceSinglePass = true;
    if (this.wireframe === true)
      data.wireframe = true;
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round")
      data.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round")
      data.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true)
      data.flatShading = true;
    if (this.visible === false)
      data.visible = false;
    if (this.toneMapped === false)
      data.toneMapped = false;
    if (this.fog === false)
      data.fog = false;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n = srcPlanes.length;
      dstPlanes = new Array(n);
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
};
var MeshBasicMaterial = class extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color2(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
};
var _tables = _generateTables();
function _generateTables() {
  const buffer = new ArrayBuffer(4);
  const floatView = new Float32Array(buffer);
  const uint32View = new Uint32Array(buffer);
  const baseTable = new Uint32Array(512);
  const shiftTable = new Uint32Array(512);
  for (let i = 0; i < 256; ++i) {
    const e = i - 127;
    if (e < -27) {
      baseTable[i] = 0;
      baseTable[i | 256] = 32768;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else if (e < -14) {
      baseTable[i] = 1024 >> -e - 14;
      baseTable[i | 256] = 1024 >> -e - 14 | 32768;
      shiftTable[i] = -e - 1;
      shiftTable[i | 256] = -e - 1;
    } else if (e <= 15) {
      baseTable[i] = e + 15 << 10;
      baseTable[i | 256] = e + 15 << 10 | 32768;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    } else if (e < 128) {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 24;
      shiftTable[i | 256] = 24;
    } else {
      baseTable[i] = 31744;
      baseTable[i | 256] = 64512;
      shiftTable[i] = 13;
      shiftTable[i | 256] = 13;
    }
  }
  const mantissaTable = new Uint32Array(2048);
  const exponentTable = new Uint32Array(64);
  const offsetTable = new Uint32Array(64);
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13;
    let e = 0;
    while ((m & 8388608) === 0) {
      m <<= 1;
      e -= 8388608;
    }
    m &= ~8388608;
    e += 947912704;
    mantissaTable[i] = m | e;
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + (i - 1024 << 13);
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23;
  }
  exponentTable[31] = 1199570944;
  exponentTable[32] = 2147483648;
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + (i - 32 << 23);
  }
  exponentTable[63] = 3347054592;
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024;
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable
  };
}
var _vector$8 = new Vector32();
var _vector2$1 = new Vector22();
var BufferAttribute2 = class {
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRange = { offset: 0, count: -1 };
    this.gpuType = FloatType2;
    this.version = 0;
  }
  onUploadCallback() {
  }
  set needsUpdate(value) {
    if (value === true)
      this.version++;
  }
  setUsage(value) {
    this.usage = value;
    return this;
  }
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i];
    }
    return this;
  }
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2$1.fromBufferAttribute(this, i);
        _vector2$1.applyMatrix3(m);
        this.setXY(i, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector$8.fromBufferAttribute(this, i);
        _vector$8.applyMatrix3(m);
        this.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
      }
    }
    return this;
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$8.fromBufferAttribute(this, i);
      _vector$8.applyMatrix4(m);
      this.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$8.fromBufferAttribute(this, i);
      _vector$8.applyNormalMatrix(m);
      this.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector$8.fromBufferAttribute(this, i);
      _vector$8.transformDirection(m);
      this.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
    }
    return this;
  }
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized)
      value = denormalize(value, this.array);
    return value;
  }
  setComponent(index, component, value) {
    if (this.normalized)
      value = normalize(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  getX(index) {
    let x = this.array[index * this.itemSize];
    if (this.normalized)
      x = denormalize(x, this.array);
    return x;
  }
  setX(index, x) {
    if (this.normalized)
      x = normalize(x, this.array);
    this.array[index * this.itemSize] = x;
    return this;
  }
  getY(index) {
    let y = this.array[index * this.itemSize + 1];
    if (this.normalized)
      y = denormalize(y, this.array);
    return y;
  }
  setY(index, y) {
    if (this.normalized)
      y = normalize(y, this.array);
    this.array[index * this.itemSize + 1] = y;
    return this;
  }
  getZ(index) {
    let z = this.array[index * this.itemSize + 2];
    if (this.normalized)
      z = denormalize(z, this.array);
    return z;
  }
  setZ(index, z) {
    if (this.normalized)
      z = normalize(z, this.array);
    this.array[index * this.itemSize + 2] = z;
    return this;
  }
  getW(index) {
    let w = this.array[index * this.itemSize + 3];
    if (this.normalized)
      w = denormalize(w, this.array);
    return w;
  }
  setW(index, w) {
    if (this.normalized)
      w = normalize(w, this.array);
    this.array[index * this.itemSize + 3] = w;
    return this;
  }
  setXY(index, x, y) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    return this;
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
      z = normalize(z, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    return this;
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize;
    if (this.normalized) {
      x = normalize(x, this.array);
      y = normalize(y, this.array);
      z = normalize(z, this.array);
      w = normalize(w, this.array);
    }
    this.array[index + 0] = x;
    this.array[index + 1] = y;
    this.array[index + 2] = z;
    this.array[index + 3] = w;
    return this;
  }
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "")
      data.name = this.name;
    if (this.usage !== StaticDrawUsage)
      data.usage = this.usage;
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange;
    return data;
  }
};
var Uint16BufferAttribute = class extends BufferAttribute2 {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute2 {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
};
var Float32BufferAttribute2 = class extends BufferAttribute2 {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
};
var _id$2 = 0;
var _m1 = new Matrix42();
var _obj = new Object3D2();
var _offset = new Vector32();
var _box$1 = new Box32();
var _boxMorphTargets = new Box32();
var _vector$7 = new Vector32();
var BufferGeometry2 = class _BufferGeometry extends EventDispatcher2 {
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  getIndex() {
    return this.index;
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  getAttribute(name) {
    return this.attributes[name];
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z);
    this.applyMatrix4(_m1);
    return this;
  }
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  setFromPoints(points) {
    const position = [];
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i];
      position.push(point.x, point.y, point.z || 0);
    }
    this.setAttribute("position", new Float32BufferAttribute2(position, 3));
    return this;
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box32();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingBox.set(
        new Vector32(-Infinity, -Infinity, -Infinity),
        new Vector32(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _box$1.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(this.boundingBox.min, _box$1.min);
            this.boundingBox.expandByPoint(_vector$7);
            _vector$7.addVectors(this.boundingBox.max, _box$1.max);
            this.boundingBox.expandByPoint(_vector$7);
          } else {
            this.boundingBox.expandByPoint(_box$1.min);
            this.boundingBox.expandByPoint(_box$1.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere2();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this);
      this.boundingSphere.set(new Vector32(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$1.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$7.addVectors(_box$1.min, _boxMorphTargets.min);
            _box$1.expandByPoint(_vector$7);
            _vector$7.addVectors(_box$1.max, _boxMorphTargets.max);
            _box$1.expandByPoint(_vector$7);
          } else {
            _box$1.expandByPoint(_boxMorphTargets.min);
            _box$1.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$1.getCenter(center);
      let maxRadiusSq = 0;
      for (let i = 0, il = position.count; i < il; i++) {
        _vector$7.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector$7.fromBufferAttribute(morphAttribute, j);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j);
              _vector$7.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$7));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const indices = index.array;
    const positions = attributes.position.array;
    const normals = attributes.normal.array;
    const uvs = attributes.uv.array;
    const nVertices = positions.length / 3;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute2(new Float32Array(4 * nVertices), 4));
    }
    const tangents = this.getAttribute("tangent").array;
    const tan1 = [], tan2 = [];
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector32();
      tan2[i] = new Vector32();
    }
    const vA = new Vector32(), vB = new Vector32(), vC = new Vector32(), uvA = new Vector22(), uvB = new Vector22(), uvC = new Vector22(), sdir = new Vector32(), tdir = new Vector32();
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3);
      vB.fromArray(positions, b * 3);
      vC.fromArray(positions, c * 3);
      uvA.fromArray(uvs, a * 2);
      uvB.fromArray(uvs, b * 2);
      uvC.fromArray(uvs, c * 2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r))
        return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
      tan1[a].add(sdir);
      tan1[b].add(sdir);
      tan1[c].add(sdir);
      tan2[a].add(tdir);
      tan2[b].add(tdir);
      tan2[c].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: indices.length
      }];
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(
          indices[j + 0],
          indices[j + 1],
          indices[j + 2]
        );
      }
    }
    const tmp6 = new Vector32(), tmp22 = new Vector32();
    const n = new Vector32(), n2 = new Vector32();
    function handleVertex(v) {
      n.fromArray(normals, v * 3);
      n2.copy(n);
      const t = tan1[v];
      tmp6.copy(t);
      tmp6.sub(n.multiplyScalar(n.dot(t))).normalize();
      tmp22.crossVectors(n2, t);
      const test = tmp22.dot(tan2[v]);
      const w = test < 0 ? -1 : 1;
      tangents[v * 4] = tmp6.x;
      tangents[v * 4 + 1] = tmp6.y;
      tangents[v * 4 + 2] = tmp6.z;
      tangents[v * 4 + 3] = w;
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i];
      const start = group.start;
      const count = group.count;
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0]);
        handleVertex(indices[j + 1]);
        handleVertex(indices[j + 2]);
      }
    }
  }
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute2(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0);
        }
      }
      const pA = new Vector32(), pB = new Vector32(), pC = new Vector32();
      const nA = new Vector32(), nB = new Vector32(), nC = new Vector32();
      const cb = new Vector32(), ab = new Vector32();
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0);
          const vB = index.getX(i + 1);
          const vC = index.getX(i + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0);
          pB.fromBufferAttribute(positionAttribute, i + 1);
          pC.fromBufferAttribute(positionAttribute, i + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector$7.fromBufferAttribute(normals, i);
      _vector$7.normalize();
      normals.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i] * itemSize;
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute2(array2, itemSize, normalized);
    }
    if (this.index === null) {
      console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new _BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data.uuid = this.uuid;
    data.type = this.type;
    if (this.name !== "")
      data.name = this.name;
    if (Object.keys(this.userData).length > 0)
      data.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0)
          data[key] = parameters[key];
      }
      return data;
    }
    data.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data.data.attributes[key] = attribute.toJSON(data.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i];
        array.push(attribute.toJSON(data.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes;
      data.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius
      };
    }
    return data;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone(data));
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox4 = source.boundingBox;
    if (boundingBox4 !== null) {
      this.boundingBox = boundingBox4.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _inverseMatrix$3 = new Matrix42();
var _ray$3 = new Ray();
var _sphere$5 = new Sphere2();
var _sphereHitAt = new Vector32();
var _vA$1 = new Vector32();
var _vB$1 = new Vector32();
var _vC$1 = new Vector32();
var _tempA = new Vector32();
var _morphA = new Vector32();
var _uvA$1 = new Vector22();
var _uvB$1 = new Vector22();
var _uvC$1 = new Vector22();
var _normalA = new Vector32();
var _normalB = new Vector32();
var _normalC = new Vector32();
var _intersectionPoint = new Vector32();
var _intersectionPointWorld = new Vector32();
var Mesh2 = class extends Object3D2 {
  constructor(geometry = new BufferGeometry2(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m;
        }
      }
    }
  }
  getVertexPosition(index, target4) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target4.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i = 0, il = morphPosition.length; i < il; i++) {
        const influence = morphInfluences[i];
        const morphAttribute = morphPosition[i];
        if (influence === 0)
          continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target4), influence);
        }
      }
      target4.add(_morphA);
    }
    return target4;
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0)
      return;
    if (geometry.boundingSphere === null)
      geometry.computeBoundingSphere();
    _sphere$5.copy(geometry.boundingSphere);
    _sphere$5.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$5.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$5, _sphereHitAt) === null)
        return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2)
        return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false)
        return;
    }
    this._computeIntersections(raycaster, intersects2, _ray$3);
  }
  _computeIntersections(raycaster, intersects2, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j);
            const b = index.getX(j + 1);
            const c = index.getX(j + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i);
          const b = index.getX(i + 1);
          const c = index.getX(i + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j;
            const b = j + 1;
            const c = j + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects2.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i = start, il = end; i < il; i += 3) {
          const a = i;
          const b = i + 1;
          const c = i + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3);
            intersects2.push(intersection);
          }
        }
      }
    }
  }
};
function checkIntersection(object, material, raycaster, ray2, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray2.intersectTriangle(pA, pB, pC, material.side === FrontSide2, point);
  }
  if (intersect === null)
    return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far)
    return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray2, uv, uv1, normal, a, b, c) {
  object.getVertexPosition(a, _vA$1);
  object.getVertexPosition(b, _vB$1);
  object.getVertexPosition(c, _vC$1);
  const intersection = checkIntersection(object, material, raycaster, ray2, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    if (uv) {
      _uvA$1.fromBufferAttribute(uv, a);
      _uvB$1.fromBufferAttribute(uv, b);
      _uvC$1.fromBufferAttribute(uv, c);
      intersection.uv = Triangle2.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector22());
    }
    if (uv1) {
      _uvA$1.fromBufferAttribute(uv1, a);
      _uvB$1.fromBufferAttribute(uv1, b);
      _uvC$1.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle2.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector22());
      intersection.uv2 = intersection.uv1;
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle2.getInterpolation(_intersectionPoint, _vA$1, _vB$1, _vC$1, _normalA, _normalB, _normalC, new Vector32());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector32(),
      materialIndex: 0
    };
    Triangle2.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
  }
  return intersection;
}
var BoxGeometry = class _BoxGeometry extends BufferGeometry2 {
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector32();
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf;
          vector[u] = x * udir;
          vector[v] = y * vdir;
          vector[w] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u] = 0;
          vector[v] = 0;
          vector[w] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy;
          const b = numberOfVertices + ix + gridX1 * (iy + 1);
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u in src) {
    dst[u] = {};
    for (const p in src[u]) {
      const property = src[u][p];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u][p] = null;
        } else {
          dst[u][p] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u][p] = property.slice();
      } else {
        dst[u][p] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u = 0; u < uniforms.length; u++) {
    const tmp6 = cloneUniforms(uniforms[u]);
    for (const p in tmp6) {
      merged[p] = tmp6[p];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u = 0; u < src.length; u++) {
    dst.push(src[u].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  if (renderer.getRenderTarget() === null) {
    return renderer.outputColorSpace;
  }
  return ColorManagement.workingColorSpace;
}
var UniformsUtils2 = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material2 {
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      derivatives: false,
      // set to use derivatives
      fragDepth: false,
      // set to use fragment depth values
      drawBuffers: false,
      // set to use draw buffers
      shaderTextureLOD: false
      // set to use shader texture LOD
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.glslVersion = this.glslVersion;
    data.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0)
      data.defines = this.defines;
    data.vertexShader = this.vertexShader;
    data.fragmentShader = this.fragmentShader;
    data.lights = this.lights;
    data.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true)
        extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0)
      data.extensions = extensions;
    return data;
  }
};
var Camera = class extends Object3D2 {
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix42();
    this.projectionMatrix = new Matrix42();
    this.projectionMatrixInverse = new Matrix42();
    this.coordinateSystem = WebGLCoordinateSystem;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  getWorldDirection(target4) {
    return super.getWorldDirection(target4).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var PerspectiveCamera = class extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current .filmGauge.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Calculates the focal length from the current .fov and .filmGauge.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *
   * then for each monitor you would call it like this
   *
   *   const w = 1920;
   *   const h = 1080;
   *   const fullWidth = w * 3;
   *   const fullHeight = h * 2;
   *
   *   --A--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   *   --B--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   *   --C--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   *   --D--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   *   --E--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   *   --F--
   *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   *
   *   Note there is no reason monitors have to be the same size or in a grid.
   */
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0)
      left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.fov = this.fov;
    data.object.zoom = this.zoom;
    data.object.near = this.near;
    data.object.far = this.far;
    data.object.focus = this.focus;
    data.object.aspect = this.aspect;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    data.object.filmGauge = this.filmGauge;
    data.object.filmOffset = this.filmOffset;
    return data;
  }
};
var fov = -90;
var aspect = 1;
var CubeCamera = class extends Object3D2 {
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras)
      this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  update(renderer, scene) {
    if (this.parent === null)
      this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
};
var CubeTexture = class extends Texture2 {
  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    images = images !== void 0 ? images : [];
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    if (options.encoding !== void 0) {
      warnOnce("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace.");
      options.colorSpace = options.encoding === sRGBEncoding ? SRGBColorSpace : NoColorSpace;
    }
    this.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
    this.texture.isRenderTargetTexture = true;
    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;
    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;
  }
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh2(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  clear(renderer, color, depth, stencil) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i = 0; i < 6; i++) {
      renderer.setRenderTarget(this, i);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
var _vector1 = new Vector32();
var _vector2 = new Vector32();
var _normalMatrix = new Matrix3();
var Plane2 = class {
  constructor(normal = new Vector32(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z);
    this.constant = w;
    return this;
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a);
    return this;
  }
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  projectPoint(point, target4) {
    return target4.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  intersectLine(line, target4) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target4.copy(line.start);
      }
      return null;
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t < 0 || t > 1) {
      return null;
    }
    return target4.copy(line.start).addScaledVector(direction, t);
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  coplanarPoint(target4) {
    return target4.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _sphere$4 = new Sphere2();
var _vector$6 = new Vector32();
var Frustum = class {
  constructor(p0 = new Plane2(), p1 = new Plane2(), p2 = new Plane2(), p3 = new Plane2(), p4 = new Plane2(), p5 = new Plane2()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  copy(frustum) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i]);
    }
    return this;
  }
  setFromProjectionMatrix(m, coordinateSystem = WebGLCoordinateSystem) {
    const planes = this.planes;
    const me = m.elements;
    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
    if (coordinateSystem === WebGLCoordinateSystem) {
      planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      planes[5].setComponents(me2, me6, me10, me14).normalize();
    } else {
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
    }
    return this;
  }
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null)
        object.computeBoundingSphere();
      _sphere$4.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null)
        geometry.computeBoundingSphere();
      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSprite(sprite) {
    _sphere$4.center.set(0, 0, 0);
    _sphere$4.radius = 0.7071067811865476;
    _sphere$4.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$4);
  }
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  intersectsBox(box) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      const plane = planes[i];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  containsPoint(point) {
    const planes = this.planes;
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true)
        return;
      if (animationLoop === null)
        return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = gl.HALF_FLOAT;
        } else {
          throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");
        }
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRange = attribute.updateRange;
    gl.bindBuffer(bufferType, buffer);
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count
        );
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(updateRange.offset, updateRange.offset + updateRange.count)
        );
      }
      updateRange.count = -1;
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data) {
      gl.deleteBuffer(data.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    if (attribute.isInterleavedBufferAttribute)
      attribute = attribute.data;
    const data = buffers.get(attribute);
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType);
      data.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var PlaneGeometry = class _PlaneGeometry extends BufferGeometry2 {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half;
        vertices.push(x, -y, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy;
        const b = ix + gridX1 * (iy + 1);
        const c = ix + 1 + gridX1 * (iy + 1);
        const d = ix + 1 + gridX1 * iy;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
  }
};
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n	return dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_v0 0.339\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_v1 0.276\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_v4 0.046\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_v5 0.016\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_v6 0.0038\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "\nconst mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(\n	vec3( 0.8224621, 0.177538, 0.0 ),\n	vec3( 0.0331941, 0.9668058, 0.0 ),\n	vec3( 0.0170827, 0.0723974, 0.9105199 )\n);\nconst mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(\n	vec3( 1.2249401, - 0.2249404, 0.0 ),\n	vec3( - 0.0420569, 1.0420571, 0.0 ),\n	vec3( - 0.0196376, - 0.0786361, 1.0982735 )\n);\nvec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );\n}\nvec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {\n	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );\n}\nvec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return sRGBTransferOETF( value );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_fragment = "#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( LEGACY_LIGHTS )\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#else\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	anisotropyV /= material.anisotropy;\n	material.anisotropy = saturate( material.anisotropy );\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return saturate(v);\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColor;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n	return packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$e = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 }
    // basic, lambert, phong
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: new Matrix3() },
    normalScale: { value: new Vector22(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: new Color2(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: new Matrix3() }
  },
  sprite: {
    diffuse: { value: new Color2(16777215) },
    opacity: { value: 1 },
    center: { value: new Vector22(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: new Matrix3() },
    alphaTest: { value: 0 }
  }
};
var ShaderLib = {
  basic: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) },
        specular: { value: new Color2(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
        // temporary
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: new Color2(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distanceRGBA: {
    uniforms: mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: new Vector32() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag
  },
  shadow: {
    uniforms: mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: new Color2(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector22(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color2(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector22() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color2(0) },
      specularColor: { value: new Color2(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector22() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
var _rgb = { r: 0, b: 0, g: 0 };
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color2(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function render(renderList, scene) {
    let forceClear = false;
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh2(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh2(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide2,
            depthTest: false,
            depthWrite: false,
            fog: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render
  };
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const extension = capabilities.isWebGL2 ? null : extensions.get("OES_vertex_array_object");
  const vaoAvailable = capabilities.isWebGL2 || extension !== null;
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material);
      if (currentState !== state) {
        currentState = state;
        bindVertexArrayObject(currentState.object);
      }
      updateBuffers = needsUpdate(object, geometry, program, index);
      if (updateBuffers)
        saveCache(object, geometry, program, index);
    } else {
      const wireframe = material.wireframe === true;
      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {
        currentState.geometry = geometry.id;
        currentState.program = program.id;
        currentState.wireframe = wireframe;
        updateBuffers = true;
      }
    }
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2)
      return gl.createVertexArray();
    return extension.createVertexArrayOES();
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.bindVertexArray(vao);
    return extension.bindVertexArrayOES(vao);
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2)
      return gl.deleteVertexArray(vao);
    return extension.deleteVertexArrayOES(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0;
      enabledAttributes[i] = 0;
      attributeDivisors[i] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0)
          return true;
        if (cachedAttribute.attribute !== geometryAttribute)
          return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data)
          return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum)
      return true;
    if (currentState.index !== index)
      return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            attribute = object.instanceColor;
        }
        const data = {};
        data.attribute = attribute;
        if (attribute && attribute.data) {
          data.data = attribute.data;
        }
        cache[name] = data;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
      extension2[capabilities.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i);
        enabledAttributes[i] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
      if (extensions.get("ANGLE_instanced_arrays") === null)
        return;
    }
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor)
            geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0)
            continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = capabilities.isWebGL2 === true && (type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType);
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data;
            const stride = data.stride;
            const offset = geometryAttribute.offset;
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, data.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(programAttribute.location + i, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0)
      return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0)
        continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState)
      return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawArraysInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawArraysInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0)
      return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  const isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl.constructor.name === "WebGL2RenderingContext";
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const drawBuffers = isWebGL2 || extensions.has("WEBGL_draw_buffers");
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const vertexTextures = maxVertexTextures > 0;
  const floatFragmentTextures = isWebGL2 || extensions.has("OES_texture_float");
  const floatVertexTextures = vertexTextures && floatFragmentTextures;
  const maxSamples = isWebGL2 ? gl.getParameter(gl.MAX_SAMPLES) : 0;
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane2(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture && texture.isRenderTargetTexture === false) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var OrthographicCamera = class extends Camera {
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x;
    this.view.offsetY = y;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    data.object.zoom = this.zoom;
    data.object.left = this.left;
    data.object.right = this.right;
    data.object.top = this.top;
    data.object.bottom = this.bottom;
    data.object.near = this.near;
    data.object.far = this.far;
    if (this.view !== null)
      data.object.view = Object.assign({}, this.view);
    return data;
  }
};
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var _flatCamera = new OrthographicCamera();
var _clearColor = new Color2();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var PHI = (1 + Math.sqrt(5)) / 2;
var INV_PHI = 1 / PHI;
var _axisDirections = [
  new Vector32(1, 1, 1),
  new Vector32(-1, 1, 1),
  new Vector32(1, 1, -1),
  new Vector32(-1, 1, -1),
  new Vector32(0, PHI, INV_PHI),
  new Vector32(0, PHI, -INV_PHI),
  new Vector32(INV_PHI, 0, PHI),
  new Vector32(-INV_PHI, 0, PHI),
  new Vector32(PHI, INV_PHI, 0),
  new Vector32(-PHI, INV_PHI, 0)
];
var PMREMGenerator = class {
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._lodPlanes = [];
    this._sizeLods = [];
    this._sigmas = [];
    this._blurMaterial = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._compileMaterial(this._blurMaterial);
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    this._setSize(256);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null)
      this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null)
      this._equirectMaterial.dispose();
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null)
      this._blurMaterial.dispose();
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose();
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat2,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh2(this._lodPlanes[0], material);
    this._renderer.compile(tmpMesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const backgroundMaterial = new MeshBasicMaterial({
      name: "PMREM.Background",
      side: BackSide,
      depthWrite: false,
      depthTest: false
    });
    const backgroundBox = new Mesh2(new BoxGeometry(), backgroundMaterial);
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(forwardSign[i], 0, 0);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i]);
        cubeCamera.lookAt(0, forwardSign[i], 0);
      } else {
        cubeCamera.up.set(0, upSign[i], 0);
        cubeCamera.lookAt(0, 0, forwardSign[i]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    backgroundBox.geometry.dispose();
    backgroundBox.material.dispose();
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = new Mesh2(this._lodPlanes[0], material);
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = new Mesh2(this._lodPlanes[lodOut], blurMaterial);
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels;
      const weight = Math.exp(-x2 * x2 / 2);
      weights.push(weight);
      if (i === 0) {
        sum += weight;
      } else if (i < samples) {
        sum += 2 * weight;
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const lodPlanes = [];
  const sizeLods = [];
  const sigmas = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
    } else if (i === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x = face % 3 * 2 / 3 - 1;
      const y = face > 2 ? 0 : -1;
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry2();
    planes.setAttribute("position", new BufferAttribute2(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute2(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute2(faceIndex, faceIndexSize));
    lodPlanes.push(planes);
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodPlanes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target4, x, y, width, height) {
  target4.viewport.set(x, y, width, height);
  target4.scissor.set(x, y, width, height);
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector32(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        if (texture.isRenderTargetTexture && texture.needsPMREMUpdate === true) {
          texture.needsPMREMUpdate = false;
          let renderTarget = cubeUVmaps.get(texture);
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer);
              const renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i = 0; i < length; i++) {
      if (image[i] !== void 0)
        count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    let extension;
    switch (name) {
      case "WEBGL_depth_texture":
        extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        extension = gl.getExtension(name);
    }
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function(capabilities) {
      if (capabilities.isWebGL2) {
        getExtension("EXT_color_buffer_float");
      } else {
        getExtension("WEBGL_depth_texture");
        getExtension("OES_texture_float");
        getExtension("OES_texture_half_float");
        getExtension("OES_texture_half_float_linear");
        getExtension("OES_standard_derivatives");
        getExtension("OES_element_index_uint");
        getExtension("OES_vertex_array_object");
        getExtension("ANGLE_instanced_arrays");
      }
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries2 = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    for (const name in geometry.morphAttributes) {
      const array = geometry.morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.remove(array[i]);
      }
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries2[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries2[geometry.id] === true)
      return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries2[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
    const morphAttributes = geometry.morphAttributes;
    for (const name in morphAttributes) {
      const array = morphAttributes[name];
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], gl.ARRAY_BUFFER);
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0];
        const b = array[i + 1];
        const c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0;
        const b = i + 1;
        const c = i + 2;
        indices.push(a, b, b, c, c, a);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute)
      attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0)
      return;
    let extension, methodName;
    if (isWebGL2) {
      extension = gl;
      methodName = "drawElementsInstanced";
    } else {
      extension = extensions.get("ANGLE_instanced_arrays");
      methodName = "drawElementsInstancedANGLE";
      if (extension === null) {
        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        return;
      }
    }
    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function numericalSort(a, b) {
  return a[0] - b[0];
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1]);
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {};
  const morphInfluences = new Float32Array(8);
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector42();
  const workInfluences = [];
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0];
  }
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    if (capabilities.isWebGL2 === true) {
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      let entry = morphTextures.get(geometry);
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function() {
          texture.dispose();
          morphTextures.delete(geometry);
          geometry.removeEventListener("dispose", disposeTexture);
        };
        if (entry !== void 0)
          entry.texture.dispose();
        const hasMorphPosition = geometry.morphAttributes.position !== void 0;
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
        const hasMorphColors = geometry.morphAttributes.color !== void 0;
        const morphTargets = geometry.morphAttributes.position || [];
        const morphNormals = geometry.morphAttributes.normal || [];
        const morphColors = geometry.morphAttributes.color || [];
        let vertexDataCount = 0;
        if (hasMorphPosition === true)
          vertexDataCount = 1;
        if (hasMorphNormals === true)
          vertexDataCount = 2;
        if (hasMorphColors === true)
          vertexDataCount = 3;
        let width = geometry.attributes.position.count * vertexDataCount;
        let height = 1;
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize);
          width = capabilities.maxTextureSize;
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
        const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
        texture.type = FloatType2;
        texture.needsUpdate = true;
        const vertexDataStride = vertexDataCount * 4;
        for (let i = 0; i < morphTargetsCount; i++) {
          const morphTarget = morphTargets[i];
          const morphNormal = morphNormals[i];
          const morphColor = morphColors[i];
          const offset = width * height * 4 * i;
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride;
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j);
              buffer[offset + stride + 0] = morph.x;
              buffer[offset + stride + 1] = morph.y;
              buffer[offset + stride + 2] = morph.z;
              buffer[offset + stride + 3] = 0;
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j);
              buffer[offset + stride + 4] = morph.x;
              buffer[offset + stride + 5] = morph.y;
              buffer[offset + stride + 6] = morph.z;
              buffer[offset + stride + 7] = 0;
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j);
              buffer[offset + stride + 8] = morph.x;
              buffer[offset + stride + 9] = morph.y;
              buffer[offset + stride + 10] = morph.z;
              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector22(width, height)
        };
        morphTextures.set(geometry, entry);
        geometry.addEventListener("dispose", disposeTexture);
      }
      let morphInfluencesSum = 0;
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
      program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
      program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length;
      let influences = influencesList[geometry.id];
      if (influences === void 0 || influences.length !== length) {
        influences = [];
        for (let i = 0; i < length; i++) {
          influences[i] = [i, 0];
        }
        influencesList[geometry.id] = influences;
      }
      for (let i = 0; i < length; i++) {
        const influence = influences[i];
        influence[0] = i;
        influence[1] = objectInfluences[i];
      }
      influences.sort(absNumericalSort);
      for (let i = 0; i < 8; i++) {
        if (i < length && influences[i][1]) {
          workInfluences[i][0] = influences[i][0];
          workInfluences[i][1] = influences[i][1];
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;
          workInfluences[i][1] = 0;
        }
      }
      workInfluences.sort(numericalSort);
      const morphTargets = geometry.morphAttributes.position;
      const morphNormals = geometry.morphAttributes.normal;
      let morphInfluencesSum = 0;
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i];
        const index = influence[0];
        const value = influence[1];
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (morphTargets && geometry.getAttribute("morphTarget" + i) !== morphTargets[index]) {
            geometry.setAttribute("morphTarget" + i, morphTargets[index]);
          }
          if (morphNormals && geometry.getAttribute("morphNormal" + i) !== morphNormals[index]) {
            geometry.setAttribute("morphNormal" + i, morphNormals[index]);
          }
          morphInfluences[i] = value;
          morphInfluencesSum += value;
        } else {
          if (morphTargets && geometry.hasAttribute("morphTarget" + i) === true) {
            geometry.deleteAttribute("morphTarget" + i);
          }
          if (morphNormals && geometry.hasAttribute("morphNormal" + i) === true) {
            geometry.deleteAttribute("morphNormal" + i);
          }
          morphInfluences[i] = 0;
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
    }
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries2, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries2.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries2.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose
  };
}
var emptyTexture = new Texture2();
var emptyArrayTexture = new DataArrayTexture();
var empty3dTexture = new Data3DTexture();
var emptyCubeTexture = new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0)
    return array;
  const n = nBlocks * blockSize;
  let r = arrayCacheF32[n];
  if (r === void 0) {
    r = new Float32Array(n);
    arrayCacheF32[n] = r;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0);
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize;
      array[i].toArray(r, offset);
    }
  }
  return r;
}
function arraysEqual(a, b) {
  if (a.length !== b.length)
    return false;
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i];
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n];
  if (r === void 0) {
    r = new Int32Array(n);
    arrayCacheI32[n] = r;
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit();
  }
  return r;
}
function setValueV1f(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1f(this.addr, v);
  cache[0] = v;
}
function setValueV2f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b);
      cache[0] = v.r;
      cache[1] = v.g;
      cache[2] = v.b;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4fv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueM2(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix2fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix3fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v) {
  const cache = this.cache;
  const elements = v.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v))
      return;
    gl.uniformMatrix4fv(this.addr, false, v);
    copyArray(cache, v);
  } else {
    if (arraysEqual(cache, elements))
      return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1i(this.addr, v);
  cache[0] = v;
}
function setValueV2i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2i(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3i(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4i(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4i(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4iv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV1ui(gl, v) {
  const cache = this.cache;
  if (cache[0] === v)
    return;
  gl.uniform1ui(this.addr, v);
  cache[0] = v;
}
function setValueV2ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2ui(this.addr, v.x, v.y);
      cache[0] = v.x;
      cache[1] = v.y;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform2uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV3ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3ui(this.addr, v.x, v.y, v.z);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform3uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueV4ui(gl, v) {
  const cache = this.cache;
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
      gl.uniform4ui(this.addr, v.x, v.y, v.z, v.w);
      cache[0] = v.x;
      cache[1] = v.y;
      cache[2] = v.z;
      cache[3] = v.w;
    }
  } else {
    if (arraysEqual(cache, v))
      return;
    gl.uniform4uiv(this.addr, v);
    copyArray(cache, v);
  }
}
function setValueT1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2D(v || emptyTexture, unit);
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v || empty3dTexture, unit);
}
function setValueT6(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    case 35664:
      return setValueV2f;
    case 35665:
      return setValueV3f;
    case 35666:
      return setValueV4f;
    case 35674:
      return setValueM2;
    case 35675:
      return setValueM3;
    case 35676:
      return setValueM4;
    case 5124:
    case 35670:
      return setValueV1i;
    case 35667:
    case 35671:
      return setValueV2i;
    case 35668:
    case 35672:
      return setValueV3i;
    case 35669:
    case 35673:
      return setValueV4i;
    case 5125:
      return setValueV1ui;
    case 36294:
      return setValueV2ui;
    case 36295:
      return setValueV3ui;
    case 36296:
      return setValueV4ui;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v);
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2);
  gl.uniform2fv(this.addr, data);
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3);
  gl.uniform3fv(this.addr, data);
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniform4fv(this.addr, data);
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data);
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data);
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data);
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v);
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v);
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v);
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v);
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v);
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v);
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v);
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v);
}
function setValueT1Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i]);
  }
}
function setValueT3DArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i]);
  }
}
function setValueT6Array(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i]);
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const cache = this.cache;
  const n = v.length;
  const units = allocTexUnits(textures, n);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    case 35664:
      return setValueV2fArray;
    case 35665:
      return setValueV3fArray;
    case 35666:
      return setValueV4fArray;
    case 35674:
      return setValueM2Array;
    case 35675:
      return setValueM3Array;
    case 35676:
      return setValueM4Array;
    case 5124:
    case 35670:
      return setValueV1iArray;
    case 35667:
    case 35671:
      return setValueV2iArray;
    case 35668:
    case 35672:
      return setValueV3iArray;
    case 35669:
    case 35673:
      return setValueV4iArray;
    case 5125:
      return setValueV1uiArray;
    case 36294:
      return setValueV2uiArray;
    case 36295:
      return setValueV3uiArray;
    case 36296:
      return setValueV4uiArray;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array;
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray;
  }
}
var SingleUniform = class {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.setValue = getSingularSetter(activeInfo.type);
  }
};
var PureArrayUniform = class {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
};
var StructuredUniform = class {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      u.setValue(gl, value[u.id], textures);
    }
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex)
      id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
var WebGLUniforms = class {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name];
    if (u !== void 0)
      u.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v = object[name];
    if (v !== void 0)
      this.setValue(gl, name, v);
  }
  static upload(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i], v = values[u.id];
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = [];
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i];
      if (u.id in values)
        r.push(u);
    }
    return r;
  }
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var COMPLETION_STATUS_KHR = 37297;
var programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to = Math.min(errorLine + 6, lines.length);
  for (let i = from; i < to; i++) {
    const line = i + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i]}`);
  }
  return lines2.join("\n");
}
function getEncodingComponents(colorSpace) {
  const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
  const encodingPrimaries = ColorManagement.getPrimaries(colorSpace);
  let gamutMapping;
  if (workingPrimaries === encodingPrimaries) {
    gamutMapping = "";
  } else if (workingPrimaries === P3Primaries && encodingPrimaries === Rec709Primaries) {
    gamutMapping = "LinearDisplayP3ToLinearSRGB";
  } else if (workingPrimaries === Rec709Primaries && encodingPrimaries === P3Primaries) {
    gamutMapping = "LinearSRGBToLinearDisplayP3";
  }
  switch (colorSpace) {
    case LinearSRGBColorSpace:
    case LinearDisplayP3ColorSpace:
      return [gamutMapping, "LinearTransferOETF"];
    case SRGBColorSpace:
    case DisplayP3ColorSpace:
      return [gamutMapping, "sRGBTransferOETF"];
    default:
      console.warn("THREE.WebGLProgram: Unsupported color space:", colorSpace);
      return [gamutMapping, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const errors = gl.getShaderInfoLog(shader).trim();
  if (status && errors === "")
    return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return `vec4 ${functionName}( vec4 value ) { return ${components[0]}( ${components[1]}( value ) ); }`;
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName;
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = "Linear";
      break;
    case ReinhardToneMapping:
      toneMappingName = "Reinhard";
      break;
    case CineonToneMapping:
      toneMappingName = "OptimizedCineon";
      break;
    case ACESFilmicToneMapping:
      toneMappingName = "ACESFilmic";
      break;
    case CustomToneMapping:
      toneMappingName = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", toneMapping);
      toneMappingName = "Linear";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives || !!parameters.envMapCubeUVHeight || parameters.bumpMap || parameters.normalMapTangentSpace || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "",
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "",
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "",
    (parameters.extensionShaderTextureLOD || parameters.envMap || parameters.transmission) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false)
      continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2)
      locationSize = 2;
    if (info.type === gl.FLOAT_MAT3)
      locationSize = 3;
    if (info.type === gl.FLOAT_MAT4)
      locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
var shaderChunkMap = /* @__PURE__ */ new Map([
  ["encodings_fragment", "colorspace_fragment"],
  // @deprecated, r154
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  // @deprecated, r154
  ["output_fragment", "opaque_fragment"]
  // @deprecated, r154
]);
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
  }
  return shadowMapTypeDefine;
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = "ENVMAP_TYPE_CUBE";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
        break;
      case CubeUVReflectionMapping:
        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  }
  return envMapTypeDefine;
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = "ENVMAP_MODE_REFLECTION";
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
        break;
    }
  }
  return envMapModeDefine;
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case MixOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
        break;
      case AddOperation:
        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
        break;
    }
  }
  return envMapBlendingDefine;
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null)
    return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      customExtensions,
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors && parameters.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 && parameters.isWebGL2 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
      "	attribute vec3 morphTarget0;",
      "	attribute vec3 morphTarget1;",
      "	attribute vec3 morphTarget2;",
      "	attribute vec3 morphTarget3;",
      "	#ifdef USE_MORPHNORMALS",
      "		attribute vec3 morphNormal0;",
      "		attribute vec3 morphNormal1;",
      "		attribute vec3 morphNormal2;",
      "		attribute vec3 morphNormal3;",
      "	#else",
      "		attribute vec3 morphTarget4;",
      "		attribute vec3 morphTarget5;",
      "		attribute vec3 morphTarget6;",
      "		attribute vec3 morphTarget7;",
      "	#endif",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      "precision mediump sampler2DArray;",
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "precision mediump sampler2DArray;",
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programLog = gl.getProgramInfoLog(program).trim();
      const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
      const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        console.warn("THREE.WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
var _id$1 = 0;
var WebGLShaderCache = class {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0)
        this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    let stage = cache.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return stage;
  }
};
var WebGLShaderStage = class {
  constructor(code) {
    this.id = _id$1++;
    this.code = code;
    this.usedTimes = 0;
  }
};
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const programs = [];
  const IS_WEBGL2 = capabilities.isWebGL2;
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  const SUPPORTS_VERTEX_TEXTURES = capabilities.vertexTextures;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    if (value === 0)
      return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0)
      morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0)
      morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0)
      morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    const HAS_ATTRIBUTE_UV1 = !!geometry.attributes.uv1;
    const HAS_ATTRIBUTE_UV2 = !!geometry.attributes.uv2;
    const HAS_ATTRIBUTE_UV3 = !!geometry.attributes.uv3;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      isWebGL2: IS_WEBGL2,
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      supportsVertexTextures: SUPPORTS_VERTEX_TEXTURES,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: SUPPORTS_VERTEX_TEXTURES && HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      vertexUv1s: HAS_ATTRIBUTE_UV1,
      vertexUv2s: HAS_ATTRIBUTE_UV2,
      vertexUv3s: HAS_ATTRIBUTE_UV3,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: fog && fog.isFogExp2,
      flatShading: material.flatShading === true,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      useLegacyLights: renderer._useLegacyLights,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives: HAS_EXTENSIONS && material.extensions.derivatives === true,
      extensionFragDepth: HAS_EXTENSIONS && material.extensions.fragDepth === true,
      extensionDrawBuffers: HAS_EXTENSIONS && material.extensions.drawBuffers === true,
      extensionShaderTextureLOD: HAS_EXTENSIONS && material.extensions.shaderTextureLOD === true,
      rendererExtensionFragDepth: IS_WEBGL2 || extensions.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: IS_WEBGL2 || extensions.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: IS_WEBGL2 || extensions.has("EXT_shader_texture_lod"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.isWebGL2)
      _programLayers.enable(0);
    if (parameters.supportsVertexTextures)
      _programLayers.enable(1);
    if (parameters.instancing)
      _programLayers.enable(2);
    if (parameters.instancingColor)
      _programLayers.enable(3);
    if (parameters.matcap)
      _programLayers.enable(4);
    if (parameters.envMap)
      _programLayers.enable(5);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(6);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(7);
    if (parameters.clearcoat)
      _programLayers.enable(8);
    if (parameters.iridescence)
      _programLayers.enable(9);
    if (parameters.alphaTest)
      _programLayers.enable(10);
    if (parameters.vertexColors)
      _programLayers.enable(11);
    if (parameters.vertexAlphas)
      _programLayers.enable(12);
    if (parameters.vertexUv1s)
      _programLayers.enable(13);
    if (parameters.vertexUv2s)
      _programLayers.enable(14);
    if (parameters.vertexUv3s)
      _programLayers.enable(15);
    if (parameters.vertexTangents)
      _programLayers.enable(16);
    if (parameters.anisotropy)
      _programLayers.enable(17);
    if (parameters.alphaHash)
      _programLayers.enable(18);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.skinning)
      _programLayers.enable(4);
    if (parameters.morphTargets)
      _programLayers.enable(5);
    if (parameters.morphNormals)
      _programLayers.enable(6);
    if (parameters.morphColors)
      _programLayers.enable(7);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(8);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(9);
    if (parameters.useLegacyLights)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils2.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program;
    for (let p = 0, pl = programs.length; p < pl; p++) {
      const preexistingProgram = programs[p];
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram;
        ++program.usedTimes;
        break;
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program);
      programs[i] = programs[programs.length - 1];
      programs.pop();
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    remove,
    update,
    dispose
  };
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id;
  } else if (a.z !== b.z) {
    return a.z - b.z;
  } else {
    return a.id - b.id;
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder;
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder;
  } else if (a.z !== b.z) {
    return b.z - a.z;
  } else {
    return a.id - b.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1)
      opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i];
      if (renderItem.id === null)
        break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector32(),
            color: new Color2()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector32(),
            direction: new Vector32(),
            color: new Color2(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector32(),
            color: new Color2(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector32(),
            skyColor: new Color2(),
            groundColor: new Color2()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color2(),
            position: new Vector32(),
            halfWidth: new Vector32(),
            halfHeight: new Vector32()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector22()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector22()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector22(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i = 0; i < 9; i++)
    state.probe.push(new Vector32());
  const vector3 = new Vector32();
  const matrix4 = new Matrix42();
  const matrix42 = new Matrix42();
  function setup(lights, useLegacyLights) {
    let r = 0, g = 0, b = 0;
    for (let i = 0; i < 9; i++)
      state.probe[i].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    const scaleFactor = useLegacyLights === true ? Math.PI : 1;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor;
        g += color.g * intensity * scaleFactor;
        b += color.b * intensity * scaleFactor;
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow)
            numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity * scaleFactor);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity * scaleFactor);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity * scaleFactor);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        if (extensions.has("OES_texture_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
        } else if (extensions.has("OES_texture_half_float_linear") === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
        } else {
          console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.");
        }
      }
    }
    state.ambient[0] = r;
    state.ambient[1] = g;
    state.ambient[2] = b;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities);
  const lightsArray = [];
  const shadowsArray = [];
  function init() {
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights(useLegacyLights) {
    lights.setup(lightsArray, useLegacyLights);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions, capabilities);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions, capabilities);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose
  };
}
var MeshDepthMaterial = class extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
var MeshDistanceMaterial = class extends Material2 {
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector22(), _viewportSize = new Vector22(), _viewport = new Vector42(), _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;
  const shadowSide = { [FrontSide2]: BackSide, [BackSide]: FrontSide2, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector22() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry2();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute2(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh2(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false)
      return;
    if (scope.autoUpdate === false && scope.needsUpdate === false)
      return;
    if (lights.length === 0)
      return;
    const currentRenderTarget = _renderer.getRenderTarget();
    const activeCubeFace = _renderer.getActiveCubeFace();
    const activeMipmapLevel = _renderer.getActiveMipmapLevel();
    const _state = _renderer.state;
    _state.setBlending(NoBlending);
    _state.buffers.color.setClear(1, 1, 1, 1);
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const toVSM = _previousType !== VSMShadowMap && this.type === VSMShadowMap;
    const fromVSM = _previousType === VSMShadowMap && this.type !== VSMShadowMap;
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i];
      const shadow = light.shadow;
      if (shadow === void 0) {
        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false)
        continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || toVSM === true || fromVSM === true) {
        const pars = this.type !== VSMShadowMap ? { minFilter: NearestFilter, magFilter: NearestFilter } : {};
        if (shadow.map !== null) {
          shadow.map.dispose();
        }
        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
        shadow.map.texture.name = light.name + ".shadowMap";
        shadow.camera.updateProjectionMatrix();
      }
      _renderer.setRenderTarget(shadow.map);
      _renderer.clear();
      const viewportCount = shadow.getViewportCount();
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp);
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w
        );
        _state.viewport(_viewport);
        shadow.updateMatrices(light, vp);
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.mapPass);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    _renderer.setRenderTarget(shadow.map);
    _renderer.clear();
    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (_renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = _renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false)
      return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = _objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
        }
      }
    }
    const children = object.children;
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type);
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function ColorBuffer() {
    let locked = false;
    const color = new Vector42();
    let currentColorMask = null;
    const currentColorClear = new Vector42(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a;
          g *= a;
          b *= a;
        }
        color.set(r, g, b, a);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color2(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector42().fromArray(scissorParam);
  const currentViewport = new Vector42().fromArray(viewportParam);
  function createTexture(type, target4, count, dimensions) {
    const data = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i = 0; i < count; i++) {
      if (isWebGL2 && (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY)) {
        gl.texImage3D(target4, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      } else {
        gl.texImage2D(target4 + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  if (isWebGL2) {
    emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
    emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  }
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target4, framebuffer) {
    if (currentBoundFramebuffers[target4] !== framebuffer) {
      gl.bindFramebuffer(target4, framebuffer);
      currentBoundFramebuffers[target4] = framebuffer;
      if (isWebGL2) {
        if (target4 === gl.DRAW_FRAMEBUFFER) {
          currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
        }
        if (target4 === gl.FRAMEBUFFER) {
          currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
        }
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture;
        if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          for (let i = 0, il = textures.length; i < il; i++) {
            drawBuffers2[i] = gl.COLOR_ATTACHMENT0 + i;
          }
          drawBuffers2.length = textures.length;
          needsUpdate = true;
        }
      } else {
        if (drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
          drawBuffers2[0] = gl.COLOR_ATTACHMENT0;
          needsUpdate = true;
        }
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2);
      } else {
        extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers2);
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  if (isWebGL2) {
    equationToGL[MinEquation] = gl.MIN;
    equationToGL[MaxEquation] = gl.MAX;
  } else {
    const extension = extensions.get("EXT_blend_minmax");
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT;
      equationToGL[MaxEquation] = extension.MAX_EXT;
    }
  }
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW)
      flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable)
        gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0)
      webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments);
    } catch (error) {
      console.error("THREE.WebGLState:", error);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    if (isWebGL2 === true) {
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    }
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color2(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const isWebGL2 = capabilities.isWebGL2;
  const maxTextures = capabilities.maxTextures;
  const maxCubemapSize = capabilities.maxCubemapSize;
  const maxTextureSize = capabilities.maxTextureSize;
  const maxSamples = capabilities.maxSamples;
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? (
      // eslint-disable-next-line compat/compat
      new OffscreenCanvas(width, height)
    ) : createElementNS("canvas");
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1;
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height);
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;
        const width = floor(scale * image.width);
        const height = floor(scale * image.height);
        if (_canvas2 === void 0)
          _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function isPowerOfTwo$1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2)
      return false;
    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
  }
  function generateMipmap(target4) {
    _gl.generateMipmap(target4);
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (isWebGL2 === false)
      return glFormat;
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0)
        return _gl[internalFormatName];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT)
        internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT)
        internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE)
        internalFormat = _gl.R8I;
      if (glType === _gl.SHORT)
        internalFormat = _gl.R16I;
      if (glType === _gl.INT)
        internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT)
        internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT)
        internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE)
        internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4)
        internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1)
        internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getMipLevels(texture, image, supportsMips) {
    if (textureNeedsGenerateMipmaps(texture, supportsMips) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function filterFallback(f) {
    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
      return _gl.NEAREST;
    }
    return _gl.LINEAR;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0)
      return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture);
      info.memory.textures--;
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i].length; level++)
            _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
        }
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++)
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i = 0; i < renderTargetProperties.__webglColorRenderbuffer.length; i++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i])
            _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i = 0, il = texture.length; i < il; i++) {
        const attachmentProperties = properties.get(texture[i]);
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture);
          info.memory.textures--;
        }
        properties.remove(texture[i]);
      }
    }
    properties.remove(texture);
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= maxTextures) {
      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture)
      updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    } else {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE);
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE);
      if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
        _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, _gl.CLAMP_TO_EDGE);
      }
      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
      }
      _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterFallback(texture.magFilter));
      _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterFallback(texture.minFilter));
      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
      }
    }
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      if (texture.magFilter === NearestFilter)
        return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter)
        return;
      if (texture.type === FloatType2 && extensions.has("OES_texture_float_linear") === false)
        return;
      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has("OES_texture_half_float_linear") === false))
        return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture)
      textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture)
      textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;
      let image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
      image = verifyColorSpace(texture, image);
      const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.colorSpace);
      let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture, supportsMips);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const levels = getMipLevels(texture, image, supportsMips);
      if (texture.isDepthTexture) {
        glInternalFormat = _gl.DEPTH_COMPONENT;
        if (isWebGL2) {
          if (texture.type === FloatType2) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = _gl.DEPTH24_STENCIL8;
          } else {
            glInternalFormat = _gl.DEPTH_COMPONENT16;
          }
        } else {
          if (texture.type === FloatType2) {
            console.error("WebGLRenderer: Floating point depth texture requires WebGL2.");
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
            console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
            texture.type = UnsignedIntType;
            glType = utils.convert(texture.type);
          }
        }
        if (texture.format === DepthStencilFormat && glInternalFormat === _gl.DEPTH_COMPONENT) {
          glInternalFormat = _gl.DEPTH_STENCIL;
          if (texture.type !== UnsignedInt248Type) {
            console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
            texture.type = UnsignedInt248Type;
            glType = utils.convert(texture.type);
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat2) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data, 0, 0);
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (texture.format !== RGBAFormat2) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i = 0; i < levels; i++) {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i];
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_2D, i, 0, 0, glFormat, glType, mipmap);
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6)
      return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
        } else {
          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i]);
      }
      const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      let levels = getMipLevels(texture, image, supportsMips);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps;
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j];
            if (texture.format !== RGBAFormat2) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0)
            levels++;
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, cubeImage[0].width, cubeImage[0].height);
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, cubeImage[i].width, cubeImage[i].height, glFormat, glType, cubeImage[i].data);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              const mipmapImage = mipmap.image[i].image;
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, 0, 0, glFormat, glType, cubeImage[i]);
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j];
              if (useTexStorage) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, 0, 0, glFormat, glType, mipmap.image[i]);
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate)
        texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, properties.get(texture).__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = isWebGL2 === true ? _gl.DEPTH_COMPONENT24 : _gl.DEPTH_COMPONENT16;
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture;
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType2) {
            glInternalFormat = _gl.DEPTH_COMPONENT32F;
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = _gl.DEPTH_COMPONENT24;
          }
        }
        const samples = getRenderTargetSamples(renderTarget);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget);
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, _gl.DEPTH24_STENCIL8, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        const samples = getRenderTargetSamples(renderTarget);
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
    if (isCube)
      throw new Error("Depth Texture with cube render targets is not supported");
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    setTexture2D(renderTarget.depthTexture, 0);
    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube)
        throw new Error("target.depthTexture not supported in Cube render targets");
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i]);
          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);
        }
      } else {
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i = 0; i < 6; i++) {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
        }
      }
    } else {
      if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture;
          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i]);
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture();
              info.memory.textures++;
            }
          }
        } else {
          console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
        }
      }
      if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        const textures = isMultipleRenderTargets ? texture : [texture];
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i];
          renderTargetProperties.__webglColorRenderbuffer[i] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture, supportsMips);
      for (let i = 0; i < 6; i++) {
        if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture;
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i];
        const attachmentProperties = properties.get(attachment);
        state.bindTexture(_gl.TEXTURE_2D, attachmentProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_2D, attachment, supportsMips);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, 0);
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(_gl.TEXTURE_2D);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        } else {
          console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture, supportsMips);
      if (isWebGL2 && texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;
    const textures = renderTarget.isWebGLMultipleRenderTargets === true ? renderTarget.texture : [renderTarget.texture];
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i];
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target4 = renderTarget.isWebGLCubeRenderTarget ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(target4, webglTexture);
        generateMipmap(target4);
        state.unbindTexture();
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (isWebGL2 && renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
      const textures = renderTarget.isWebGLMultipleRenderTargets ? renderTarget.texture : [renderTarget.texture];
      const width = renderTarget.width;
      const height = renderTarget.height;
      let mask = _gl.COLOR_BUFFER_BIT;
      const invalidationArray = [];
      const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      const renderTargetProperties = properties.get(renderTarget);
      const isMultipleRenderTargets = renderTarget.isWebGLMultipleRenderTargets === true;
      if (isMultipleRenderTargets) {
        for (let i = 0; i < textures.length; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, null);
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, null, 0);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
      for (let i = 0; i < textures.length; i++) {
        invalidationArray.push(_gl.COLOR_ATTACHMENT0 + i);
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle);
        }
        const ignoreDepthValues = renderTargetProperties.__ignoreDepthValues !== void 0 ? renderTargetProperties.__ignoreDepthValues : false;
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer)
            mask |= _gl.DEPTH_BUFFER_BIT;
          if (renderTarget.stencilBuffer)
            mask |= _gl.STENCIL_BUFFER_BIT;
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, [depthStyle]);
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures[i]).__webglTexture;
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
        }
        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArray);
        }
      }
      state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      if (isMultipleRenderTargets) {
        for (let i = 0; i < textures.length; i++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i]);
          const webglTexture = properties.get(textures[i]).__webglTexture;
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i, _gl.TEXTURE_2D, webglTexture, 0);
        }
      }
      state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return isWebGL2 && renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true || texture.format === _SRGBAFormat)
      return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (isWebGL2 === false) {
          if (extensions.has("EXT_sRGB") === true && format === RGBAFormat2) {
            texture.format = _SRGBAFormat;
            texture.minFilter = LinearFilter;
            texture.generateMipmaps = false;
          } else {
            image = ImageUtils.sRGBToLinear(image);
          }
        } else {
          if (format !== RGBAFormat2 || type !== UnsignedByteType) {
            console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
          }
        }
      } else {
        console.error("THREE.WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2;
  function convert(p, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p === UnsignedByteType)
      return gl.UNSIGNED_BYTE;
    if (p === UnsignedShort4444Type)
      return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p === UnsignedShort5551Type)
      return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p === ByteType)
      return gl.BYTE;
    if (p === ShortType)
      return gl.SHORT;
    if (p === UnsignedShortType)
      return gl.UNSIGNED_SHORT;
    if (p === IntType)
      return gl.INT;
    if (p === UnsignedIntType)
      return gl.UNSIGNED_INT;
    if (p === FloatType2)
      return gl.FLOAT;
    if (p === HalfFloatType) {
      if (isWebGL2)
        return gl.HALF_FLOAT;
      extension = extensions.get("OES_texture_half_float");
      if (extension !== null) {
        return extension.HALF_FLOAT_OES;
      } else {
        return null;
      }
    }
    if (p === AlphaFormat)
      return gl.ALPHA;
    if (p === RGBAFormat2)
      return gl.RGBA;
    if (p === LuminanceFormat)
      return gl.LUMINANCE;
    if (p === LuminanceAlphaFormat)
      return gl.LUMINANCE_ALPHA;
    if (p === DepthFormat)
      return gl.DEPTH_COMPONENT;
    if (p === DepthStencilFormat)
      return gl.DEPTH_STENCIL;
    if (p === _SRGBAFormat) {
      extension = extensions.get("EXT_sRGB");
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT;
      } else {
        return null;
      }
    }
    if (p === RedFormat)
      return gl.RED;
    if (p === RedIntegerFormat)
      return gl.RED_INTEGER;
    if (p === RGFormat)
      return gl.RG;
    if (p === RGIntegerFormat)
      return gl.RG_INTEGER;
    if (p === RGBAIntegerFormat)
      return gl.RGBA_INTEGER;
    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc1");
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL;
      } else {
        return null;
      }
    }
    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p === RGB_ETC2_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p === RGBA_ETC2_EAC_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
      } else {
        return null;
      }
    }
    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p === RGBA_ASTC_4x4_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p === RGBA_ASTC_5x4_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p === RGBA_ASTC_5x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p === RGBA_ASTC_6x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p === RGBA_ASTC_6x6_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p === RGBA_ASTC_8x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p === RGBA_ASTC_8x6_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p === RGBA_ASTC_8x8_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p === RGBA_ASTC_10x5_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p === RGBA_ASTC_10x6_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p === RGBA_ASTC_10x8_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p === RGBA_ASTC_10x10_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p === RGBA_ASTC_12x10_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p === RGBA_ASTC_12x12_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p === RGBA_BPTC_Format || p === RGB_BPTC_SIGNED_Format || p === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p === RGB_BPTC_SIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p === RGB_BPTC_UNSIGNED_Format)
          return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p === RED_RGTC1_Format || p === SIGNED_RED_RGTC1_Format || p === RED_GREEN_RGTC2_Format || p === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p === RGBA_BPTC_Format)
          return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p === SIGNED_RED_RGTC1_Format)
          return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p === RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p === SIGNED_RED_GREEN_RGTC2_Format)
          return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p === UnsignedInt248Type) {
      if (isWebGL2)
        return gl.UNSIGNED_INT_24_8;
      extension = extensions.get("WEBGL_depth_texture");
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL;
      } else {
        return null;
      }
    }
    return gl[p] !== void 0 ? gl[p] : null;
  }
  return { convert };
}
var ArrayCamera = class extends PerspectiveCamera {
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.cameras = array;
  }
};
var Group2 = class extends Object3D2 {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
};
var _moveEvent = { type: "move" };
var WebXRController = class {
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group2();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group2();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector32();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector32();
    }
    return this._targetRay;
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group2();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector32();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector32();
    }
    return this._grip;
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  // private method
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group2();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
};
var DepthTexture = class extends Texture2 {
  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
    format = format !== void 0 ? format : DepthFormat;
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    if (type === void 0 && format === DepthFormat)
      type = UnsignedIntType;
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type;
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.image = { width, height };
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.compareFunction !== null)
      data.compareFunction = this.compareFunction;
    return data;
  }
};
var WebXRManager = class extends EventDispatcher2 {
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const cameraL = new PerspectiveCamera();
    cameraL.layers.enable(1);
    cameraL.viewport = new Vector42();
    const cameraR = new PerspectiveCamera();
    cameraR.layers.enable(2);
    cameraR.viewport = new Vector42();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    cameraXR.layers.enable(1);
    cameraXR.layers.enable(2);
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        if (inputSource === null)
          continue;
        controllerInputSources[i] = null;
        controllers[i].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        if (session.renderState.layers === void 0 || renderer.capabilities.isWebGL2 === false) {
          const layerInit = {
            antialias: session.renderState.layers === void 0 ? attributes.antialias : true,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat2,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = new XRWebGLBinding(session, gl);
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat2,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0
            }
          );
          const renderTargetProperties = renderer.properties.get(newRenderTarget);
          renderTargetProperties.__ignoreDepthValues = glProjLayer.ignoreDepthValues;
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i2;
              break;
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource;
              controllerIndex = i2;
              break;
            }
          }
          if (controllerIndex === -1)
            break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector32();
    const cameraRPos = new Vector32();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      const near2 = near + zOffset;
      const far2 = far + zOffset;
      const left2 = left - xOffset;
      const right2 = right + (ipd - xOffset);
      const top2 = topFov * far / far2 * near2;
      const bottom2 = bottomFov * far / far2 * near2;
      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
      camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null)
        return;
      cameraXR.near = cameraR.near = cameraL.near = camera.near;
      cameraXR.far = cameraR.far = cameraL.far = camera.far;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues ? void 0 : glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i);
            camera.viewport = new Vector42();
            cameras[i] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i];
        const controller = controllers[i];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMap.value = envMap;
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      const scaleFactor = renderer._useLegacyLights === true ? Math.PI : 1;
      uniforms.lightMapIntensity.value = material.lightMapIntensity * scaleFactor;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    const envMap = properties.get(material).envMap;
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = capabilities.isWebGL2 ? gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function bind(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i = 0; i < maxBindingPoints; i++) {
      if (allocatedBindingPoints.indexOf(i) === -1) {
        allocatedBindingPoints.push(i);
        return i;
      }
    }
    console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i = 0, il = uniforms.length; i < il; i++) {
      const uniform = uniforms[i];
      if (hasUniformChanged(uniform, i, cache) === true) {
        const offset = uniform.__offset;
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        let arrayOffset = 0;
        for (let i2 = 0; i2 < values.length; i2++) {
          const value = values[i2];
          const info2 = getUniformSize(value);
          if (typeof value === "number") {
            uniform.__data[0] = value;
            gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
          } else if (value.isMatrix3) {
            uniform.__data[0] = value.elements[0];
            uniform.__data[1] = value.elements[1];
            uniform.__data[2] = value.elements[2];
            uniform.__data[3] = value.elements[0];
            uniform.__data[4] = value.elements[3];
            uniform.__data[5] = value.elements[4];
            uniform.__data[6] = value.elements[5];
            uniform.__data[7] = value.elements[0];
            uniform.__data[8] = value.elements[6];
            uniform.__data[9] = value.elements[7];
            uniform.__data[10] = value.elements[8];
            uniform.__data[11] = value.elements[0];
          } else {
            value.toArray(uniform.__data, arrayOffset);
            arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
          }
        }
        gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, cache) {
    const value = uniform.value;
    if (cache[index] === void 0) {
      if (typeof value === "number") {
        cache[index] = value;
      } else {
        const values = Array.isArray(value) ? value : [value];
        const tempValues = [];
        for (let i = 0; i < values.length; i++) {
          tempValues.push(values[i].clone());
        }
        cache[index] = tempValues;
      }
      return true;
    } else {
      if (typeof value === "number") {
        if (cache[index] !== value) {
          cache[index] = value;
          return true;
        }
      } else {
        const cachedObjects = Array.isArray(cache[index]) ? cache[index] : [cache[index]];
        const values = Array.isArray(value) ? value : [value];
        for (let i = 0; i < cachedObjects.length; i++) {
          const cachedObject = cachedObjects[i];
          if (cachedObject.equals(values[i]) === false) {
            cachedObject.copy(values[i]);
            return true;
          }
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    let chunkOffset = 0;
    for (let i = 0, l = uniforms.length; i < l; i++) {
      const uniform = uniforms[i];
      const infos = {
        boundary: 0,
        // bytes
        storage: 0
        // bytes
      };
      const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
      for (let j = 0, jl = values.length; j < jl; j++) {
        const value = values[j];
        const info2 = getUniformSize(value);
        infos.boundary += info2.boundary;
        infos.storage += info2.storage;
      }
      uniform.__data = new Float32Array(infos.storage / Float32Array.BYTES_PER_ELEMENT);
      uniform.__offset = offset;
      if (i > 0) {
        chunkOffset = offset % chunkSize;
        const remainingSizeInChunk = chunkSize - chunkOffset;
        if (chunkOffset !== 0 && remainingSizeInChunk - infos.boundary < 0) {
          offset += chunkSize - chunkOffset;
          uniform.__offset = offset;
        }
      }
      offset += infos.storage;
    }
    chunkOffset = offset % chunkSize;
    if (chunkOffset > 0)
      offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind,
    update,
    dispose
  };
}
var WebGLRenderer = class {
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = true,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this._outputColorSpace = SRGBColorSpace;
    this._useLegacyLights = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    const _this = this;
    let _isContextLost = false;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector42();
    const _currentScissor = new Vector42();
    let _currentScissorTest = null;
    const _currentClearColor = new Color2(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector42(0, 0, _width, _height);
    const _scissor = new Vector42(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    let _transmissionRenderTarget = null;
    const _projScreenMatrix2 = new Matrix42();
    const _vector22 = new Vector22();
    const _vector32 = new Vector32();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext(contextNames, contextAttributes) {
      for (let i = 0; i < contextNames.length; i++) {
        const contextName = contextNames[i];
        const context2 = canvas.getContext(contextName, contextAttributes);
        if (context2 !== null)
          return context2;
      }
      return null;
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas)
        canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextNames = ["webgl2", "webgl", "experimental-webgl"];
        if (_this.isWebGL1Renderer === true) {
          contextNames.shift();
        }
        _gl = getContext(contextNames, contextAttributes);
        if (_gl === null) {
          if (getContext(contextNames)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
      if (typeof WebGLRenderingContext !== "undefined" && _gl instanceof WebGLRenderingContext) {
        console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163.");
      }
      if (_gl.getShaderPrecisionFormat === void 0) {
        _gl.getShaderPrecisionFormat = function() {
          return { "rangeMin": 1, "rangeMax": 1, "precision": 1 };
        };
      }
    } catch (error) {
      console.error("THREE.WebGLRenderer: " + error.message);
      throw error;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries2, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters);
      extensions.init(capabilities);
      utils = new WebGLUtils(_gl, extensions, capabilities);
      state = new WebGLState(_gl, extensions, capabilities);
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl, capabilities);
      bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);
      geometries2 = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries2, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions, capabilities);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    const xr = new WebXRManager(_this, _gl);
    this.xr = xr;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension)
        extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0)
        return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target4) {
      return target4.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr.isPresenting) {
        console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target4) {
      return target4.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.getCurrentViewport = function(target4) {
      return target4.copy(_currentViewport);
    };
    this.getViewport = function(target4) {
      return target4.copy(_viewport);
    };
    this.setViewport = function(x, y, width, height) {
      if (x.isVector4) {
        _viewport.set(x.x, x.y, x.z, x.w);
      } else {
        _viewport.set(x, y, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissor = function(target4) {
      return target4.copy(_scissor);
    };
    this.setScissor = function(x, y, width, height) {
      if (x.isVector4) {
        _scissor.set(x.x, x.y, x.z, x.w);
      } else {
        _scissor.set(x, y, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target4) {
      return target4.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor.apply(background, arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha.apply(background, arguments);
    };
    this.clear = function(color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = targetFormat === RGBAIntegerFormat || targetFormat === RGIntegerFormat || targetFormat === RedIntegerFormat;
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = targetType === UnsignedByteType || targetType === UnsignedIntType || targetType === UnsignedShortType || targetType === UnsignedInt248Type || targetType === UnsignedShort4444Type || targetType === UnsignedShort5551Type;
          const clearColor = background.getClearColor();
          const a = background.getClearAlpha();
          const r = clearColor.r;
          const g = clearColor.g;
          const b = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r;
            uintClearColor[1] = g;
            uintClearColor[2] = b;
            uintClearColor[3] = a;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r;
            intClearColor[1] = g;
            intClearColor[2] = b;
            intClearColor[3] = a;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2)
        bits |= _gl.DEPTH_BUFFER_BIT;
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr.dispose();
      xr.removeEventListener("sessionstart", onXRSessionStart);
      xr.removeEventListener("sessionend", onXRSessionEnd);
      if (_transmissionRenderTarget) {
        _transmissionRenderTarget.dispose();
        _transmissionRenderTarget = null;
      }
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      console.log("THREE.WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      console.log("THREE.WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null)
        scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries2.getWireframeAttribute(geometry);
        if (index === void 0)
          return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity)
        return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0)
          lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide2;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null)
        targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights(_this._useLegacyLights);
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i = 0; i < material.length; i++) {
              const material2 = material[i];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      renderStateStack.pop();
      currentRenderState = null;
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback)
        onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined")
      animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr.addEventListener("sessionstart", onXRSessionStart);
    xr.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true)
        return;
      if (scene.matrixWorldAutoUpdate === true)
        scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true)
        camera.updateMatrixWorld();
      if (xr.enabled === true && xr.isPresenting === true) {
        if (xr.cameraAutoUpdate === true)
          xr.updateCamera(camera);
        camera = xr.getCamera();
      }
      if (scene.isScene === true)
        scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init();
      renderStateStack.push(currentRenderState);
      _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix2);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true)
        clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true)
        clipping.endShadows();
      if (this.info.autoReset === true)
        this.info.reset();
      background.render(currentRenderList, scene);
      currentRenderState.setupLights(_this._useLegacyLights);
      if (camera.isArrayCamera) {
        const cameras = camera.cameras;
        for (let i = 0, l = cameras.length; i < l; i++) {
          const camera2 = cameras[i];
          renderScene(currentRenderList, scene, camera2, camera2.viewport);
        }
      } else {
        renderScene(currentRenderList, scene, camera);
      }
      if (_currentRenderTarget !== null) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (scene.isScene === true)
        scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false)
        return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true)
            object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector32.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null)
                  object.computeBoundingSphere();
                _vector32.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null)
                  geometry.computeBoundingSphere();
                _vector32.copy(geometry.boundingSphere.center);
              }
              _vector32.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix2);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i = 0, l = groups.length; i < l; i++) {
                const group = groups[i];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector32.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector32.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i = 0, l = children.length; i < l; i++) {
        projectObject(children[i], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const opaqueObjects = currentRenderList2.opaque;
      const transmissiveObjects = currentRenderList2.transmissive;
      const transparentObjects = currentRenderList2.transparent;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true)
        clipping.setGlobalState(_this.clippingPlanes, camera);
      if (transmissiveObjects.length > 0)
        renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
      if (viewport)
        state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0)
        renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0)
        renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0)
        renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      const isWebGL2 = capabilities.isWebGL2;
      if (_transmissionRenderTarget === null) {
        _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: extensions.has("EXT_color_buffer_half_float") ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: isWebGL2 ? 4 : 0
        });
      }
      _this.getDrawingBufferSize(_vector22);
      if (isWebGL2) {
        _transmissionRenderTarget.setSize(_vector22.x, _vector22.y);
      } else {
        _transmissionRenderTarget.setSize(floorPowerOfTwo(_vector22.x), floorPowerOfTwo(_vector22.y));
      }
      const currentRenderTarget = _this.getRenderTarget();
      _this.setRenderTarget(_transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1)
        _this.setClearColor(16777215, 0.5);
      _this.clear();
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
      textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      let renderTargetNeedsUpdate = false;
      for (let i = 0, l = transmissiveObjects.length; i < l; i++) {
        const renderItem = transmissiveObjects[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = renderItem.material;
        const group = renderItem.group;
        if (material.side === DoubleSide && object.layers.test(camera.layers)) {
          const currentSide = material.side;
          material.side = BackSide;
          material.needsUpdate = true;
          renderObject(object, scene, camera, geometry, material, group);
          material.side = currentSide;
          material.needsUpdate = true;
          renderTargetNeedsUpdate = true;
        }
      }
      if (renderTargetNeedsUpdate === true) {
        textures.updateMultisampleRenderTarget(_transmissionRenderTarget);
        textures.updateRenderTargetMipmap(_transmissionRenderTarget);
      }
      _this.setRenderTarget(currentRenderTarget);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i = 0, l = renderList.length; i < l; i++) {
        const renderItem = renderList[i];
        const object = renderItem.object;
        const geometry = renderItem.geometry;
        const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
        const group = renderItem.group;
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide2;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBuild(object, parameters2, _this);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true)
        scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (capabilities.isWebGL2 === true && materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (capabilities.floatVertexTextures) {
            if (skeleton.boneTexture === null)
              skeleton.computeBoneTexture();
            p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
            p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
          } else {
            console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.");
          }
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0 && capabilities.isWebGL2 === true) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, _transmissionRenderTarget);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i = 0, l = groups.length; i < l; i++) {
          if (capabilities.isWebGL2) {
            const group = groups[i];
            uniformsGroups.update(group, program);
            uniformsGroups.bind(group, program);
          } else {
            console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.");
          }
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = depthTexture;
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__hasExternalTextures = true;
      if (renderTargetProperties.__hasExternalTextures) {
        renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0;
        if (!renderTargetProperties.__autoAllocateDepthBuffer) {
          if (extensions.has("WEBGL_multisampled_render_to_texture") === true) {
            console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided");
            renderTargetProperties.__useRenderToTexture = false;
          }
        }
      }
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let useDefaultFramebuffer = true;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, null);
          useDefaultFramebuffer = false;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (capabilities.isWebGL2 && renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const textureProperties = properties.get(renderTarget.texture);
        const layer = activeCubeFace || 0;
        _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.texture;
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (textureFormat !== RGBAFormat2 && utils.convert(textureFormat) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || capabilities.isWebGL2 && extensions.has("EXT_color_buffer_float"));
          if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
          !(textureType === FloatType2 && (capabilities.isWebGL2 || extensions.has("OES_texture_float") || extensions.has("WEBGL_color_buffer_float"))) && // Chrome Mac >= 52 and Firefox
          !halfFloatSupportedByExt) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.copyFramebufferToTexture = function(position, texture, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, position.x, position.y, width, height);
      state.unbindTexture();
    };
    this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {
      const width = srcTexture.image.width;
      const height = srcTexture.image.height;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      textures.setTexture2D(dstTexture, 0);
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      if (srcTexture.isDataTexture) {
        _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
      } else {
        if (srcTexture.isCompressedTexture) {
          _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);
        } else {
          _gl.texSubImage2D(_gl.TEXTURE_2D, level, position.x, position.y, glFormat, glType, srcTexture.image);
        }
      }
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(_gl.TEXTURE_2D);
      state.unbindTexture();
    };
    this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {
      if (_this.isWebGL1Renderer) {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
        return;
      }
      const width = sourceBox.max.x - sourceBox.min.x + 1;
      const height = sourceBox.max.y - sourceBox.min.y + 1;
      const depth2 = sourceBox.max.z - sourceBox.min.z + 1;
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
        return;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const unpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const unpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const unpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const unpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const unpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[0] : srcTexture.image;
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, sourceBox.min.x);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, sourceBox.min.y);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, sourceBox.min.z);
      if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
        _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image.data);
      } else {
        if (srcTexture.isCompressedArrayTexture) {
          console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.");
          _gl.compressedTexSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, image.data);
        } else {
          _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, width, height, depth2, glFormat, glType, image);
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, unpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, unpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, unpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, unpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, unpackSkipImages);
      if (level === 0 && dstTexture.generateMipmaps)
        _gl.generateMipmap(glTarget);
      state.unbindTexture();
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl = this.getContext();
    gl.drawingBufferColorSpace = colorSpace === DisplayP3ColorSpace ? "display-p3" : "srgb";
    gl.unpackColorSpace = ColorManagement.workingColorSpace === LinearDisplayP3ColorSpace ? "display-p3" : "srgb";
  }
  get physicallyCorrectLights() {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    return !this.useLegacyLights;
  }
  set physicallyCorrectLights(value) {
    console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead.");
    this.useLegacyLights = !value;
  }
  get outputEncoding() {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    return this.outputColorSpace === SRGBColorSpace ? sRGBEncoding : LinearEncoding;
  }
  set outputEncoding(encoding) {
    console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead.");
    this.outputColorSpace = encoding === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;
  }
  get useLegacyLights() {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
    return this._useLegacyLights;
  }
  set useLegacyLights(value) {
    console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733.");
    this._useLegacyLights = value;
  }
};
var WebGL1Renderer = class extends WebGLRenderer {
};
WebGL1Renderer.prototype.isWebGL1Renderer = true;
var Scene2 = class extends Object3D2 {
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null)
      this.background = source.background.clone();
    if (source.environment !== null)
      this.environment = source.environment.clone();
    if (source.fog !== null)
      this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data = super.toJSON(meta);
    if (this.fog !== null)
      data.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0)
      data.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1)
      data.object.backgroundIntensity = this.backgroundIntensity;
    return data;
  }
};
var _vector$5 = new Vector32();
var _intersectPoint = new Vector32();
var _worldScale = new Vector32();
var _mvPosition = new Vector32();
var _alignedPosition = new Vector22();
var _rotatedPosition = new Vector22();
var _viewWorldMatrix = new Matrix42();
var _vA = new Vector32();
var _vB = new Vector32();
var _vC = new Vector32();
var _uvA = new Vector22();
var _uvB = new Vector22();
var _uvC = new Vector22();
var _v1$2 = new Vector32();
var _v2$1 = new Vector32();
var _basePosition = new Vector32();
var _skinIndex = new Vector42();
var _skinWeight = new Vector42();
var _vector3 = new Vector32();
var _matrix4 = new Matrix42();
var _vertex = new Vector32();
var _sphere$3 = new Sphere2();
var _inverseMatrix$2 = new Matrix42();
var _ray$2 = new Ray();
var _offsetMatrix = new Matrix42();
var _identityMatrix = new Matrix42();
var _instanceLocalMatrix = new Matrix42();
var _instanceWorldMatrix = new Matrix42();
var _box3 = new Box32();
var _identity = new Matrix42();
var _mesh = new Mesh2();
var _sphere$2 = new Sphere2();
var _start$1 = new Vector32();
var _end$1 = new Vector32();
var _inverseMatrix$1 = new Matrix42();
var _ray$1 = new Ray();
var _sphere$1 = new Sphere2();
var _start = new Vector32();
var _end = new Vector32();
var _inverseMatrix = new Matrix42();
var _ray = new Ray();
var _sphere = new Sphere2();
var _position$2 = new Vector32();
var Curve = class {
  constructor() {
    this.type = "Curve";
    this.arcLengthDivisions = 200;
  }
  // Virtual base class method to overwrite and implement in subclasses
  //	- t [0 .. 1]
  getPoint() {
    console.warn("THREE.Curve: .getPoint() not implemented.");
    return null;
  }
  // Get point at relative position in curve according to arc length
  // - u [0 .. 1]
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getPoint(t, optionalTarget);
  }
  // Get sequence of points using getPoint( t )
  getPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions));
    }
    return points;
  }
  // Get sequence of points using getPointAt( u )
  getSpacedPoints(divisions = 5) {
    const points = [];
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions));
    }
    return points;
  }
  // Get total curve arc length
  getLength() {
    const lengths = this.getLengths();
    return lengths[lengths.length - 1];
  }
  // Get list of cumulative segment lengths
  getLengths(divisions = this.arcLengthDivisions) {
    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
      return this.cacheArcLengths;
    }
    this.needsUpdate = false;
    const cache = [];
    let current, last = this.getPoint(0);
    let sum = 0;
    cache.push(0);
    for (let p = 1; p <= divisions; p++) {
      current = this.getPoint(p / divisions);
      sum += current.distanceTo(last);
      cache.push(sum);
      last = current;
    }
    this.cacheArcLengths = cache;
    return cache;
  }
  updateArcLengths() {
    this.needsUpdate = true;
    this.getLengths();
  }
  // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths();
    let i = 0;
    const il = arcLengths.length;
    let targetArcLength;
    if (distance) {
      targetArcLength = distance;
    } else {
      targetArcLength = u * arcLengths[il - 1];
    }
    let low = 0, high = il - 1, comparison;
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2);
      comparison = arcLengths[i] - targetArcLength;
      if (comparison < 0) {
        low = i + 1;
      } else if (comparison > 0) {
        high = i - 1;
      } else {
        high = i;
        break;
      }
    }
    i = high;
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1);
    }
    const lengthBefore = arcLengths[i];
    const lengthAfter = arcLengths[i + 1];
    const segmentLength = lengthAfter - lengthBefore;
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
    const t = (i + segmentFraction) / (il - 1);
    return t;
  }
  // Returns a unit vector tangent at t
  // In case any sub curve does not implement its tangent derivation,
  // 2 points a small delta apart will be used to find its gradient
  // which seems to give a reasonable approximation
  getTangent(t, optionalTarget) {
    const delta = 1e-4;
    let t1 = t - delta;
    let t2 = t + delta;
    if (t1 < 0)
      t1 = 0;
    if (t2 > 1)
      t2 = 1;
    const pt1 = this.getPoint(t1);
    const pt2 = this.getPoint(t2);
    const tangent = optionalTarget || (pt1.isVector2 ? new Vector22() : new Vector32());
    tangent.copy(pt2).sub(pt1).normalize();
    return tangent;
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u);
    return this.getTangent(t, optionalTarget);
  }
  computeFrenetFrames(segments, closed) {
    const normal = new Vector32();
    const tangents = [];
    const normals = [];
    const binormals = [];
    const vec = new Vector32();
    const mat = new Matrix42();
    for (let i = 0; i <= segments; i++) {
      const u = i / segments;
      tangents[i] = this.getTangentAt(u, new Vector32());
    }
    normals[0] = new Vector32();
    binormals[0] = new Vector32();
    let min = Number.MAX_VALUE;
    const tx = Math.abs(tangents[0].x);
    const ty = Math.abs(tangents[0].y);
    const tz = Math.abs(tangents[0].z);
    if (tx <= min) {
      min = tx;
      normal.set(1, 0, 0);
    }
    if (ty <= min) {
      min = ty;
      normal.set(0, 1, 0);
    }
    if (tz <= min) {
      normal.set(0, 0, 1);
    }
    vec.crossVectors(tangents[0], normal).normalize();
    normals[0].crossVectors(tangents[0], vec);
    binormals[0].crossVectors(tangents[0], normals[0]);
    for (let i = 1; i <= segments; i++) {
      normals[i] = normals[i - 1].clone();
      binormals[i] = binormals[i - 1].clone();
      vec.crossVectors(tangents[i - 1], tangents[i]);
      if (vec.length() > Number.EPSILON) {
        vec.normalize();
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
      }
      binormals[i].crossVectors(tangents[i], normals[i]);
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));
      theta /= segments;
      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
        theta = -theta;
      }
      for (let i = 1; i <= segments; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
        binormals[i].crossVectors(tangents[i], normals[i]);
      }
    }
    return {
      tangents,
      normals,
      binormals
    };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions;
    return this;
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.6,
        type: "Curve",
        generator: "Curve.toJSON"
      }
    };
    data.arcLengthDivisions = this.arcLengthDivisions;
    data.type = this.type;
    return data;
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions;
    return this;
  }
};
var EllipseCurve = class extends Curve {
  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {
    super();
    this.isEllipseCurve = true;
    this.type = "EllipseCurve";
    this.aX = aX;
    this.aY = aY;
    this.xRadius = xRadius;
    this.yRadius = yRadius;
    this.aStartAngle = aStartAngle;
    this.aEndAngle = aEndAngle;
    this.aClockwise = aClockwise;
    this.aRotation = aRotation;
  }
  getPoint(t, optionalTarget) {
    const point = optionalTarget || new Vector22();
    const twoPi = Math.PI * 2;
    let deltaAngle = this.aEndAngle - this.aStartAngle;
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;
    while (deltaAngle < 0)
      deltaAngle += twoPi;
    while (deltaAngle > twoPi)
      deltaAngle -= twoPi;
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0;
      } else {
        deltaAngle = twoPi;
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi;
      } else {
        deltaAngle = deltaAngle - twoPi;
      }
    }
    const angle = this.aStartAngle + t * deltaAngle;
    let x = this.aX + this.xRadius * Math.cos(angle);
    let y = this.aY + this.yRadius * Math.sin(angle);
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation);
      const sin = Math.sin(this.aRotation);
      const tx = x - this.aX;
      const ty = y - this.aY;
      x = tx * cos - ty * sin + this.aX;
      y = tx * sin + ty * cos + this.aY;
    }
    return point.set(x, y);
  }
  copy(source) {
    super.copy(source);
    this.aX = source.aX;
    this.aY = source.aY;
    this.xRadius = source.xRadius;
    this.yRadius = source.yRadius;
    this.aStartAngle = source.aStartAngle;
    this.aEndAngle = source.aEndAngle;
    this.aClockwise = source.aClockwise;
    this.aRotation = source.aRotation;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.aX = this.aX;
    data.aY = this.aY;
    data.xRadius = this.xRadius;
    data.yRadius = this.yRadius;
    data.aStartAngle = this.aStartAngle;
    data.aEndAngle = this.aEndAngle;
    data.aClockwise = this.aClockwise;
    data.aRotation = this.aRotation;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.aX = json.aX;
    this.aY = json.aY;
    this.xRadius = json.xRadius;
    this.yRadius = json.yRadius;
    this.aStartAngle = json.aStartAngle;
    this.aEndAngle = json.aEndAngle;
    this.aClockwise = json.aClockwise;
    this.aRotation = json.aRotation;
    return this;
  }
};
var ArcCurve = class extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    this.isArcCurve = true;
    this.type = "ArcCurve";
  }
};
function CubicPoly() {
  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;
  function init(x0, x1, t0, t1) {
    c0 = x0;
    c1 = t0;
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
    c3 = 2 * x0 - 2 * x1 + t0 + t1;
  }
  return {
    initCatmullRom: function(x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
    },
    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
      t1 *= dt1;
      t2 *= dt1;
      init(x1, x2, t1, t2);
    },
    calc: function(t) {
      const t2 = t * t;
      const t3 = t2 * t;
      return c0 + c1 * t + c2 * t2 + c3 * t3;
    }
  };
}
var tmp = new Vector32();
var px = new CubicPoly();
var py = new CubicPoly();
var pz = new CubicPoly();
var CatmullRomCurve3 = class extends Curve {
  constructor(points = [], closed = false, curveType = "centripetal", tension = 0.5) {
    super();
    this.isCatmullRomCurve3 = true;
    this.type = "CatmullRomCurve3";
    this.points = points;
    this.closed = closed;
    this.curveType = curveType;
    this.tension = tension;
  }
  getPoint(t, optionalTarget = new Vector32()) {
    const point = optionalTarget;
    const points = this.points;
    const l = points.length;
    const p = (l - (this.closed ? 0 : 1)) * t;
    let intPoint = Math.floor(p);
    let weight = p - intPoint;
    if (this.closed) {
      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2;
      weight = 1;
    }
    let p0, p3;
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l];
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0]);
      p0 = tmp;
    }
    const p1 = points[intPoint % l];
    const p2 = points[(intPoint + 1) % l];
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l];
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
      p3 = tmp;
    }
    if (this.curveType === "centripetal" || this.curveType === "chordal") {
      const pow = this.curveType === "chordal" ? 0.5 : 0.25;
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);
      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);
      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);
      if (dt1 < 1e-4)
        dt1 = 1;
      if (dt0 < 1e-4)
        dt0 = dt1;
      if (dt2 < 1e-4)
        dt2 = dt1;
      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
    } else if (this.curveType === "catmullrom") {
      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
    }
    point.set(
      px.calc(weight),
      py.calc(weight),
      pz.calc(weight)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    this.closed = source.closed;
    this.curveType = source.curveType;
    this.tension = source.tension;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    data.closed = this.closed;
    data.curveType = this.curveType;
    data.tension = this.tension;
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector32().fromArray(point));
    }
    this.closed = json.closed;
    this.curveType = json.curveType;
    this.tension = json.tension;
    return this;
  }
};
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5;
  const v1 = (p3 - p1) * 0.5;
  const t2 = t * t;
  const t3 = t * t2;
  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
}
function QuadraticBezierP0(t, p) {
  const k = 1 - t;
  return k * k * p;
}
function QuadraticBezierP1(t, p) {
  return 2 * (1 - t) * t * p;
}
function QuadraticBezierP2(t, p) {
  return t * t * p;
}
function QuadraticBezier(t, p0, p1, p2) {
  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
}
function CubicBezierP0(t, p) {
  const k = 1 - t;
  return k * k * k * p;
}
function CubicBezierP1(t, p) {
  const k = 1 - t;
  return 3 * k * k * t * p;
}
function CubicBezierP2(t, p) {
  return 3 * (1 - t) * t * t * p;
}
function CubicBezierP3(t, p) {
  return t * t * t * p;
}
function CubicBezier(t, p0, p1, p2, p3) {
  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
}
var CubicBezierCurve = class extends Curve {
  constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22(), v3 = new Vector22()) {
    super();
    this.isCubicBezierCurve = true;
    this.type = "CubicBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector22()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
var CubicBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector32(), v1 = new Vector32(), v2 = new Vector32(), v3 = new Vector32()) {
    super();
    this.isCubicBezierCurve3 = true;
    this.type = "CubicBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
  }
  getPoint(t, optionalTarget = new Vector32()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t, v0.z, v1.z, v2.z, v3.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    this.v3.copy(source.v3);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    data.v3 = this.v3.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    this.v3.fromArray(json.v3);
    return this;
  }
};
var LineCurve = class extends Curve {
  constructor(v1 = new Vector22(), v2 = new Vector22()) {
    super();
    this.isLineCurve = true;
    this.type = "LineCurve";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector22()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector22()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var LineCurve3 = class extends Curve {
  constructor(v1 = new Vector32(), v2 = new Vector32()) {
    super();
    this.isLineCurve3 = true;
    this.type = "LineCurve3";
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector32()) {
    const point = optionalTarget;
    if (t === 1) {
      point.copy(this.v2);
    } else {
      point.copy(this.v2).sub(this.v1);
      point.multiplyScalar(t).add(this.v1);
    }
    return point;
  }
  // Line curve is linear, so we can overwrite default getPointAt
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget);
  }
  getTangent(t, optionalTarget = new Vector32()) {
    return optionalTarget.subVectors(this.v2, this.v1).normalize();
  }
  getTangentAt(u, optionalTarget) {
    return this.getTangent(u, optionalTarget);
  }
  copy(source) {
    super.copy(source);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve = class extends Curve {
  constructor(v0 = new Vector22(), v1 = new Vector22(), v2 = new Vector22()) {
    super();
    this.isQuadraticBezierCurve = true;
    this.type = "QuadraticBezierCurve";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector22()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var QuadraticBezierCurve3 = class extends Curve {
  constructor(v0 = new Vector32(), v1 = new Vector32(), v2 = new Vector32()) {
    super();
    this.isQuadraticBezierCurve3 = true;
    this.type = "QuadraticBezierCurve3";
    this.v0 = v0;
    this.v1 = v1;
    this.v2 = v2;
  }
  getPoint(t, optionalTarget = new Vector32()) {
    const point = optionalTarget;
    const v0 = this.v0, v1 = this.v1, v2 = this.v2;
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.v0.copy(source.v0);
    this.v1.copy(source.v1);
    this.v2.copy(source.v2);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.v0 = this.v0.toArray();
    data.v1 = this.v1.toArray();
    data.v2 = this.v2.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.v0.fromArray(json.v0);
    this.v1.fromArray(json.v1);
    this.v2.fromArray(json.v2);
    return this;
  }
};
var SplineCurve = class extends Curve {
  constructor(points = []) {
    super();
    this.isSplineCurve = true;
    this.type = "SplineCurve";
    this.points = points;
  }
  getPoint(t, optionalTarget = new Vector22()) {
    const point = optionalTarget;
    const points = this.points;
    const p = (points.length - 1) * t;
    const intPoint = Math.floor(p);
    const weight = p - intPoint;
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
    const p1 = points[intPoint];
    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
    point.set(
      CatmullRom(weight, p0.x, p1.x, p2.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p2.y, p3.y)
    );
    return point;
  }
  copy(source) {
    super.copy(source);
    this.points = [];
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i];
      this.points.push(point.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.points = [];
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i];
      data.points.push(point.toArray());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.points = [];
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i];
      this.points.push(new Vector22().fromArray(point));
    }
    return this;
  }
};
var Curves = Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve
});
var CurvePath = class extends Curve {
  constructor() {
    super();
    this.type = "CurvePath";
    this.curves = [];
    this.autoClose = false;
  }
  add(curve) {
    this.curves.push(curve);
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0);
    const endPoint = this.curves[this.curves.length - 1].getPoint(1);
    if (!startPoint.equals(endPoint)) {
      const lineType = startPoint.isVector2 === true ? "LineCurve" : "LineCurve3";
      this.curves.push(new Curves[lineType](endPoint, startPoint));
    }
    return this;
  }
  // To get accurate point with reference to
  // entire path distance at time t,
  // following has to be done:
  // 1. Length of each sub path have to be known
  // 2. Locate and identify type of curve
  // 3. Get t for the curve
  // 4. Return curve.getPointAt(t')
  getPoint(t, optionalTarget) {
    const d = t * this.getLength();
    const curveLengths = this.getCurveLengths();
    let i = 0;
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d;
        const curve = this.curves[i];
        const segmentLength = curve.getLength();
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
        return curve.getPointAt(u, optionalTarget);
      }
      i++;
    }
    return null;
  }
  // We cannot use the default THREE.Curve getPoint() with getLength() because in
  // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
  // getPoint() depends on getLength
  getLength() {
    const lens = this.getCurveLengths();
    return lens[lens.length - 1];
  }
  // cacheLengths must be recalculated.
  updateArcLengths() {
    this.needsUpdate = true;
    this.cacheLengths = null;
    this.getCurveLengths();
  }
  // Compute lengths and cache them
  // We cannot overwrite getLengths() because UtoT mapping uses it.
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths;
    }
    const lengths = [];
    let sums = 0;
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength();
      lengths.push(sums);
    }
    this.cacheLengths = lengths;
    return lengths;
  }
  getSpacedPoints(divisions = 40) {
    const points = [];
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions));
    }
    if (this.autoClose) {
      points.push(points[0]);
    }
    return points;
  }
  getPoints(divisions = 12) {
    const points = [];
    let last;
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i];
      const resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
      const pts = curve.getPoints(resolution);
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j];
        if (last && last.equals(point))
          continue;
        points.push(point);
        last = point;
      }
    }
    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
      points.push(points[0]);
    }
    return points;
  }
  copy(source) {
    super.copy(source);
    this.curves = [];
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i];
      this.curves.push(curve.clone());
    }
    this.autoClose = source.autoClose;
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.autoClose = this.autoClose;
    data.curves = [];
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i];
      data.curves.push(curve.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.autoClose = json.autoClose;
    this.curves = [];
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i];
      this.curves.push(new Curves[curve.type]().fromJSON(curve));
    }
    return this;
  }
};
var Path = class extends CurvePath {
  constructor(points) {
    super();
    this.type = "Path";
    this.currentPoint = new Vector22();
    if (points) {
      this.setFromPoints(points);
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y);
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y);
    }
    return this;
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y);
    return this;
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector22(x, y));
    this.curves.push(curve);
    this.currentPoint.set(x, y);
    return this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector22(aCPx, aCPy),
      new Vector22(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector22(aCP1x, aCP1y),
      new Vector22(aCP2x, aCP2y),
      new Vector22(aX, aY)
    );
    this.curves.push(curve);
    this.currentPoint.set(aX, aY);
    return this;
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts);
    const curve = new SplineCurve(npts);
    this.curves.push(curve);
    this.currentPoint.copy(pts[pts.length - 1]);
    return this;
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absarc(
      aX + x0,
      aY + y0,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise
    );
    return this;
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
    return this;
  }
  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const x0 = this.currentPoint.x;
    const y0 = this.currentPoint.y;
    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    return this;
  }
  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0);
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y);
      }
    }
    this.curves.push(curve);
    const lastPoint = curve.getPoint(1);
    this.currentPoint.copy(lastPoint);
    return this;
  }
  copy(source) {
    super.copy(source);
    this.currentPoint.copy(source.currentPoint);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.currentPoint = this.currentPoint.toArray();
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.currentPoint.fromArray(json.currentPoint);
    return this;
  }
};
var LatheGeometry = class _LatheGeometry extends BufferGeometry2 {
  constructor(points = [new Vector22(0, -0.5), new Vector22(0.5, 0), new Vector22(0, 0.5)], segments = 12, phiStart = 0, phiLength = Math.PI * 2) {
    super();
    this.type = "LatheGeometry";
    this.parameters = {
      points,
      segments,
      phiStart,
      phiLength
    };
    segments = Math.floor(segments);
    phiLength = clamp(phiLength, 0, Math.PI * 2);
    const indices = [];
    const vertices = [];
    const uvs = [];
    const initNormals = [];
    const normals = [];
    const inverseSegments = 1 / segments;
    const vertex2 = new Vector32();
    const uv = new Vector22();
    const normal = new Vector32();
    const curNormal = new Vector32();
    const prevNormal = new Vector32();
    let dx = 0;
    let dy = 0;
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          prevNormal.copy(normal);
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          break;
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
          break;
        default:
          dx = points[j + 1].x - points[j].x;
          dy = points[j + 1].y - points[j].y;
          normal.x = dy * 1;
          normal.y = -dx;
          normal.z = dy * 0;
          curNormal.copy(normal);
          normal.x += prevNormal.x;
          normal.y += prevNormal.y;
          normal.z += prevNormal.z;
          normal.normalize();
          initNormals.push(normal.x, normal.y, normal.z);
          prevNormal.copy(curNormal);
      }
    }
    for (let i = 0; i <= segments; i++) {
      const phi = phiStart + i * inverseSegments * phiLength;
      const sin = Math.sin(phi);
      const cos = Math.cos(phi);
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin;
        vertex2.y = points[j].y;
        vertex2.z = points[j].x * cos;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        uv.x = i / segments;
        uv.y = j / (points.length - 1);
        uvs.push(uv.x, uv.y);
        const x = initNormals[3 * j + 0] * sin;
        const y = initNormals[3 * j + 1];
        const z = initNormals[3 * j + 0] * cos;
        normals.push(x, y, z);
      }
    }
    for (let i = 0; i < segments; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length;
        const a = base;
        const b = base + points.length;
        const c = base + points.length + 1;
        const d = base + 1;
        indices.push(a, b, d);
        indices.push(c, d, b);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
  }
};
var CapsuleGeometry = class _CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path();
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
    super(path.getPoints(capSegments), radialSegments);
    this.type = "CapsuleGeometry";
    this.parameters = {
      radius,
      length,
      capSegments,
      radialSegments
    };
  }
  static fromJSON(data) {
    return new _CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
  }
};
var CircleGeometry = class _CircleGeometry extends BufferGeometry2 {
  constructor(radius = 1, segments = 32, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CircleGeometry";
    this.parameters = {
      radius,
      segments,
      thetaStart,
      thetaLength
    };
    segments = Math.max(3, segments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector32();
    const uv = new Vector22();
    vertices.push(0, 0, 0);
    normals.push(0, 0, 1);
    uvs.push(0.5, 0.5);
    for (let s = 0, i = 3; s <= segments; s++, i += 3) {
      const segment = thetaStart + s / segments * thetaLength;
      vertex2.x = radius * Math.cos(segment);
      vertex2.y = radius * Math.sin(segment);
      vertices.push(vertex2.x, vertex2.y, vertex2.z);
      normals.push(0, 0, 1);
      uv.x = (vertices[i] / radius + 1) / 2;
      uv.y = (vertices[i + 1] / radius + 1) / 2;
      uvs.push(uv.x, uv.y);
    }
    for (let i = 1; i <= segments; i++) {
      indices.push(i, i + 1, 0);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
  }
};
var CylinderGeometry = class _CylinderGeometry extends BufferGeometry2 {
  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "CylinderGeometry";
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
    const scope = this;
    radialSegments = Math.floor(radialSegments);
    heightSegments = Math.floor(heightSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let index = 0;
    const indexArray = [];
    const halfHeight = height / 2;
    let groupStart = 0;
    generateTorso();
    if (openEnded === false) {
      if (radiusTop > 0)
        generateCap(true);
      if (radiusBottom > 0)
        generateCap(false);
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function generateTorso() {
      const normal = new Vector32();
      const vertex2 = new Vector32();
      let groupCount = 0;
      const slope = (radiusBottom - radiusTop) / height;
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = [];
        const v = y / heightSegments;
        const radius = v * (radiusBottom - radiusTop) + radiusTop;
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments;
          const theta = u * thetaLength + thetaStart;
          const sinTheta = Math.sin(theta);
          const cosTheta = Math.cos(theta);
          vertex2.x = radius * sinTheta;
          vertex2.y = -v * height + halfHeight;
          vertex2.z = radius * cosTheta;
          vertices.push(vertex2.x, vertex2.y, vertex2.z);
          normal.set(sinTheta, slope, cosTheta).normalize();
          normals.push(normal.x, normal.y, normal.z);
          uvs.push(u, 1 - v);
          indexRow.push(index++);
        }
        indexArray.push(indexRow);
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x];
          const b = indexArray[y + 1][x];
          const c = indexArray[y + 1][x + 1];
          const d = indexArray[y][x + 1];
          indices.push(a, b, d);
          indices.push(b, c, d);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, 0);
      groupStart += groupCount;
    }
    function generateCap(top) {
      const centerIndexStart = index;
      const uv = new Vector22();
      const vertex2 = new Vector32();
      let groupCount = 0;
      const radius = top === true ? radiusTop : radiusBottom;
      const sign2 = top === true ? 1 : -1;
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0);
        normals.push(0, sign2, 0);
        uvs.push(0.5, 0.5);
        index++;
      }
      const centerIndexEnd = index;
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments;
        const theta = u * thetaLength + thetaStart;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        vertex2.x = radius * sinTheta;
        vertex2.y = halfHeight * sign2;
        vertex2.z = radius * cosTheta;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, sign2, 0);
        uv.x = cosTheta * 0.5 + 0.5;
        uv.y = sinTheta * 0.5 * sign2 + 0.5;
        uvs.push(uv.x, uv.y);
        index++;
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x;
        const i = centerIndexEnd + x;
        if (top === true) {
          indices.push(i, i + 1, c);
        } else {
          indices.push(i + 1, i, c);
        }
        groupCount += 3;
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
      groupStart += groupCount;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var ConeGeometry = class _ConeGeometry extends CylinderGeometry {
  constructor(radius = 1, height = 1, radialSegments = 32, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {
    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
    this.type = "ConeGeometry";
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength
    };
  }
  static fromJSON(data) {
    return new _ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
  }
};
var PolyhedronGeometry = class _PolyhedronGeometry extends BufferGeometry2 {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super();
    this.type = "PolyhedronGeometry";
    this.parameters = {
      vertices,
      indices,
      radius,
      detail
    };
    const vertexBuffer = [];
    const uvBuffer = [];
    subdivide(detail);
    applyRadius(radius);
    generateUVs();
    this.setAttribute("position", new Float32BufferAttribute2(vertexBuffer, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(vertexBuffer.slice(), 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvBuffer, 2));
    if (detail === 0) {
      this.computeVertexNormals();
    } else {
      this.normalizeNormals();
    }
    function subdivide(detail2) {
      const a = new Vector32();
      const b = new Vector32();
      const c = new Vector32();
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a);
        getVertexByIndex(indices[i + 1], b);
        getVertexByIndex(indices[i + 2], c);
        subdivideFace(a, b, c, detail2);
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1;
      const v = [];
      for (let i = 0; i <= cols; i++) {
        v[i] = [];
        const aj = a.clone().lerp(c, i / cols);
        const bj = b.clone().lerp(c, i / cols);
        const rows = cols - i;
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj;
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows);
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2);
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k]);
            pushVertex(v[i][k]);
          } else {
            pushVertex(v[i][k + 1]);
            pushVertex(v[i + 1][k + 1]);
            pushVertex(v[i + 1][k]);
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector32();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        vertex2.normalize().multiplyScalar(radius2);
        vertexBuffer[i + 0] = vertex2.x;
        vertexBuffer[i + 1] = vertex2.y;
        vertexBuffer[i + 2] = vertex2.z;
      }
    }
    function generateUVs() {
      const vertex2 = new Vector32();
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0];
        vertex2.y = vertexBuffer[i + 1];
        vertex2.z = vertexBuffer[i + 2];
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5;
        const v = inclination(vertex2) / Math.PI + 0.5;
        uvBuffer.push(u, 1 - v);
      }
      correctUVs();
      correctSeam();
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0];
        const x1 = uvBuffer[i + 2];
        const x2 = uvBuffer[i + 4];
        const max = Math.max(x0, x1, x2);
        const min = Math.min(x0, x1, x2);
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2)
            uvBuffer[i + 0] += 1;
          if (x1 < 0.2)
            uvBuffer[i + 2] += 1;
          if (x2 < 0.2)
            uvBuffer[i + 4] += 1;
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z);
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3;
      vertex2.x = vertices[stride + 0];
      vertex2.y = vertices[stride + 1];
      vertex2.z = vertices[stride + 2];
    }
    function correctUVs() {
      const a = new Vector32();
      const b = new Vector32();
      const c = new Vector32();
      const centroid = new Vector32();
      const uvA = new Vector22();
      const uvB = new Vector22();
      const uvC = new Vector22();
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
        centroid.copy(a).add(b).add(c).divideScalar(3);
        const azi = azimuth(centroid);
        correctUV(uvA, j + 0, a, azi);
        correctUV(uvB, j + 2, b, azi);
        correctUV(uvC, j + 4, c, azi);
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1;
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x);
    }
    function inclination(vector) {
      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
  }
};
var DodecahedronGeometry = class _DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const r = 1 / t;
    const vertices = [
      // (1, 1, 1)
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      // (0, 1/, )
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      // (1/, , 0)
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      // (, 0, 1/)
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r
    ];
    const indices = [
      3,
      11,
      7,
      3,
      7,
      15,
      3,
      15,
      13,
      7,
      19,
      17,
      7,
      17,
      6,
      7,
      6,
      15,
      17,
      4,
      8,
      17,
      8,
      10,
      17,
      10,
      6,
      8,
      0,
      16,
      8,
      16,
      2,
      8,
      2,
      10,
      0,
      12,
      1,
      0,
      1,
      18,
      0,
      18,
      16,
      6,
      10,
      2,
      6,
      2,
      13,
      6,
      13,
      15,
      2,
      16,
      18,
      2,
      18,
      3,
      2,
      3,
      13,
      18,
      1,
      9,
      18,
      9,
      11,
      18,
      11,
      3,
      4,
      14,
      12,
      4,
      12,
      0,
      4,
      0,
      8,
      11,
      9,
      5,
      11,
      5,
      19,
      11,
      19,
      7,
      19,
      5,
      14,
      19,
      14,
      4,
      19,
      4,
      17,
      1,
      12,
      14,
      1,
      14,
      5,
      1,
      5,
      9
    ];
    super(vertices, indices, radius, detail);
    this.type = "DodecahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _DodecahedronGeometry(data.radius, data.detail);
  }
};
var _v0 = new Vector32();
var _v1$1 = new Vector32();
var _normal = new Vector32();
var _triangle = new Triangle2();
var EdgesGeometry = class extends BufferGeometry2 {
  constructor(geometry = null, thresholdAngle = 1) {
    super();
    this.type = "EdgesGeometry";
    this.parameters = {
      geometry,
      thresholdAngle
    };
    if (geometry !== null) {
      const precisionPoints = 4;
      const precision = Math.pow(10, precisionPoints);
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
      const indexAttr = geometry.getIndex();
      const positionAttr = geometry.getAttribute("position");
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count;
      const indexArr = [0, 0, 0];
      const vertKeys = ["a", "b", "c"];
      const hashes = new Array(3);
      const edgeData = {};
      const vertices = [];
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i);
          indexArr[1] = indexAttr.getX(i + 1);
          indexArr[2] = indexAttr.getX(i + 2);
        } else {
          indexArr[0] = i;
          indexArr[1] = i + 1;
          indexArr[2] = i + 2;
        }
        const { a, b, c } = _triangle;
        a.fromBufferAttribute(positionAttr, indexArr[0]);
        b.fromBufferAttribute(positionAttr, indexArr[1]);
        c.fromBufferAttribute(positionAttr, indexArr[2]);
        _triangle.getNormal(_normal);
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;
        if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
          continue;
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3;
          const vecHash0 = hashes[j];
          const vecHash1 = hashes[jNext];
          const v0 = _triangle[vertKeys[j]];
          const v1 = _triangle[vertKeys[jNext]];
          const hash = `${vecHash0}_${vecHash1}`;
          const reverseHash = `${vecHash1}_${vecHash0}`;
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z);
              vertices.push(v1.x, v1.y, v1.z);
            }
            edgeData[reverseHash] = null;
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone()
            };
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key];
          _v0.fromBufferAttribute(positionAttr, index0);
          _v1$1.fromBufferAttribute(positionAttr, index1);
          vertices.push(_v0.x, _v0.y, _v0.z);
          vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
        }
      }
      this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
};
var Shape = class extends Path {
  constructor(points) {
    super(points);
    this.uuid = generateUUID();
    this.type = "Shape";
    this.holes = [];
  }
  getPointsHoles(divisions) {
    const holesPts = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions);
    }
    return holesPts;
  }
  // get points of shape and holes (keypoints based on segments parameter)
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions)
    };
  }
  copy(source) {
    super.copy(source);
    this.holes = [];
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i];
      this.holes.push(hole.clone());
    }
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.uuid = this.uuid;
    data.holes = [];
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i];
      data.holes.push(hole.toJSON());
    }
    return data;
  }
  fromJSON(json) {
    super.fromJSON(json);
    this.uuid = json.uuid;
    this.holes = [];
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i];
      this.holes.push(new Path().fromJSON(hole));
    }
    return this;
  }
};
var Earcut = {
  triangulate: function(data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length;
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    let outerNode = linkedList(data, 0, outerLen, dim, true);
    const triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev)
      return triangles;
    let minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles)
      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX)
          minX = x;
        if (y < minY)
          minY = y;
        if (x > maxX)
          maxX = x;
        if (y > maxY)
          maxY = y;
      }
      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 32767 / invSize : 0;
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
    return triangles;
  }
};
function linkedList(data, start, end, dim, clockwise) {
  let i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  let p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  let stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  let p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  const ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  const x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  const minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  let p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  let p = start;
  do {
    const a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start;
  do {
    let b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue = [];
  let i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  const bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  const bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  let p = outerNode, qx = -Infinity, m;
  const hx = hole.x, hy = hole.y;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx)
          return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  const stop = m, mx = m.x, my = m.y;
  let tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  let p = start;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  let p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (cx - px2) * (ay - py2) >= (ax - px2) * (cy - py2) && (ax - px2) * (by - py2) >= (bx - px2) * (ay - py2) && (bx - px2) * (cy - py2) >= (cx - px2) * (by - py2);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2));
  const o2 = sign(area(p1, q1, q2));
  const o3 = sign(area(p2, q2, p1));
  const o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  let p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  let p = a, inside = false;
  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;
  do {
    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  const p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
function signedArea(data, start, end, dim) {
  let sum = 0;
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
var ShapeUtils = class _ShapeUtils {
  // calculate area of the contour polygon
  static area(contour) {
    const n = contour.length;
    let a = 0;
    for (let p = n - 1, q = 0; q < n; p = q++) {
      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
    }
    return a * 0.5;
  }
  static isClockWise(pts) {
    return _ShapeUtils.area(pts) < 0;
  }
  static triangulateShape(contour, holes) {
    const vertices = [];
    const holeIndices = [];
    const faces = [];
    removeDupEndPts(contour);
    addContour(vertices, contour);
    let holeIndex = contour.length;
    holes.forEach(removeDupEndPts);
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex);
      holeIndex += holes[i].length;
      addContour(vertices, holes[i]);
    }
    const triangles = Earcut.triangulate(vertices, holeIndices);
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3));
    }
    return faces;
  }
};
function removeDupEndPts(points) {
  const l = points.length;
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop();
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x);
    vertices.push(contour[i].y);
  }
}
var ExtrudeGeometry = class _ExtrudeGeometry extends BufferGeometry2 {
  constructor(shapes = new Shape([new Vector22(0.5, 0.5), new Vector22(-0.5, 0.5), new Vector22(-0.5, -0.5), new Vector22(0.5, -0.5)]), options = {}) {
    super();
    this.type = "ExtrudeGeometry";
    this.parameters = {
      shapes,
      options
    };
    shapes = Array.isArray(shapes) ? shapes : [shapes];
    const scope = this;
    const verticesArray = [];
    const uvArray = [];
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      addShape(shape);
    }
    this.setAttribute("position", new Float32BufferAttribute2(verticesArray, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvArray, 2));
    this.computeVertexNormals();
    function addShape(shape) {
      const placeholder = [];
      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;
      const steps = options.steps !== void 0 ? options.steps : 1;
      const depth = options.depth !== void 0 ? options.depth : 1;
      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;
      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 0.2;
      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1;
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;
      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;
      const extrudePath = options.extrudePath;
      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;
      let extrudePts, extrudeByPath = false;
      let splineTube, binormal, normal, position2;
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps);
        extrudeByPath = true;
        bevelEnabled = false;
        splineTube = extrudePath.computeFrenetFrames(steps, false);
        binormal = new Vector32();
        normal = new Vector32();
        position2 = new Vector32();
      }
      if (!bevelEnabled) {
        bevelSegments = 0;
        bevelThickness = 0;
        bevelSize = 0;
        bevelOffset = 0;
      }
      const shapePoints = shape.extractPoints(curveSegments);
      let vertices = shapePoints.shape;
      const holes = shapePoints.holes;
      const reverse = !ShapeUtils.isClockWise(vertices);
      if (reverse) {
        vertices = vertices.reverse();
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h] = ahole.reverse();
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes);
      const contour = vertices;
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        vertices = vertices.concat(ahole);
      }
      function scalePt2(pt, vec, size) {
        if (!vec)
          console.error("THREE.ExtrudeGeometry: vec does not exist");
        return pt.clone().addScaledVector(vec, size);
      }
      const vlen = vertices.length, flen = faces.length;
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by;
        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq);
          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
          const ptNextShift_x = inNext.x - v_next_y / v_next_len;
          const ptNextShift_y = inNext.y + v_next_x / v_next_len;
          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
          if (v_trans_lensq <= 2) {
            return new Vector22(v_trans_x, v_trans_y);
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2);
          }
        } else {
          let direction_eq = false;
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true;
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true;
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y;
            v_trans_y = v_prev_x;
            shrink_by = Math.sqrt(v_prev_lensq);
          } else {
            v_trans_x = v_prev_x;
            v_trans_y = v_prev_y;
            shrink_by = Math.sqrt(v_prev_lensq / 2);
          }
        }
        return new Vector22(v_trans_x / shrink_by, v_trans_y / shrink_by);
      }
      const contourMovements = [];
      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
        if (j === il)
          j = 0;
        if (k === il)
          k = 0;
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
      }
      const holesMovements = [];
      let oneHoleMovements, verticesMovements = contourMovements.concat();
      for (let h = 0, hl = holes.length; h < hl; h++) {
        const ahole = holes[h];
        oneHoleMovements = [];
        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {
          if (j === il)
            j = 0;
          if (k === il)
            k = 0;
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
        }
        holesMovements.push(oneHoleMovements);
        verticesMovements = verticesMovements.concat(oneHoleMovements);
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, -z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            v(vert.x, vert.y, -z);
          }
        }
      }
      const bs = bevelSize + bevelOffset;
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0);
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
          position2.copy(extrudePts[0]).add(normal).add(binormal);
          v(position2.x, position2.y, position2.z);
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
          if (!extrudeByPath) {
            v(vert.x, vert.y, depth / steps * s);
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
            position2.copy(extrudePts[s]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments;
        const z = bevelThickness * Math.cos(t * Math.PI / 2);
        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2);
          v(vert.x, vert.y, depth + z);
        }
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          oneHoleMovements = holesMovements[h];
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z);
            } else {
              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
            }
          }
        }
      }
      buildLidFaces();
      buildSideFaces();
      function buildLidFaces() {
        const start = verticesArray.length / 3;
        if (bevelEnabled) {
          let layer = 0;
          let offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2] + offset, face[1] + offset, face[0] + offset);
          }
          layer = steps + bevelSegments * 2;
          offset = vlen * layer;
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + offset, face[1] + offset, face[2] + offset);
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[2], face[1], face[0]);
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i];
            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0);
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3;
        let layeroffset = 0;
        sidewalls(contour, layeroffset);
        layeroffset += contour.length;
        for (let h = 0, hl = holes.length; h < hl; h++) {
          const ahole = holes[h];
          sidewalls(ahole, layeroffset);
          layeroffset += ahole.length;
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1);
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length;
        while (--i >= 0) {
          const j = i;
          let k = i - 1;
          if (k < 0)
            k = contour2.length - 1;
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s;
            const slen2 = vlen * (s + 1);
            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
            f4(a, b, c, d);
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x);
        placeholder.push(y);
        placeholder.push(z);
      }
      function f3(a, b, c) {
        addVertex(a);
        addVertex(b);
        addVertex(c);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[2]);
      }
      function f4(a, b, c, d) {
        addVertex(a);
        addVertex(b);
        addVertex(d);
        addVertex(b);
        addVertex(c);
        addVertex(d);
        const nextIndex = verticesArray.length / 3;
        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
        addUV(uvs[0]);
        addUV(uvs[1]);
        addUV(uvs[3]);
        addUV(uvs[1]);
        addUV(uvs[2]);
        addUV(uvs[3]);
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0]);
        verticesArray.push(placeholder[index * 3 + 1]);
        verticesArray.push(placeholder[index * 3 + 2]);
      }
      function addUV(vector2) {
        uvArray.push(vector2.x);
        uvArray.push(vector2.y);
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    const options = this.parameters.options;
    return toJSON$1(shapes, options, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    const extrudePath = data.options.extrudePath;
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
    }
    return new _ExtrudeGeometry(geometryShapes, data.options);
  }
};
var WorldUVGenerator = {
  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    return [
      new Vector22(a_x, a_y),
      new Vector22(b_x, b_y),
      new Vector22(c_x, c_y)
    ];
  },
  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
    const a_x = vertices[indexA * 3];
    const a_y = vertices[indexA * 3 + 1];
    const a_z = vertices[indexA * 3 + 2];
    const b_x = vertices[indexB * 3];
    const b_y = vertices[indexB * 3 + 1];
    const b_z = vertices[indexB * 3 + 2];
    const c_x = vertices[indexC * 3];
    const c_y = vertices[indexC * 3 + 1];
    const c_z = vertices[indexC * 3 + 2];
    const d_x = vertices[indexD * 3];
    const d_y = vertices[indexD * 3 + 1];
    const d_z = vertices[indexD * 3 + 2];
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector22(a_x, 1 - a_z),
        new Vector22(b_x, 1 - b_z),
        new Vector22(c_x, 1 - c_z),
        new Vector22(d_x, 1 - d_z)
      ];
    } else {
      return [
        new Vector22(a_y, 1 - a_z),
        new Vector22(b_y, 1 - b_z),
        new Vector22(c_y, 1 - c_z),
        new Vector22(d_y, 1 - d_z)
      ];
    }
  }
};
function toJSON$1(shapes, options, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  data.options = Object.assign({}, options);
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON();
  return data;
}
var IcosahedronGeometry = class _IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2;
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1
    ];
    const indices = [
      0,
      11,
      5,
      0,
      5,
      1,
      0,
      1,
      7,
      0,
      7,
      10,
      0,
      10,
      11,
      1,
      5,
      9,
      5,
      11,
      4,
      11,
      10,
      2,
      10,
      7,
      6,
      7,
      1,
      8,
      3,
      9,
      4,
      3,
      4,
      2,
      3,
      2,
      6,
      3,
      6,
      8,
      3,
      8,
      9,
      4,
      9,
      5,
      2,
      4,
      11,
      6,
      2,
      10,
      8,
      6,
      7,
      9,
      8,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "IcosahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _IcosahedronGeometry(data.radius, data.detail);
  }
};
var OctahedronGeometry = class _OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1,
      0,
      0,
      0,
      1,
      0,
      0,
      -1
    ];
    const indices = [
      0,
      2,
      4,
      0,
      4,
      3,
      0,
      3,
      5,
      0,
      5,
      2,
      1,
      2,
      5,
      1,
      5,
      3,
      1,
      3,
      4,
      1,
      4,
      2
    ];
    super(vertices, indices, radius, detail);
    this.type = "OctahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _OctahedronGeometry(data.radius, data.detail);
  }
};
var RingGeometry = class _RingGeometry extends BufferGeometry2 {
  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 32, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {
    super();
    this.type = "RingGeometry";
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength
    };
    thetaSegments = Math.max(3, thetaSegments);
    phiSegments = Math.max(1, phiSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let radius = innerRadius;
    const radiusStep = (outerRadius - innerRadius) / phiSegments;
    const vertex2 = new Vector32();
    const uv = new Vector22();
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + i / thetaSegments * thetaLength;
        vertex2.x = radius * Math.cos(segment);
        vertex2.y = radius * Math.sin(segment);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normals.push(0, 0, 1);
        uv.x = (vertex2.x / outerRadius + 1) / 2;
        uv.y = (vertex2.y / outerRadius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }
      radius += radiusStep;
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1);
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel;
        const a = segment;
        const b = segment + thetaSegments + 1;
        const c = segment + thetaSegments + 2;
        const d = segment + 1;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
  }
};
var ShapeGeometry = class _ShapeGeometry extends BufferGeometry2 {
  constructor(shapes = new Shape([new Vector22(0, 0.5), new Vector22(-0.5, -0.5), new Vector22(0.5, -0.5)]), curveSegments = 12) {
    super();
    this.type = "ShapeGeometry";
    this.parameters = {
      shapes,
      curveSegments
    };
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let groupStart = 0;
    let groupCount = 0;
    if (Array.isArray(shapes) === false) {
      addShape(shapes);
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i]);
        this.addGroup(groupStart, groupCount, i);
        groupStart += groupCount;
        groupCount = 0;
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function addShape(shape) {
      const indexOffset = vertices.length / 3;
      const points = shape.extractPoints(curveSegments);
      let shapeVertices = points.shape;
      const shapeHoles = points.holes;
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse();
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse();
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i];
        shapeVertices = shapeVertices.concat(shapeHole);
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i];
        vertices.push(vertex2.x, vertex2.y, 0);
        normals.push(0, 0, 1);
        uvs.push(vertex2.x, vertex2.y);
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i];
        const a = face[0] + indexOffset;
        const b = face[1] + indexOffset;
        const c = face[2] + indexOffset;
        indices.push(a, b, c);
        groupCount += 3;
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    const shapes = this.parameters.shapes;
    return toJSON(shapes, data);
  }
  static fromJSON(data, shapes) {
    const geometryShapes = [];
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]];
      geometryShapes.push(shape);
    }
    return new _ShapeGeometry(geometryShapes, data.curveSegments);
  }
};
function toJSON(shapes, data) {
  data.shapes = [];
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i];
      data.shapes.push(shape.uuid);
    }
  } else {
    data.shapes.push(shapes.uuid);
  }
  return data;
}
var SphereGeometry = class _SphereGeometry extends BufferGeometry2 {
  constructor(radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {
    super();
    this.type = "SphereGeometry";
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength
    };
    widthSegments = Math.max(3, Math.floor(widthSegments));
    heightSegments = Math.max(2, Math.floor(heightSegments));
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
    let index = 0;
    const grid = [];
    const vertex2 = new Vector32();
    const normal = new Vector32();
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = [];
      const v = iy / heightSegments;
      let uOffset = 0;
      if (iy === 0 && thetaStart === 0) {
        uOffset = 0.5 / widthSegments;
      } else if (iy === heightSegments && thetaEnd === Math.PI) {
        uOffset = -0.5 / widthSegments;
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments;
        vertex2.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength);
        vertex2.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.copy(vertex2).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(u + uOffset, 1 - v);
        verticesRow.push(index++);
      }
      grid.push(verticesRow);
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1];
        const b = grid[iy][ix];
        const c = grid[iy + 1][ix];
        const d = grid[iy + 1][ix + 1];
        if (iy !== 0 || thetaStart > 0)
          indices.push(a, b, d);
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
  }
};
var TetrahedronGeometry = class _TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1
    ];
    const indices = [
      2,
      1,
      0,
      0,
      3,
      2,
      1,
      3,
      0,
      2,
      3,
      1
    ];
    super(vertices, indices, radius, detail);
    this.type = "TetrahedronGeometry";
    this.parameters = {
      radius,
      detail
    };
  }
  static fromJSON(data) {
    return new _TetrahedronGeometry(data.radius, data.detail);
  }
};
var TorusGeometry = class _TorusGeometry extends BufferGeometry2 {
  constructor(radius = 1, tube = 0.4, radialSegments = 12, tubularSegments = 48, arc = Math.PI * 2) {
    super();
    this.type = "TorusGeometry";
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc
    };
    radialSegments = Math.floor(radialSegments);
    tubularSegments = Math.floor(tubularSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const center = new Vector32();
    const vertex2 = new Vector32();
    const normal = new Vector32();
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = i / tubularSegments * arc;
        const v = j / radialSegments * Math.PI * 2;
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u);
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u);
        vertex2.z = tube * Math.sin(v);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        center.x = radius * Math.cos(u);
        center.y = radius * Math.sin(u);
        normal.subVectors(vertex2, center).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1;
        const b = (tubularSegments + 1) * (j - 1) + i - 1;
        const c = (tubularSegments + 1) * (j - 1) + i;
        const d = (tubularSegments + 1) * j + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
  }
};
var TorusKnotGeometry = class _TorusKnotGeometry extends BufferGeometry2 {
  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {
    super();
    this.type = "TorusKnotGeometry";
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p,
      q
    };
    tubularSegments = Math.floor(tubularSegments);
    radialSegments = Math.floor(radialSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    const vertex2 = new Vector32();
    const normal = new Vector32();
    const P1 = new Vector32();
    const P2 = new Vector32();
    const B = new Vector32();
    const T = new Vector32();
    const N = new Vector32();
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = i / tubularSegments * p * Math.PI * 2;
      calculatePositionOnCurve(u, p, q, radius, P1);
      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
      T.subVectors(P2, P1);
      N.addVectors(P2, P1);
      B.crossVectors(T, N);
      N.crossVectors(B, T);
      B.normalize();
      N.normalize();
      for (let j = 0; j <= radialSegments; ++j) {
        const v = j / radialSegments * Math.PI * 2;
        const cx = -tube * Math.cos(v);
        const cy = tube * Math.sin(v);
        vertex2.x = P1.x + (cx * N.x + cy * B.x);
        vertex2.y = P1.y + (cx * N.y + cy * B.y);
        vertex2.z = P1.z + (cx * N.z + cy * B.z);
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
        normal.subVectors(vertex2, P1).normalize();
        normals.push(normal.x, normal.y, normal.z);
        uvs.push(i / tubularSegments);
        uvs.push(j / radialSegments);
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1);
        const b = (radialSegments + 1) * j + (i - 1);
        const c = (radialSegments + 1) * j + i;
        const d = (radialSegments + 1) * (j - 1) + i;
        indices.push(a, b, d);
        indices.push(b, c, d);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function calculatePositionOnCurve(u, p2, q2, radius2, position) {
      const cu = Math.cos(u);
      const su = Math.sin(u);
      const quOverP = q2 / p2 * u;
      const cs = Math.cos(quOverP);
      position.x = radius2 * (2 + cs) * 0.5 * cu;
      position.y = radius2 * (2 + cs) * su * 0.5;
      position.z = radius2 * Math.sin(quOverP) * 0.5;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  static fromJSON(data) {
    return new _TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
  }
};
var TubeGeometry = class _TubeGeometry extends BufferGeometry2 {
  constructor(path = new QuadraticBezierCurve3(new Vector32(-1, -1, 0), new Vector32(-1, 1, 0), new Vector32(1, 1, 0)), tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {
    super();
    this.type = "TubeGeometry";
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed
    };
    const frames = path.computeFrenetFrames(tubularSegments, closed);
    this.tangents = frames.tangents;
    this.normals = frames.normals;
    this.binormals = frames.binormals;
    const vertex2 = new Vector32();
    const normal = new Vector32();
    const uv = new Vector22();
    let P = new Vector32();
    const vertices = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    generateBufferData();
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute2(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute2(uvs, 2));
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i);
      }
      generateSegment(closed === false ? tubularSegments : 0);
      generateUVs();
      generateIndices();
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P);
      const N = frames.normals[i];
      const B = frames.binormals[i];
      for (let j = 0; j <= radialSegments; j++) {
        const v = j / radialSegments * Math.PI * 2;
        const sin = Math.sin(v);
        const cos = -Math.cos(v);
        normal.x = cos * N.x + sin * B.x;
        normal.y = cos * N.y + sin * B.y;
        normal.z = cos * N.z + sin * B.z;
        normal.normalize();
        normals.push(normal.x, normal.y, normal.z);
        vertex2.x = P.x + radius * normal.x;
        vertex2.y = P.y + radius * normal.y;
        vertex2.z = P.z + radius * normal.z;
        vertices.push(vertex2.x, vertex2.y, vertex2.z);
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1);
          const b = (radialSegments + 1) * j + (i - 1);
          const c = (radialSegments + 1) * j + i;
          const d = (radialSegments + 1) * (j - 1) + i;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments;
          uv.y = j / radialSegments;
          uvs.push(uv.x, uv.y);
        }
      }
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  toJSON() {
    const data = super.toJSON();
    data.path = this.parameters.path.toJSON();
    return data;
  }
  static fromJSON(data) {
    return new _TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed
    );
  }
};
var WireframeGeometry = class extends BufferGeometry2 {
  constructor(geometry = null) {
    super();
    this.type = "WireframeGeometry";
    this.parameters = {
      geometry
    };
    if (geometry !== null) {
      const vertices = [];
      const edges = /* @__PURE__ */ new Set();
      const start = new Vector32();
      const end = new Vector32();
      if (geometry.index !== null) {
        const position = geometry.attributes.position;
        const indices = geometry.index;
        let groups = geometry.groups;
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }];
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o];
          const groupStart = group.start;
          const groupCount = group.count;
          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j);
              const index2 = indices.getX(i + (j + 1) % 3);
              start.fromBufferAttribute(position, index1);
              end.fromBufferAttribute(position, index2);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position;
        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j;
            const index2 = 3 * i + (j + 1) % 3;
            start.fromBufferAttribute(position, index1);
            end.fromBufferAttribute(position, index2);
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z);
              vertices.push(end.x, end.y, end.z);
            }
          }
        }
      }
      this.setAttribute("position", new Float32BufferAttribute2(vertices, 3));
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
};
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false;
  } else {
    edges.add(hash1);
    edges.add(hash2);
    return true;
  }
}
var Geometries = Object.freeze({
  __proto__: null,
  BoxGeometry,
  CapsuleGeometry,
  CircleGeometry,
  ConeGeometry,
  CylinderGeometry,
  DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  IcosahedronGeometry,
  LatheGeometry,
  OctahedronGeometry,
  PlaneGeometry,
  PolyhedronGeometry,
  RingGeometry,
  ShapeGeometry,
  SphereGeometry,
  TetrahedronGeometry,
  TorusGeometry,
  TorusKnotGeometry,
  TubeGeometry,
  WireframeGeometry
});
function convertArray(array, type, forceClone) {
  if (!array || // let 'undefined' and 'null' pass
  !forceClone && array.constructor === type)
    return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function isTypedArray(object) {
  return ArrayBuffer.isView(object) && !(object instanceof DataView);
}
var Interpolant = class {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  evaluate(t) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan:
            if (!(t < t1)) {
              for (let giveUpAt = i1 + 2; ; ) {
                if (t1 === void 0) {
                  if (t < t0)
                    break forward_scan;
                  i1 = pp.length;
                  this._cachedIndex = i1;
                  return this.copySampleValue_(i1 - 1);
                }
                if (i1 === giveUpAt)
                  break;
                t0 = t1;
                t1 = pp[++i1];
                if (t < t1) {
                  break seek;
                }
              }
              right = pp.length;
              break linear_scan;
            }
          if (!(t >= t0)) {
            const t1global = pp[1];
            if (t < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt)
                break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t, t1);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset + i];
    }
    return result;
  }
  // Template methods for derived classes:
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {
  }
};
var CubicInterpolant2 = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
    const sP = -wP * ppp + 2 * wP * pp - wP * p;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
    const sN = wN * ppp - wN * pp;
    for (let i = 0; i !== stride; ++i) {
      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i = 0; i !== stride; ++i) {
      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  // Serialization (in static context, because of constructor invocation
  // and automatic invocation of .toJSON):
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant2(this.times, this.values, this.getValueSize(), result);
  }
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      console.warn("THREE.KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  // move all keyframes either forwards or backwards in time
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset;
      }
    }
    return this;
  }
  // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale;
      }
    }
    return this;
  }
  // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
  // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to !== -1 && times[to] > endTime) {
      --to;
    }
    ++to;
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1);
        from = to - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to);
      this.values = this.values.slice(from * stride, to * stride);
    }
    return this;
  }
  // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      console.error("THREE.KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i];
      if (typeof currTime === "number" && isNaN(currTime)) {
        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i];
          if (isNaN(value)) {
            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  // removes equivalent sequential keys as common in morph target sequences
  // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
  optimize() {
    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false;
      const time = times[i];
      const timeNext = times[i + 1];
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j];
            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i];
          const readOffset = i * stride, writeOffset = writeIndex * stride;
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
        values[writeOffset + j] = values[readOffset + j];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion2.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var LoadingManager = class {
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i = 0, l = handlers.length; i < l; i += 2) {
        const regex = handlers[i];
        const loader = handlers[i + 1];
        if (regex.global)
          regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  }
};
var DefaultLoadingManager = new LoadingManager();
var Loader = class {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  load() {
  }
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  parse() {
  }
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  setPath(path) {
    this.path = path;
    return this;
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
};
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
var _projScreenMatrix$1 = new Matrix42();
var _lightPositionWorld$1 = new Vector32();
var _lookTarget$1 = new Vector32();
var _projScreenMatrix = new Matrix42();
var _lightPositionWorld = new Vector32();
var _lookTarget = new Vector32();
var _eyeRight = new Matrix42();
var _eyeLeft = new Matrix42();
var _projectionMatrix = new Matrix42();
var _position$1 = new Vector32();
var _quaternion$1 = new Quaternion2();
var _scale$1 = new Vector32();
var _orientation$1 = new Vector32();
var _position2 = new Vector32();
var _quaternion = new Quaternion2();
var _scale = new Vector32();
var _orientation = new Vector32();
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
var _supportedObjectNames = ["material", "materials", "bones", "map"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0)
      binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
      bindings[i].unbind();
    }
  }
};
var PropertyBinding = class _PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
    this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new _PropertyBinding(root, path, parsedPath);
    } else {
      return new _PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name Node name to be sanitized.
   * @return {string}
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result)
            return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  // Direct
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  // create getter / setter pair for a property in the scene graph
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var _controlInterpolantsResultBuffer = new Float32Array(1);
var Uniform = class _Uniform {
  constructor(value) {
    this.value = value;
  }
  clone() {
    return new _Uniform(this.value.clone === void 0 ? this.value : this.value.clone());
  }
};
var _vector$4 = new Vector22();
var _startP = new Vector32();
var _startEnd = new Vector32();
var Line3 = class {
  constructor(start = new Vector32(), end = new Vector32()) {
    this.start = start;
    this.end = end;
  }
  set(start, end) {
    this.start.copy(start);
    this.end.copy(end);
    return this;
  }
  copy(line) {
    this.start.copy(line.start);
    this.end.copy(line.end);
    return this;
  }
  getCenter(target4) {
    return target4.addVectors(this.start, this.end).multiplyScalar(0.5);
  }
  delta(target4) {
    return target4.subVectors(this.end, this.start);
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end);
  }
  distance() {
    return this.start.distanceTo(this.end);
  }
  at(t, target4) {
    return this.delta(target4).multiplyScalar(t).add(this.start);
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start);
    _startEnd.subVectors(this.end, this.start);
    const startEnd2 = _startEnd.dot(_startEnd);
    const startEnd_startP = _startEnd.dot(_startP);
    let t = startEnd_startP / startEnd2;
    if (clampToLine) {
      t = clamp(t, 0, 1);
    }
    return t;
  }
  closestPointToPoint(point, clampToLine, target4) {
    const t = this.closestPointToPointParameter(point, clampToLine);
    return this.delta(target4).multiplyScalar(t).add(this.start);
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix);
    this.end.applyMatrix4(matrix);
    return this;
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end);
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _vector$3 = new Vector32();
var _vector$2 = new Vector32();
var _boneMatrix = new Matrix42();
var _matrixWorldInv = new Matrix42();
var _vector$1 = new Vector32();
var _color1 = new Color2();
var _color2 = new Color2();
var _v1 = new Vector32();
var _v2 = new Vector32();
var _v3 = new Vector32();
var _vector = new Vector32();
var _camera = new Camera();
var _box = new Box32();
var _axis = new Vector32();
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    console.warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/three-mesh-bvh/src/core/Constants.js
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = Symbol("SKIP_GENERATION");

// node_modules/three-mesh-bvh/src/core/build/geometryUtils.js
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute2(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo) {
  const triCount = getTriCount(geo);
  const drawRange = geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}

// node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js
function arrayToBox(nodeIndex32, array, target4) {
  target4.min.x = array[nodeIndex32];
  target4.min.y = array[nodeIndex32 + 1];
  target4.min.z = array[nodeIndex32 + 2];
  target4.max.x = array[nodeIndex32 + 3];
  target4.max.y = array[nodeIndex32 + 4];
  target4.max.z = array[nodeIndex32 + 5];
  return target4;
}
function makeEmptyBounds(target4) {
  target4[0] = target4[1] = target4[2] = Infinity;
  target4[3] = target4[4] = target4[5] = -Infinity;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target4) {
  target4.set(source);
}
function unionBounds(a, b, target4) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target4[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target4[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}

// node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js
function getBounds(triangleBounds, offset, count, target4, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target4[0] = minx;
  target4[1] = miny;
  target4[2] = minz;
  target4[3] = maxx;
  target4[4] = maxy;
  target4[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, fullBounds) {
  makeEmptyBounds(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c = posAttr[getters[el]](ci);
      } else {
        a = posArr[ai + el];
        b = posArr[bi + el];
        c = posArr[ci + el];
      }
      let min = a;
      if (b < min)
        min = b;
      if (c < min)
        min = c;
      let max = a;
      if (b > max)
        max = b;
      if (c > max)
        max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}

// node_modules/three-mesh-bvh/src/core/build/splitUtils.js
var BIN_COUNT = 32;
var binsSort = (a, b) => a.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds2 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds2) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}

// node_modules/three-mesh-bvh/src/core/MeshBVHNode.js
var MeshBVHNode = class {
  constructor() {
  }
};

// node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/build/buildTree.js
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree(bvh, options) {
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = getTriCount(geometry);
  const indirectBuffer = bvh._indirectBuffer;
  let reachedMaxDepth = false;
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geometry, fullBounds);
  const partionFunc = options.indirect ? partition_indirect : partition;
  const roots = [];
  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const roots = buildTree(bvh, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i = 0; i < roots.length; i++) {
    const root = roots[i];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  bvh._roots = packedRoots;
  return;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i = 0; i < 6; i++) {
      float32Array[stride4Offset + i] = boundingData[i];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}

// node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = p[field];
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val = axis.dot(p);
      min = val < min ? val : min;
      max = val > max ? val : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector32();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val = axis.dot(p);
          min = Math.min(val, min);
          max = Math.max(val, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var areIntersecting = function() {
  const cacheSatBounds = new SeparatingAxisBounds();
  return function areIntersecting2(shape1, shape2) {
    const points1 = shape1.points;
    const satAxes1 = shape1.satAxes;
    const satBounds1 = shape1.satBounds;
    const points2 = shape2.points;
    const satAxes2 = shape2.satAxes;
    const satBounds2 = shape2.satBounds;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds1[i];
      const sa = satAxes1[i];
      cacheSatBounds.setFromPoints(sa, points2);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sb = satBounds2[i];
      const sa = satAxes2[i];
      cacheSatBounds.setFromPoints(sa, points1);
      if (sb.isSeparated(cacheSatBounds))
        return false;
    }
  };
}();

// node_modules/three-mesh-bvh/src/math/MathUtilities.js
var closestPointLineToLine = function() {
  const dir1 = new Vector32();
  const dir2 = new Vector32();
  const v02 = new Vector32();
  return function closestPointLineToLine2(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector22();
  const temp14 = new Vector32();
  const temp23 = new Vector32();
  return function closestPointsSegmentToSegment2(l1, l2, target1, target22) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target22);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target22);
      } else {
        l2.at(1, target22);
      }
      l1.closestPointToPoint(target22, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target22);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp14;
      const closestPoint2 = temp23;
      l1.closestPointToPoint(p2, true, temp14);
      l2.closestPointToPoint(p, true, temp23);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target22.copy(p2);
        return;
      } else {
        target1.copy(p);
        target22.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector32();
  const projectedPointTemp = new Vector32();
  const planeTemp = new Plane2();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle2(sphere, triangle4) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle4;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle4.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle4.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();

// node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js
var ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle2 {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector32());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere2();
    this.plane = new Plane2();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector32();
  const point2 = new Vector32();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target22 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target22)
          target22.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target22)
        target22.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target22)
        target22.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector32();
  const dir = new Vector32();
  const dir1 = new Vector32();
  const dir2 = new Vector32();
  const tempDir = new Vector32();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector32();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target4 = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target4) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target4.start.set(0, 0, 0);
        target4.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target4) {
          target4.start.copy(edge1.end);
          target4.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target4) {
          target4.start.copy(edge2.end);
          target4.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp6 = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp6;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target4) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target4.start.copy(edge1.start);
        } else {
          target4.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target4.end.copy(edge1.end);
        } else {
          target4.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target4 = new Vector32();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target4);
    return point.distanceTo(target4);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector32();
  const point2 = new Vector32();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target22 = null) {
    const lineTarget = target1 || target22 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target22) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target22)
          lineTarget.getCenter(target22);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target22)
          target22.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target22)
          target22.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target22)
            target22.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/math/OrientedBox.js
var OrientedBox = class {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector32();
    this.max = new Vector32();
    this.matrix = new Matrix42();
    this.invMatrix = new Matrix42();
    this.points = new Array(8).fill().map(() => new Vector32());
    this.satAxes = new Array(3).fill().map(() => new Vector32());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix)
      this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector32();
  return function intersectsTriangle(triangle4) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle4.isExtendedTriangle) {
      saTri.copy(triangle4);
      saTri.update();
      triangle4 = saTri;
    } else if (triangle4.needsUpdate) {
      triangle4.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle4.a;
    pointsArr[1] = triangle4.b;
    pointsArr[2] = triangle4.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle4.satBounds;
    const triSatAxes = triangle4.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = function() {
  return function closestPointToPoint2(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target4 = new Vector32();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target4);
    return point.distanceTo(target4);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector32();
  const point2 = new Vector32();
  return function distanceToBox(box, threshold = 0, target1 = null, target22 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target22) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target22)
          target22.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target22)
          target22.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target22)
              target22.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target22)
            target22.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();

// node_modules/three-mesh-bvh/src/utils/PrimitivePool.js
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};

// node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();

// node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}

// node_modules/three-mesh-bvh/src/core/utils/BufferStack.js
var _BufferStack = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack = new _BufferStack();

// node_modules/three-mesh-bvh/src/core/cast/shapecast.js
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box32());
function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp5 = score1;
        score1 = score2;
        score2 = temp5;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal)
      return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal)
      return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js
var temp = new Vector32();
var temp1 = new Vector32();
function closestPointToPoint(bvh, point, target4 = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity)
    return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target4.point)
    target4.point = temp1.clone();
  else
    target4.point.copy(temp1);
  target4.distance = closestDistance, target4.faceIndex = closestDistanceTriIndex;
  return target4;
}

// node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js
var _vA2 = new Vector32();
var _vB2 = new Vector32();
var _vC2 = new Vector32();
var _uvA2 = new Vector22();
var _uvB2 = new Vector22();
var _uvC2 = new Vector22();
var _normalA2 = new Vector32();
var _normalB2 = new Vector32();
var _normalC2 = new Vector32();
var _intersectionPoint2 = new Vector32();
function checkIntersection2(ray2, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray2.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray2.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray2.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side) {
  _vA2.fromBufferAttribute(position, a);
  _vB2.fromBufferAttribute(position, b);
  _vC2.fromBufferAttribute(position, c);
  const intersection = checkIntersection2(ray2, _vA2, _vB2, _vC2, _intersectionPoint2, side);
  if (intersection) {
    if (uv) {
      _uvA2.fromBufferAttribute(uv, a);
      _uvB2.fromBufferAttribute(uv, b);
      _uvC2.fromBufferAttribute(uv, c);
      intersection.uv = Triangle2.getInterpolation(_intersectionPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector22());
    }
    if (uv1) {
      _uvA2.fromBufferAttribute(uv1, a);
      _uvB2.fromBufferAttribute(uv1, b);
      _uvC2.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle2.getInterpolation(_intersectionPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector22());
    }
    if (normal) {
      _normalA2.fromBufferAttribute(normal, a);
      _normalB2.fromBufferAttribute(normal, b);
      _normalC2.fromBufferAttribute(normal, c);
      intersection.normal = Triangle2.getInterpolation(_intersectionPoint2, _vA2, _vB2, _vC2, _normalA2, _normalB2, _normalC2, new Vector32());
      if (intersection.normal.dot(ray2.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector32(),
      materialIndex: 0
    };
    Triangle2.getNormal(_vA2, _vB2, _vC2, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray2, tri, intersections) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray2, position, normal, uv, uv1, a, b, c, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}

// node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
var tempV1 = new Vector32();
var tempV2 = new Vector32();
var tempV3 = new Vector32();
var tempUV1 = new Vector22();
var tempUV2 = new Vector22();
var tempUV3 = new Vector22();

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js
function intersectTris(bvh, side, ray2, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geometry, side, ray2, i, intersections);
  }
}
function intersectClosestTri(bvh, side, ray2, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/refit.generated.js
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z = posAttr.getZ(index);
        if (x < minx)
          minx = x;
        if (x > maxx)
          maxx = x;
        if (y < miny)
          miny = y;
        if (y > maxy)
          maxy = y;
        if (z < minz)
          minz = z;
        if (z > maxz)
          maxz = z;
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js
var _boundingBox = new Box32();
function intersectRay(nodeIndex32, array, ray2, target4) {
  arrayToBox(nodeIndex32, array, _boundingBox);
  return ray2.intersectBox(_boundingBox, target4);
}

// node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js
function intersectTris_indirect(bvh, side, ray2, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, side, ray2, vi, intersections);
  }
}
function intersectClosestTri_indirect(bvh, side, ray2, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray2, _indirectBuffer ? _indirectBuffer[i] : i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle4) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle(triangle4, tri * 3, index, pos);
    triangle4.needsUpdate = true;
    if (intersectsTriangleFunc(triangle4, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}

// node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js
var _boxIntersection = new Vector32();
function raycast(bvh, root, side, ray2, intersects2) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast(0, bvh, side, ray2, intersects2);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray2, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(bvh, side, ray2, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, _boxIntersection)) {
      _raycast(leftIndex, bvh, side, ray2, intersects2);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, _boxIntersection)) {
      _raycast(rightIndex, bvh, side, ray2, intersects2);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js
var _boxIntersection2 = new Vector32();
var _xyzFields = ["x", "y", "z"];
function raycastFirst(bvh, root, side, ray2) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst(0, bvh, side, ray2);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(bvh, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, _boxIntersection2);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, _boxIntersection2);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js
var boundingBox = new Box32();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix42();
var obb = new OrientedBox();
var obb2 = new OrientedBox();
function intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2);
      obb2.matrix.copy(invertedMat);
      obb2.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle(triangle2, i, thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle(triangle, i, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2, i2, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js
var tempMatrix = new Matrix42();
var obb3 = new OrientedBox();
var obb22 = new OrientedBox();
var temp12 = new Vector32();
var temp2 = new Vector32();
var temp3 = new Vector32();
var temp4 = new Vector32();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target22 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp12;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target22) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb22.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb22.min.copy(box.min);
            obb22.max.copy(box.max);
            obb22.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb22.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle(triangle4, 3 * i, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle(triangle4, 3 * i, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target22) {
    if (!target22.point)
      target22.point = tempTargetDest2.clone();
    else
      target22.point.copy(tempTargetDest2);
    target22.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target22.distance = tempTargetDest1.sub(target22.point).length();
    target22.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse2(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse2(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t = 3 * bvh.resolveTriangleIndex(i);
        for (let j = 0; j < 3; j++) {
          let index = t + j;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse2(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse2(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js
var _boxIntersection3 = new Vector32();
function raycast_indirect(bvh, root, side, ray2, intersects2) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast2(0, bvh, side, ray2, intersects2);
  BufferStack.clearBuffer();
}
function _raycast2(nodeIndex32, bvh, side, ray2, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris_indirect(bvh, side, ray2, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray2, _boxIntersection3)) {
      _raycast2(leftIndex, bvh, side, ray2, intersects2);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray2, _boxIntersection3)) {
      _raycast2(rightIndex, bvh, side, ray2, intersects2);
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js
var _boxIntersection4 = new Vector32();
var _xyzFields2 = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root, side, ray2) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst2(0, bvh, side, ray2);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst2(nodeIndex32, bvh, side, ray2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri_indirect(bvh, side, ray2, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields2[splitAxis];
    const rayDir = ray2.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray2, _boxIntersection4);
    const c1Result = c1Intersection ? _raycastFirst2(c1, bvh, side, ray2) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray2, _boxIntersection4);
    const c2Result = c2Intersection ? _raycastFirst2(c2, bvh, side, ray2) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}

// node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js
var boundingBox2 = new Box32();
var triangle3 = new ExtendedTriangle();
var triangle22 = new ExtendedTriangle();
var invertedMat2 = new Matrix42();
var obb4 = new OrientedBox();
var obb23 = new OrientedBox();
function intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry2(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry2(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat2.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb23);
      obb23.matrix.copy(invertedMat2);
      obb23.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb23.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle(triangle22, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle22.needsUpdate = true;
            if (tri.intersectsTriangle(triangle22)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti = bvh.resolveTriangleIndex(i);
        setTriangle(triangle3, 3 * ti, thisIndex, thisPos);
        triangle3.a.applyMatrix4(invertedMat2);
        triangle3.b.applyMatrix4(invertedMat2);
        triangle3.c.applyMatrix4(invertedMat2);
        triangle3.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle22, i2, index, pos);
          triangle22.needsUpdate = true;
          if (triangle3.intersectsTriangle(triangle22)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox2);
    const leftIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox2);
    const rightIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}

// node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js
var tempMatrix2 = new Matrix42();
var obb5 = new OrientedBox();
var obb24 = new OrientedBox();
var temp13 = new Vector32();
var temp22 = new Vector32();
var temp32 = new Vector32();
var temp42 = new Vector32();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target22 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb5.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb5.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle4 = ExtendedTrianglePool.getPrimitive();
  const triangle23 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp13;
  let tempTargetDest1 = temp22;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target22) {
    tempTarget2 = temp32;
    tempTargetDest2 = temp42;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix2.copy(geometryToBvh).invert();
  obb24.matrix.copy(tempMatrix2);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb5.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb24.min.copy(box.min);
            obb24.max.copy(box.max);
            obb24.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb24.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle23, 3 * ti2, otherIndex, otherPos);
                triangle23.a.applyMatrix4(geometryToBvh);
                triangle23.b.applyMatrix4(geometryToBvh);
                triangle23.c.applyMatrix4(geometryToBvh);
                triangle23.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti = bvh.resolveTriangleIndex(i);
                  setTriangle(triangle4, 3 * ti, index, pos);
                  triangle4.needsUpdate = true;
                  const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle23, 3 * i2, otherIndex, otherPos);
            triangle23.a.applyMatrix4(geometryToBvh);
            triangle23.b.applyMatrix4(geometryToBvh);
            triangle23.c.applyMatrix4(geometryToBvh);
            triangle23.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti = bvh.resolveTriangleIndex(i);
              setTriangle(triangle4, 3 * ti, index, pos);
              triangle4.needsUpdate = true;
              const dist = triangle4.distanceToTriangle(triangle23, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle4);
  ExtendedTrianglePool.releasePrimitive(triangle23);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target22) {
    if (!target22.point)
      target22.point = tempTargetDest2.clone();
    else
      target22.point.copy(tempTargetDest2);
    target22.point.applyMatrix4(tempMatrix2);
    tempTargetDest1.applyMatrix4(tempMatrix2);
    target22.distance = tempTargetDest1.sub(target22.point).length();
    target22.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}

// node_modules/three-mesh-bvh/src/utils/BufferUtils.js
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}

// node_modules/three-mesh-bvh/src/core/cast/bvhcast.js
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box32());
var _leftBox1 = new Box32();
var _rightBox1 = new Box32();
var _leftBox2 = new Box32();
var _rightBox2 = new Box32();
var _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix42().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j = 0, jl = otherRoots.length; j < jl; j++) {
      _bufferStack2.setBuffer(otherRoots[i]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}

// node_modules/three-mesh-bvh/src/core/MeshBVH.js
var obb6 = new OrientedBox();
var tempBox = new Box32();
var MeshBVH = class _MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice(),
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute2(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box32());
      }
    }
    const { _indirectBuffer } = this;
    this.resolveTriangleIndex = options.indirect ? (i) => _indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse2(0);
    function _traverse2(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse2(left, depth + 1);
          _traverse2(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray2, materialOrSide = FrontSide2) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects2 = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects2.length;
      raycastFunc(this, i, materialSide, ray2, intersects2);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j = startCount, jl = intersects2.length; j < jl; j++) {
          intersects2[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects2;
  }
  raycastFirst(ray2, materialOrSide = FrontSide2) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray2);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle4 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle4);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle4);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle23 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle23, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle23, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle23.a.applyMatrix4(matrixToLocal);
          triangle23.b.applyMatrix4(matrixToLocal);
          triangle23.c.applyMatrix4(matrixToLocal);
          triangle23.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle23, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb6.set(box.min, box.max, boxToMesh);
    obb6.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb6.intersectsBox(box2),
        intersectsTriangle: (tri) => obb6.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target22 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target22,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target4 = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target4,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target4) {
    target4.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target4.union(tempBox);
    });
    return target4;
  }
};

// node_modules/three-mesh-bvh/src/objects/MeshBVHVisualizer.js
var boundingBox3 = new Box32();

// node_modules/three-mesh-bvh/src/debug/Debug.js
var _box12 = new Box32();
var _box22 = new Box32();
var _vec = new Vector32();

// node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}

// node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js
var ray = new Ray();
var tmpInverseMatrix = new Matrix42();
var origMeshRaycastFunc = Mesh2.prototype.raycast;
function acceleratedRaycast(raycaster, intersects2) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);
      if (hit) {
        intersects2.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material);
      for (let i = 0, l = hits.length; i < l; i++) {
        const hit = convertRaycastIntersect(hits[i], this, raycaster);
        if (hit) {
          intersects2.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects2);
  }
}

// node_modules/three-mesh-bvh/src/utils/StaticGeometryGenerator.js
var _positionVector = new Vector32();
var _normalVector = new Vector32();
var _tangentVector = new Vector32();
var _tangentVector4 = new Vector42();
var _morphVector = new Vector32();
var _temp = new Vector32();
var _skinIndex2 = new Vector42();
var _skinWeight2 = new Vector42();
var _matrix2 = new Matrix42();
var _boneMatrix2 = new Matrix42();

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/bvh/ThreeMeshBVHHelper.js
var ThreeMeshBVHHelper = class {
  static assignBVH(mesh, bvh) {
    mesh.raycast = acceleratedRaycast;
    mesh.geometry.boundsTree = bvh;
  }
  static assignDefaultBVHIfNone(mesh) {
    let bvh = mesh.geometry.boundsTree || this.defaultBVH(mesh);
    this.assignBVH(mesh, bvh);
  }
  static createBVH(mesh, options) {
    return new MeshBVH(mesh.geometry, options);
  }
  static defaultBVH(mesh) {
    return this.createBVH(mesh, { strategy: CENTER, maxLeafTris: 10, maxDepth: 40, verbose: false });
  }
  static copyBVH(meshDest, meshSrc) {
    const existingBVH = meshSrc.geometry.boundsTree;
    if (existingBVH) {
      meshDest.raycast = acceleratedRaycast;
      this.assignBVH(meshDest, existingBVH);
    }
  }
  static updateRaycaster(raycaster) {
    raycaster.firstHitOnly = true;
  }
};

// node_modules/@polygonjs/polygonjs/node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function mergeGeometries(geometries2, useGroups = false) {
  const isIndexed = geometries2[0].index !== null;
  const attributesUsed = new Set(Object.keys(geometries2[0].attributes));
  const morphAttributesUsed = new Set(Object.keys(geometries2[0].morphAttributes));
  const attributes = {};
  const morphAttributes = {};
  const morphTargetsRelative = geometries2[0].morphTargetsRelative;
  const mergedGeometry = new BufferGeometry();
  let offset = 0;
  for (let i = 0; i < geometries2.length; ++i) {
    const geometry = geometries2[i];
    let attributesCount = 0;
    if (isIndexed !== (geometry.index !== null)) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.");
      return null;
    }
    for (const name in geometry.attributes) {
      if (!attributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
        return null;
      }
      if (attributes[name] === void 0)
        attributes[name] = [];
      attributes[name].push(geometry.attributes[name]);
      attributesCount++;
    }
    if (attributesCount !== attributesUsed.size) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". Make sure all geometries have the same number of attributes.");
      return null;
    }
    if (morphTargetsRelative !== geometry.morphTargetsRelative) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". .morphTargetsRelative must be consistent throughout all geometries.");
      return null;
    }
    for (const name in geometry.morphAttributes) {
      if (!morphAttributesUsed.has(name)) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ".  .morphAttributes must be consistent throughout all geometries.");
        return null;
      }
      if (morphAttributes[name] === void 0)
        morphAttributes[name] = [];
      morphAttributes[name].push(geometry.morphAttributes[name]);
    }
    if (useGroups) {
      let count;
      if (isIndexed) {
        count = geometry.index.count;
      } else if (geometry.attributes.position !== void 0) {
        count = geometry.attributes.position.count;
      } else {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index " + i + ". The geometry must have either an index or a position attribute");
        return null;
      }
      mergedGeometry.addGroup(offset, count, i);
      offset += count;
    }
  }
  if (isIndexed) {
    let indexOffset = 0;
    const mergedIndex = [];
    for (let i = 0; i < geometries2.length; ++i) {
      const index = geometries2[i].index;
      for (let j = 0; j < index.count; ++j) {
        mergedIndex.push(index.getX(j) + indexOffset);
      }
      indexOffset += geometries2[i].attributes.position.count;
    }
    mergedGeometry.setIndex(mergedIndex);
  }
  for (const name in attributes) {
    const mergedAttribute = mergeAttributes(attributes[name]);
    if (!mergedAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " attribute.");
      return null;
    }
    mergedGeometry.setAttribute(name, mergedAttribute);
  }
  for (const name in morphAttributes) {
    const numMorphTargets = morphAttributes[name][0].length;
    if (numMorphTargets === 0)
      break;
    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
    mergedGeometry.morphAttributes[name] = [];
    for (let i = 0; i < numMorphTargets; ++i) {
      const morphAttributesToMerge = [];
      for (let j = 0; j < morphAttributes[name].length; ++j) {
        morphAttributesToMerge.push(morphAttributes[name][j][i]);
      }
      const mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
      if (!mergedMorphAttribute) {
        console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the " + name + " morphAttribute.");
        return null;
      }
      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);
    }
  }
  return mergedGeometry;
}
function mergeAttributes(attributes) {
  let TypedArray;
  let itemSize;
  let normalized;
  let gpuType = -1;
  let arrayLength = 0;
  for (let i = 0; i < attributes.length; ++i) {
    const attribute = attributes[i];
    if (attribute.isInterleavedBufferAttribute) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. InterleavedBufferAttributes are not supported.");
      return null;
    }
    if (TypedArray === void 0)
      TypedArray = attribute.array.constructor;
    if (TypedArray !== attribute.array.constructor) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.");
      return null;
    }
    if (itemSize === void 0)
      itemSize = attribute.itemSize;
    if (itemSize !== attribute.itemSize) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.");
      return null;
    }
    if (normalized === void 0)
      normalized = attribute.normalized;
    if (normalized !== attribute.normalized) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.");
      return null;
    }
    if (gpuType === -1)
      gpuType = attribute.gpuType;
    if (gpuType !== attribute.gpuType) {
      console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.");
      return null;
    }
    arrayLength += attribute.array.length;
  }
  const array = new TypedArray(arrayLength);
  let offset = 0;
  for (let i = 0; i < attributes.length; ++i) {
    array.set(attributes[i].array, offset);
    offset += attributes[i].array.length;
  }
  const result = new BufferAttribute(array, itemSize, normalized);
  if (gpuType !== void 0) {
    result.gpuType = gpuType;
  }
  return result;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/util/IndexBuilder.js
var POSITION = "position";
var CoreGeometryIndexBuilder = class {
  static createIndexIfNone(geometry) {
    if (!geometry.index) {
      const position = geometry.getAttribute(POSITION);
      if (position) {
        const position_array = position.array;
        geometry.setIndex(rangeWithEnd(position_array.length / 3));
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/builders/Merge.js
var dummyMesh2 = new Mesh();
var CoreGeometryBuilderMerge = class {
  static merge(geometries2) {
    if (geometries2.length === 0) {
      return;
    }
    for (const geometry of geometries2) {
      CoreGeometryIndexBuilder.createIndexIfNone(geometry);
    }
    dummyMesh2.geometry = geometries2[0];
    const indexed_attribute_names = ThreejsPoint.indexedAttributeNames(dummyMesh2);
    const new_values_by_attribute_name = {};
    for (const indexed_attribute_name of indexed_attribute_names) {
      const index_by_values = {};
      const all_geometries_points = [];
      for (const geometry of geometries2) {
        const points = pointsFromBufferGeometry(geometry);
        for (const point of points) {
          all_geometries_points.push(point);
          const value = point.indexedAttribValue(indexed_attribute_name);
          if (value) {
            index_by_values[value] != null ? index_by_values[value] : index_by_values[value] = Object.keys(index_by_values).length;
          }
        }
      }
      const values = Object.keys(index_by_values);
      for (const point of all_geometries_points) {
        const value = point.indexedAttribValue(indexed_attribute_name);
        if (value) {
          const new_index = index_by_values[value];
          point.setAttribIndex(indexed_attribute_name, new_index);
        }
      }
      new_values_by_attribute_name[indexed_attribute_name] = values;
    }
    const mergedGeometry = mergeGeometries(geometries2);
    dummyMesh2.geometry = mergedGeometry;
    Object.keys(new_values_by_attribute_name).forEach((indexed_attribute_name) => {
      const values = new_values_by_attribute_name[indexed_attribute_name];
      ThreejsPoint.setIndexedAttributeValues(dummyMesh2, indexed_attribute_name, values);
    });
    if (mergedGeometry) {
      delete mergedGeometry.userData.mergedUserData;
    }
    return mergedGeometry;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/cad/CadCommon.js
var CadGeometryType = ((CadGeometryType2) => {
  CadGeometryType2["POINT_2D"] = "CADPoint2D";
  CadGeometryType2["CURVE_2D"] = "CADCurve2D";
  CadGeometryType2["VERTEX"] = "CADVertex";
  CadGeometryType2["EDGE"] = "CADEdge";
  CadGeometryType2["WIRE"] = "CADWire";
  CadGeometryType2["FACE"] = "CADFace";
  CadGeometryType2["SHELL"] = "CADShell";
  CadGeometryType2["SOLID"] = "CADSolid";
  CadGeometryType2["COMPSOLID"] = "CADCompsolid";
  CadGeometryType2["COMPOUND"] = "CADCompound";
  return CadGeometryType2;
})(CadGeometryType || {});
var CAD_GEOMETRY_TYPES = [
  "CADPoint2D",
  "CADCurve2D",
  "CADVertex",
  "CADEdge",
  "CADWire",
  "CADFace",
  "CADShell",
  "CADSolid",
  "CADCompsolid",
  "CADCompound"
  /* COMPOUND */
];
var CAD_GEOMETRY_TYPES_SET = new Set(CAD_GEOMETRY_TYPES);
var CAD_GEOMETRY_TYPES_SHAPE = [
  "CADVertex",
  "CADEdge",
  "CADWire",
  "CADFace",
  "CADShell",
  "CADSolid",
  "CADCompsolid",
  "CADCompound"
  /* COMPOUND */
];
var CAD_GEOMETRY_TYPES_SET_SHAPE = new Set(CAD_GEOMETRY_TYPES_SHAPE);

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/cad/CadCoreType.js
function isCADObject(o) {
  return CAD_GEOMETRY_TYPES_SET.has(o.type);
}
var CoreCadType = class {
  static isPoint2d(object) {
    return object.type == CadGeometryType.POINT_2D;
  }
  static isGeom2dCurve(object) {
    return object.type == CadGeometryType.CURVE_2D;
  }
  static isVertex(object) {
    return object.type == CadGeometryType.VERTEX;
  }
  static isEdge(object) {
    return object.type == CadGeometryType.EDGE;
  }
  static isWire(object) {
    return object.type == CadGeometryType.WIRE;
  }
  static isFace(object) {
    return object.type == CadGeometryType.FACE;
  }
  static isShell(object) {
    return object.type == CadGeometryType.SHELL;
  }
  static isSolid(object) {
    return object.type == CadGeometryType.SOLID;
  }
  static isCompsolid(object) {
    return object.type == CadGeometryType.COMPSOLID;
  }
  static isCompound(object) {
    return object.type == CadGeometryType.COMPOUND;
  }
  static isShape(object) {
    return CAD_GEOMETRY_TYPES_SET_SHAPE.has(object.type);
  }
  static isGeometryShape(geometry) {
    return CoreType.isFunction(geometry.ShapeType);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/csg/CsgCoreType.js
var import_modeling = __toESM(require_src());

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/csg/CsgCommon.js
var CsgGeometryType = ((CsgGeometryType2) => {
  CsgGeometryType2["PATH2"] = "CSGPath2";
  CsgGeometryType2["GEOM2"] = "CSGGeom2";
  CsgGeometryType2["GEOM3"] = "CSGGeom3";
  return CsgGeometryType2;
})(CsgGeometryType || {});
var CSG_GEOMETRY_TYPES = [
  "CSGPath2",
  "CSGGeom2",
  "CSGGeom3"
  /* GEOM3 */
];
var CSG_GEOMETRY_TYPES_SET = new Set(CSG_GEOMETRY_TYPES);

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/csg/CsgCoreType.js
function isCSGObject(o) {
  return CSG_GEOMETRY_TYPES_SET.has(o.type);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/tet/TetCoreType.js
function isTetObject(o) {
  return o.type == CoreObjectType.TET;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Group.js
var tmpBox3 = new Box3();
var tmpPos = new Vector3();
var _indices = [];
var _points2 = [];
var _relatedPoints = [];
var _relatedVertices = [];
var _relatedPrimitives = [];
var _relatedPrimitivesForObject = [];
function objectTotalPointsCount(object) {
  let sum = 0;
  object.traverse((child) => {
    sum += pointsCountFromObject(child);
  });
  return sum;
}
var CoreGroup = class _CoreGroup extends CoreEntity {
  constructor() {
    super(void 0, 0);
    this._allObjects = [];
    this._attributes = {};
    this.touch();
  }
  dispose() {
    if (this._allObjects) {
      for (const object of this._allObjects) {
        if (object.dispose) {
          object.dispose();
        }
      }
    }
    this._allObjects.length = 0;
  }
  geometry() {
    return null;
  }
  builder() {
    return void 0;
  }
  //
  //
  // TIMESTAMP
  //
  //
  timestamp() {
    return this._timestamp;
  }
  touch() {
    const performance3 = Poly.performance.performanceManager();
    this._timestamp = performance3.now();
  }
  // reset() {
  // 	// this.resetBoundingBox();
  // 	// this._bounding_sphere = undefined;
  // 	// this._coreGeometries = undefined;
  // 	// this._coreObjects = undefined;
  // }
  resetBoundingBox() {
  }
  //
  //
  // CLONE
  //
  //
  clone() {
    const coreGroup = new _CoreGroup();
    if (this._allObjects) {
      const allCoreObjects = this.allCoreObjects();
      const clonedObjects = [];
      for (const coreObject of allCoreObjects) {
        const clonedObject = coreObject.clone().object();
        if (clonedObject) {
          clonedObjects.push(clonedObject);
        }
      }
      coreGroup.setAllObjects(clonedObjects);
    }
    const attribNames = this.attribNames();
    for (const attribName of attribNames) {
      const value = this.attribValue(attribName);
      coreGroup.addAttribute(attribName, value);
    }
    return coreGroup;
  }
  //
  //
  // ALL OBJECTS
  //
  //
  setAllObjects(objects) {
    this._allObjects = objects;
    this.touch();
  }
  allObjects() {
    return this._allObjects;
  }
  allCoreObjects() {
    var _a;
    return (_a = this.allObjects()) == null ? void 0 : _a.map((o, i) => coreObjectInstanceFactory(o, i));
  }
  //
  //
  // CAD OBJECTS
  //
  //
  cadObjects() {
    var _a;
    const list = ((_a = this._allObjects) == null ? void 0 : _a.filter(isCADObject)) || void 0;
    return list;
  }
  cadObjectsWithShape() {
    var _a;
    return (_a = this.cadObjects()) == null ? void 0 : _a.filter((o) => CoreCadType.isShape(o));
  }
  cadCoreObjects() {
    var _a;
    return (_a = this.cadObjects()) == null ? void 0 : _a.map((o, i) => coreObjectInstanceFactory(o, i));
  }
  //
  //
  // CSG OBJECTS
  //
  //
  csgObjects() {
    var _a;
    const list = ((_a = this._allObjects) == null ? void 0 : _a.filter(isCSGObject)) || void 0;
    return list;
  }
  csgCoreObjects() {
    var _a;
    return (_a = this.csgObjects()) == null ? void 0 : _a.map((o, i) => coreObjectInstanceFactory(o, i));
  }
  //
  //
  // QUAD OBJECTS
  //
  //
  quadObjects() {
    var _a;
    const list = ((_a = this._allObjects) == null ? void 0 : _a.filter(isQuadObject)) || void 0;
    return list;
  }
  quadCoreObjects() {
    var _a;
    return (_a = this.quadObjects()) == null ? void 0 : _a.map((o, i) => coreObjectInstanceFactory(o, i));
  }
  threejsOrQuadObjects() {
    return this._allObjects ? this._allObjects.filter(isQuadOrThreejsObject) : [];
  }
  threejsOrQuadCoreObjects() {
    return this.threejsOrQuadObjects().map((o, i) => coreObjectInstanceFactory(o, i));
  }
  //
  //
  // SDF OBJECTS
  //
  //
  // SDFObjects() {
  // 	const list = this._allObjects?.filter((o) => SDF_OBJECT_TYPES_SET.has(o.type as SDFObjectType)) || undefined;
  // 	return list as SDFObject[] | undefined;
  // }
  // SDFCoreObjects() {
  // 	return this.csgObjects()?.map((o, i) => coreObjectInstanceFactory(o, i));
  // }
  //
  //
  // TET OBJECTS
  //
  //
  tetObjects() {
    var _a;
    const list = ((_a = this._allObjects) == null ? void 0 : _a.filter(isTetObject)) || void 0;
    return list;
  }
  tetCoreObjects() {
    var _a;
    return (_a = this.tetObjects()) == null ? void 0 : _a.map((o, i) => coreObjectInstanceFactory(o, i));
  }
  //
  //
  // THREEJS OBJECTS
  //
  //
  threejsObjects() {
    return this._allObjects ? this._allObjects.filter(isObject3D) : [];
  }
  threejsObjectsWithGeo() {
    return this.threejsObjects().filter(object3DHasGeometry);
  }
  threejsCoreObjects() {
    return this.threejsObjects().map((o, i) => new ThreejsCoreObject(o, i));
  }
  geometries() {
    return this.threejsObjectsWithGeo().map((o) => o.geometry);
  }
  // coreGeometries(): CoreGeometry[] {
  // 	return this.geometries().map((g) => new CoreGeometry(g));
  // }
  //
  //
  // POINTS
  //
  //
  points(target4) {
    return pointsFromObjects(this.allObjects(), target4);
  }
  pointsCount() {
    return arraySum(this.allObjects().map((g) => pointsCountFromObject(g)));
  }
  totalPointsCount() {
    const threejsObjects = this.threejsObjects();
    let sum = 0;
    for (const object of threejsObjects) {
      sum += objectTotalPointsCount(object);
    }
    return sum;
  }
  pointsFromGroup(group, target4) {
    if (group) {
      CoreString.indices(group, _indices);
      this.points(_points2);
      const compactPoints = [];
      const pointsInGroup = arrayCompact(
        _indices.map((i) => _points2[i]),
        compactPoints
      );
      target4.length = 0;
      arrayPushItems(pointsInGroup, target4);
      return target4;
    } else {
      return this.points(target4);
    }
  }
  pointAttribNames() {
    const firstObject = this.allObjects()[0];
    if (firstObject) {
      return pointAttributeNames(firstObject);
    } else {
      return [];
    }
  }
  hasPointAttrib(attribName) {
    const firstObject = this.allObjects()[0];
    if (firstObject) {
      return hasPointAttribute(firstObject, attribName);
    } else {
      return false;
    }
  }
  pointAttribType(attribName) {
    const firstObject = this.allObjects()[0];
    if (firstObject) {
      return pointAttributeType(firstObject, attribName);
    } else {
      return AttribType.NUMERIC;
    }
  }
  pointAttribNamesMatchingMask(masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.pointAttribNames());
  }
  pointAttribSizes() {
    const firstObject = this.allObjects()[0];
    if (firstObject) {
      return pointAttributeSizes(firstObject);
    } else {
      return {};
    }
  }
  pointAttribSize(attribName) {
    const firstObject = this.allObjects()[0];
    if (firstObject) {
      return pointAttributeSize(firstObject, attribName);
    } else {
      return 0;
    }
  }
  //
  //
  // OBJECTS
  //
  //
  static _fromObjects(objects) {
    const coreGroup = new _CoreGroup();
    coreGroup.setAllObjects(objects);
    return coreGroup;
  }
  objectAttribTypesByName() {
    return coreObjectAttributeTypesByName(this.allCoreObjects());
  }
  objectAttribNames() {
    return coreObjectsAttribNames(this.allCoreObjects());
  }
  objectAttribNamesMatchingMask(masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.objectAttribNames());
  }
  objectAttribSizesByName() {
    return coreObjectsAttribSizesByName(this.allCoreObjects());
  }
  //
  //
  //
  //
  //
  renameAttribute(oldName, newName) {
    const attribValue = this.attribValue(oldName);
    if (attribValue == null) {
      return;
    }
    this.addAttribute(newName, attribValue);
    this.deleteAttribute(oldName);
  }
  attribNamesMatchingMask(masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.attribNames());
  }
  hasAttribute(attribName) {
    return this.attribValue(attribName) != null;
  }
  addAttribute(attribName, attribValue) {
    this.attributes()[attribName] = attribValue;
  }
  addNumericAttribute(attribName, size = 1, defaultValue2 = 0) {
    const attributes = this.attributes();
    if (defaultValue2 != null) {
      if (attribValueNonPrimitive(defaultValue2)) {
        const clonedDefaultValue = cloneAttribValue(defaultValue2);
        if (clonedDefaultValue != null) {
          attributes[attribName] = clonedDefaultValue;
        }
      } else {
        attributes[attribName] = defaultValue2;
      }
    } else {
      switch (size) {
        case 1: {
          return this.attributes()[attribName] = 0;
        }
        case 2: {
          return this.attributes()[attribName] = new Vector2(0, 0);
        }
        case 3: {
          return this.attributes()[attribName] = new Vector3(0, 0, 0);
        }
        case 4: {
          return this.attributes()[attribName] = new Vector4(0, 0, 0, 0);
        }
      }
    }
  }
  deleteAttribute(name) {
    delete this.attributes()[name];
  }
  attribValue(attribName) {
    return this._attributes && this._attributes[attribName];
  }
  attribNames() {
    return this._attributes ? Object.keys(this._attributes) : [];
  }
  attribType(name) {
    const val = this.attribValue(name);
    if (CoreType.isString(val)) {
      return AttribType.STRING;
    } else {
      return AttribType.NUMERIC;
    }
  }
  attribSizes() {
    const h = {};
    for (const attrib_name of this.attribNames()) {
      const size = this.attribSize(attrib_name);
      if (size != null) {
        h[attrib_name] = size;
      }
    }
    return h;
  }
  attribSize(name) {
    const val = this.attribValue(name);
    if (val == null) {
      return null;
    }
    return CoreAttribute.attribSizeFromValue(val);
  }
  attributes() {
    return this._attributes || this._createAttributesDictionaryIfNone();
  }
  _createAttributesDictionaryIfNone() {
    if (!this._attributes) {
      this._attributes = {};
    }
    return this._attributes;
  }
  // override
  setAttribValue(attribName, attribValue) {
    this.addAttribute(attribName, attribValue);
  }
  stringAttribValue(attribName) {
    return this.attribValue(attribName);
  }
  position(target4) {
    const objectsCount = this._allObjects.length;
    target4.set(0, 0, 0);
    for (const object of this._allObjects) {
      coreObjectClassFactory(object).position(object, tmpPos);
      target4.add(tmpPos);
    }
    target4.divideScalar(objectsCount);
    return target4;
  }
  attributeNames() {
    const attributes = this.attributes();
    if (!attributes) {
      return [];
    }
    return Object.keys(attributes);
  }
  attributeNamesMatchingMask(masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.attributeNames());
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  relatedObjects(target4, traversedRelatedEntityData) {
    arrayCopy(this.allCoreObjects(), target4);
  }
  relatedPrimitives(target4, traversedRelatedEntityData) {
    target4.length = 0;
    const objects = this.allObjects();
    let i = 0;
    for (const object of objects) {
      coreObjectClassFactory(object).relatedPrimitives(object, i, _relatedPrimitivesForObject);
      for (const _relatedPrimitiveForObject of _relatedPrimitivesForObject) {
        target4.push(_relatedPrimitiveForObject);
      }
      i++;
    }
  }
  relatedVertices(target4, traversedRelatedEntityData) {
    this.relatedPrimitives(_relatedPrimitives);
    uniqRelatedEntities(
      _relatedPrimitives,
      (primitive) => {
        primitive.relatedVertices(_relatedVertices);
        return _relatedVertices;
      },
      target4
    );
  }
  relatedPoints(target4, traversedRelatedEntityData) {
    this.relatedVertices(_relatedVertices);
    return uniqRelatedEntities(
      _relatedVertices,
      (vertex2) => {
        vertex2.relatedPoints(_relatedPoints);
        return _relatedPoints;
      },
      target4
    );
  }
  relatedEntities(attribClass, coreGroup, target4, traversedRelatedEntityData) {
    switch (attribClass) {
      case AttribClass.POINT: {
        this.relatedPoints(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.VERTEX: {
        this.relatedVertices(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.PRIMITIVE: {
        this.relatedPrimitives(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.OBJECT: {
        this.relatedObjects(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.CORE_GROUP: {
        target4.length = 1;
        target4[0] = coreGroup;
        return;
      }
    }
    TypeAssert.unreachable(attribClass);
  }
  //
  //
  // UTILS
  //
  //
  objectsData() {
    var _a;
    return ((_a = this._allObjects) == null ? void 0 : _a.map((o) => coreObjectClassFactory(o).objectData(o))) || [];
  }
  boundingBox(target4) {
    target4.makeEmpty();
    const coreObjects = this.allCoreObjects();
    for (const coreObject of coreObjects) {
      coreObject.boundingBox(tmpBox3);
      target4.union(tmpBox3);
    }
  }
  static geometryFromObject(object) {
    if (object.isMesh || object.isLine || object.isPoints) {
      return object.geometry;
    }
    return null;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/_Base.js
var OPERATIONS_COMPOSER_NODE_TYPE = "operationsComposer";
var BaseOperation = class {
  constructor(_scene, states, _node) {
    this._scene = _scene;
    this.states = states;
    this._node = _node;
  }
  static type() {
    throw "type to be overriden";
  }
  type() {
    const c = this.constructor;
    return c.type();
  }
  static context() {
    console.error("operation has no node_context", this);
    throw "context requires override";
  }
  context() {
    const c = this.constructor;
    return c.context();
  }
  scene() {
    return this._scene;
  }
  cook(input_contents, params) {
  }
  convertExportParamData(options) {
    const { params, paramName, paramData } = options;
    const default_param = params[paramName];
    if (CoreType.isBoolean(paramData)) {
      return paramData;
    }
    if (CoreType.isNumber(paramData)) {
      if (CoreType.isBoolean(default_param)) {
        return paramData >= 1 ? true : false;
      } else {
        return paramData;
      }
    }
    if (CoreType.isString(paramData)) {
      if (default_param) {
        if (default_param instanceof TypedNodePathParamValue) {
          return default_param.setPath(paramData);
        }
        if (default_param instanceof TypedParamPathParamValue) {
          return default_param.setPath(paramData);
        }
      }
      return paramData;
    }
    if (CoreType.isArray(paramData)) {
      params[paramName].fromArray(paramData);
    }
  }
};
BaseOperation.DEFAULT_PARAMS = {};
BaseOperation.INPUT_CLONED_STATE = [];

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/_Base.js
var BaseSopOperation = class _BaseSopOperation extends BaseOperation {
  static context() {
    return NodeContext.SOP;
  }
  cook(inputCoreGroups, params) {
  }
  //
  //
  // UTILS
  //
  //
  createCoreGroupFromObjects(objects) {
    const coreGroup = new CoreGroup();
    coreGroup.setAllObjects(objects);
    return coreGroup;
  }
  createCoreGroupFromGeometry(geometry, type = ObjectType.MESH) {
    const object = _BaseSopOperation.createObject(geometry, type);
    return this.createCoreGroupFromObjects(object ? [object] : []);
  }
  createObject(geometry, type, material) {
    return _BaseSopOperation.createObject(geometry, type, material);
  }
  static createObject(geometry, type, material) {
    this.createIndexIfNone(geometry);
    const objectConstructor = objectConstructorByObjectType(type) || objectConstructorByObjectType(ObjectType.MESH);
    material = material || DEFAULT_MATERIALS[type];
    const object = new objectConstructor(geometry, material);
    this.applyObjectDefault(object);
    return object;
  }
  static applyObjectDefault(object) {
    object.castShadow = true;
    object.receiveShadow = true;
    object.frustumCulled = false;
    object.matrixAutoUpdate = false;
  }
  createIndexIfNone(geometry) {
    _BaseSopOperation.createIndexIfNone(geometry);
  }
  static createIndexIfNone(geometry) {
    CoreGeometryIndexBuilder.createIndexIfNone(geometry);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsCoreObject.js
var COMPUTE_PRECISE_BOUNDS = true;
var SPHERE_EMPTY = new Sphere(new Vector3(0, 0, 0), 0);
var ThreejsCoreObject = class _ThreejsCoreObject extends BaseCoreObject {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  humanType() {
    return dataFromObject(this._object).humanName;
  }
  object() {
    return this._object;
  }
  geometry() {
    return this._object.geometry;
  }
  // object():Object3D{
  // 	return this._object
  // }
  // coreGeometry(): CoreGeometry | null {
  // 	const geo = this.geometry();
  // 	if (geo) {
  // 		return new CoreGeometry(geo);
  // 	} else {
  // 		return null;
  // 	}
  // 	// const geo = this.geometry()
  // 	// if (geo) {
  // 	// 	return new CoreGeometry(geo)
  // 	// } else {
  // 	// 	return null
  // 	// }
  // }
  static objectData(object) {
    const data = objectData(object);
    data.verticesCount = ThreejsVertex.entitiesCount(object);
    data.pointsCount = ThreejsPoint.entitiesCount(object);
    const primitiveClass = primitiveClassFactoryNonAbstract(object);
    data.primitivesCount = (primitiveClass == null ? void 0 : primitiveClass.entitiesCount(object)) || 0;
    data.primitiveName = (primitiveClass == null ? void 0 : primitiveClass.primitiveName()) || "";
    return data;
  }
  static position(object, target4) {
    target4.copy(object.position);
  }
  static boundingBox(object, target4) {
    target4.setFromObject(object, COMPUTE_PRECISE_BOUNDS);
  }
  static geometryBoundingBox(object, target4) {
    const geometry = object.geometry;
    if (geometry) {
      if (!geometry.boundingBox) {
        geometry.computeBoundingBox();
      }
      if (geometry.boundingBox) {
        target4.copy(geometry.boundingBox);
      }
    } else {
      target4.makeEmpty();
    }
  }
  static boundingSphere(object, target4) {
    const geometry = object.geometry;
    if (!geometry) {
      target4.copy(SPHERE_EMPTY);
      return;
    }
    geometry.computeBoundingSphere();
    const computedSphere = geometry.boundingSphere;
    if (!computedSphere) {
      target4.copy(SPHERE_EMPTY);
      return;
    }
    target4.copy(computedSphere);
  }
  static geometryBoundingSphere(object, target4) {
    this.boundingSphere(object, target4);
  }
  // computeVertexNormals() {
  // 	this.coreGeometry()?.computeVertexNormals();
  // }
  static clone(srcObject) {
    const clonedObject = srcObject.clone();
    var sourceLookup = /* @__PURE__ */ new Map();
    var cloneLookup = /* @__PURE__ */ new Map();
    _ThreejsCoreObject.parallelTraverse(
      srcObject,
      clonedObject,
      function(sourceNode, clonedNode) {
        sourceLookup.set(clonedNode, sourceNode);
        cloneLookup.set(sourceNode, clonedNode);
      }
    );
    clonedObject.traverse(function(node) {
      const srcNode = sourceLookup.get(node);
      const meshNode = node;
      if (meshNode.geometry && srcNode && srcNode.geometry) {
        const srcNodeGeometry = srcNode.geometry;
        meshNode.geometry = cloneBufferGeometry(srcNodeGeometry);
        ThreeMeshBVHHelper.copyBVH(meshNode, srcNode);
      }
      if (meshNode.material) {
        applyCustomMaterials(node, meshNode.material);
        const material_with_color = meshNode.material;
        if (material_with_color.color == null) {
          material_with_color.color = new Color(1, 1, 1);
        }
      }
      if (srcNode) {
        if (srcNode.userData) {
          node.userData = objectCloneDeep(srcNode.userData);
        }
        const src_node_with_animations = srcNode;
        if (src_node_with_animations.animations) {
          node.animations = src_node_with_animations.animations.map(
            (animation) => animation.clone()
          );
        }
        const skinned_node = node;
        if (skinned_node.isSkinnedMesh) {
          var clonedMesh = skinned_node;
          var sourceMesh = srcNode;
          var sourceBones = sourceMesh.skeleton.bones;
          clonedMesh.skeleton = sourceMesh.skeleton.clone();
          clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
          const new_bones = sourceBones.map(function(bone) {
            return cloneLookup.get(bone);
          });
          clonedMesh.skeleton.bones = new_bones;
          clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
        }
      }
    });
    return clonedObject;
  }
  static parallelTraverse(a, b, callback) {
    callback(a, b);
    for (var i = 0; i < a.children.length; i++) {
      const childA = a.children[i];
      const childB = b.children[i];
      if (childA && childB) {
        this.parallelTraverse(childA, childB, callback);
      }
    }
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    switch (transformTargetType) {
      case TransformTargetType.OBJECT: {
        applyTransformWithSpaceToObject(object, matrix, transformSpace, transformMode);
        return;
      }
      case TransformTargetType.GEOMETRY: {
        const geometry = object.geometry;
        if (geometry) {
          geometry.applyMatrix4(matrix);
        }
        return;
      }
    }
    TypeAssert.unreachable(transformTargetType);
  }
  static mergeCompact(options) {
    const { objects, material, objectType, mergedObjects, onError } = options;
    const firstObject = objects[0];
    if (!firstObject) {
      return;
    }
    const geometries2 = [];
    for (const object of objects) {
      const geometry = object.geometry;
      if (geometry) {
        geometry.applyMatrix4(object.matrix);
        geometries2.push(geometry);
      }
    }
    try {
      const mergedGeometry = CoreGeometryBuilderMerge.merge(geometries2);
      if (mergedGeometry) {
        const newObject = BaseSopOperation.createObject(mergedGeometry, objectType, material);
        if (newObject) {
          objectContentCopyProperties(firstObject, newObject);
          mergedObjects.push(newObject);
        }
      } else {
        onError("merge failed, check that input geometries have the same attributes");
      }
    } catch (e) {
      onError(e.message || "unknown error");
    }
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedPrimitiveIds(object, index, target4, traversedRelatedEntityData) {
    const _primitiveClassFactory = primitiveClassFactoryNonAbstract(object);
    if (!_primitiveClassFactory) {
      target4.length = 0;
      return;
    }
    const count = _primitiveClassFactory == null ? void 0 : _primitiveClassFactory.entitiesCount(object);
    target4.length = count;
    for (let i = 0; i < count; i++) {
      target4[i] = i;
    }
    if (traversedRelatedEntityData && traversedRelatedEntityData[AttribClass.PRIMITIVE].ids != target4) {
      arrayCopy(target4, traversedRelatedEntityData[AttribClass.PRIMITIVE].ids);
    }
  }
  static relatedPrimitiveClass(object) {
    return primitiveClassFactoryNonAbstract(object);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/primitive/CorePrimitive.js
function _warnOverloadRequired3(functionName) {
  console.warn(`CorePrimitive.${functionName} needs to be overloaded`);
}
var _ids = [];
var CorePrimitive = class extends CoreEntityWithObject {
  builder() {
    return void 0;
  }
  static entitiesCount(object) {
    return 0;
  }
  static addAttribute(object, attribName, attribute) {
    _warnOverloadRequired3("addAttribute");
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    _warnOverloadRequired3("addNumericAttribute");
  }
  static attributes(object) {
    _warnOverloadRequired3("attributes");
    return;
  }
  attributes() {
    if (!this._object) {
      return;
    }
    return this.constructor.attributes(this._object);
  }
  static attribute(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    return attributes[attribName];
  }
  attribute(attribName) {
    if (!this._object) {
      return;
    }
    return this.constructor.attribute(this._object, attribName);
  }
  static renameAttribute(object, oldName, newName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    const attribute = this.attribute(object, oldName);
    if (!attribute) {
      return;
    }
    attributes[newName] = attribute;
    delete attributes[oldName];
  }
  static deleteAttribute(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    delete attributes[attribName];
  }
  static attribSize(object, attribName) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return -1;
    }
    attribName = CoreAttribute.remapName(attribName);
    return attributes[attribName].itemSize || 0;
  }
  attribSize(attribName) {
    if (!this._object) {
      return 0;
    }
    return this.constructor.attribSize(this._object, attribName);
  }
  static hasAttribute(object, attribName) {
    const remappedName = CoreAttribute.remapName(attribName);
    return this.attributes(object) ? this.attributes(object)[remappedName] != null : false;
  }
  hasAttribute(attribName) {
    if (!this._object) {
      return false;
    }
    return this.constructor.hasAttribute(this._object, attribName);
  }
  static attributeNames(object) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return [];
    }
    return Object.keys(attributes);
  }
  static attributeNamesMatchingMask(object, masksString) {
    return CoreAttribute.attribNamesMatchingMask(masksString, this.attributeNames(object));
  }
  static attribValue(object, index, attribName, target4) {
    if (attribName === Attribute.PRIMITIVE_INDEX) {
      return index;
    }
    let componentName = null;
    let componentIndex = null;
    if (attribName[attribName.length - 2] === DOT) {
      componentName = attribName[attribName.length - 1];
      componentIndex = COMPONENT_INDICES[componentName];
      attribName = attribName.substring(0, attribName.length - 2);
    }
    const remapedName = CoreAttribute.remapName(attribName);
    if (remapedName == Attribute.POSITION) {
      return this.position(object, index, target4);
    }
    if (remapedName == Attribute.NORMAL) {
      return this.normal(object, index, target4);
    }
    const attrib = this.attribute(object, remapedName);
    if (attrib) {
      const { array } = attrib;
      const itemSize = attrib.itemSize;
      const startIndex = index * itemSize;
      if (componentIndex == null) {
        switch (itemSize) {
          case 1:
            return array[startIndex];
            break;
          case 2:
            target4 = target4 || new Vector2();
            target4.fromArray(array, startIndex);
            return target4;
            break;
          case 3:
            target4 = target4 || new Vector3();
            target4.fromArray(array, startIndex);
            return target4;
            break;
          case 4:
            target4 = target4 || new Vector4();
            target4.fromArray(array, startIndex);
            return target4;
            break;
          default:
            throw `size not valid (${itemSize})`;
        }
      } else {
        switch (itemSize) {
          case 1:
            return array[startIndex];
            break;
          default:
            return array[startIndex + componentIndex];
        }
      }
    } else {
      const attributesDict = this.attributes(object) || {};
      const attribNames = Object.keys(attributesDict);
      const message = `attrib ${attribName} not found. availables are: ${attribNames.join(",")}`;
      console.warn(message);
      throw message;
    }
  }
  attribValue(attribName, target4) {
    if (!this._object) {
      return 0;
    }
    return this.constructor.attribValue(this._object, this._index, attribName, target4);
  }
  attribValueNumber(attribName) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return 0;
    }
    return attrib.array[this._index];
  }
  attribValueVector2(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 2);
    return target4;
  }
  attribValueVector3(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 3);
    return target4;
  }
  attribValueVector4(attribName, target4) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    target4.fromArray(attrib.array, this._index * 4);
    return target4;
  }
  static attribType(object, attribName) {
    const attribute = object ? this.attribute(object, attribName) : null;
    if (attribute && (attribute == null ? void 0 : attribute.isString) == true) {
      return AttribType.STRING;
    } else {
      return AttribType.NUMERIC;
    }
  }
  attribType(attribName) {
    return this.constructor.attribType(this._object, attribName);
  }
  static stringAttribValue(object, index, attribName) {
    return this.attribValue(object, index, attribName);
  }
  stringAttribValue(attribName) {
    return this.attribValue(attribName);
  }
  // setPosition(newPosition: Vector3) {
  // 	this.setAttribValueFromVector3(Attribute.POSITION, newPosition);
  // }
  // setNormal(newNormal: Vector3) {
  // 	return this.setAttribValueFromVector3(Attribute.NORMAL, newNormal);
  // }
  static position(object, primitiveIndex, target4) {
    _warnOverloadRequired3("position");
    return target4;
  }
  static normal(object, primitiveIndex, target4) {
    _warnOverloadRequired3("normal");
    return target4;
  }
  static computeVertexNormalsIfAttributeVersionChanged(object) {
    _warnOverloadRequired3("computeVertexNormalsIfAttributeVersionChanged");
  }
  setAttribValue(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      console.warn(`no attribute ${attribName}`);
      return;
    }
    const array = attrib.array;
    const attribSize = attrib.itemSize;
    if (CoreType.isArray(value)) {
      for (let i = 0; i < attribSize; i++) {
        array[this._index * attribSize + i] = value[i];
      }
      return;
    }
    switch (attribSize) {
      case 1:
        array[this._index] = value;
        break;
      case 2:
        const v2 = value;
        const i2 = this._index * 2;
        array[i2 + 0] = v2.x;
        array[i2 + 1] = v2.y;
        break;
      case 3:
        const isColor2 = value.r != null;
        const i3 = this._index * 3;
        if (isColor2) {
          const col = value;
          array[i3 + 0] = col.r;
          array[i3 + 1] = col.g;
          array[i3 + 2] = col.b;
        } else {
          const v3 = value;
          array[i3 + 0] = v3.x;
          array[i3 + 1] = v3.y;
          array[i3 + 2] = v3.z;
        }
        break;
      case 4:
        const v4 = value;
        const i4 = this._index * 4;
        array[i4 + 0] = v4.x;
        array[i4 + 1] = v4.y;
        array[i4 + 2] = v4.z;
        array[i4 + 3] = v4.w;
        break;
      default:
        console.warn(`CorePrimitive.setAttribValue does not yet allow attribSize ${attribSize}`);
        throw `attrib size ${attribSize} not implemented`;
    }
  }
  setAttribValueFromNumber(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib) {
      return;
    }
    const array = attrib.array;
    array[this._index] = value;
  }
  setAttribValueFromVector2(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || attrib.isString == true) {
      return;
    }
    value.toArray(attrib.array, this._index * 2);
  }
  setAttribValueFromVector3(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || attrib.isString == true) {
      return;
    }
    value.toArray(attrib.array, this._index * 3);
  }
  setAttribValueFromVector4(attribName, value) {
    const attrib = this.attribute(attribName);
    if (!attrib || attrib.isString == true) {
      return;
    }
    value.toArray(attrib.array, this._index * 4);
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedPointIds(object, pointIndex, target4, traversedRelatedEntityData) {
    const ids = traversedRelatedEntityData ? traversedRelatedEntityData[AttribClass.VERTEX].ids : _ids;
    this.relatedVertexIds(object, pointIndex, ids);
    uniqRelatedEntityIds(
      ids,
      (vertexId, relatedEntityIds) => {
        this.relatedVertexClass(object).relatedPointIds(object, vertexId, relatedEntityIds);
      },
      target4
    );
  }
  static relatedPointClass(object) {
    return this.relatedVertexClass(object).relatedPointClass(object);
  }
  relatedEntities(attribClass, coreGroup, target4, traversedRelatedEntityData) {
    switch (attribClass) {
      case AttribClass.POINT: {
        this.relatedPoints(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.VERTEX: {
        this.relatedVertices(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.PRIMITIVE: {
        target4.length = 1;
        target4[0] = this;
        return;
      }
      case AttribClass.OBJECT: {
        this.relatedObjects(target4, traversedRelatedEntityData);
        return;
      }
      case AttribClass.CORE_GROUP: {
        target4.length = 1;
        target4[0] = coreGroup;
        return;
      }
    }
    TypeAssert.unreachable(attribClass);
  }
  static graph(object) {
    console.warn("CorePrimitive.graph needs to be overriden");
    return void 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/primitive/CorePrimitiveUtils.js
function primitivesCountFromObject(object) {
  const primitiveClass = corePrimitiveClassFactory(object);
  return primitiveClass.entitiesCount(object);
}
function primitivesFromObject(object, target4) {
  const primitiveClass = corePrimitiveClassFactory(object);
  const primitivesCount = primitiveClass.entitiesCount(object);
  target4.length = primitivesCount;
  for (let i = 0; i < primitivesCount; i++) {
    target4[i] = corePrimitiveInstanceFactory(object, i);
  }
  return target4;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsPrimitive.js
var target3 = {
  attributeAdded: false,
  values: []
};
var ThreejsPrimitive = class extends CorePrimitive {
  constructor(object, index) {
    super(object, index);
    this._updateGeometry();
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    attributes[attribName] = attribute;
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue2 = 0) {
    const primitivesCount = this.entitiesCount(object);
    target3.values = new Array(primitivesCount * size);
    attributeNumericValues(object, primitivesCountFromObject, size, defaultValue2, target3);
    const attribute = {
      isString: false,
      array: target3.values,
      itemSize: size
    };
    this.addAttribute(object, attribName, attribute);
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    if (!geometry.userData.primAttributes) {
      geometry.userData.primAttributes = {};
    }
    return geometry.userData.primAttributes;
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static stride() {
    return 3;
  }
  static relatedVertexIds(object, primitiveIndex, target22) {
    const geometry = object.geometry;
    if (!geometry) {
      target22.length = 0;
      return;
    }
    const stride = this.stride();
    target22.length = stride;
    for (let i = 0; i < stride; i++) {
      target22[i] = primitiveIndex * stride + i;
    }
  }
  static relatedVertexClass(object) {
    return ThreejsVertex;
  }
  static relatedObjectClass(object) {
    return ThreejsCoreObject;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/builders/Mesh.js
var _v32 = new Vector3();
var STRIDE2 = 3;
var threeMeshFromPrimitives = (object, entities) => {
  const mesh = object;
  const geometry = mesh.geometry;
  if (!geometry) {
    return void 0;
  }
  const oldIndex = geometry.getIndex();
  if (!oldIndex) {
    return void 0;
  }
  const oldIndexArray = oldIndex.array;
  const primitives = entities;
  const newIndices = new Array(primitives.length * STRIDE2);
  let i = 0;
  for (const primitive of primitives) {
    _v32.fromArray(oldIndexArray, primitive.index() * STRIDE2);
    _v32.toArray(newIndices, i * STRIDE2);
    i++;
  }
  geometry.setIndex(newIndices);
  return mesh;
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsPrimitiveTriangle.js
var _triangle2 = new Triangle();
var _p0 = new Vector3();
var _p1 = new Vector3();
var _p2 = new Vector3();
var normalsComputedWithPositionAttributeVersion = /* @__PURE__ */ new Map();
var ThreejsPrimitiveTriangle = class extends ThreejsPrimitive {
  constructor(object, index) {
    super(object, index);
    this._geometry = object.geometry;
  }
  static primitiveName() {
    return "triangle";
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count / 3;
  }
  static position(object, primitiveIndex, target4) {
    if (!(object && object.geometry)) {
      return target4;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target4;
    }
    const positionArray = positionAttribute.array;
    _p0.fromArray(positionArray, primitiveIndex * 3 + 0);
    _p1.fromArray(positionArray, primitiveIndex * 3 + 1);
    _p2.fromArray(positionArray, primitiveIndex * 3 + 2);
    target4.copy(_p0).add(_p1).add(_p2).divideScalar(3);
    return target4;
  }
  static normal(object, primitiveIndex, target4) {
    if (!(object && object.geometry)) {
      return target4;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target4;
    }
    const positionArray = positionAttribute.array;
    _triangle2.a.fromArray(positionArray, primitiveIndex * 3 + 0);
    _triangle2.b.fromArray(positionArray, primitiveIndex * 3 + 1);
    _triangle2.c.fromArray(positionArray, primitiveIndex * 3 + 2);
    _triangle2.getNormal(target4);
    return target4;
  }
  position(target4) {
    return this.constructor.position(this._object, this._index, target4);
  }
  normal(target4) {
    return this.constructor.normal(this._object, this._index, target4);
  }
  static computeVertexNormalsIfAttributeVersionChanged(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return null;
    }
    const positionAttribute = geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return;
    }
    if (!(positionAttribute instanceof BufferAttribute)) {
      return;
    }
    let lastVersion = normalsComputedWithPositionAttributeVersion.get(geometry.uuid);
    if (lastVersion == null || lastVersion != positionAttribute.version) {
      geometry.computeVertexNormals();
      normalsComputedWithPositionAttributeVersion.set(geometry.uuid, positionAttribute.version);
    }
  }
  builder() {
    return threeMeshFromPrimitives;
  }
  static stride() {
    return 3;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsPrimitiveLineSegment.js
var _p02 = new Vector3();
var _p12 = new Vector3();
var ThreejsPrimitiveLineSegment = class extends ThreejsPrimitive {
  constructor(object, index) {
    super(object, index);
    this._geometry = object.geometry;
  }
  static primitiveName() {
    return "line";
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count / 2;
  }
  static position(object, primitiveIndex, target4) {
    if (!(object && object.geometry)) {
      return target4;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target4;
    }
    const positionArray = positionAttribute.array;
    _p02.fromArray(positionArray, primitiveIndex * 3 + 0);
    _p12.fromArray(positionArray, primitiveIndex * 3 + 1);
    target4.copy(_p02).add(_p12).divideScalar(2);
    return target4;
  }
  static normal(object, primitiveIndex, target4) {
    if (!(object && object.geometry)) {
      return target4;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target4;
    }
    const positionArray = positionAttribute.array;
    _p02.fromArray(positionArray, primitiveIndex * 3 + 0);
    _p12.fromArray(positionArray, primitiveIndex * 3 + 1);
    target4.copy(_p12).sub(_p12).normalize();
    return target4;
  }
  position(target4) {
    return this.constructor.position(this._object, this._index, target4);
  }
  normal(target4) {
    return this.constructor.normal(this._object, this._index, target4);
  }
  static computeVertexNormalsIfAttributeVersionChanged(object) {
  }
  static stride() {
    return 2;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreejsPrimitivePoint.js
var _p03 = new Vector3();
var ThreejsPrimitivePoint = class extends ThreejsPrimitive {
  constructor(object, index) {
    super(object, index);
    this._geometry = object.geometry;
  }
  static primitiveName() {
    return "point";
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count;
  }
  static position(object, primitiveIndex, target4) {
    if (!(object && object.geometry)) {
      return target4;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target4;
    }
    const positionArray = positionAttribute.array;
    _p03.fromArray(positionArray, primitiveIndex * 3 + 0);
    target4.copy(_p03);
    return target4;
  }
  static normal(object, primitiveIndex, target4) {
    return target4.set(0, 1, 0);
  }
  position(target4) {
    return this.constructor.position(this._object, this._index, target4);
  }
  normal(target4) {
    return this.constructor.normal(this._object, this._index, target4);
  }
  static computeVertexNormalsIfAttributeVersionChanged(object) {
  }
  static stride() {
    return 1;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/modules/three/ThreeModule.js
var pointClassFactory = (object) => {
  if (isObject3D(object)) {
    return ThreejsPoint;
  }
};
var pointClassFactoryEnsured = () => ThreejsPoint;
var pointInstanceFactory = (object, index = 0) => {
  if (isObject3D(object)) {
    return new ThreejsPoint(object, index);
  }
};
var pointInstanceFactoryEnsured = (object, index = 0) => {
  return new ThreejsPoint(object, index);
};
var vertexClassFactory = (object) => {
  if (isObject3D(object)) {
    return ThreejsVertex;
  }
};
var vertexClassFactoryEnsured = () => ThreejsVertex;
var vertexInstanceFactory = (object, index = 0) => {
  if (isObject3D(object)) {
    return new ThreejsVertex(object, index);
  }
};
var vertexInstanceFactoryEnsured = (object, index = 0) => {
  return new ThreejsVertex(object, index);
};
var primitiveClassFactoryNonAbstract = (object) => {
  if (isObject3D(object)) {
    if (object.isMesh) {
      return ThreejsPrimitiveTriangle;
    }
    if (object.isLineSegments) {
      return ThreejsPrimitiveLineSegment;
    }
    if (object.isPoints) {
      return ThreejsPrimitivePoint;
    }
    return ThreejsPrimitiveTriangle;
  }
};
var primitiveClassFactoryEnsured = () => ThreejsPrimitiveTriangle;
var primitiveClassFactory = primitiveClassFactoryNonAbstract;
var primitiveInstanceFactory = (object, index = 0) => {
  if (isObject3D(object)) {
    if (object.isMesh) {
      return new ThreejsPrimitiveTriangle(object, index);
    }
    if (object.isLineSegments) {
      return new ThreejsPrimitiveLineSegment(object, index);
    }
    if (object.isPoints) {
      return new ThreejsPrimitivePoint(object, index);
    }
  }
};
var primitiveInstanceFactoryEnsured = (object, index = 0) => {
  return new ThreejsPrimitiveTriangle(object, index);
};
var primitiveVerticesCountFactory = (object) => {
  if (isObject3D(object)) {
    if (object.isMesh) {
      return 3;
    }
    if (object.isLineSegments) {
      return 2;
    }
    if (object.isPoints) {
      return 1;
    }
  }
  return 0;
};
var objectClassFactory = (object) => {
  if (isObject3D(object) || object.isObject3D) {
    return ThreejsCoreObject;
  }
};
var objectClassFactoryEnsured = () => ThreejsCoreObject;
var objectInstanceFactory = (object, index = 0) => {
  if (isObject3D(object)) {
    return new ThreejsCoreObject(object, index);
  }
};
var objectInstanceFactoryEnsured = (object, index = 0) => {
  return new ThreejsCoreObject(object, index);
};
var object3DFactory = {
  pointClass: pointClassFactory,
  pointInstance: pointInstanceFactory,
  vertexClass: vertexClassFactory,
  vertexInstance: vertexInstanceFactory,
  primitiveClass: primitiveClassFactory,
  primitiveInstance: primitiveInstanceFactory,
  objectClass: objectClassFactory,
  objectInstance: objectInstanceFactory
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/CoreObjectFactory.js
var coreFactoryFunctions = [object3DFactory];
function corePointClassFactory(object) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.pointClass(object);
    if (result) {
      return result;
    }
  }
  return object3DFactory.pointClass(object) || pointClassFactoryEnsured();
}
function corePointInstanceFactory(object, index = 0) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.pointInstance(object, index);
    if (result) {
      return result;
    }
  }
  return object3DFactory.pointInstance(object, index) || pointInstanceFactoryEnsured(object, index);
}
function coreVertexClassFactory(object) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.vertexClass(object);
    if (result) {
      return result;
    }
  }
  return object3DFactory.vertexClass(object) || vertexClassFactoryEnsured();
}
function coreVertexInstanceFactory(object, index = 0) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.vertexInstance(object, index);
    if (result) {
      return result;
    }
  }
  return object3DFactory.vertexInstance(object, index) || vertexInstanceFactoryEnsured(object, index);
}
function corePrimitiveClassFactory(object) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.primitiveClass(object);
    if (result) {
      return result;
    }
  }
  return object3DFactory.primitiveClass(object) || primitiveClassFactoryEnsured();
}
function corePrimitiveInstanceFactory(object, index = 0) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.primitiveInstance(object, index);
    if (result) {
      return result;
    }
  }
  return object3DFactory.primitiveInstance(object, index) || primitiveInstanceFactoryEnsured(object, index);
}
function coreObjectClassFactory(object) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.objectClass(object);
    if (result) {
      return result;
    }
  }
  return object3DFactory.objectClass(object) || objectClassFactoryEnsured();
}
function coreObjectInstanceFactory(object, index = 0) {
  for (const factoryFunction of coreFactoryFunctions) {
    const result = factoryFunction.objectInstance(object, index);
    if (result) {
      return result;
    }
  }
  return object3DFactory.objectInstance(object, index) || objectInstanceFactoryEnsured(object);
}
var ENTITY_CLASS_FACTORY = {
  [AttribClass.POINT]: corePointClassFactory,
  [AttribClass.VERTEX]: coreVertexClassFactory,
  [AttribClass.PRIMITIVE]: corePrimitiveClassFactory,
  [AttribClass.OBJECT]: coreObjectClassFactory,
  [AttribClass.CORE_GROUP]: null
};
var ENTITY_INSTANCE_FACTORY = {
  [AttribClass.POINT]: corePointInstanceFactory,
  [AttribClass.VERTEX]: coreVertexInstanceFactory,
  [AttribClass.PRIMITIVE]: corePrimitiveInstanceFactory,
  [AttribClass.OBJECT]: coreObjectInstanceFactory,
  [AttribClass.CORE_GROUP]: null
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/entities/point/CorePointUtils.js
var _indices2 = [];
var _tmpPoints = [];
function pointsFromCoreObjects(coreObjects, target4) {
  target4.length = 0;
  for (const coreObject of coreObjects) {
    pointsFromObject(coreObject.object(), _tmpPoints);
    arrayPushItems(_tmpPoints, target4);
  }
  return target4;
}
function pointsFromObjects(objects, target4) {
  target4.length = 0;
  for (const object of objects) {
    pointsFromObject(object, _tmpPoints);
    arrayPushItems(_tmpPoints, target4);
  }
  return target4;
}
function pointsCountFromObject(object) {
  const pointClass = corePointClassFactory(object);
  return pointClass.entitiesCount(object);
}
function pointsFromObject(object, target4) {
  const pointClass = corePointClassFactory(object);
  const pointsCount = pointClass.entitiesCount(object);
  target4.length = pointsCount;
  for (let i = 0; i < pointsCount; i++) {
    target4[i] = corePointInstanceFactory(object, i);
  }
  return target4;
}
function pointsFromObjectFromGroup(object, group, target4) {
  if (group) {
    CoreString.indices(group, _indices2);
    const points = pointsFromObject(object, _tmpPoints);
    const compactPoints = [];
    const selectedPoints = arrayCompact(
      _indices2.map((i) => points[i]),
      compactPoints
    );
    target4.length = 0;
    arrayPushItems(selectedPoints, target4);
    return target4;
  } else {
    return pointsFromObject(object, target4);
  }
}
function hasPointAttribute(object, attribName) {
  const pointClass = corePointClassFactory(object);
  const attributes = pointClass.attributes(object);
  if (!attributes) {
    return false;
  }
  return attribName in attributes;
}
function pointAttributeNames(object) {
  const pointClass = corePointClassFactory(object);
  const attributes = pointClass.attributes(object);
  if (!attributes) {
    return [];
  }
  return Object.keys(attributes);
}
function pointAttributeSize(object, attribName) {
  const pointClass = corePointClassFactory(object);
  const attributes = pointClass.attributes(object);
  if (!attributes) {
    return 0;
  }
  return attributes[attribName].itemSize;
}
function pointAttributeSizes(object) {
  const pointClass = corePointClassFactory(object);
  const attributes = pointClass.attributes(object);
  if (!attributes) {
    return {};
  }
  const attribNames = Object.keys(attributes);
  const h = {};
  for (const attribName of attribNames) {
    h[attribName] = attributes[attribName].itemSize;
  }
  return h;
}
function pointAttributeType(object, attribName) {
  const pointClass = corePointClassFactory(object);
  const attributes = pointClass.attributes(object);
  if (!attributes) {
    return AttribType.NUMERIC;
  }
  return pointClass.attribType(object, attribName);
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/flags/Base.js
var BaseFlag = class {
  constructor(node) {
    this.node = node;
    this._state = true;
    this._hooks = null;
  }
  onUpdate(hook) {
    this._hooks = this._hooks || [];
    this._hooks.push(hook);
  }
  _onUpdate() {
  }
  set(newState) {
    if (this._state != newState) {
      if (this.node.insideALockedParent()) {
        const lockedParent = this.node.lockedParent();
        console.warn(
          `node '${this.node.path()}' cannot have its flag changed, since it is inside '${lockedParent ? lockedParent.path() : ""}', which is locked`
        );
        return;
      }
      this._state = newState;
      this._onUpdate();
      this.runHooks();
    }
  }
  active() {
    return this._state;
  }
  toggle() {
    this.set(!this._state);
  }
  runHooks() {
    if (this._hooks) {
      for (const hook of this._hooks) {
        hook();
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/flags/Bypass.js
var BypassFlag = class extends BaseFlag {
  constructor() {
    super(...arguments);
    this._state = false;
  }
  _onUpdate() {
    this.node.emit(NodeEvent.FLAG_BYPASS_UPDATED);
    this.node.setDirty();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/flags/Display.js
var DisplayFlag = class extends BaseFlag {
  _onUpdate() {
    this.node.emit(NodeEvent.FLAG_DISPLAY_UPDATED);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/flags/Optimize.js
var OptimizeFlag = class extends BaseFlag {
  constructor() {
    super(...arguments);
    this._state = false;
  }
  _onUpdate() {
    this.node.emit(NodeEvent.FLAG_OPTIMIZE_UPDATED);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/FlagsController.js
var FlagsController = class {
  constructor(node) {
    this.node = node;
  }
  hasDisplay() {
    return false;
  }
  hasBypass() {
    return false;
  }
  hasOptimize() {
    return false;
  }
};
function Display(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.display = new DisplayFlag(this.node);
    }
    hasDisplay() {
      return true;
    }
  };
}
function Bypass(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.bypass = new BypassFlag(this.node);
    }
    hasBypass() {
      return true;
    }
  };
}
function Optimize(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.optimize = new OptimizeFlag(this.node);
    }
    hasOptimize() {
      return true;
    }
  };
}
var FlagsControllerD = class extends Display(FlagsController) {
};
var FlagsControllerB = class extends Bypass(FlagsController) {
};
var FlagsControllerDB = class extends Bypass(Display(FlagsController)) {
};
var FlagsControllerBO = class extends Optimize(Bypass(FlagsController)) {
};
var FlagsControllerDBO = class extends Optimize(Bypass(Display(FlagsController))) {
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/InputCloneMode.js
var InputCloneMode = ((InputCloneMode2) => {
  InputCloneMode2["ALWAYS"] = "always";
  InputCloneMode2["NEVER"] = "never";
  InputCloneMode2["FROM_NODE"] = "from_node";
  return InputCloneMode2;
})(InputCloneMode || {});

// node_modules/jsep/dist/jsep.js
var Hooks = class {
  /**
   * @callback HookCallback
   * @this {*|Jsep} this
   * @param {Jsep} env
   * @returns: void
   */
  /**
   * Adds the given callback to the list of callbacks for the given hook.
   *
   * The callback will be invoked when the hook it is registered for is run.
   *
   * One callback function can be registered to multiple hooks and the same hook multiple times.
   *
   * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
   * @param {HookCallback|boolean} callback The callback function which is given environment variables.
   * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
   * @public
   */
  add(name, callback, first) {
    if (typeof arguments[0] != "string") {
      for (let name2 in arguments[0]) {
        this.add(name2, arguments[0][name2], arguments[1]);
      }
    } else {
      (Array.isArray(name) ? name : [name]).forEach(function(name2) {
        this[name2] = this[name2] || [];
        if (callback) {
          this[name2][first ? "unshift" : "push"](callback);
        }
      }, this);
    }
  }
  /**
   * Runs a hook invoking all registered callbacks with the given environment variables.
   *
   * Callbacks will be invoked synchronously and in the order in which they were registered.
   *
   * @param {string} name The name of the hook.
   * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
   * @public
   */
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var Plugins = class {
  constructor(jsep2) {
    this.jsep = jsep2;
    this.registered = {};
  }
  /**
   * @callback PluginSetup
   * @this {Jsep} jsep
   * @returns: void
   */
  /**
   * Adds the given plugin(s) to the registry
   *
   * @param {object} plugins
   * @param {string} plugins.name The name of the plugin
   * @param {PluginSetup} plugins.init The init function
   * @public
   */
  register(...plugins) {
    plugins.forEach((plugin) => {
      if (typeof plugin !== "object" || !plugin.name || !plugin.init) {
        throw new Error("Invalid JSEP plugin format");
      }
      if (this.registered[plugin.name]) {
        return;
      }
      plugin.init(this.jsep);
      this.registered[plugin.name] = plugin;
    });
  }
};
var Jsep = class _Jsep {
  /**
   * @returns {string}
   */
  static get version() {
    return "1.0.2";
  }
  /**
   * @returns {string}
   */
  static toString() {
    return "JavaScript Expression Parser (JSEP) v" + _Jsep.version;
  }
  // ==================== CONFIG ================================
  /**
   * @method addUnaryOp
   * @param {string} op_name The name of the unary op to add
   * @returns {Jsep}
   */
  static addUnaryOp(op_name) {
    _Jsep.max_unop_len = Math.max(op_name.length, _Jsep.max_unop_len);
    _Jsep.unary_ops[op_name] = 1;
    return _Jsep;
  }
  /**
   * @method jsep.addBinaryOp
   * @param {string} op_name The name of the binary op to add
   * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
   * @returns {Jsep}
   */
  static addBinaryOp(op_name, precedence2) {
    _Jsep.max_binop_len = Math.max(op_name.length, _Jsep.max_binop_len);
    _Jsep.binary_ops[op_name] = precedence2;
    return _Jsep;
  }
  /**
   * @method addIdentifierChar
   * @param {string} char The additional character to treat as a valid part of an identifier
   * @returns {Jsep}
   */
  static addIdentifierChar(char) {
    _Jsep.additional_identifier_chars.add(char);
    return _Jsep;
  }
  /**
   * @method addLiteral
   * @param {string} literal_name The name of the literal to add
   * @param {*} literal_value The value of the literal
   * @returns {Jsep}
   */
  static addLiteral(literal_name, literal_value) {
    _Jsep.literals[literal_name] = literal_value;
    return _Jsep;
  }
  /**
   * @method removeUnaryOp
   * @param {string} op_name The name of the unary op to remove
   * @returns {Jsep}
   */
  static removeUnaryOp(op_name) {
    delete _Jsep.unary_ops[op_name];
    if (op_name.length === _Jsep.max_unop_len) {
      _Jsep.max_unop_len = _Jsep.getMaxKeyLen(_Jsep.unary_ops);
    }
    return _Jsep;
  }
  /**
   * @method removeAllUnaryOps
   * @returns {Jsep}
   */
  static removeAllUnaryOps() {
    _Jsep.unary_ops = {};
    _Jsep.max_unop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeIdentifierChar
   * @param {string} char The additional character to stop treating as a valid part of an identifier
   * @returns {Jsep}
   */
  static removeIdentifierChar(char) {
    _Jsep.additional_identifier_chars.delete(char);
    return _Jsep;
  }
  /**
   * @method removeBinaryOp
   * @param {string} op_name The name of the binary op to remove
   * @returns {Jsep}
   */
  static removeBinaryOp(op_name) {
    delete _Jsep.binary_ops[op_name];
    if (op_name.length === _Jsep.max_binop_len) {
      _Jsep.max_binop_len = _Jsep.getMaxKeyLen(_Jsep.binary_ops);
    }
    return _Jsep;
  }
  /**
   * @method removeAllBinaryOps
   * @returns {Jsep}
   */
  static removeAllBinaryOps() {
    _Jsep.binary_ops = {};
    _Jsep.max_binop_len = 0;
    return _Jsep;
  }
  /**
   * @method removeLiteral
   * @param {string} literal_name The name of the literal to remove
   * @returns {Jsep}
   */
  static removeLiteral(literal_name) {
    delete _Jsep.literals[literal_name];
    return _Jsep;
  }
  /**
   * @method removeAllLiterals
   * @returns {Jsep}
   */
  static removeAllLiterals() {
    _Jsep.literals = {};
    return _Jsep;
  }
  // ==================== END CONFIG ============================
  /**
   * @returns {string}
   */
  get char() {
    return this.expr.charAt(this.index);
  }
  /**
   * @returns {number}
   */
  get code() {
    return this.expr.charCodeAt(this.index);
  }
  /**
   * @param {string} expr a string with the passed in express
   * @returns Jsep
   */
  constructor(expr) {
    this.expr = expr;
    this.index = 0;
  }
  /**
   * static top-level parser
   * @returns {jsep.Expression}
   */
  static parse(expr) {
    return new _Jsep(expr).parse();
  }
  /**
   * Get the longest key length of any object
   * @param {object} obj
   * @returns {number}
   */
  static getMaxKeyLen(obj) {
    return Math.max(0, ...Object.keys(obj).map((k) => k.length));
  }
  /**
   * `ch` is a character code in the next three functions
   * @param {number} ch
   * @returns {boolean}
   */
  static isDecimalDigit(ch) {
    return ch >= 48 && ch <= 57;
  }
  /**
   * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
   * @param {string} op_val
   * @returns {number}
   */
  static binaryPrecedence(op_val) {
    return _Jsep.binary_ops[op_val] || 0;
  }
  /**
   * Looks for start of identifier
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierStart(ch) {
    return ch >= 65 && ch <= 90 || // A...Z
    ch >= 97 && ch <= 122 || // a...z
    ch >= 128 && !_Jsep.binary_ops[String.fromCharCode(ch)] || // any non-ASCII that is not an operator
    _Jsep.additional_identifier_chars.has(String.fromCharCode(ch));
  }
  /**
   * @param {number} ch
   * @returns {boolean}
   */
  static isIdentifierPart(ch) {
    return _Jsep.isIdentifierStart(ch) || _Jsep.isDecimalDigit(ch);
  }
  /**
   * throw error at index of the expression
   * @param {string} message
   * @throws
   */
  throwError(message) {
    const error = new Error(message + " at character " + this.index);
    error.index = this.index;
    error.description = message;
    throw error;
  }
  /**
   * Run a given hook
   * @param {string} name
   * @param {jsep.Expression|false} [node]
   * @returns {?jsep.Expression}
   */
  runHook(name, node) {
    if (_Jsep.hooks[name]) {
      const env = { context: this, node };
      _Jsep.hooks.run(name, env);
      return env.node;
    }
    return node;
  }
  /**
   * Runs a given hook until one returns a node
   * @param {string} name
   * @returns {?jsep.Expression}
   */
  searchHook(name) {
    if (_Jsep.hooks[name]) {
      const env = { context: this };
      _Jsep.hooks[name].find(function(callback) {
        callback.call(env.context, env);
        return env.node;
      });
      return env.node;
    }
  }
  /**
   * Push `index` up to the next non-space character
   */
  gobbleSpaces() {
    let ch = this.code;
    while (ch === _Jsep.SPACE_CODE || ch === _Jsep.TAB_CODE || ch === _Jsep.LF_CODE || ch === _Jsep.CR_CODE) {
      ch = this.expr.charCodeAt(++this.index);
    }
    this.runHook("gobble-spaces");
  }
  /**
   * Top-level method to parse all expressions and returns compound or single node
   * @returns {jsep.Expression}
   */
  parse() {
    this.runHook("before-all");
    const nodes = this.gobbleExpressions();
    const node = nodes.length === 1 ? nodes[0] : {
      type: _Jsep.COMPOUND,
      body: nodes
    };
    return this.runHook("after-all", node);
  }
  /**
   * top-level parser (but can be reused within as well)
   * @param {number} [untilICode]
   * @returns {jsep.Expression[]}
   */
  gobbleExpressions(untilICode) {
    let nodes = [], ch_i, node;
    while (this.index < this.expr.length) {
      ch_i = this.code;
      if (ch_i === _Jsep.SEMCOL_CODE || ch_i === _Jsep.COMMA_CODE) {
        this.index++;
      } else {
        if (node = this.gobbleExpression()) {
          nodes.push(node);
        } else if (this.index < this.expr.length) {
          if (ch_i === untilICode) {
            break;
          }
          this.throwError('Unexpected "' + this.char + '"');
        }
      }
    }
    return nodes;
  }
  /**
   * The main parsing function.
   * @returns {?jsep.Expression}
   */
  gobbleExpression() {
    const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
    this.gobbleSpaces();
    return this.runHook("after-expression", node);
  }
  /**
   * Search for the operation portion of the string (e.g. `+`, `===`)
   * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
   * and move down from 3 to 2 to 1 character until a matching binary operation is found
   * then, return that binary operation
   * @returns {string|boolean}
   */
  gobbleBinaryOp() {
    this.gobbleSpaces();
    let to_check = this.expr.substr(this.index, _Jsep.max_binop_len);
    let tc_len = to_check.length;
    while (tc_len > 0) {
      if (_Jsep.binary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
        this.index += tc_len;
        return to_check;
      }
      to_check = to_check.substr(0, --tc_len);
    }
    return false;
  }
  /**
   * This function is responsible for gobbling an individual expression,
   * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
   * @returns {?jsep.BinaryExpression}
   */
  gobbleBinaryExpression() {
    let node, biop, prec, stack, biop_info, left, right, i, cur_biop;
    left = this.gobbleToken();
    if (!left) {
      return left;
    }
    biop = this.gobbleBinaryOp();
    if (!biop) {
      return left;
    }
    biop_info = { value: biop, prec: _Jsep.binaryPrecedence(biop) };
    right = this.gobbleToken();
    if (!right) {
      this.throwError("Expected expression after " + biop);
    }
    stack = [left, biop_info, right];
    while (biop = this.gobbleBinaryOp()) {
      prec = _Jsep.binaryPrecedence(biop);
      if (prec === 0) {
        this.index -= biop.length;
        break;
      }
      biop_info = { value: biop, prec };
      cur_biop = biop;
      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
        right = stack.pop();
        biop = stack.pop().value;
        left = stack.pop();
        node = {
          type: _Jsep.BINARY_EXP,
          operator: biop,
          left,
          right
        };
        stack.push(node);
      }
      node = this.gobbleToken();
      if (!node) {
        this.throwError("Expected expression after " + cur_biop);
      }
      stack.push(biop_info, node);
    }
    i = stack.length - 1;
    node = stack[i];
    while (i > 1) {
      node = {
        type: _Jsep.BINARY_EXP,
        operator: stack[i - 1].value,
        left: stack[i - 2],
        right: node
      };
      i -= 2;
    }
    return node;
  }
  /**
   * An individual part of a binary expression:
   * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
   * @returns {boolean|jsep.Expression}
   */
  gobbleToken() {
    let ch, to_check, tc_len, node;
    this.gobbleSpaces();
    node = this.searchHook("gobble-token");
    if (node) {
      return this.runHook("after-token", node);
    }
    ch = this.code;
    if (_Jsep.isDecimalDigit(ch) || ch === _Jsep.PERIOD_CODE) {
      return this.gobbleNumericLiteral();
    }
    if (ch === _Jsep.SQUOTE_CODE || ch === _Jsep.DQUOTE_CODE) {
      node = this.gobbleStringLiteral();
    } else if (ch === _Jsep.OBRACK_CODE) {
      node = this.gobbleArray();
    } else {
      to_check = this.expr.substr(this.index, _Jsep.max_unop_len);
      tc_len = to_check.length;
      while (tc_len > 0) {
        if (_Jsep.unary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
          this.index += tc_len;
          const argument = this.gobbleToken();
          if (!argument) {
            this.throwError("missing unaryOp argument");
          }
          return this.runHook("after-token", {
            type: _Jsep.UNARY_EXP,
            operator: to_check,
            argument,
            prefix: true
          });
        }
        to_check = to_check.substr(0, --tc_len);
      }
      if (_Jsep.isIdentifierStart(ch)) {
        node = this.gobbleIdentifier();
        if (_Jsep.literals.hasOwnProperty(node.name)) {
          node = {
            type: _Jsep.LITERAL,
            value: _Jsep.literals[node.name],
            raw: node.name
          };
        } else if (node.name === _Jsep.this_str) {
          node = { type: _Jsep.THIS_EXP };
        }
      } else if (ch === _Jsep.OPAREN_CODE) {
        node = this.gobbleGroup();
      }
    }
    if (!node) {
      return this.runHook("after-token", false);
    }
    node = this.gobbleTokenProperty(node);
    return this.runHook("after-token", node);
  }
  /**
   * Gobble properties of of identifiers/strings/arrays/groups.
   * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
   * It also gobbles function calls:
   * e.g. `Math.acos(obj.angle)`
   * @param {jsep.Expression} node
   * @returns {jsep.Expression}
   */
  gobbleTokenProperty(node) {
    this.gobbleSpaces();
    let ch = this.code;
    while (ch === _Jsep.PERIOD_CODE || ch === _Jsep.OBRACK_CODE || ch === _Jsep.OPAREN_CODE) {
      this.index++;
      if (ch === _Jsep.PERIOD_CODE) {
        this.gobbleSpaces();
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: false,
          object: node,
          property: this.gobbleIdentifier()
        };
      } else if (ch === _Jsep.OBRACK_CODE) {
        node = {
          type: _Jsep.MEMBER_EXP,
          computed: true,
          object: node,
          property: this.gobbleExpression()
        };
        this.gobbleSpaces();
        ch = this.code;
        if (ch !== _Jsep.CBRACK_CODE) {
          this.throwError("Unclosed [");
        }
        this.index++;
      } else if (ch === _Jsep.OPAREN_CODE) {
        node = {
          type: _Jsep.CALL_EXP,
          "arguments": this.gobbleArguments(_Jsep.CPAREN_CODE),
          callee: node
        };
      }
      this.gobbleSpaces();
      ch = this.code;
    }
    return node;
  }
  /**
   * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
   * keep track of everything in the numeric literal and then calling `parseFloat` on that string
   * @returns {jsep.Literal}
   */
  gobbleNumericLiteral() {
    let number = "", ch, chCode;
    while (_Jsep.isDecimalDigit(this.code)) {
      number += this.expr.charAt(this.index++);
    }
    if (this.code === _Jsep.PERIOD_CODE) {
      number += this.expr.charAt(this.index++);
      while (_Jsep.isDecimalDigit(this.code)) {
        number += this.expr.charAt(this.index++);
      }
    }
    ch = this.char;
    if (ch === "e" || ch === "E") {
      number += this.expr.charAt(this.index++);
      ch = this.char;
      if (ch === "+" || ch === "-") {
        number += this.expr.charAt(this.index++);
      }
      while (_Jsep.isDecimalDigit(this.code)) {
        number += this.expr.charAt(this.index++);
      }
      if (!_Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
        this.throwError("Expected exponent (" + number + this.char + ")");
      }
    }
    chCode = this.code;
    if (_Jsep.isIdentifierStart(chCode)) {
      this.throwError("Variable names cannot start with a number (" + number + this.char + ")");
    } else if (chCode === _Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === _Jsep.PERIOD_CODE) {
      this.throwError("Unexpected period");
    }
    return {
      type: _Jsep.LITERAL,
      value: parseFloat(number),
      raw: number
    };
  }
  /**
   * Parses a string literal, staring with single or double quotes with basic support for escape codes
   * e.g. `"hello world"`, `'this is\nJSEP'`
   * @returns {jsep.Literal}
   */
  gobbleStringLiteral() {
    let str = "";
    let quote = this.expr.charAt(this.index++);
    let closed = false;
    while (this.index < this.expr.length) {
      let ch = this.expr.charAt(this.index++);
      if (ch === quote) {
        closed = true;
        break;
      } else if (ch === "\\") {
        ch = this.expr.charAt(this.index++);
        switch (ch) {
          case "n":
            str += "\n";
            break;
          case "r":
            str += "\r";
            break;
          case "t":
            str += "	";
            break;
          case "b":
            str += "\b";
            break;
          case "f":
            str += "\f";
            break;
          case "v":
            str += "\v";
            break;
          default:
            str += ch;
        }
      } else {
        str += ch;
      }
    }
    if (!closed) {
      this.throwError('Unclosed quote after "' + str + '"');
    }
    return {
      type: _Jsep.LITERAL,
      value: str,
      raw: quote + str + quote
    };
  }
  /**
   * Gobbles only identifiers
   * e.g.: `foo`, `_value`, `$x1`
   * Also, this function checks if that identifier is a literal:
   * (e.g. `true`, `false`, `null`) or `this`
   * @returns {jsep.Identifier}
   */
  gobbleIdentifier() {
    let ch = this.code, start = this.index;
    if (_Jsep.isIdentifierStart(ch)) {
      this.index++;
    } else {
      this.throwError("Unexpected " + this.char);
    }
    while (this.index < this.expr.length) {
      ch = this.code;
      if (_Jsep.isIdentifierPart(ch)) {
        this.index++;
      } else {
        break;
      }
    }
    return {
      type: _Jsep.IDENTIFIER,
      name: this.expr.slice(start, this.index)
    };
  }
  /**
   * Gobbles a list of arguments within the context of a function call
   * or array literal. This function also assumes that the opening character
   * `(` or `[` has already been gobbled, and gobbles expressions and commas
   * until the terminator character `)` or `]` is encountered.
   * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
   * @param {number} termination
   * @returns {jsep.Expression[]}
   */
  gobbleArguments(termination) {
    const args = [];
    let closed = false;
    let separator_count = 0;
    while (this.index < this.expr.length) {
      this.gobbleSpaces();
      let ch_i = this.code;
      if (ch_i === termination) {
        closed = true;
        this.index++;
        if (termination === _Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
          this.throwError("Unexpected token " + String.fromCharCode(termination));
        }
        break;
      } else if (ch_i === _Jsep.COMMA_CODE) {
        this.index++;
        separator_count++;
        if (separator_count !== args.length) {
          if (termination === _Jsep.CPAREN_CODE) {
            this.throwError("Unexpected token ,");
          } else if (termination === _Jsep.CBRACK_CODE) {
            for (let arg = args.length; arg < separator_count; arg++) {
              args.push(null);
            }
          }
        }
      } else if (args.length !== separator_count && separator_count !== 0) {
        this.throwError("Expected comma");
      } else {
        const node = this.gobbleExpression();
        if (!node || node.type === _Jsep.COMPOUND) {
          this.throwError("Expected comma");
        }
        args.push(node);
      }
    }
    if (!closed) {
      this.throwError("Expected " + String.fromCharCode(termination));
    }
    return args;
  }
  /**
   * Responsible for parsing a group of things within parentheses `()`
   * that have no identifier in front (so not a function call)
   * This function assumes that it needs to gobble the opening parenthesis
   * and then tries to gobble everything within that parenthesis, assuming
   * that the next thing it should see is the close parenthesis. If not,
   * then the expression probably doesn't have a `)`
   * @returns {boolean|jsep.Expression}
   */
  gobbleGroup() {
    this.index++;
    let nodes = this.gobbleExpressions(_Jsep.CPAREN_CODE);
    if (this.code === _Jsep.CPAREN_CODE) {
      this.index++;
      if (nodes.length === 1) {
        return nodes[0];
      } else if (!nodes.length) {
        return false;
      } else {
        return {
          type: _Jsep.SEQUENCE_EXP,
          expressions: nodes
        };
      }
    } else {
      this.throwError("Unclosed (");
    }
  }
  /**
   * Responsible for parsing Array literals `[1, 2, 3]`
   * This function assumes that it needs to gobble the opening bracket
   * and then tries to gobble the expressions as arguments.
   * @returns {jsep.ArrayExpression}
   */
  gobbleArray() {
    this.index++;
    return {
      type: _Jsep.ARRAY_EXP,
      elements: this.gobbleArguments(_Jsep.CBRACK_CODE)
    };
  }
};
var hooks = new Hooks();
Object.assign(Jsep, {
  hooks,
  plugins: new Plugins(Jsep),
  // Node Types
  // ----------
  // This is the full set of types that any JSEP node can be.
  // Store them here to save space when minified
  COMPOUND: "Compound",
  SEQUENCE_EXP: "SequenceExpression",
  IDENTIFIER: "Identifier",
  MEMBER_EXP: "MemberExpression",
  LITERAL: "Literal",
  THIS_EXP: "ThisExpression",
  CALL_EXP: "CallExpression",
  UNARY_EXP: "UnaryExpression",
  BINARY_EXP: "BinaryExpression",
  ARRAY_EXP: "ArrayExpression",
  TAB_CODE: 9,
  LF_CODE: 10,
  CR_CODE: 13,
  SPACE_CODE: 32,
  PERIOD_CODE: 46,
  // '.'
  COMMA_CODE: 44,
  // ','
  SQUOTE_CODE: 39,
  // single quote
  DQUOTE_CODE: 34,
  // double quotes
  OPAREN_CODE: 40,
  // (
  CPAREN_CODE: 41,
  // )
  OBRACK_CODE: 91,
  // [
  CBRACK_CODE: 93,
  // ]
  QUMARK_CODE: 63,
  // ?
  SEMCOL_CODE: 59,
  // ;
  COLON_CODE: 58,
  // :
  // Operations
  // ----------
  // Use a quickly-accessible map to store all of the unary operators
  // Values are set to `1` (it really doesn't matter)
  unary_ops: {
    "-": 1,
    "!": 1,
    "~": 1,
    "+": 1
  },
  // Also use a map for the binary operations but set their values to their
  // binary precedence for quick reference (higher number = higher precedence)
  // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
  binary_ops: {
    "||": 1,
    "&&": 2,
    "|": 3,
    "^": 4,
    "&": 5,
    "==": 6,
    "!=": 6,
    "===": 6,
    "!==": 6,
    "<": 7,
    ">": 7,
    "<=": 7,
    ">=": 7,
    "<<": 8,
    ">>": 8,
    ">>>": 8,
    "+": 9,
    "-": 9,
    "*": 10,
    "/": 10,
    "%": 10
  },
  // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
  additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
  // Literals
  // ----------
  // Store the values to return for the various literals we may encounter
  literals: {
    "true": true,
    "false": false,
    "null": null
  },
  // Except for `this`, which is special. This could be changed to something like `'self'` as well
  this_str: "this"
});
Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
var jsep = (expr) => new Jsep(expr).parse();
var staticMethods = Object.getOwnPropertyNames(Jsep);
staticMethods.forEach((m) => {
  if (jsep[m] === void 0 && m !== "prototype") {
    jsep[m] = Jsep[m];
  }
});
jsep.Jsep = Jsep;
var CONDITIONAL_EXP = "ConditionalExpression";
var ternary = {
  name: "ternary",
  init(jsep2) {
    jsep2.hooks.add("after-expression", function gobbleTernary(env) {
      if (env.node && this.code === jsep2.QUMARK_CODE) {
        this.index++;
        const test = env.node;
        const consequent = this.gobbleExpression();
        if (!consequent) {
          this.throwError("Expected expression");
        }
        this.gobbleSpaces();
        if (this.code === jsep2.COLON_CODE) {
          this.index++;
          const alternate = this.gobbleExpression();
          if (!alternate) {
            this.throwError("Expected expression");
          }
          env.node = {
            type: CONDITIONAL_EXP,
            test,
            consequent,
            alternate
          };
        } else if (consequent.operator === ":") {
          env.node = {
            type: CONDITIONAL_EXP,
            test,
            consequent: consequent.left,
            alternate: consequent.right
          };
        } else {
          this.throwError("Expected :");
        }
      }
    });
  }
};
jsep.plugins.register(ternary);

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/traversers/ParsedTree.js
jsep.addUnaryOp("@");
var precedence = 10;
jsep.addBinaryOp("**", precedence);
var JSEP_IDENTIFIER = "Identifier";
var JSEP_LITERAL = "Literal";
var JSEP_CALL_EXPRESSION = "CallExpression";
var STRING_EXPRESSION_SEPARATOR = "`";
function stringValueElements(v) {
  if (v != null) {
    if (CoreType.isString(v)) {
      return v.split(STRING_EXPRESSION_SEPARATOR);
    } else {
      return [];
    }
  } else {
    return [];
  }
}
var ParsedTree = class {
  constructor(_param) {
    this._param = _param;
  }
  node() {
    return this._node;
  }
  errorMessage() {
    return this._errorMessage;
  }
  parseExpression(string) {
    try {
      this.reset();
      this._node = jsep(string);
    } catch (e) {
      const message = `could not parse the expression '${string}' (error: ${e})`;
      this._errorMessage = message;
    }
  }
  parseExpressionForStringParam(string) {
    try {
      this.reset();
      const elements = stringValueElements(string);
      const nodes = [];
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        let node;
        if (i % 2 == 1) {
          node = jsep(element);
        } else {
          const sanitizedElement = element.replace(/\'/g, "\\'");
          node = {
            type: JSEP_LITERAL,
            value: `'${sanitizedElement}'`,
            raw: `'${sanitizedElement}'`
          };
          this._param.scene().missingExpressionReferencesController.registerToIgnore(node);
        }
        nodes.push(node);
      }
      this._node = {
        type: JSEP_CALL_EXPRESSION,
        arguments: nodes,
        callee: {
          type: JSEP_IDENTIFIER,
          name: "strConcat"
        }
      };
    } catch (e) {
      const message = `could not parse the expression '${string}' (error: ${e})`;
      this._errorMessage = message;
    }
  }
  // static string_value_contains_expression(v:string): boolean{
  // 	return ((this.string_value_elements(v).length - 1) % 2) === 0;
  // }
  // deep_parse_for_string_expressions(){
  // 	// for string expressions which have more than a single `<expr>` element
  // 	// pt_`@ptnum`
  // 	// `@ptnum`_pt
  // 	// pt_`@ptnum`_`1+1`
  // 	if(this.node.type == JSEP_COMPOUND){
  // 		const args = this.node.body
  // 		let arg;
  // 		for(let i=0; i<args.length; i++){
  // 			arg = args[i]
  // 			if(arg.type == JSEP_LITERAL){
  // 				const arg_node = jsep(arg.value)
  // 				args[i] = arg_node
  // 			}
  // 		}
  // 	} else {
  // 		// for string expressions which havea single `<expr>` element
  // 		// `@ptnum`
  // 		if(this.node.type == JSEP_LITERAL){
  // 			const raw = this.node.raw
  // 			const first_char_code = raw.charCodeAt(0)
  // 			const last_char_code = raw.charCodeAt(raw.length-1)
  // 			if(first_char_code == HOUDINI_QUOTE_CODE && last_char_code == HOUDINI_QUOTE_CODE){
  // 				this.node = jsep("''+"+this.node.value) // add the prefix ''+ to ensure we have a string as a result, and not a number
  // 			}
  // 		}
  // 	}
  // }
  reset() {
    this._node = void 0;
    this._errorMessage = void 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/LiteralConstructsController.js
var LiteralConstructsController = class {
  static if(args) {
    const condition = args[0];
    const valTrue = args[1];
    const valFalse = args[2];
    return `((${condition}) ? (${valTrue}) : (${valFalse}))`;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/traversers/_Base.js
var VARIABLE_PREFIX = "$";
var BaseTraverser = class {
  constructor(param) {
    this.param = param;
    this._set_error_from_error_bound = this._set_error_from_error.bind(this);
  }
  clearError() {
    this._errorMessage = void 0;
  }
  setError(message) {
    this._errorMessage = this._errorMessage || message;
  }
  _set_error_from_error(error) {
    if (CoreType.isString(error)) {
      this._errorMessage = error;
    } else {
      this._errorMessage = error.message;
    }
  }
  isErrored() {
    return this._errorMessage != null;
  }
  errorMessage() {
    return this._errorMessage;
  }
  reset() {
    this._errorMessage = void 0;
  }
  traverse_node(node) {
    const method_name = `traverse_${node.type}`;
    const method = this[method_name];
    if (method) {
      return this[method_name](node);
    } else {
      this.setError(`expression unknown node type: ${node.type}`);
    }
  }
  traverse_BinaryExpression(node) {
    return `${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)}`;
  }
  // protected traverse_LogicalExpression(node: jsep.LogicalExpression): string {
  // 	// || or &&
  // 	return `${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)}`;
  // }
  traverse_MemberExpression(node) {
    return `${this.traverse_node(node.object)}.${this.traverse_node(node.property)}`;
  }
  traverse_ConditionalExpression(node) {
    return `(${this.traverse_node(node.test)}) ? (${this.traverse_node(node.consequent)}) : (${this.traverse_node(
      node.alternate
    )})`;
  }
  // currently only used for string expressions such as
  // pt_`@ptnum+1`
  traverse_Compound(node) {
    const args = node.body;
    let traversed_args = [];
    for (let i = 0; i < args.length; i++) {
      const arg_node = args[i];
      if (arg_node.type == "Identifier") {
        if (arg_node.name[0] == VARIABLE_PREFIX) {
          traversed_args.push("`${" + this.traverse_node(arg_node) + "}`");
        } else {
          traversed_args.push(`'${arg_node.name}'`);
        }
      } else {
        traversed_args.push("`${" + this.traverse_node(arg_node) + "}`");
      }
    }
    return traversed_args.join(" + ");
  }
  traverse_Literal(node) {
    return `${node.raw}`;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/Common.js
var VAR_OBJECT = `geometry`;
var VAR_ENTITY = `entity`;
var VAR_ENTITIES = `entities`;
var CLASS_CORE_POINT = `corePointClassFactory(${VAR_OBJECT})`;
var CLASS_THREEJS_POINT = "ThreejsPoint";
var FUNC_GET_ENTITIES_ATTRIBUTE = "getEntitiesAttribute";
var FUNC_GET_ENTITY_ATTRIBUTE_VALUE = "getEntityAttributeValue";
var FUNC_GET_ENTITY_ATTRIBUTE_VALUE_FUNC = "getEntityAttributeValueFunc";

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/AttributeRequirementsController.js
var AttributeRequirementsController = class _AttributeRequirementsController {
  constructor() {
  }
  reset() {
    if (this._attributeNames) {
      this._attributeNames.clear();
    }
  }
  assignAttributesLines() {
    if (this._attributeNames) {
      const lines = [];
      for (const attribName of this._attributeNames) {
        lines.push(_AttributeRequirementsController.assignAttributeLine(attribName));
      }
      return lines.join(";\n");
    } else {
      return "";
    }
  }
  assignArraysLines() {
    if (this._attributeNames) {
      const lines = [];
      if (this._attributeNames.size > 0) {
        const objectLine = `const ${VAR_OBJECT} = entities[0].object();`;
        lines.push(objectLine);
      }
      for (const attribName of this._attributeNames) {
        lines.push(_AttributeRequirementsController.assignItemSizeLine(attribName));
        lines.push(_AttributeRequirementsController.assignArrayLine(attribName));
      }
      return lines.join(";\n");
    } else {
      return "";
    }
  }
  attributePresenceCheckLine() {
    if (this._attributeNames) {
      const varNames = [];
      for (const attribName of this._attributeNames) {
        const varName = _AttributeRequirementsController._varAttribute(attribName);
        varNames.push(varName);
      }
      if (varNames.length > 0) {
        return varNames.join(" && ");
      }
    }
    return "true";
  }
  missingAttributesLine() {
    if (this._attributeNames) {
      let lineElements = ["(()=>{", "const missingAttributes = [];"];
      for (const attribName of this._attributeNames) {
        const varName = _AttributeRequirementsController._varAttribute(attribName);
        lineElements.push(`if( !${varName} ) {	missingAttributes.push('${attribName}'); }`);
      }
      lineElements.push("return missingAttributes;", "})");
      return lineElements.join("");
    }
    return "[]";
  }
  add(attribName) {
    this._attributeNames = this._attributeNames || /* @__PURE__ */ new Set();
    this._attributeNames.add(attribName);
  }
  static assignAttributeLine(attribName) {
    const varAttribute = this._varAttribute(attribName);
    return `const ${varAttribute} = ${FUNC_GET_ENTITIES_ATTRIBUTE}(${VAR_ENTITIES},'${attribName}')`;
  }
  static assignItemSizeLine(attribName) {
    const varAttribute = this._varAttribute(attribName);
    const varAttributeSize = this._varAttribSize(attribName);
    return `const ${varAttributeSize} = ${varAttribute}.itemSize`;
  }
  static assignArrayLine(attribName) {
    const varAttribute = this._varAttribute(attribName);
    const varArray = this._varArray(attribName);
    const isIndexedCondition = `(${VAR_ENTITIES}[0] && ${VAR_ENTITIES}[0] instanceof ${CLASS_THREEJS_POINT} && ${CLASS_CORE_POINT}.isAttribIndexed(${VAR_OBJECT}, '${attribName}'))`;
    const indexedArray = `${VAR_ENTITIES}.map(e=>e.indexedAttribValue('${attribName}'))`;
    const nonIndexedArray = `${varAttribute}.array`;
    return `const ${varArray} = ${isIndexedCondition} ? ${indexedArray} : ${nonIndexedArray};`;
  }
  static _varAttribute(attribName) {
    return `attrib_${attribName}`;
  }
  static _varAttribSize(attribName) {
    return `attribSize_${attribName}`;
  }
  static _varArray(attribName) {
    return `array_${attribName}`;
  }
  varAttributeSize(attribName) {
    return _AttributeRequirementsController._varAttribSize(attribName);
  }
  varArray(attribName) {
    return _AttributeRequirementsController._varArray(attribName);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/traversers/FunctionGenerator.js
var QUOTE = "'";
var ARGUMENTS_SEPARATOR = ", ";
var ATTRIBUTE_PREFIX = "@";
var NATIVE_MATH_METHODS = [
  "abs",
  "acos",
  "acosh",
  "asin",
  "asinh",
  "atan",
  "atan2",
  "atanh",
  "ceil",
  "cos",
  "cosh",
  "exp",
  "expm1",
  "floor",
  "log",
  "log1p",
  "log2",
  "log10",
  "max",
  "min",
  "pow",
  "round",
  "sign",
  "sin",
  "sinh",
  "sqrt",
  "tan",
  "tanh"
];
var NATIVE_ES6_MATH_METHODS = ["cbrt", "hypot", "log10", "trunc"];
var NATIVE_MATH_METHODS_RENAMED = {
  math_random: "random"
};
var CORE_MATH_METHODS = ["fit", "fit01", "fract", "deg2rad", "rad2deg", "rand", "clamp"];
var EASING_METHODS = Object.keys(Easing);
var CORE_STRING_METHODS = ["precision"];
var NATIVE_MATH_CONSTANTS = ["E", "LN2", "LN10", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"];
var DIRECT_EXPRESSION_FUNCTIONS = {};
NATIVE_MATH_METHODS.forEach((name) => {
  DIRECT_EXPRESSION_FUNCTIONS[name] = `Math.${name}`;
});
NATIVE_ES6_MATH_METHODS.forEach((name) => {
  DIRECT_EXPRESSION_FUNCTIONS[name] = `Math.${name}`;
});
Object.keys(NATIVE_MATH_METHODS_RENAMED).forEach((name) => {
  const remaped = NATIVE_MATH_METHODS_RENAMED[name];
  DIRECT_EXPRESSION_FUNCTIONS[name] = `Math.${remaped}`;
});
CORE_MATH_METHODS.forEach((name) => {
  DIRECT_EXPRESSION_FUNCTIONS[name] = `Core.Math.${name}`;
});
EASING_METHODS.forEach((name) => {
  DIRECT_EXPRESSION_FUNCTIONS[name] = `Core.Math.Easing.${name}`;
});
CORE_STRING_METHODS.forEach((name) => {
  DIRECT_EXPRESSION_FUNCTIONS[name] = `Core.String.${name}`;
});
var LITERAL_CONSTRUCT = {
  if: LiteralConstructsController.if
};
var GLOBAL_CONSTANTS = {};
NATIVE_MATH_CONSTANTS.forEach((name) => {
  GLOBAL_CONSTANTS[name] = `Math.${name}`;
});
var PROPERTY_OFFSETS = {
  x: 0,
  y: 1,
  z: 2,
  w: 3,
  r: 0,
  g: 1,
  b: 2
};
var Core = {
  Math: CoreMath,
  String: CoreString
};
function getEntitiesAttributes(entities, attribName) {
  const firstEntity = entities[0];
  if (firstEntity instanceof ThreejsPoint) {
    return firstEntity.attribute(attribName);
  } else {
    return entities.map((e) => e.attribValue(attribName, new Vector4()));
  }
}
function getCorePointAttribValue(entity, attribName, array, attributeSize, propertyOffset) {
  return array[entity.index() * attributeSize + propertyOffset];
}
var VECTOR_PROPERTY_NAME_BY_OFFSET = {
  0: "x",
  1: "y",
  2: "z",
  3: "w"
};
var COLOR_PROPERTY_NAME_BY_OFFSET = {
  0: "r",
  1: "g",
  2: "b",
  3: "r"
};
var _target2 = new Vector4();
function getCoreEntityAttribValue(entity, attribName, array, attributeSize, propertyOffset) {
  const value = entity.attribValue(attribName, _target2);
  if (isArray(value)) {
    return value[propertyOffset];
  }
  if (isVector(value)) {
    return value[VECTOR_PROPERTY_NAME_BY_OFFSET[propertyOffset]];
  }
  if (isColor(value)) {
    return value[COLOR_PROPERTY_NAME_BY_OFFSET[propertyOffset]];
  }
  return value;
}
function getCoreEntityAttribValueFunc(entity) {
  if (entity instanceof ThreejsPoint) {
    return getCorePointAttribValue;
  }
  return getCoreEntityAttribValue;
}
var FUNCTION_ARGS_DICT = {
  corePointClassFactory,
  ThreejsPoint,
  Core,
  CoreType,
  [FUNC_GET_ENTITIES_ATTRIBUTE]: getEntitiesAttributes,
  [FUNC_GET_ENTITY_ATTRIBUTE_VALUE_FUNC]: getCoreEntityAttribValueFunc
};
var FUNCTION_ARG_NAMES = Object.keys(FUNCTION_ARGS_DICT);
var FUNCTION_ARGS = FUNCTION_ARG_NAMES.map((argName) => FUNCTION_ARGS_DICT[argName]);
var FunctionGenerator = class extends BaseTraverser {
  // public jsep_dependencies: JsepDependency[] = []
  // public jsep_nodes_by_missing_paths: JsepsByString = {}
  // private string_generator: ExpressionStringGenerator = new ExpressionStringGenerator()
  constructor(param) {
    super(param);
    this.param = param;
    this._entitiesDependent = false;
    this._attribute_requirements_controller = new AttributeRequirementsController();
    this.methods = [];
    this.method_index = -1;
    this.methodDependencies = [];
    this.immutableDependencies = [];
  }
  entitiesDependent() {
    return this._entitiesDependent;
  }
  parseTree(parsedTree) {
    this.reset();
    if (!parsedTree.errorMessage()) {
      try {
        this._attribute_requirements_controller = new AttributeRequirementsController();
        const node = parsedTree.node();
        if (node) {
          const function_main_string = this.traverse_node(node);
          if (function_main_string && !this.isErrored()) {
            this.function_main_string = function_main_string;
          }
        } else {
          console.warn("no parsedTree.node");
        }
      } catch (e) {
        console.warn(`error in expression for param ${this.param.path()}`);
        console.warn(e);
      }
      if (this.function_main_string) {
        try {
          const body = this._functionBody();
          this.function = new Function(
            ...FUNCTION_ARG_NAMES,
            "param",
            "methods",
            "_set_error_from_error",
            `
					try {
						${body}
					} catch(e) {
						_set_error_from_error(e)
						return null;
					}`
          );
        } catch (e) {
          console.warn(e);
          this.setError("cannot generate function");
        }
      } else {
        this.setError("cannot generate function body");
      }
    } else {
      this.setError("cannot parse expression");
    }
  }
  reset() {
    super.reset();
    this.function_main_string = void 0;
    this.methods = [];
    this.method_index = -1;
    this.function = void 0;
    this._entitiesDependent = false;
    this.methodDependencies = [];
    this.immutableDependencies = [];
  }
  _functionBody() {
    const entitiesDependent = this._entitiesDependent;
    if (entitiesDependent) {
      return `
			const ${VAR_ENTITIES} = param.expressionController.entities();
			
			if(${VAR_ENTITIES}){
				return new Promise( async (resolve, reject)=>{
					try {
						const entityCallback = param.expressionController.entityCallback();
						// assign_attributes_lines
						${this._attribute_requirements_controller.assignAttributesLines()}
						// check if attributes are present
						if( ${this._attribute_requirements_controller.attributePresenceCheckLine()} ){
							// assign function
							const ${FUNC_GET_ENTITY_ATTRIBUTE_VALUE} = ${FUNC_GET_ENTITY_ATTRIBUTE_VALUE_FUNC}(entities[0]);
							// assign_arrays_lines
							${this._attribute_requirements_controller.assignArraysLines()}
							for(const ${VAR_ENTITY} of ${VAR_ENTITIES}){
								result = ${this.function_main_string};
								entityCallback(${VAR_ENTITY}, result);
							}
							resolve()
						} else {
							const missingAttributes = ${this._attribute_requirements_controller.missingAttributesLine()}().join(', ');
							const error = new Error('attribute ' + missingAttributes + ' not found')
							_set_error_from_error(error)
							reject(error)
						}
					}catch(e){
						_set_error_from_error(e)
						reject(e)
					}
				})
			}
			return []`;
    } else {
      return `
			return new Promise( async (resolve, reject)=>{
				try {
					const value = ${this.function_main_string}
					resolve(value)
				} catch(e) {
					_set_error_from_error(e)
					reject()
				}
			})
			`;
    }
  }
  evalAllowed() {
    return this.function != null;
  }
  evalFunction() {
    if (this.function) {
      this.clearError();
      const result = this.function(...FUNCTION_ARGS, this.param, this.methods, this._set_error_from_error_bound);
      return result;
    }
  }
  //
  //
  // TRAVERSE METHODS
  //
  //
  traverse_CallExpression(node) {
    const methodArguments = node.arguments.map((arg) => {
      return this.traverse_node(arg);
    });
    const callee = node.callee;
    const method_name = callee.name;
    if (method_name) {
      const literal_contruct = LITERAL_CONSTRUCT[method_name];
      if (literal_contruct) {
        return literal_contruct(methodArguments);
      }
      const arguments_joined = `${methodArguments.join(ARGUMENTS_SEPARATOR)}`;
      const direct_function_name = DIRECT_EXPRESSION_FUNCTIONS[method_name];
      if (direct_function_name) {
        return `${direct_function_name}(${arguments_joined})`;
      }
      const expressionRegister = Poly.expressionsRegister;
      const indirect_method = expressionRegister.getMethod(method_name);
      if (indirect_method) {
        const pathNode = node.arguments[0];
        const functionString = `return ${methodArguments[0]}`;
        let pathArgumentFunction;
        let pathArgument;
        try {
          pathArgumentFunction = new Function(functionString);
          pathArgument = pathArgumentFunction();
        } catch {
        }
        this._createMethodAndDependencies(method_name, pathArgument, pathNode);
        return `(await methods[${this.method_index}].processArguments([${arguments_joined}]))`;
      } else {
        const available_methods = expressionRegister.availableMethods().join(", ");
        const message = `method not found (${method_name}), available methods are: ${available_methods}`;
        Poly.warn(message);
      }
    }
    this.setError(`unknown method: ${method_name}`);
  }
  traverse_BinaryExpression(node) {
    return `(${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)})`;
  }
  // protected override traverse_LogicalExpression(node: jsep.LogicalExpression): string {
  // 	// || or &&
  // 	// if(node.right.type == 'Identifier'){
  // 	// 	this.set_error(`cannot have identifier after ${node.operator}`)
  // 	// 	return ""
  // 	// }
  // 	return `(${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)})`;
  // }
  // protected override traverse_MemberExpression(node: jsep.MemberExpression): string {
  // 	return `${this.traverse_node(node.object)}.${this.traverse_node(node.property)}`;
  // }
  traverse_UnaryExpression(node) {
    if (node.operator === ATTRIBUTE_PREFIX) {
      this._entitiesDependent = true;
      let argument = node.argument;
      let attributeName;
      let property;
      switch (argument.type) {
        case "Identifier": {
          const argument_identifier = argument;
          attributeName = argument_identifier.name;
          break;
        }
        case "MemberExpression": {
          const argument_member_expression = argument;
          const attrib_node = argument_member_expression.object;
          const property_node = argument_member_expression.property;
          attributeName = attrib_node.name;
          property = property_node.name;
          break;
        }
      }
      if (attributeName) {
        attributeName = CoreAttribute.remapName(attributeName);
        if (attributeName == Attribute.POINT_INDEX || attributeName == Attribute.OBJECT_INDEX) {
          return `((${VAR_ENTITY} != null) ? ${VAR_ENTITY}.index() : 0)`;
        } else {
          const var_attribute_size = this._attribute_requirements_controller.varAttributeSize(attributeName);
          const var_array = this._attribute_requirements_controller.varArray(attributeName);
          this._attribute_requirements_controller.add(attributeName);
          let propertyOffset = property ? PROPERTY_OFFSETS[property] : 0;
          if (propertyOffset == null) {
            propertyOffset = 0;
          }
          return `${FUNC_GET_ENTITY_ATTRIBUTE_VALUE}(${VAR_ENTITY}, '${attributeName}', ${var_array}, ${var_attribute_size}, ${propertyOffset})`;
        }
      } else {
        console.warn("attribute not found");
        return "";
      }
    } else {
      return `${node.operator}${this.traverse_node(node.argument)}`;
    }
  }
  // protected override traverse_Literal(node: jsep.Literal): string {
  // 	return `${node.raw}`; // 5 or 'string' (raw will include quotes)
  // }
  traverse_Identifier(node) {
    const identifier_first_char = node.name[0];
    if (identifier_first_char == VARIABLE_PREFIX) {
      const identifier_name_without_dollar_sign = node.name.substring(1);
      const direct_constant_name = GLOBAL_CONSTANTS[identifier_name_without_dollar_sign];
      if (direct_constant_name) {
        return direct_constant_name;
      }
      const method_name = `traverse_Identifier_${identifier_name_without_dollar_sign}`;
      const method = this[method_name];
      if (method) {
        return this[method_name]();
      } else {
        this.setError(`identifier unknown: ${node.name}`);
      }
    } else {
      return node.name;
    }
  }
  //
  //
  // Identifier methods (called from Identifier_body)
  //
  //
  traverse_Identifier_F() {
    this.immutableDependencies.push(this.param.scene().timeController.graphNode);
    return `param.scene().timeController.frame()`;
  }
  // protected traverse_Identifier_FPS(): string {
  // 	this.immutable_dependencies.push(this.param.scene().timeController.graphNode);
  // 	return `param.scene().timeController.fps`;
  // }
  traverse_Identifier_T() {
    this.immutableDependencies.push(this.param.scene().timeController.graphNode);
    return `param.scene().timeController.time()`;
  }
  traverse_Identifier_OS() {
    const nameNode = this.param.node.nameController.graphNode();
    this.param.addGraphInput(nameNode);
    return `param.node.name()`;
  }
  traverse_Identifier_CH() {
    return `${QUOTE}${this.param.name()}${QUOTE}`;
  }
  traverse_Identifier_CEX() {
    return this._method_centroid("x");
  }
  traverse_Identifier_CEY() {
    return this._method_centroid("y");
  }
  traverse_Identifier_CEZ() {
    return this._method_centroid("z");
  }
  // TODO:
  // '$OS': '_eval_identifier_as_node_name',
  // '$BBX': '_eval_identifier_as_bounding_box_relative',
  _method_centroid(component) {
    const method_arguments = [0, `${QUOTE}${component}${QUOTE}`];
    const arguments_joined = method_arguments.join(ARGUMENTS_SEPARATOR);
    this._createMethodAndDependencies("centroid", 0);
    return `(await methods[${this.method_index}].processArguments([${arguments_joined}]))`;
  }
  //
  //
  // Methods dependencies
  //
  //
  _createMethodAndDependencies(methodName, pathArgument, pathNode) {
    const expressionRegister = Poly.expressionsRegister;
    const methodConstructor = expressionRegister.getMethod(methodName);
    if (!methodConstructor) {
      const availableMethods = expressionRegister.availableMethods();
      const message = `method not found (${methodName}), available methods are: ${availableMethods.join(", ")}`;
      this.setError(message);
      Poly.warn(message);
      return;
    }
    const method = new methodConstructor(this.param);
    this.method_index += 1;
    this.methods[this.method_index] = method;
    const methodDependency = method.findDependency({ indexOrPath: pathArgument });
    if (methodDependency) {
      if (pathNode) {
        methodDependency.set_jsep_node(pathNode);
      }
      this.methodDependencies.push(methodDependency);
    } else {
      if (pathNode && CoreType.isString(pathArgument)) {
        this.param.scene().missingExpressionReferencesController.register(this.param, pathArgument, pathNode);
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/traversers/ExpressionStringGenerator.js
var ARGUMENTS_SEPARATOR2 = ", ";
var ExpressionStringGenerator = class extends BaseTraverser {
  constructor(param) {
    super(param);
    this.param = param;
  }
  parseTree(parsedTree) {
    const node = parsedTree.node();
    if (parsedTree.errorMessage() == null && node) {
      try {
        return this.traverse_node(node);
      } catch (e) {
        this.setError("could not traverse tree");
      }
    } else {
      this.setError("cannot parse tree");
    }
  }
  traverse_CallExpression(node) {
    const methodArguments = node.arguments.map((arg) => {
      return this.traverse_node(arg);
    });
    const argumentsJoined = `${methodArguments.join(ARGUMENTS_SEPARATOR2)}`;
    const methodName = node.callee.name;
    return `${methodName}(${argumentsJoined})`;
  }
  traverse_UnaryExpression(node) {
    return `${node.operator}${this.traverse_node(node.argument)}`;
  }
  traverse_Identifier(node) {
    return `${node.name}`;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/DependenciesController.js
var DependenciesController = class {
  constructor(param) {
    this.param = param;
    this._cyclicGraphDetected = false;
    this.methodDependencies = [];
  }
  setError(message) {
    this._errorMessage = this._errorMessage || message;
  }
  errorMessage() {
    return this._errorMessage;
  }
  reset() {
    this.param.graphDisconnectPredecessors();
    this.methodDependencies.forEach((methodDependency) => {
      methodDependency.reset();
    });
    this.methodDependencies = [];
  }
  update(functionGenerator) {
    this._cyclicGraphDetected = false;
    this._connectImmutableDependencies(functionGenerator);
    this.methodDependencies = functionGenerator.methodDependencies;
    this._handleMethodDependencies();
    this._listenForNameChanges();
  }
  _connectImmutableDependencies(functionGenerator) {
    const dependendies = functionGenerator.immutableDependencies;
    for (const dependency of dependendies) {
      if (this._cyclicGraphDetected == false) {
        if (this.param.addGraphInput(dependency) == false) {
          this._cyclicGraphDetected = true;
          this.setError("cannot create expression, infinite graph detected");
          this.reset();
          return;
        }
      }
    }
  }
  _handleMethodDependencies() {
    this.methodDependencies.forEach((methodDependency) => {
      if (this._cyclicGraphDetected == false) {
        this._handleMethodDependency(methodDependency);
      }
    });
  }
  _handleMethodDependency(method_dependency) {
    const node_simple = method_dependency.resolved_graph_node;
    if (node_simple) {
      if (!this.param.addGraphInput(node_simple)) {
        this._cyclicGraphDetected = true;
        this.setError("cannot create expression, infinite graph detected");
        this.reset();
        return;
      }
    }
  }
  _listenForNameChanges() {
    this.methodDependencies.forEach((methodDependency) => {
      methodDependency.listen_for_name_changes();
    });
  }
  // private connect_missing_paths(function_generator: FunctionGenerator){
  // 	const jsep_nodes_by_missing_paths = function_generator.jsep_nodes_by_missing_paths
  // 	const missing_paths = Object.keys(jsep_nodes_by_missing_paths)
  // 	missing_paths.forEach((missing_path)=>{
  // 		const fullPath = CoreWalker.make_absolute(this.param.node(), missing_path)
  // 		const jsep_nodes = jsep_nodes_by_missing_paths[missing_path]
  // 		jsep_nodes.forEach(jsep_node=>{
  // 			const missing_expression_reference = this.references_controller.register(this.param, jsep_node, fullPath)
  // 			this.missing_expression_references_by_id[missing_expression_reference.id] = missing_expression_reference
  // 		})
  // 	})
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/ExpressionManager.js
var ExpressionManager = class {
  constructor(param) {
    this.param = param;
    this._parseStarted = false;
    this.parsedTree = new ParsedTree(this.param);
    this._functionGenerator = new FunctionGenerator(this.param);
    this.dependenciesController = new DependenciesController(this.param);
  }
  generatedFunctionEntitiesDependent() {
    return this._functionGenerator.entitiesDependent();
  }
  parseExpression(expression) {
    if (this._parseStarted) {
      throw new Error(`parse in progress for param ${this.param.path()}`);
    }
    this._parseStarted = true;
    this.parsedTree = this.parsedTree || new ParsedTree(this.param);
    this.reset();
    if (this.param.expressionParsedAsString()) {
      this.parsedTree.parseExpressionForStringParam(expression);
    } else {
      this.parsedTree.parseExpression(expression);
    }
    this._functionGenerator.parseTree(this.parsedTree);
    if (this._functionGenerator.errorMessage() == null) {
      this.dependenciesController.update(this._functionGenerator);
      const errorMessage = this.dependenciesController.errorMessage();
      if (errorMessage) {
        this.param.states.error.set(errorMessage);
      } else {
        this._parseStarted = false;
      }
    }
  }
  async computeFunction() {
    if (this._computeAllowed()) {
      try {
        const newValue = await this._functionGenerator.evalFunction();
        return newValue;
      } catch (e) {
        Poly.error("error while evaluating expression", e);
      }
    } else {
      Poly.error("compute not allowed");
    }
  }
  reset() {
    this._parseStarted = false;
    this.dependenciesController.reset();
    this._functionGenerator.reset();
  }
  isErrored() {
    return this._functionGenerator.isErrored();
  }
  errorMessage() {
    return this._functionGenerator.errorMessage();
  }
  _computeAllowed() {
    return this._functionGenerator.evalAllowed();
  }
  updateFromMethodDependencyNameChange() {
    this._expressionStringGenerator = this._expressionStringGenerator || new ExpressionStringGenerator(this.param);
    const newExpressionString = this._expressionStringGenerator.parseTree(this.parsedTree);
    if (newExpressionString) {
      this.param.set(newExpressionString);
    } else {
      console.warn("failed to regenerate expression");
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/utils/ExpressionController.js
var ExpressionController = class {
  // private _reset_bound = this.reset.bind(this);
  constructor(param) {
    this.param = param;
  }
  // remove_dirty_hook() {
  // 	// this.param.dirtyController.removePostDirtyHook('expression_controller_reset');
  // }
  dispose() {
    this.param.scene().expressionsController.deregisterParam(this.param);
    this._resetMethodDependencies();
    this._manager = void 0;
  }
  _resetMethodDependencies() {
    var _a, _b;
    (_a = this._methodDependenciesByGraphNodeId) == null ? void 0 : _a.forEach((methodDependency) => {
      methodDependency.dispose();
    });
    (_b = this._methodDependenciesByGraphNodeId) == null ? void 0 : _b.clear();
  }
  registerMethodDependency(methodDependency) {
    this._methodDependenciesByGraphNodeId = this._methodDependenciesByGraphNodeId || /* @__PURE__ */ new Map();
    this._methodDependenciesByGraphNodeId.set(methodDependency.graphNodeId(), methodDependency);
  }
  active() {
    return this._expression != null;
  }
  expression() {
    return this._expression;
  }
  isErrored() {
    if (this._manager) {
      return this._manager.isErrored();
    }
    return false;
  }
  errorMessage() {
    if (this._manager) {
      return this._manager.errorMessage();
    }
    return null;
  }
  entitiesDependent() {
    var _a;
    const managerEntitiesDependent = ((_a = this._manager) == null ? void 0 : _a.generatedFunctionEntitiesDependent()) || false;
    return this.param.options.isExpressionForEntities() && managerEntitiesDependent;
  }
  // private reset() {
  // 	this._manager?.clear_error();
  // }
  setExpression(expression, setDirty = true) {
    var _a;
    if (this.param.disposed()) {
      this._resetMethodDependencies();
      this._expression = void 0;
      return;
    }
    this.param.scene().missingExpressionReferencesController.deregisterParam(this.param);
    this.param.scene().expressionsController.deregisterParam(this.param);
    if (this._expression != expression) {
      this._resetMethodDependencies();
      this._expression = expression;
      if (this._expression) {
        this._manager = this._manager || new ExpressionManager(this.param);
        this._manager.parseExpression(this._expression);
      } else {
        (_a = this._manager) == null ? void 0 : _a.reset();
      }
      if (setDirty) {
        this.param.setDirty();
      }
    }
  }
  updateFromMethodDependencyNameChange() {
    if (this._manager && this.active()) {
      this._manager.updateFromMethodDependencyNameChange();
    }
  }
  computeExpression() {
    if (this._manager && this.active()) {
      return this._manager.computeFunction();
    }
  }
  async computeExpressionForEntities(entities, callback) {
    var _a;
    this._setEntities(entities, callback);
    await this.computeExpression();
    const errorMessage = (_a = this._manager) == null ? void 0 : _a.errorMessage();
    if (errorMessage) {
      this.param.node.states.error.set(`expression evaluation error: ${errorMessage}`);
    }
    this._resetEntities();
  }
  computeExpressionForPoints(entities, callback) {
    return this.computeExpressionForEntities(entities, callback);
  }
  computeExpressionForVertices(entities, callback) {
    return this.computeExpressionForEntities(entities, callback);
  }
  computeExpressionForPrimitives(entities, callback) {
    return this.computeExpressionForEntities(entities, callback);
  }
  computeExpressionForObjects(entities, callback) {
    return this.computeExpressionForEntities(entities, callback);
  }
  computeExpressionForCoreGroup(entity, callback) {
    return this.computeExpressionForEntities([entity], callback);
  }
  entities() {
    return this._entities;
  }
  entityCallback() {
    return this._entityCallback;
  }
  _setEntities(entities, callback) {
    this._entities = entities;
    this._entityCallback = callback;
  }
  _resetEntities() {
    this._entities = void 0;
    this._entityCallback = void 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/_Numeric.js
var TypedNumericParam = class extends TypedParam {
  isNumeric() {
    return true;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  _prefilterInvalidRawInput(raw_input) {
    if (CoreType.isArray(raw_input)) {
      return raw_input[0];
    } else {
      return raw_input;
    }
  }
  processRawInput() {
    const converted = this.convert(this._raw_input);
    if (converted != null) {
      if (this._expression_controller) {
        this._expression_controller.setExpression(void 0, false);
        this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
      }
      const wasErrored = this.states.error.active();
      this.states.error.clear();
      if (converted != this._value || wasErrored) {
        this._updateValue(converted);
        this.setSuccessorsDirty(this);
      }
    } else {
      if (CoreType.isString(this._raw_input)) {
        this.states.error.clear();
        this._expression_controller = this._expression_controller || new ExpressionController(this);
        if (this._raw_input != this._expression_controller.expression()) {
          this._expression_controller.setExpression(this._raw_input);
          this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
        }
      } else {
        this.states.error.set(`param input is invalid (${this.path()})`);
      }
    }
  }
  async processComputation() {
    var _a;
    if (((_a = this.expressionController) == null ? void 0 : _a.active()) && !this.expressionController.entitiesDependent()) {
      const expression_result = await this.expressionController.computeExpression();
      if (this.expressionController.isErrored()) {
        this.states.error.set(
          `expression error: "${this.expressionController.expression()}" (${this.expressionController.errorMessage()})`
        );
      } else {
        const converted = this.convert(expression_result);
        if (converted != null) {
          if (this.states.error.active()) {
            this.states.error.clear();
          }
          this._updateValue(converted);
        } else {
          this.states.error.set(
            `expression returns an invalid type (${expression_result}) (${this.expressionController.expression()})`
          );
        }
      }
    }
  }
  _updateValue(new_value) {
    this._value = new_value;
    const parentParam = this.parentParam();
    if (parentParam) {
      parentParam.setValueFromComponents();
    }
    this.options.executeCallback();
    this.emitController.emit(ParamEvent.VALUE_UPDATED);
    this.removeDirtyState();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/_BaseString.js
var TypedStringParam = class extends TypedParam {
  expressionParsedAsString() {
    return true;
  }
  processRawInput() {
    if (stringValueElements(this._raw_input).length >= 3) {
      this._expression_controller = this._expression_controller || new ExpressionController(this);
      if (this._raw_input != this._expression_controller.expression()) {
        this.states.error.clear();
        this._expression_controller.setExpression(this._raw_input, false);
        this.setDirty();
        this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
      }
    } else {
      this.processRawInputWithoutExpression();
    }
  }
  async processComputation() {
    var _a;
    if (((_a = this.expressionController) == null ? void 0 : _a.active()) && !this.expressionController.entitiesDependent()) {
      const expressionResult = await this.expressionController.computeExpression();
      if (this.expressionController.isErrored()) {
        this.states.error.set(
          `expression error: "${this.expressionController.expression()}" (${this.expressionController.errorMessage()})`
        );
      } else {
        const converted = this.convert(expressionResult);
        if (converted != null) {
          this.states.error.clear();
          this._assignValue(converted);
          this.emitController.emit(ParamEvent.VALUE_UPDATED);
          this.options.executeCallback();
        } else {
          this.states.error.set(`expression returns an invalid type (${expressionResult})`);
        }
        this.removeDirtyState();
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/_BasePath.js
var TypedPathParam = class extends TypedStringParam {
  constructor() {
    super(...arguments);
    this.decomposedPath = new DecomposedPath();
  }
  dispose() {
    this.scene().referencesController.resetReferenceFromParam(this);
    super.dispose();
  }
  _handleReferences(node, path) {
    if (path == "") {
      return;
    }
    this.scene().referencesController.setNamedNodesFromParam(this);
    if (node) {
      this.scene().referencesController.setReferenceFromParam(this, node);
      this.scene().missingExpressionReferencesController.deregisterParam(this);
    } else {
      this.scene().missingExpressionReferencesController.register(this, path);
    }
  }
  async processComputation() {
    var _a;
    if (((_a = this.expressionController) == null ? void 0 : _a.active()) && !this.expressionController.entitiesDependent()) {
      await super.processComputation();
    } else {
      this._findTarget();
    }
  }
  processRawInputWithoutExpression() {
    const wasErrored = this.states.error.active();
    if (this._value.path() != this._raw_input || this._expression_controller || wasErrored) {
      this._setValuePathAndFindTarget(this._raw_input, true);
      this.states.error.clear();
      this.emitController.emit(ParamEvent.VALUE_UPDATED);
      this.options.executeCallback();
      if (this._expression_controller) {
        this._expression_controller.setExpression(void 0, false);
        this._expression_controller = void 0;
        this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
      }
    }
  }
  _setValuePathAndFindTarget(path, setDirty) {
    this._value.setPath(path);
    this._findTarget();
    if (setDirty) {
      this.setDirty();
    }
    this.emitController.emit(ParamEvent.VALUE_UPDATED);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/NodePath.js
var tmpConvertedValue = new TypedNodePathParamValue();
var NodePathParam = class extends TypedPathParam {
  static type() {
    return ParamType.NODE_PATH;
  }
  _initializeParam() {
    this._value = new TypedNodePathParamValue();
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return `${this._raw_input}`;
  }
  valueSerialized() {
    return `${this.value}`;
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  setNode(node, options) {
    if ((options == null ? void 0 : options.relative) == true) {
      const path = CoreWalker.relativePath(this.node, node);
      this.set(path);
    } else {
      this.set(node.path());
    }
  }
  _assignValue(value) {
    const path = CoreType.isString(value) ? value : value.path();
    if (this._value.path() != path) {
      this._setValuePathAndFindTarget(path, false);
    }
  }
  convert(rawVal) {
    if (CoreType.isString(rawVal)) {
      tmpConvertedValue.setPath(rawVal);
      return tmpConvertedValue;
    } else {
      return null;
    }
  }
  // protected override async processComputation() {
  // 	this._findTarget();
  // }
  _findTarget() {
    if (!this.node) {
      return;
    }
    const path = this._value.path();
    let node = null;
    const pathNonEmpty = path != null && path !== "";
    this.scene().referencesController.resetReferenceFromParam(this);
    this.decomposedPath.reset();
    if (pathNonEmpty) {
      node = CoreWalker.findNode(this.node, path, this.decomposedPath);
    }
    const currentFoundEntity = this._value.node();
    const newlyFoundEntity = node;
    if (newlyFoundEntity) {
      if (newlyFoundEntity.graphNodeId() == this.node.graphNodeId()) {
        this.states.error.set(`param cannot refer to its own node`);
        return;
      }
    }
    this._handleReferences(node, path);
    if ((currentFoundEntity == null ? void 0 : currentFoundEntity.graphNodeId()) !== (newlyFoundEntity == null ? void 0 : newlyFoundEntity.graphNodeId())) {
      const dependentOnFoundNode = this.options.dependentOnFoundNode();
      const previouslyFoundNode = this._value.node();
      if (previouslyFoundNode) {
        if (dependentOnFoundNode) {
          this.removeGraphInput(previouslyFoundNode);
        } else {
        }
      }
      if (node) {
        this._assignFoundNode(node);
      } else {
        this._value.setNode(null);
      }
      this.options.executeCallback();
    }
    if (pathNonEmpty && !node && this.scene().loadingController.loaded()) {
      if (pathNonEmpty) {
        this.states.error.set(`no node found at path '${path}'`);
      }
    }
    this.removeDirtyState();
  }
  _assignFoundNode(node) {
    const dependentOnFoundNode = this.options.dependentOnFoundNode();
    if (this._isNodeExpectedContext(node)) {
      if (this._isNodeExpectedType(node)) {
        this.states.error.clear();
        this._value.setNode(node);
        if (dependentOnFoundNode) {
          this.addGraphInput(node);
        }
      } else {
        this.states.error.set(
          `node type is ${node.type()} but the params expects one of ${(this._expectedNodeTypes() || []).join(
            ", "
          )}`
        );
      }
    } else {
      this.states.error.set(
        `node context is ${node.context()} but the params expects a ${this._expectedContext()}`
      );
    }
  }
  _expectedContext() {
    return this.options.nodeSelectionContext();
  }
  _isNodeExpectedContext(node) {
    const expectedContext = this._expectedContext();
    if (expectedContext == null) {
      return true;
    }
    return expectedContext == node.context();
  }
  _expectedNodeTypes() {
    return this.options.nodeSelectionTypes();
  }
  _isNodeExpectedType(node) {
    const expected_types = this._expectedNodeTypes();
    if (expected_types == null) {
      return true;
    }
    return expected_types == null ? void 0 : expected_types.includes(node.type());
  }
  notifyPathRebuildRequired(node) {
    this.decomposedPath.updateFromNameChange(node);
    const newPath = this.decomposedPath.toPath();
    this.set(newPath);
  }
  notifyTargetParamOwnerParamsUpdated(node) {
    this.setDirty();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/ParamPath.js
var tmpConvertedValue2 = new TypedParamPathParamValue();
var ParamPathParam = class extends TypedPathParam {
  constructor() {
    super(...arguments);
    this._onResolvedParamDisposeBound = this._onResolvedParamDispose.bind(this);
  }
  static type() {
    return ParamType.PARAM_PATH;
  }
  _initializeParam() {
    this._value = new TypedParamPathParamValue();
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return `${this._raw_input}`;
  }
  valueSerialized() {
    return `${this.value}`;
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  setParam(param) {
    this.set(param.path());
  }
  _assignValue(value) {
    const path = CoreType.isString(value) ? value : value.path();
    if (this._value.path() != path) {
      this._setValuePathAndFindTarget(path, false);
    }
  }
  convert(rawVal) {
    if (CoreType.isString(rawVal)) {
      tmpConvertedValue2.setPath(rawVal);
      return tmpConvertedValue2;
    } else {
      return null;
    }
  }
  // protected override async processComputation() {
  // 	this.findTarget();
  // }
  _findTarget() {
    if (!this.node) {
      return;
    }
    const path = this._value.path();
    let param = null;
    const pathNonEmpty = path != null && path !== "";
    this.scene().referencesController.resetReferenceFromParam(this);
    this.decomposedPath.reset();
    if (pathNonEmpty) {
      param = CoreWalker.findParam(this.node, path, this.decomposedPath);
    }
    const currentFoundEntity = this._value.param();
    const newlyFoundEntity = param;
    if (newlyFoundEntity) {
      if (newlyFoundEntity.graphNodeId() == this.graphNodeId()) {
        this.states.error.set(`param cannot refer to itself`);
        return;
      }
    }
    this._handleReferences(param, path);
    if ((currentFoundEntity == null ? void 0 : currentFoundEntity.graphNodeId()) !== (newlyFoundEntity == null ? void 0 : newlyFoundEntity.graphNodeId())) {
      const dependentOnFoundParam = this.options.dependentOnFoundParam();
      const previouslyFoundParam = this._value.param();
      if (previouslyFoundParam) {
        if (dependentOnFoundParam) {
          this.removeGraphInput(previouslyFoundParam);
        } else {
        }
        previouslyFoundParam.deregisterOnDispose(this._onResolvedParamDisposeBound);
      }
      if (param) {
        this._assignFoundParam(param);
      } else {
        this._value.setParam(null);
      }
      this.options.executeCallback();
    }
    this.removeDirtyState();
  }
  _assignFoundParam(param) {
    const dependentOnFoundParam = this.options.dependentOnFoundParam();
    this._value.setParam(param);
    if (dependentOnFoundParam) {
      this.addGraphInput(param);
    }
    param.onDispose(this._onResolvedParamDisposeBound);
  }
  // private _expected_context() {
  // 	return this.options.node_selection_context;
  // }
  // private _is_node_expected_context(node: BaseNodeType) {
  // 	const expected_context = this._expected_context();
  // 	if (expected_context == null) {
  // 		return true;
  // 	}
  // 	const node_context = node.parent?.childrenController?.context;
  // 	return expected_context == node_context;
  // }
  // private _expected_node_types() {
  // 	return this.options.node_selection_types;
  // }
  // private _is_node_expected_type(node: BaseNodeType) {
  // 	const expected_types = this._expected_node_types();
  // 	if (expected_types == null) {
  // 		return true;
  // 	}
  // 	return expected_types?.includes(node.type);
  // }
  notifyPathRebuildRequired(param) {
    this.decomposedPath.updateFromNameChange(param);
    const new_path = this.decomposedPath.toPath();
    this.set(new_path);
  }
  notifyTargetParamOwnerParamsUpdated(node) {
    this.setDirty();
  }
  async _onResolvedParamDispose() {
    this.setDirty();
    await this.compute();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/String.js
var StringParam = class extends TypedStringParam {
  static type() {
    return ParamType.STRING;
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  _cloneRawInput(raw_input) {
    return `${raw_input}`;
  }
  rawInputSerialized() {
    return `${this._raw_input}`;
  }
  valueSerialized() {
    return `${this.value}`;
  }
  _copyValue(param) {
    this.set(param.value);
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  convert(rawVal) {
    if (CoreType.isString(rawVal)) {
      return rawVal;
    }
    return `${rawVal}`;
  }
  rawInput() {
    return this._raw_input;
  }
  _assignValue(value) {
    this._value = value;
  }
  async processRawInputWithoutExpression() {
    const wasErrored = this.states.error.active();
    if (this._raw_input != this._value || this._expression_controller || wasErrored) {
      this._assignValue(this._raw_input);
      this.states.error.clear();
      this.removeDirtyState();
      this.setSuccessorsDirty(this);
      this.emitController.emit(ParamEvent.VALUE_UPDATED);
      this.options.executeCallback();
      if (this._expression_controller) {
        this._expression_controller.setExpression(void 0, false);
        this._expression_controller = void 0;
        this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Float.js
var FloatParam = class _FloatParam extends TypedNumericParam {
  static type() {
    return ParamType.FLOAT;
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return this._raw_input;
  }
  valueSerialized() {
    return this.value;
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  _prefilterInvalidRawInput(raw_input) {
    if (CoreType.isArray(raw_input)) {
      return raw_input[0];
    }
    if (CoreType.isString(raw_input) && CoreString.isNumber(raw_input)) {
      const num = parseFloat(raw_input);
      if (num != null) {
        const converted = this.convert(num);
        if (converted != null) {
          return converted;
        }
      }
    }
    if (CoreType.isNumber(raw_input)) {
      const converted = this.convert(raw_input);
      if (converted != null) {
        return converted;
      }
    }
    return raw_input;
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  static convert(raw_val) {
    if (CoreType.isNumber(raw_val)) {
      return raw_val;
    } else {
      if (CoreType.isBoolean(raw_val)) {
        return raw_val ? 1 : 0;
      } else {
        if (CoreString.isNumber(raw_val)) {
          const parsed = parseFloat(raw_val);
          if (CoreType.isNumber(parsed)) {
            return parsed;
          }
        }
      }
      return null;
    }
  }
  convert(raw_val) {
    const result = _FloatParam.convert(raw_val);
    if (result != null) {
      return this.options.ensureInRange(result);
    } else {
      return result;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/_Multiple.js
var TypedMultipleParam = class extends TypedParam {
  constructor() {
    super(...arguments);
    this._components_contructor = FloatParam;
    this._componentsCount = 0;
  }
  get components() {
    return this._components;
  }
  isNumeric() {
    return true;
  }
  isDefault() {
    for (const c of this.components) {
      if (!c.isDefault()) {
        return false;
      }
    }
    return true;
  }
  rawInput() {
    return this._components.map((c) => c.rawInput());
  }
  rawInputSerialized() {
    return this._components.map((c) => c.rawInputSerialized());
  }
  _copyValue(param) {
    for (let i = 0; i < this.components.length; i++) {
      const component = this.components[i];
      const src_component = param.components[i];
      component.copyValue(src_component);
    }
  }
  initComponents() {
    var _a;
    if (this._components != null) {
      return;
    }
    let index = 0;
    this._components = new Array(this.componentNames().length);
    for (const componentName of this.componentNames()) {
      const component = new this._components_contructor(this.scene(), this.node, {
        serializerClass: (_a = this._serializer) == null ? void 0 : _a.constructor
      });
      let default_val;
      if (CoreType.isArray(this._default_value)) {
        default_val = this._default_value[index];
      } else {
        default_val = this._default_value[componentName];
      }
      component.options.copy(this.options);
      component.setInitValue(default_val);
      component.setName(`${this.name()}${componentName}`);
      component.set_parent_param(this);
      this._components[index] = component;
      index++;
    }
    this._componentsCount = this._components.length;
  }
  async processComputation() {
    await this.computeComponents();
    this.setValueFromComponents();
  }
  // set_raw_input_from_components() {}
  hasExpression() {
    var _a;
    for (const c of this.components) {
      if ((_a = c.expressionController) == null ? void 0 : _a.active()) {
        return true;
      }
    }
    return false;
  }
  // private _promises:Promise<void>[] = [];
  async computeComponents() {
    const components = this.components;
    for (const c of components) {
      if (c.isDirty()) {
        await c.compute();
      }
    }
    this.removeDirtyState();
  }
  _prefilterInvalidRawInput(raw_input) {
    if (!CoreType.isArray(raw_input)) {
      const numberOrString = raw_input;
      const raw_input_wrapped_in_array = this.componentNames().map(() => numberOrString);
      return raw_input_wrapped_in_array;
    } else {
      return raw_input;
    }
  }
  processRawInput() {
    const cooker = this.scene().cooker;
    cooker.block();
    const components = this.components;
    for (const c of components) {
      c.emitController.blockParentEmit();
    }
    const value = this._raw_input;
    let prevValue = 0;
    if (CoreType.isArray(value)) {
      for (let i = 0; i < this._componentsCount; i++) {
        let componentValue = value[i];
        if (componentValue == null) {
          componentValue = prevValue;
        }
        components[i].set(componentValue);
        prevValue = componentValue;
      }
    } else {
      for (let i = 0; i < this._componentsCount; i++) {
        const componentName = this.componentNames()[i];
        let componentValue = value[componentName];
        if (componentValue == null) {
          componentValue = prevValue;
        }
        components[i].set(componentValue);
        prevValue = componentValue;
      }
    }
    cooker.unblock();
    for (const component of this.components) {
      component.emitController.unblockParentEmit();
    }
    this.emitController.emit(ParamEvent.VALUE_UPDATED);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/UIData.js
var UIData = class {
  constructor(node, x = 0, y = 0) {
    this.node = node;
    this._position = new Vector2();
    this._width = 50;
    this._color = new Color(0.75, 0.75, 0.75);
    this._layoutVertical = true;
    this._json = {
      x: 0,
      y: 0
    };
    this._position.x = x;
    this._position.y = y;
  }
  dispose() {
    this._comment = void 0;
  }
  setComment(comment) {
    this._comment = comment;
    this.node.emit(NodeEvent.UI_DATA_COMMENT_UPDATED);
  }
  comment() {
    return this._comment;
  }
  setColor(color) {
    this._color = color;
  }
  color() {
    return this._color;
  }
  // setIcon(icon: string) {
  // 	this._icon = icon;
  // }
  // icon() {
  // 	return this._icon;
  // }
  setLayoutHorizontal() {
    this._layoutVertical = false;
  }
  isLayoutVertical() {
    return this._layoutVertical;
  }
  copy(ui_data) {
    this._position.copy(ui_data.position());
    this._color.copy(ui_data.color());
  }
  position() {
    return this._position;
  }
  setPosition(newPosition, y = 0) {
    if (CoreType.isNumber(newPosition)) {
      const x = newPosition;
      this._position.set(x, y);
    } else {
      this._position.copy(newPosition);
    }
    this.node.emit(NodeEvent.UI_DATA_POSITION_UPDATED);
    return this;
  }
  translate(offset, snap = false) {
    this._position.add(offset);
    if (snap) {
      this._position.x = Math.round(this._position.x);
      this._position.y = Math.round(this._position.y);
    }
    this.node.emit(NodeEvent.UI_DATA_POSITION_UPDATED);
    return this;
  }
  toJSON() {
    this._json.x = this._position.x;
    this._json.y = this._position.y;
    this._json.comment = this._comment;
    return this._json;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/states/Base.js
var NodeBaseState = class {
  constructor(node) {
    this.node = node;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/states/TimeDependent.js
var NodeTimeDependentState = class extends NodeBaseState {
  active() {
    return this.paramsTimeDependent() || this.inputsTimeDependent();
  }
  paramsTimeDependent() {
    const paramNames = this.node.params.names;
    for (const paramName of paramNames) {
      const param = this.node.params.get(paramName);
      if (param && param.states.timeDependent.active()) {
        return true;
      }
    }
    return false;
  }
  inputsTimeDependent() {
    const inputs = this.node.io.inputs.inputs();
    for (const input of inputs) {
      if (input && input.states.timeDependent.active()) {
        return true;
      }
    }
    return false;
  }
  forceTimeDependent() {
    const predecessorIds = this.node.graphPredecessorIds();
    const frameNode = this.node.scene().timeController.graphNode;
    if (predecessorIds == null || !predecessorIds.includes(frameNode.graphNodeId())) {
      this.node.addGraphInput(frameNode, false);
    }
  }
  unforceTimeDependent() {
    const frameNode = this.node.scene().timeController.graphNode;
    this.node.removeGraphInput(frameNode);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/states/Error.js
var NodeErrorState = class extends NodeBaseState {
  set(message) {
    if (this._message != message) {
      if (message) {
        Poly.error(`[${this.node.path()}] error: '${message}' (from '${this._message}')`);
      } else {
        Poly.warn(`[${this.node.path()}] clear error`);
      }
      this._message = message;
      this.onUpdate();
    }
  }
  message() {
    return this._message;
  }
  clear() {
    this.set(void 0);
  }
  active() {
    return this._message != null;
  }
  onUpdate() {
    if (this._message != null) {
      this.node._setContainer(
        null
        /*, `from error '${this._message}'`*/
      );
    }
    this.node.emit(NodeEvent.ERROR_UPDATED);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/StatesController.js
var NodeStatesController = class {
  constructor(node) {
    this.node = node;
    this.timeDependent = new NodeTimeDependentState(this.node);
    this.error = new NodeErrorState(this.node);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/hierarchy/ParentController.js
var HierarchyParentController = class {
  constructor(node) {
    this.node = node;
    this._parent = null;
  }
  parent() {
    return this._parent;
  }
  setParent(parent) {
    if (parent != this.node.parentController.parent()) {
      this._parent = parent;
      if (this._parent) {
        this.node.nameController.requestNameToParent(this.node.name());
      }
    }
  }
  firstAncestorWithContext(context) {
    if (this._parent) {
      if (this._parent.context() == context) {
        return this._parent;
      } else {
        return this._parent.parentController.firstAncestorWithContext(context);
      }
    }
    return null;
  }
  findParent(callback) {
    if (this._parent) {
      if (callback(this._parent) == true) {
        return this._parent;
      } else {
        return this._parent.parentController.findParent(callback);
      }
    }
    return null;
  }
  path(relativeToParent) {
    const separator = CoreWalker.SEPARATOR;
    if (this._parent != null) {
      if (this._parent == relativeToParent) {
        return this.node.name();
      } else {
        const parent_fullPath = this._parent.path(relativeToParent);
        if (parent_fullPath === separator) {
          return parent_fullPath + this.node.name();
        } else {
          return parent_fullPath + separator + this.node.name();
        }
      }
    } else {
      return separator;
    }
  }
  onSetParent() {
    if (this._on_set_parent_hooks) {
      for (const hook of this._on_set_parent_hooks) {
        hook();
      }
    }
  }
  findNode(path) {
    if (path == null) {
      return null;
    }
    if (path == CoreWalker.CURRENT || path == CoreWalker.CURRENT_WITH_SLASH) {
      return this.node;
    }
    if (path == CoreWalker.PARENT || path == CoreWalker.PARENT_WITH_SLASH) {
      return this.node.parent();
    }
    const separator = CoreWalker.SEPARATOR;
    if (path === separator) {
      return this.node.scene().root();
    }
    if (path[0] === separator) {
      path = path.substring(1, path.length);
      return this.node.scene().root().node(path);
    }
    if (path.split) {
      const elements = path.split(separator);
      if (elements.length === 1) {
        const name = elements[0];
        if (this.node.childrenController) {
          return this.node.childrenController.childByName(name);
        } else {
          return null;
        }
      } else {
        return CoreWalker.findNode(this.node, path);
      }
    } else {
      console.error("unexpected path given:", path);
      return null;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/NodeSelection.js
var _nodes = [];
var _nodeIds = [];
var CoreNodeSelection = class {
  constructor(_node) {
    this._node = _node;
    this._nodeIds = [];
  }
  node() {
    return this._node;
  }
  nodeIds() {
    return this._nodeIds;
  }
  nodeFromIndex(index) {
    this._node.scene().graph.nodesFromIds(this._nodeIds, _nodes);
    return _nodes[index];
  }
  nodes(target4) {
    this._node.scene().graph.nodesFromIds(this._nodeIds, target4);
    return target4;
  }
  contains(node) {
    return this._nodeIds.includes(node.graphNodeId());
  }
  equals(nodes) {
    arrayMap(nodes, (node) => node.graphNodeId(), _nodeIds);
    _nodeIds.sort();
    return arrayIsEqual(_nodeIds, this._nodeIds);
  }
  clear() {
    this._nodeIds.length = 0;
    this._sendUpdateEvent();
  }
  set(nodes) {
    this._nodeIds.length = 0;
    this.add(nodes);
  }
  add(nodesToAdd) {
    arrayMap(nodesToAdd, (node) => node.graphNodeId(), _nodeIds);
    arrayUnion(this._nodeIds, _nodeIds, this._nodeIds);
    this._sendUpdateEvent();
  }
  remove(nodesToRemove) {
    arrayMap(nodesToRemove, (node) => node.graphNodeId(), _nodeIds);
    arrayDifference(this._nodeIds, _nodeIds, this._nodeIds);
    this._sendUpdateEvent();
  }
  _checkValidity() {
    this.nodes(_nodes);
    if (_nodes.length != this._nodeIds.length) {
      console.error("selection invalid: at least one node is not part of the graph");
      return;
    }
    for (const node of _nodes) {
      if (node.parent() != this._node) {
        console.error("selection invalid: at least one node is not has another parent");
      }
    }
  }
  _sendUpdateEvent() {
    this._checkValidity();
    this._node.emit(NodeEvent.SELECTION_UPDATED);
  }
  toJSON(target4) {
    arrayCopy(this._nodeIds, target4);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/container/utils/inputs/ClonedStatesController.js
var ClonedStatesController = class {
  constructor(inputs_controller) {
    this.inputs_controller = inputs_controller;
    this._clone_required_states = [];
    this._overridden = false;
  }
  initInputsClonedState(states) {
    if (CoreType.isArray(states)) {
      this._cloned_states = states;
    } else {
      this._cloned_state = states;
    }
    this._update_clone_required_state();
  }
  override_cloned_state_allowed() {
    if (this._cloned_states) {
      for (let state of this._cloned_states) {
        if (state == InputCloneMode.FROM_NODE) {
          return true;
        }
      }
    }
    if (this._cloned_state) {
      return this._cloned_state == InputCloneMode.FROM_NODE;
    }
    return false;
  }
  clone_required_state(index) {
    return this._clone_required_states[index];
  }
  clone_required_states() {
    return this._clone_required_states;
  }
  _get_clone_required_state(index) {
    const states = this._cloned_states;
    if (states) {
      const state = states[index];
      if (state != null) {
        return this.clone_required_from_state(state);
      }
    }
    if (this._cloned_state) {
      return this.clone_required_from_state(this._cloned_state);
    }
    return true;
  }
  clone_required_from_state(state) {
    switch (state) {
      case InputCloneMode.ALWAYS:
        return true;
      case InputCloneMode.NEVER:
        return false;
      case InputCloneMode.FROM_NODE:
        return !this._overridden;
    }
    return TypeAssert.unreachable(state);
  }
  override_cloned_state(state) {
    this._overridden = state;
    this._update_clone_required_state();
  }
  overriden() {
    return this._overridden;
  }
  _update_clone_required_state() {
    if (this._cloned_states) {
      const states = [];
      for (let i = 0; i < this._cloned_states.length; i++) {
        states[i] = this._get_clone_required_state(i);
      }
      this._clone_required_states = states;
      return;
    }
    if (this._cloned_state) {
      const max_inputs = this.inputs_controller.inputsCount();
      const states = [];
      for (let i = 0; i < max_inputs; i++) {
        states[i] = this._get_clone_required_state(i);
      }
      this._clone_required_states = states;
      return;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/container/utils/InputsController.js
var OperationInputsController = class {
  constructor(operationContainer) {
    this.operationContainer = operationContainer;
  }
  inputsCount() {
    return this.operationContainer.inputsCount();
  }
  initInputsClonedState(states) {
    if (!this._clonedStatesController) {
      this._clonedStatesController = new ClonedStatesController(this);
      this._clonedStatesController.initInputsClonedState(states);
    }
  }
  cloneRequired(index) {
    var _a;
    const state = (_a = this._clonedStatesController) == null ? void 0 : _a.clone_required_state(index);
    if (state != null) {
      return state;
    }
    return true;
  }
  override_cloned_state(state) {
    var _a;
    (_a = this._clonedStatesController) == null ? void 0 : _a.override_cloned_state(state);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/container/_Base.js
var BaseOperationContainer = class {
  constructor(operation, name, init_params) {
    this.operation = operation;
    this.name = name;
    this.params = {};
    this._applyDefaultParams();
    this._applyInitParams(init_params);
    this._initClonedStates();
  }
  //
  //
  // PATH PARAMS
  //
  //
  pathParamResolveRequired() {
    return this._path_params != null;
  }
  resolvePathParams(node_start) {
    if (!this._path_params) {
      return;
    }
    for (let path_param of this._path_params) {
      path_param.resolve(node_start);
    }
  }
  //
  //
  // PARAM VALUES CONVERSION
  //
  //
  _applyDefaultParams() {
    const default_params = this.operation.constructor.DEFAULT_PARAMS;
    const param_names = Object.keys(default_params);
    for (let param_name of param_names) {
      const param_data = default_params[param_name];
      const clone_param_data = this._convertParamData(param_name, param_data);
      if (clone_param_data != void 0) {
        this.params[param_name] = clone_param_data;
      }
    }
  }
  _applyInitParams(init_params) {
    const paramNames = Object.keys(init_params);
    for (let paramName of paramNames) {
      const param_data = init_params[paramName];
      if (param_data.simple_data != null) {
        const simple_data = param_data.simple_data;
        const clone_param_data = this.operation.convertExportParamData({
          paramName,
          paramData: simple_data,
          params: this.params
        });
        if (clone_param_data != void 0) {
          this.params[paramName] = clone_param_data;
        }
      }
    }
  }
  _convertParamData(param_name, param_data) {
    if (CoreType.isNumber(param_data) || CoreType.isBoolean(param_data) || CoreType.isString(param_data)) {
      return param_data;
    }
    if (param_data instanceof TypedNodePathParamValue) {
      const cloned = param_data.clone();
      if (!this._path_params) {
        this._path_params = [];
      }
      this._path_params.push(cloned);
      return cloned;
    }
    if (param_data instanceof Color || param_data instanceof Vector2 || param_data instanceof Vector3 || param_data instanceof Vector4) {
      return param_data.clone();
    }
  }
  setInput(index, input) {
    this._inputs = this._inputs || [];
    this._inputs[index] = input;
  }
  inputsCount() {
    if (this._inputs) {
      return this._inputs.length;
    } else {
      return 0;
    }
  }
  inputsController() {
    return this._inputsController = this._inputsController || new OperationInputsController(this);
  }
  _initClonedStates() {
    const default_cloned_states = this.operation.constructor.INPUT_CLONED_STATE;
    this.inputsController().initInputsClonedState(default_cloned_states);
  }
  inputCloneRequired(index) {
    if (!this._inputsController) {
      return true;
    }
    return this._inputsController.cloneRequired(index);
  }
  overrideInputCloneState(state) {
    this.inputsController().override_cloned_state(state);
  }
  //
  //
  // COOK
  //
  //
  cook(input_contents) {
    return this.operation.cook(input_contents, this.params);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/container/sop.js
var SopOperationContainer = class extends BaseOperationContainer {
  constructor(operation, name, init_params) {
    super(operation, name, init_params);
    this.operation = operation;
    this.name = name;
    this.init_params = init_params;
    this._inputs = [];
    this._currentInputIndex = 0;
    this._dirty = true;
  }
  operationType() {
    return this.operation.type();
  }
  addInput(input) {
    super.setInput(this._currentInputIndex, input);
    this.incrementInputIndex();
  }
  incrementInputIndex() {
    this._currentInputIndex++;
  }
  currentInputIndex() {
    return this._currentInputIndex;
  }
  setDirty() {
    if (this._dirty) {
      return;
    }
    this._computeResult = void 0;
    for (let i = 0; i < this._inputs.length; i++) {
      const inputOperation = this._inputs[i];
      inputOperation.setDirty();
    }
  }
  async compute(input_contents, operation_inputs_map) {
    if (this._computeResult) {
      return this._computeResult;
    }
    const operationInputContents = [];
    const nodeInputsMap = operation_inputs_map.get(this);
    if (nodeInputsMap) {
      nodeInputsMap.forEach((node_input_index, operation_input_index) => {
        operationInputContents[operation_input_index] = input_contents[node_input_index];
      });
    }
    for (let i = 0; i < this._inputs.length; i++) {
      const inputOperation = this._inputs[i];
      let result2 = await inputOperation.compute(input_contents, operation_inputs_map);
      if (result2) {
        if (this.inputCloneRequired(i)) {
          result2 = result2.clone();
        }
        operationInputContents[i] = result2;
      }
    }
    const result = this.operation.cook(operationInputContents, this.params);
    if (result) {
      if (result instanceof Promise) {
        this._computeResult = await result;
      } else {
        this._computeResult = result;
      }
    } else {
      this._computeResult = void 0;
    }
    this._dirty = false;
    return this._computeResult;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/NameController.js
var NameController = class {
  constructor(node) {
    this.node = node;
    this._graphNode = new CoreGraphNode(node.scene(), "nodeNameController");
  }
  dispose() {
    this._graphNode.dispose();
    this._onSetNameHooks = void 0;
    this._onSetFullPathHooks = void 0;
  }
  graphNode() {
    return this._graphNode;
  }
  static baseName(node) {
    let base = node.type();
    const last_char = base[base.length - 1];
    if (!CoreType.isNaN(parseInt(last_char))) {
      base += "_";
    }
    return `${base}1`;
  }
  requestNameToParent(newName) {
    const parent = this.node.parent();
    if (parent && parent.childrenAllowed() && parent.childrenController) {
      parent.childrenController.setChildName(this.node, newName);
    } else {
      console.warn("requestNameToParent failed, no parent found");
    }
  }
  setName(newName) {
    if (newName != this.node.name()) {
      if (this.node.insideALockedParent()) {
        const lockedParent = this.node.lockedParent();
        console.warn(
          `node '${this.node.path()}' cannot have its name changed, since it is inside '${lockedParent ? lockedParent.path() : ""}', which is locked`
        );
        return;
      }
      this.requestNameToParent(newName);
    }
  }
  updateNameFromParent(new_name) {
    var _a;
    this.node._setCoreName(new_name);
    this._postSetName();
    this.runPostSetFullPathHooks();
    if (this.node.childrenAllowed()) {
      const children = (_a = this.node.childrenController) == null ? void 0 : _a.children();
      if (children) {
        for (const child_node of children) {
          child_node.nameController.runPostSetFullPathHooks();
        }
      }
    }
    if (this.node.lifecycle.creationCompleted() && this.node.scene().loadingController.loaded()) {
      this.node.scene().missingExpressionReferencesController.checkForMissingNodeReferences(this.node);
      this.node.scene().expressionsController.regenerateReferringExpressions(this.node);
    }
    this.node.scene().referencesController.notifyNameUpdated(this.node);
    this.node.emit(NodeEvent.NAME_UPDATED);
  }
  add_post_set_name_hook(hook) {
    this._onSetNameHooks = this._onSetNameHooks || [];
    this._onSetNameHooks.push(hook);
  }
  add_post_set_fullPath_hook(hook) {
    this._onSetFullPathHooks = this._onSetFullPathHooks || [];
    this._onSetFullPathHooks.push(hook);
  }
  _postSetName() {
    if (this._onSetNameHooks) {
      for (const hook of this._onSetNameHooks) {
        hook();
      }
    }
  }
  runPostSetFullPathHooks() {
    if (this._onSetFullPathHooks) {
      for (const hook of this._onSetFullPathHooks) {
        hook();
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/hierarchy/ChildrenController.js
var HierarchyChildrenController = class {
  constructor(node, _context) {
    this.node = node;
    this._context = _context;
    this._childrenByName = /* @__PURE__ */ new Map();
    this._childrenIdByType = /* @__PURE__ */ new Map();
    this._childrenByType = /* @__PURE__ */ new Map();
    this._childrenAndGrandchildrenByContext = /* @__PURE__ */ new Map();
    this._children = [];
    this._childrenNames = [];
  }
  get selection() {
    return this._selection = this._selection || new CoreNodeSelection(this.node);
  }
  dispose() {
    const _tmpChildren = [];
    arrayCopy(this.children(), _tmpChildren);
    for (const child of _tmpChildren) {
      this.node.removeNode(child);
    }
    _tmpChildren.length = 0;
    this._selection = void 0;
  }
  get context() {
    return this._context;
  }
  setOutputNodeFindMethod(method) {
    this._outputNodeFindMethod = method;
  }
  outputNode() {
    if (this._outputNodeFindMethod) {
      return this._outputNodeFindMethod();
    }
  }
  //
  //
  //
  //
  //
  setChildName(node, newName) {
    let currentChildWithName;
    newName = CoreString.sanitizeName(newName);
    if ((currentChildWithName = this._childrenByName.get(newName)) != null) {
      if (node.name() === newName && currentChildWithName.graphNodeId() === node.graphNodeId()) {
        return;
      }
      newName = CoreString.increment(newName);
      return this.setChildName(node, newName);
    } else {
      const currentName = node.name();
      const currentChild = this._childrenByName.get(currentName);
      if (currentChild) {
        this._childrenByName.delete(currentName);
      }
      this._childrenByName.set(newName, node);
      this._updateCache();
      node.nameController.updateNameFromParent(newName);
      this.node.scene().nodesController.addToInstanciatedNode(node);
      this.node.scene().graphNodesController.notifyNodePathChanged(node);
    }
  }
  _nextAvailableChildName(nodeName) {
    nodeName = CoreString.sanitizeName(nodeName);
    return this._childrenByName.get(nodeName) ? this._nextAvailableChildName(CoreString.increment(nodeName)) : nodeName;
  }
  nodeContextSignature() {
    return `${this.node.context()}/${this.node.type()}`;
  }
  availableChildrenClasses() {
    return Poly.registeredNodes(this.node);
  }
  isValidChildType(node_type) {
    const node_class = this.availableChildrenClasses()[node_type];
    return node_class != null;
  }
  // create_node(node_type: string, options?: NodeCreateOptions): BaseNodeType {
  // 	const node_class = this.available_children_classes()[node_type];
  // 	if (node_class == null) {
  // 		const message = `child node type '${node_type}' not found for node '${this.node.path()}'. Available types are: ${Object.keys(
  // 			this.available_children_classes()
  // 		).join(', ')}, ${this._context}, ${this.node.type}`;
  // 		console.error(message);
  // 		throw message;
  // 	} else {
  // 		const child_node = new node_class(this.node.scene, `child_node_${node_type}`, paramsInitValueOverrides);
  // 		child_node.initialize_base_and_node();
  // 		this.add_node(child_node);
  // 		child_node.lifecycle.set_creation_completed();
  // 		return child_node;
  // 	}
  // }
  createNode(nodeClassOrString, options) {
    if (typeof nodeClassOrString == "string") {
      const nodeClass = this._findNodeClass(nodeClassOrString);
      return this._createAndInitNode(nodeClass, options);
    } else {
      return this._createAndInitNode(nodeClassOrString, options);
    }
  }
  _createAndInitNode(nodeClass, options) {
    var _a;
    const requestedNodeName = (options == null ? void 0 : options.nodeName) || NameController.baseName(nodeClass);
    const nodeName = this._nextAvailableChildName(requestedNodeName);
    const childNode = new nodeClass(this.node.scene(), nodeName, {
      ...options,
      serializerClass: (_a = this.node.serializer) == null ? void 0 : _a.constructor
    });
    childNode.initializeBaseAndNode();
    this._addNode(childNode);
    childNode.lifecycle.setCreationCompleted();
    return childNode;
  }
  _findNodeClass(node_type) {
    const nodeClass = this.availableChildrenClasses()[node_type.toLowerCase()];
    if (nodeClass == null) {
      const message = `child node type '${node_type}' not found for node '${this.node.path()}'. Available types are: ${Object.keys(
        this.availableChildrenClasses()
      ).join(", ")}, ${this._context}, ${this.node.type()}`;
      console.error(message);
      throw message;
    }
    return nodeClass;
  }
  createOperationContainer(operationType, operationContainerName, options) {
    const operationClass = Poly.registeredOperation(this._context, operationType);
    if (operationClass == null) {
      const message = `no operation found with context ${this._context}/${operationType}`;
      console.error(message);
      throw message;
    } else {
      const operation = new operationClass(this.node.scene());
      const operation_container = new SopOperationContainer(
        operation,
        operationContainerName,
        (options == null ? void 0 : options.paramsInitValueOverrides) || {}
      );
      return operation_container;
    }
  }
  _addNode(childNode) {
    childNode.setParent(this.node);
    this._addToNodesByType(childNode);
    childNode.params.init();
    childNode.parentController.onSetParent();
    childNode.nameController.runPostSetFullPathHooks();
    if (childNode.childrenAllowed() && childNode.childrenController) {
      for (const child of childNode.childrenController.children()) {
        child.nameController.runPostSetFullPathHooks();
      }
    }
    if (this.node.serializer) {
      const childNodeJSON = childNode.toJSON();
      if (childNodeJSON) {
        this.node.emit(NodeEvent.CREATED, { child_node_json: childNodeJSON });
      }
    }
    if (this.node.scene().lifecycleController.onAfterCreatedCallbackAllowed()) {
      childNode.lifecycle.runOnAfterCreatedCallbacks();
    }
    childNode.lifecycle.runOnAfterAddedCallbacks();
    this.node.lifecycle.runOnChildAddCallbacks(childNode);
    if (childNode.requireWebGL2()) {
      this.node.scene().webglController.setRequireWebGL2();
    }
    this.node.scene().missingExpressionReferencesController.checkForMissingNodeReferences(childNode);
    return childNode;
  }
  removeNode(childNode) {
    var _a;
    if (this.node.lockedOrInsideALockedParent()) {
      const lockedNode = this.node.selfOrLockedParent();
      const reason = lockedNode == this.node ? `it is locked` : `it is inside '${lockedNode ? lockedNode.path() : ""}', which is locked`;
      console.warn(`node '${this.node.path()}' cannot remove nodes, since ${reason}`);
      console.log(this.node.graphNodeId(), this.node.name());
      return;
    }
    if (childNode.parent() != this.node) {
      return console.warn(`node ${childNode.name()} not under parent ${this.node.path()}`);
    } else {
      (_a = childNode.polyNodeController) == null ? void 0 : _a.setLockedState(false);
      childNode.lifecycle.runOnBeforeDeleteCallbacks();
      if (this.selection.contains(childNode)) {
        this.selection.remove([childNode]);
      }
      const firstConnection = childNode.io.connections.firstInputConnection();
      const inputConnections = childNode.io.connections.inputConnections();
      const outputConnections = [];
      childNode.io.connections.outputConnections(outputConnections);
      if (inputConnections) {
        for (const inputConnection of inputConnections) {
          if (inputConnection) {
            inputConnection.disconnect({ setInput: true });
          }
        }
      }
      if (outputConnections) {
        for (const outputConnection of outputConnections) {
          if (outputConnection) {
            outputConnection.disconnect({ setInput: true });
            if (firstConnection) {
              const oldSrc = firstConnection.nodeSrc();
              const oldOutputIndex = firstConnection.outputIndex();
              const oldDest = outputConnection.nodeDest();
              const oldInputIndex = outputConnection.inputIndex();
              oldDest.io.inputs.setInput(oldInputIndex, oldSrc, oldOutputIndex);
            }
          }
        }
      }
      childNode.setParent(null);
      this._childrenByName.delete(childNode.name());
      this._updateCache();
      this._removeFromNodesByType(childNode);
      this.node.scene().nodesController.removeFromInstanciatedNode(childNode);
      childNode.setSuccessorsDirty(this.node);
      childNode.graphDisconnectSuccessors();
      this.node.lifecycle.runOnChildRemoveCallbacks(childNode);
      childNode.lifecycle.runOnDeleteCallbacks();
      childNode.dispose();
      childNode.emit(NodeEvent.DELETED, { parent_id: this.node.graphNodeId() });
      this.node.scene().graphNodesController.notifyNodePathChanged(childNode);
    }
  }
  _addToNodesByType(node) {
    const nodeId = node.graphNodeId();
    const type = node.type();
    MapUtils.addToSetAtEntry(this._childrenIdByType, type, nodeId);
    MapUtils.pushOnArrayAtEntry(this._childrenByType, type, node);
    this._addToChildrenAndGrandchildrenByContext(node);
  }
  _removeFromNodesByType(node) {
    const nodeId = node.graphNodeId();
    const type = node.type();
    MapUtils.removeFromSetAtEntry(this._childrenIdByType, type, nodeId);
    MapUtils.popFromArrayAtEntry(this._childrenByType, type, node);
    this._removeFromChildrenAndGrandchildrenByContext(node);
  }
  _addToChildrenAndGrandchildrenByContext(node) {
    var _a;
    const nodeId = node.graphNodeId();
    const nodeContext = node.context();
    MapUtils.addToSetAtEntry(this._childrenAndGrandchildrenByContext, nodeContext, nodeId);
    const parent = this.node.parent();
    if (parent && parent.childrenAllowed()) {
      (_a = parent.childrenController) == null ? void 0 : _a._addToChildrenAndGrandchildrenByContext(node);
    }
  }
  _removeFromChildrenAndGrandchildrenByContext(node) {
    var _a;
    const nodeId = node.graphNodeId();
    const type = node.context();
    MapUtils.removeFromSetAtEntry(this._childrenAndGrandchildrenByContext, type, nodeId);
    const parent = this.node.parent();
    if (parent && parent.childrenAllowed()) {
      (_a = parent.childrenController) == null ? void 0 : _a._removeFromChildrenAndGrandchildrenByContext(node);
    }
  }
  nodesByType(type, target4 = []) {
    const nodes = this._childrenByType.get(type);
    target4.length = nodes ? nodes.length : 0;
    if (nodes) {
      for (let i = 0; i < nodes.length; i++) {
        target4[i] = nodes[i];
      }
    }
    return target4;
  }
  childByName(name) {
    return this._childrenByName.get(name) || null;
  }
  hasChildrenAndGrandchildrenWithContext(context) {
    return this._childrenAndGrandchildrenByContext.get(context) != null;
  }
  _updateCache() {
    this._children.length = 0;
    this._childrenNames.length = 0;
    this._childrenByName.forEach((node) => {
      this._children.push(node);
      this._childrenNames.push(node.name());
    });
  }
  children() {
    return this._children;
  }
  childrenNames() {
    return this._childrenNames;
  }
  traverseChildren(callback, conditionCallback) {
    this._childrenByName.forEach((childNode) => {
      var _a;
      callback(childNode);
      if (conditionCallback == null || conditionCallback(childNode) == true) {
        (_a = childNode.childrenController) == null ? void 0 : _a.traverseChildren(callback);
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/LifeCycleController.js
var NodeLifeCycleController = class {
  constructor(node) {
    this.node = node;
    this._creationCompleted = false;
  }
  dispose() {
    this._onChildAddCallbacks = void 0;
    this._onChildRemoveCallbacks = void 0;
    this._onAfterCreatedCallbacks = void 0;
    this._onAfterAddedCallbacks = void 0;
    this._onBeforeDeletedCallbacks = void 0;
    this._onAfterDeletedCallbacks = void 0;
  }
  setCreationCompleted() {
    if (!this._creationCompleted) {
      this._creationCompleted = true;
    }
  }
  creationCompleted() {
    return this.node.scene().loadingController.loaded() && this._creationCompleted;
  }
  //
  //
  // ON CREATION COMPLETED
  //
  //
  // add_on_creation_completed_hook(callback: Callback) {
  // 	this._on_creation_completed_hooks = this._on_creation_completed_hooks || [];
  // 	this._on_creation_completed_hooks.push(callback);
  // }
  // private run_on_creation_completed_hooks() {
  // 	if (this._on_creation_completed_hooks) {
  // 		console.log('run_on_creation_completed_hooks', this.node.name);
  // 	}
  // 	this.execute_hooks(this._on_creation_completed_hooks);
  // }
  //
  //
  // ON CHILD ADD
  //
  //
  onChildAdd(callback) {
    this._onChildAddCallbacks = this._onChildAddCallbacks || [];
    this._onChildAddCallbacks.push(callback);
  }
  runOnChildAddCallbacks(node) {
    this._runCallbacksWithChildNode(this._onChildAddCallbacks, node);
  }
  //
  //
  // ON CHILD REMOVE
  //
  //
  onChildRemove(callback) {
    this._onChildRemoveCallbacks = this._onChildRemoveCallbacks || [];
    this._onChildRemoveCallbacks.push(callback);
  }
  runOnChildRemoveCallbacks(node) {
    this._runCallbacksWithChildNode(this._onChildRemoveCallbacks, node);
  }
  //
  //
  // ON CREATE
  //
  //
  onAfterCreated(callback) {
    this._onAfterCreatedCallbacks = this._onAfterCreatedCallbacks || [];
    this._onAfterCreatedCallbacks.push(callback);
  }
  runOnAfterCreatedCallbacks() {
    this._runCallbacks(this._onAfterCreatedCallbacks);
  }
  //
  //
  // ON ADD
  //
  //
  onAfterAdded(callback) {
    this._onAfterAddedCallbacks = this._onAfterAddedCallbacks || [];
    this._onAfterAddedCallbacks.push(callback);
  }
  runOnAfterAddedCallbacks() {
    this._runCallbacks(this._onAfterAddedCallbacks);
  }
  //
  //
  // ON DELETE
  //
  //
  onBeforeDeleted(callback) {
    this._onBeforeDeletedCallbacks = this._onBeforeDeletedCallbacks || [];
    this._onBeforeDeletedCallbacks.push(callback);
  }
  runOnBeforeDeleteCallbacks() {
    this._runCallbacks(this._onBeforeDeletedCallbacks);
  }
  // TODO: onAfterDeleted is not very different than methods in .dispose
  // so this should probably be removed/refactored
  onAfterDeleted(callback) {
    this._onAfterDeletedCallbacks = this._onAfterDeletedCallbacks || [];
    this._onAfterDeletedCallbacks.push(callback);
  }
  runOnDeleteCallbacks() {
    this._runCallbacks(this._onAfterDeletedCallbacks);
  }
  //
  //
  // UTILS
  //
  //
  _runCallbacks(hooks2) {
    if (!hooks2) {
      return;
    }
    let hook;
    for (hook of hooks2) {
      hook();
    }
  }
  _runCallbacksWithChildNode(hooks2, childNode) {
    if (!hooks2) {
      return;
    }
    let hook;
    for (hook of hooks2) {
      hook(childNode);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/Constant.js
var AnimNodeEasing = ((AnimNodeEasing2) => {
  AnimNodeEasing2["NONE"] = "none";
  AnimNodeEasing2["POWER1"] = "power1";
  AnimNodeEasing2["POWER2"] = "power2";
  AnimNodeEasing2["POWER3"] = "power3";
  AnimNodeEasing2["POWER4"] = "power4";
  AnimNodeEasing2["BACK"] = "back";
  AnimNodeEasing2["ELASTIC"] = "elastic";
  AnimNodeEasing2["BOUNCE"] = "bounce";
  AnimNodeEasing2["SLOW"] = "slow";
  AnimNodeEasing2["STEPS"] = "steps";
  AnimNodeEasing2["CIRC"] = "circ";
  AnimNodeEasing2["EXPO"] = "expo";
  AnimNodeEasing2["SINE"] = "sine";
  return AnimNodeEasing2;
})(AnimNodeEasing || {});
var InOutMode = ((InOutMode2) => {
  InOutMode2["IN"] = "in";
  InOutMode2["OUT"] = "out";
  InOutMode2["IN_OUT"] = "inOut";
  return InOutMode2;
})(InOutMode || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/Common.js
function animBuilderCommonVars(timelineBuilder) {
  const duration = timelineBuilder.duration();
  const vars = { duration };
  const easing = timelineBuilder.easing() || AnimNodeEasing.NONE;
  if (easing) {
    vars.ease = easing;
  }
  const delay = timelineBuilder.delay();
  if (delay != null) {
    vars.delay = delay;
  }
  const repeatParams = timelineBuilder.repeatParams();
  if (repeatParams) {
    vars.repeat = repeatParams.count;
    vars.repeatDelay = repeatParams.delay;
    vars.yoyo = repeatParams.yoyo;
  }
  return vars;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/AnimatedPropertiesRegister.js
var AnimatedPropertiesRegisterClass = class _AnimatedPropertiesRegisterClass {
  constructor() {
    this._propertiesMap = /* @__PURE__ */ new Map();
  }
  static instance() {
    return this._instance = this._instance || new _AnimatedPropertiesRegisterClass();
  }
  registerProp(property, timelineData) {
    this._propertiesMap.set(this._convert(property), timelineData);
  }
  deRegisterProp(property) {
    this._propertiesMap.delete(this._convert(property));
  }
  registeredTimelineForProperty(property) {
    return this._propertiesMap.get(this._convert(property));
  }
  registeredPropertiesCount() {
    let count = 0;
    this._propertiesMap.forEach(() => {
      count++;
    });
    return count;
  }
  _convert(property) {
    if (property.object) {
      const sceneGraphProp = property;
      return `${sceneGraphProp.object.uuid}:${sceneGraphProp.propertyName}`;
    } else {
      return property;
    }
  }
};
var AnimatedPropertiesRegister = AnimatedPropertiesRegisterClass.instance();

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/StartTimeline.js
function animBuilderStartTimeline(options) {
  const { timelineBuilder, timeline, vars, target: target4, registerableProp, registerproperties } = options;
  const position = timelineBuilder.position();
  const positionParam = position ? position.toParameter() : void 0;
  const existingTimeline = AnimatedPropertiesRegister.registeredTimelineForProperty(registerableProp);
  const newTimeline = timeline.to(target4, vars, positionParam);
  const onStart = () => {
    if (existingTimeline) {
      if (existingTimeline.stoppable) {
        existingTimeline.timeline.kill();
        AnimatedPropertiesRegister.deRegisterProp(registerableProp);
      } else {
        newTimeline.kill();
        return;
      }
    }
    if (registerproperties) {
      AnimatedPropertiesRegister.registerProp(registerableProp, {
        timeline: newTimeline,
        stoppable: timelineBuilder.stoppable()
      });
    }
  };
  const onComplete = () => {
    AnimatedPropertiesRegister.deRegisterProp(registerableProp);
  };
  if (vars.onStart) {
    const prevOnStart = vars.onStart;
    vars.onStart = () => {
      onStart();
      prevOnStart();
    };
  } else {
    vars.onStart = onStart;
  }
  if (vars.onComplete) {
    const prevOnComplete = vars.onComplete;
    vars.onComplete = () => {
      onComplete();
      prevOnComplete();
    };
  } else {
    vars.onComplete = onComplete;
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/ParamProxy.js
var FloatParamProxy = class {
  constructor(param) {
    this.param = param;
    this.proxyValue = param.value;
  }
  update(interpolant) {
    if (interpolant) {
      const val = interpolant.evaluate(this.proxyValue)[0];
      this.param.set(val);
    } else {
      this.param.set(this.proxyValue);
    }
  }
};
var IntegerParamProxy = class {
  constructor(param) {
    this.param = param;
    this.proxyValue = param.value;
  }
  update() {
    this.param.set(this.proxyValue);
  }
};
var Vector2ParamProxy = class {
  constructor(param) {
    this.param = param;
    this.proxyValue = new Vector2();
    this._array = [0, 0];
    this.proxyValue.copy(param.value);
  }
  update() {
    this.proxyValue.toArray(this._array);
    this.param.set(this._array);
  }
};
var Vector3ParamProxy = class {
  constructor(param) {
    this.param = param;
    this.proxyValue = new Vector3();
    this._array = [0, 0, 0];
    this.proxyValue.copy(param.value);
  }
  update() {
    this.proxyValue.toArray(this._array);
    this.param.set(this._array);
  }
};
var Vector4ParamProxy = class {
  constructor(param) {
    this.param = param;
    this.proxyValue = new Vector4();
    this._array = [0, 0, 0, 0];
    this.proxyValue.copy(param.value);
  }
  update() {
    this.proxyValue.toArray(this._array);
    this.param.set(this._array);
  }
};
var ColorParamProxy = class {
  constructor(param) {
    this.param = param;
    this.proxyValue = new Color();
    this._array = [0, 0, 0];
    this.proxyValue.copy(param.valuePreConversion());
  }
  update() {
    this.proxyValue.toArray(this._array);
    this.param.set(this._array);
  }
};
var AnimationNodeParamsProxy = class {
  constructor(node) {
    this._map = /* @__PURE__ */ new Map();
    const params = node.params.all;
    for (const param of params) {
      const paramProxy = this._createParamProxy(param);
      if (paramProxy) {
        this._map.set(param, paramProxy);
      }
    }
  }
  _createParamProxy(param) {
    switch (param.type()) {
      case ParamType.INTEGER: {
        return new IntegerParamProxy(param);
      }
      case ParamType.FLOAT: {
        return new FloatParamProxy(param);
      }
      case ParamType.VECTOR2: {
        return new Vector2ParamProxy(param);
      }
      case ParamType.VECTOR3: {
        return new Vector3ParamProxy(param);
      }
      case ParamType.COLOR: {
        return new ColorParamProxy(param);
      }
      case ParamType.VECTOR4: {
        return new Vector4ParamProxy(param);
      }
    }
  }
  getParamProxy(param) {
    return this._map.get(param);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/NodeParamProxiesRegister.js
var NodeParamProxiesRegisterClass = class _NodeParamProxiesRegisterClass {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  static instance() {
    return this._instance = this._instance || new _NodeParamProxiesRegisterClass();
  }
  nodeProxy(node) {
    const existingProxy = this._map.get(node);
    if (existingProxy) {
      return existingProxy;
    }
    const newProxy = new AnimationNodeParamsProxy(node);
    this._map.set(node, newProxy);
    return newProxy;
  }
  paramProxy(param) {
    return this.nodeProxy(param.node).getParamProxy(param);
  }
};
var NodeParamProxiesRegister = NodeParamProxiesRegisterClass.instance();

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/AnimBuilderTypes.js
var Operation = ((Operation2) => {
  Operation2["SET"] = "set";
  Operation2["ADD"] = "add";
  Operation2["SUBTRACT"] = "subtract";
  return Operation2;
})(Operation || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/WithOp.js
function AnimBuilderWithOp(currentValue, value, operation) {
  switch (operation) {
    case Operation.SET:
      return value;
    case Operation.ADD:
      return currentValue + value;
    case Operation.SUBTRACT:
      return currentValue - value;
  }
  TypeAssert.unreachable(operation);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Vector4.js
function populateVarsForParamVector4(param, targetValue, options) {
  if (!(targetValue instanceof Vector4)) {
    Poly.warn(
      `TimelineBuilderProperty error: cannot animate vector4 param '${param.path()}' with targetValue`,
      targetValue
    );
    return;
  }
  const proxy = NodeParamProxiesRegister.paramProxy(param);
  if (!proxy) {
    return;
  }
  const vars = animBuilderCommonVars(options.timelineBuilder);
  vars.onUpdate = () => {
    proxy.update();
  };
  const operation = options.timelineBuilder.operation();
  vars.x = AnimBuilderWithOp(param.value.x, targetValue.x, operation);
  vars.y = AnimBuilderWithOp(param.value.y, targetValue.y, operation);
  vars.z = AnimBuilderWithOp(param.value.z, targetValue.z, operation);
  vars.w = AnimBuilderWithOp(param.value.w, targetValue.w, operation);
  animBuilderStartTimeline({ ...options, vars, target: proxy.proxyValue, registerableProp: param });
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Color.js
function populateVarsForParamColor(param, targetValue, options) {
  if (!(targetValue instanceof Color || targetValue instanceof Vector3)) {
    Poly.warn(
      `TimelineBuilderProperty error: cannot animate color param '${param.path()}' with targetValue`,
      targetValue
    );
    return;
  }
  const proxy = NodeParamProxiesRegister.paramProxy(param);
  if (!proxy) {
    return;
  }
  const vars = animBuilderCommonVars(options.timelineBuilder);
  vars.onUpdate = () => {
    proxy.update();
  };
  const operation = options.timelineBuilder.operation();
  const x = targetValue instanceof Color ? targetValue.r : targetValue.x;
  const y = targetValue instanceof Color ? targetValue.g : targetValue.y;
  const z = targetValue instanceof Color ? targetValue.b : targetValue.z;
  vars.r = AnimBuilderWithOp(param.value.r, x, operation);
  vars.g = AnimBuilderWithOp(param.value.g, y, operation);
  vars.b = AnimBuilderWithOp(param.value.b, z, operation);
  animBuilderStartTimeline({ ...options, vars, target: proxy.proxyValue, registerableProp: param });
}
function populateVarsForColor(options) {
  const { vars, targetValue, targetProperty, propertyNames, operation } = options;
  for (const propertyName of propertyNames) {
    vars[propertyName] = AnimBuilderWithOp(
      targetProperty[propertyName],
      targetValue[propertyName],
      operation
    );
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Vector3.js
function populateVarsForParamVector3(param, targetValue, options) {
  if (!(targetValue instanceof Vector3)) {
    Poly.warn(
      `TimelineBuilderProperty error: cannot animate vector3 param '${param.path()}' with targetValue`,
      targetValue
    );
    return;
  }
  const proxy = NodeParamProxiesRegister.paramProxy(param);
  if (!proxy) {
    return;
  }
  const vars = animBuilderCommonVars(options.timelineBuilder);
  vars.onUpdate = () => {
    proxy.update();
  };
  const operation = options.timelineBuilder.operation();
  vars.x = AnimBuilderWithOp(param.value.x, targetValue.x, operation);
  vars.y = AnimBuilderWithOp(param.value.y, targetValue.y, operation);
  vars.z = AnimBuilderWithOp(param.value.z, targetValue.z, operation);
  animBuilderStartTimeline({ ...options, vars, target: proxy.proxyValue, registerableProp: param });
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Vector2.js
function populateVarsForParamVector2(param, targetValue, options) {
  if (!(targetValue instanceof Vector2)) {
    Poly.warn(
      `TimelineBuilderProperty error: cannot animate vector2 param '${param.path()}' with targetValue`,
      targetValue
    );
    return;
  }
  const proxy = NodeParamProxiesRegister.paramProxy(param);
  if (!proxy) {
    return;
  }
  const vars = animBuilderCommonVars(options.timelineBuilder);
  vars.onUpdate = () => {
    proxy.update();
  };
  const operation = options.timelineBuilder.operation();
  vars.x = AnimBuilderWithOp(param.value.x, targetValue.x, operation);
  vars.y = AnimBuilderWithOp(param.value.y, targetValue.y, operation);
  animBuilderStartTimeline({ ...options, vars, target: proxy.proxyValue, registerableProp: param });
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Number.js
function populateVarsForSingleNumber(param, targetValue, options) {
  if (!CoreType.isNumber(targetValue)) {
    Poly.warn(
      `TimelineBuilderProperty error: cannot animate float/integer param '${param.path()}' with targetValue`,
      targetValue
    );
    return;
  }
  const proxy = NodeParamProxiesRegister.paramProxy(param);
  if (!proxy) {
    return;
  }
  const keyframes = options.timelineBuilder.keyframes();
  const interpolant = keyframes ? keyframes.createInterpolant() : void 0;
  const vars = animBuilderCommonVars(options.timelineBuilder);
  vars.onUpdate = () => {
    proxy.update(interpolant);
  };
  if (keyframes) {
    targetValue = 1;
  }
  const operation = options.timelineBuilder.operation();
  vars.proxyValue = AnimBuilderWithOp(param.value, targetValue, operation);
  animBuilderStartTimeline({ ...options, vars, target: proxy, registerableProp: param });
}
function populateVarsForNumber(options) {
  const { vars, targetValue, targetProperty, propertyNames, operation } = options;
  for (const property_name of propertyNames) {
    vars[property_name] = AnimBuilderWithOp(targetProperty, targetValue, operation);
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Vector.js
function populateVarsForVector(options) {
  const { vars, targetValue, targetProperty, propertyNames, operation } = options;
  for (const propertyName of propertyNames) {
    vars[propertyName] = AnimBuilderWithOp(
      targetProperty[propertyName],
      targetValue[propertyName],
      operation
    );
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Quaternion.js
function populateVarsAndCreateProxyForQuaternion(options) {
  const { vars, targetValue, targetProperty } = options;
  const proxy = { value: 0 };
  const qTarget = targetProperty;
  const qStart = new Quaternion().copy(targetProperty);
  const qEnd = targetValue;
  vars.onUpdate = () => {
    qTarget.slerpQuaternions(qStart, qEnd, proxy.value);
  };
  vars.value = 1;
  return proxy;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/vars/type/Euler.js
function populateVarsForEuler(options) {
  const { vars, targetValue, targetProperty, propertyNames, operation } = options;
  for (const propertyName of propertyNames) {
    vars[propertyName] = AnimBuilderWithOp(
      targetProperty[propertyName],
      targetValue[propertyName],
      operation
    );
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/TimelineBuilderProperty.js
var PROPERTY_SEPARATOR = ".";
var TimelineBuilderProperty = class _TimelineBuilderProperty {
  constructor() {
    this._debug = false;
  }
  setName(name) {
    this._propertyName = name;
  }
  setTargetValue(value) {
    this._targetValue = value;
  }
  name() {
    return this._propertyName;
  }
  targetValue() {
    return this._targetValue;
  }
  setDebug(debug) {
    this._debug = debug;
  }
  _printDebug(message) {
    if (!this._debug) {
      return;
    }
    console.log(message);
  }
  clone() {
    const cloned = new _TimelineBuilderProperty();
    if (this._propertyName) {
      cloned.setName(this._propertyName);
    }
    if (this._targetValue != null) {
      const newTargetValue = CoreType.isNumber(this._targetValue) ? this._targetValue : this._targetValue.clone();
      cloned.setTargetValue(newTargetValue);
    }
    return cloned;
  }
  addToTimeline(options) {
    const target4 = options.propertyTarget || options.target;
    const objects = target4.objects();
    const node = target4.node();
    this._printDebug(["addToTimeline", target4, objects, node]);
    if (objects) {
      this._populateWithObjects(objects, options);
    }
    if (node) {
      this._populateWithNode(node, options);
    }
  }
  _populateWithObjects(objects, options) {
    const { timelineBuilder } = options;
    this._printDebug(["_populateWithObjects", objects]);
    if (!this._propertyName) {
      Poly.warn("no property name given");
      return;
    }
    if (this._targetValue == null) {
      Poly.warn("no target value given");
      return;
    }
    const operation = timelineBuilder.operation();
    const updateCallback = timelineBuilder.updateCallback();
    for (const object3d of objects) {
      const props = this._sceneGraphProps(object3d, this._propertyName);
      if (props) {
        const registerableProp = {
          object: object3d,
          propertyName: this._propertyName
        };
        let { targetProperty, toTarget, propertyNames } = props;
        const vars = animBuilderCommonVars(timelineBuilder);
        if (updateCallback && updateCallback.updateMatrix()) {
          const oldMatrixAutoUpdate = object3d.matrixAutoUpdate;
          vars.onUpdate = () => {
            object3d.matrixAutoUpdate = true;
          };
          vars.onComplete = () => {
            object3d.matrixAutoUpdate = oldMatrixAutoUpdate;
            if (!object3d.matrixAutoUpdate) {
              object3d.updateMatrix();
            }
          };
        }
        if (targetProperty instanceof Quaternion && this._targetValue instanceof Quaternion) {
          toTarget = populateVarsAndCreateProxyForQuaternion({
            targetValue: this._targetValue,
            vars,
            targetProperty
          });
        }
        this._populateVarsForObjectProperty({
          targetValue: this._targetValue,
          vars,
          targetProperty,
          propertyNames,
          operation
        });
        if (toTarget) {
          animBuilderStartTimeline({ ...options, vars, target: toTarget, registerableProp });
        }
      }
    }
  }
  _populateVarsForObjectProperty(options) {
    const { vars, targetValue, targetProperty, propertyNames, operation } = options;
    function warnMismatch(expectedType) {
      Poly.warn(
        `mismatch between targetValue and targetProperty (expected ${expectedType})`,
        targetValue,
        targetProperty
      );
    }
    if (CoreType.isNumber(targetProperty)) {
      if (CoreType.isNumber(targetValue)) {
        return populateVarsForNumber({ targetValue, vars, targetProperty, propertyNames, operation });
      }
      return warnMismatch("number");
    }
    if (CoreType.isEuler(targetProperty)) {
      if (targetValue instanceof Vector3) {
        return populateVarsForEuler({ targetValue, vars, targetProperty, propertyNames, operation });
      }
      return warnMismatch("euler");
    }
    if (CoreType.isVector(targetProperty)) {
      if (CoreType.isVector(targetValue)) {
        return populateVarsForVector({ targetValue, vars, targetProperty, propertyNames, operation });
      }
      return warnMismatch("vector");
    }
    if (CoreType.isColor(targetProperty)) {
      if (CoreType.isColor(targetValue)) {
        return populateVarsForColor({ targetValue, vars, targetProperty, propertyNames, operation });
      }
      return warnMismatch("color");
    }
    if (CoreType.isQuaternion(targetProperty)) {
    }
    Poly.warn(`targetValue and targetProp are not recognized types`, targetValue, targetProperty);
  }
  _sceneGraphProps(object, propertyName) {
    const elements = propertyName.split(PROPERTY_SEPARATOR);
    if (elements.length > 1) {
      const firstElement = elements.shift();
      const subObject = object[firstElement];
      if (subObject) {
        const subPropertyName = elements.join(PROPERTY_SEPARATOR);
        return this._sceneGraphProps(subObject, subPropertyName);
      } else {
        Poly.warn(`property ${firstElement} not found on object`, object);
      }
    } else {
      const targetProperty = object[propertyName];
      let toTarget = null;
      const propertyNames = [];
      if (CoreType.isNumber(targetProperty)) {
        toTarget = object;
        propertyNames.push(propertyName);
      } else {
        toTarget = targetProperty;
        if (this._targetValue instanceof Vector2) {
          propertyNames.push("x", "y");
        }
        if (this._targetValue instanceof Vector3) {
          propertyNames.push("x", "y", "z");
        }
        if (this._targetValue instanceof Vector4) {
          propertyNames.push("x", "y", "z", "w");
        }
        if (this._targetValue instanceof Color) {
          propertyNames.push("r", "g", "b");
        }
        if (this._targetValue instanceof Quaternion) {
        }
      }
      return {
        targetProperty,
        toTarget,
        propertyNames
      };
    }
  }
  _populateWithNode(node, options) {
    this._printDebug(["_populateWithNode", node]);
    const targetParam = node.p[this._propertyName];
    this._printDebug(["targetParam", targetParam]);
    if (!targetParam) {
      Poly.warn(`${this._propertyName} not found on node ${node.path()}`);
      return;
    }
    if (targetParam) {
      this._populateVarsForParam(targetParam, options);
    }
  }
  _populateVarsForParam(param, options) {
    this._printDebug(["_populateVarsForParam", param]);
    if (this._targetValue == null) {
      return;
    }
    switch (param.type()) {
      case ParamType.INTEGER:
      case ParamType.FLOAT: {
        return populateVarsForSingleNumber(param, this._targetValue, options);
      }
      case ParamType.VECTOR2: {
        return populateVarsForParamVector2(param, this._targetValue, options);
      }
      case ParamType.VECTOR3: {
        return populateVarsForParamVector3(param, this._targetValue, options);
      }
      case ParamType.COLOR: {
        return populateVarsForParamColor(param, this._targetValue, options);
      }
      case ParamType.VECTOR4: {
        return populateVarsForParamVector4(param, this._targetValue, options);
      }
    }
    Poly.warn(`param type cannot be animated (yet): '${param.type()}' '${param.path()}'`);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/thirdParty/gsap/gsapFactory.js
var GSAP_FACTORY = {
  gsap: void 0,
  timeline: (vars) => {
    return void 0;
  }
};
function gsapTimeline(vars) {
  return GSAP_FACTORY.timeline(vars);
}

// node_modules/@polygonjs/polygonjs/dist/src/core/animation/TimelineBuilder.js
var TimelineBuilder = class _TimelineBuilder {
  constructor() {
    this._timelineBuilders = [];
    this._duration = 1;
    this._operation = Operation.SET;
    this._delay = 0;
    this._stoppable = true;
    this._debug = false;
  }
  setDebug(debug) {
    this._debug = debug;
  }
  _printDebug(message) {
    if (!this._debug) {
      return;
    }
    console.log(message);
  }
  addTimelineBuilder(timeline_builder) {
    this._timelineBuilders.push(timeline_builder);
    timeline_builder.setParent(this);
  }
  timelineBuilders() {
    return this._timelineBuilders;
  }
  setParent(parent) {
    this._parent = parent;
  }
  parent() {
    return this._parent;
  }
  setTarget(target4) {
    this._target = target4;
    for (const builder of this._timelineBuilders) {
      builder.setTarget(target4);
    }
  }
  target() {
    return this._target;
  }
  setDuration(duration) {
    if (duration >= 0) {
      this._duration = duration;
      for (const builder of this._timelineBuilders) {
        builder.setDuration(duration);
      }
    }
  }
  duration() {
    return this._duration;
  }
  setKeyframes(keyframes) {
    this._keyframes = keyframes;
  }
  keyframes() {
    return this._keyframes;
  }
  setEasing(easing) {
    this._easing = easing;
    for (const builder of this._timelineBuilders) {
      builder.setEasing(easing);
    }
  }
  easing() {
    return this._easing;
  }
  setOperation(operation) {
    this._operation = operation;
    for (const builder of this._timelineBuilders) {
      builder.setOperation(operation);
    }
  }
  operation() {
    return this._operation;
  }
  setRepeatParams(repeat_params) {
    this._repeatParams = repeat_params;
    for (const builder of this._timelineBuilders) {
      builder.setRepeatParams(repeat_params);
    }
  }
  repeatParams() {
    return this._repeatParams;
  }
  setDelay(delay) {
    this._delay = delay;
    for (const builder of this._timelineBuilders) {
      builder.setDelay(delay);
    }
  }
  delay() {
    return this._delay;
  }
  setPosition(position) {
    this._position = position;
  }
  position() {
    return this._position;
  }
  setStoppable(state) {
    this._stoppable = state;
  }
  stoppable() {
    return this._stoppable;
  }
  setUpdateCallback(update_callback) {
    this._updateCallback = update_callback;
  }
  updateCallback() {
    return this._updateCallback;
  }
  // merge(timeline_builder?: TimelineBuilder) {
  // 	if (!timeline_builder) {
  // 		return;
  // 	}
  // }
  clone() {
    const newTimelineBuilder = new _TimelineBuilder();
    newTimelineBuilder.setDuration(this._duration);
    newTimelineBuilder.setOperation(this._operation);
    newTimelineBuilder.setDelay(this._delay);
    if (this._target) {
      newTimelineBuilder.setTarget(this._target.clone());
    }
    if (this._easing) {
      newTimelineBuilder.setEasing(this._easing);
    }
    if (this._keyframes) {
      newTimelineBuilder.setKeyframes(this._keyframes);
    }
    if (this._delay) {
      newTimelineBuilder.setDelay(this._delay);
    }
    if (this._updateCallback) {
      newTimelineBuilder.setUpdateCallback(this._updateCallback.clone());
    }
    if (this._repeatParams) {
      newTimelineBuilder.setRepeatParams({
        count: this._repeatParams.count,
        delay: this._repeatParams.delay,
        yoyo: this._repeatParams.yoyo
      });
    }
    if (this._property) {
      const name = this._property.name();
      if (name) {
        newTimelineBuilder.setPropertyName(name);
      }
      const targetValue = this._property.targetValue();
      if (targetValue != null) {
        newTimelineBuilder.setPropertyValue(targetValue);
      }
    }
    if (this._position) {
      newTimelineBuilder.setPosition(this._position.clone());
    }
    newTimelineBuilder.setStoppable(this._stoppable);
    for (const childTimelineBuilder of this._timelineBuilders) {
      const newChildTimelineBuilder = childTimelineBuilder.clone();
      newTimelineBuilder.addTimelineBuilder(newChildTimelineBuilder);
    }
    return newTimelineBuilder;
  }
  setPropertyName(name) {
    this.property().setName(name);
  }
  property() {
    return this._property = this._property || new TimelineBuilderProperty();
  }
  propertyName() {
    return this.property().name();
  }
  setPropertyValue(value) {
    this.property().setTargetValue(value);
  }
  propertyValue() {
    var _a;
    return (_a = this._property) == null ? void 0 : _a.targetValue();
  }
  populate(timeline, options) {
    var _a;
    this._printDebug(["populate", this, timeline, this._timelineBuilders]);
    for (const timelineBuilder of this._timelineBuilders) {
      const subTimeline = gsapTimeline();
      if (!subTimeline) {
        continue;
      }
      timelineBuilder.setDebug(this._debug);
      timelineBuilder.populate(subTimeline, options);
      const position_param = ((_a = timelineBuilder.position()) == null ? void 0 : _a.toParameter()) || void 0;
      timeline.add(subTimeline, position_param);
    }
    if (this._property && this._target) {
      this._property.setDebug(this._debug);
      this._property.addToTimeline({ timelineBuilder: this, timeline, target: this._target, ...options });
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/audio/AudioBuilder.js
var AudioBuilder = class _AudioBuilder {
  setAudioNode(inputNode) {
    this._audioNode = inputNode;
  }
  audioNode() {
    return this._audioNode;
  }
  setSource(source) {
    this._source = source;
    if (!this._audioNode) {
      this.setAudioNode(source);
    }
  }
  source() {
    return this._source;
  }
  setInstrument(instrument) {
    this._instrument = instrument;
    if (!this._audioNode) {
      this.setAudioNode(instrument);
    }
  }
  instrument() {
    return this._instrument;
  }
  setOscillatorParams(params) {
    this._oscillatorParams = params;
  }
  oscillatorParams() {
    return this._oscillatorParams;
  }
  setEnvelopeParams(params) {
    this._envelopeParams = params;
  }
  envelopeParams() {
    return this._envelopeParams;
  }
  clone() {
    const newAudioBuilder = new _AudioBuilder();
    newAudioBuilder.setAudioNode(this._audioNode);
    newAudioBuilder.setSource(this._source);
    newAudioBuilder.setInstrument(this._instrument);
    newAudioBuilder.setEnvelopeParams(this._envelopeParams);
    return newAudioBuilder;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/utils/ContainableMap.js
var ContainableClassMap = {
  [NodeContext.ANIM]: TimelineBuilder,
  [NodeContext.AUDIO]: AudioBuilder,
  [NodeContext.COP]: Texture,
  [NodeContext.EVENT]: String,
  [NodeContext.GL]: String,
  [NodeContext.JS]: String,
  [NodeContext.MANAGER]: Boolean,
  [NodeContext.MAT]: Material,
  [NodeContext.OBJ]: Object3D,
  [NodeContext.ROP]: String,
  [NodeContext.POST]: Number,
  [NodeContext.SOP]: CoreGroup
  // JS: JsContainer;
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/_Base.js
var TypedContainer = class {
  constructor(_node) {
    this._node = _node;
  }
  set_node(node) {
    this._node = node;
  }
  node() {
    return this._node;
  }
  // clone() {
  // 	let content;
  // 	const cloned_container = new (<any>this.constructor)() as TypedContainer<T>;
  // 	cloned_container.set_node(this.node());
  // 	if ((content = this.content()) != null) {
  // 		cloned_container.set_content(content); //, this.eval_key() );
  // 	}
  // 	return cloned_container;
  // }
  // reset_caches() {}
  set_content(content) {
    this._content = content;
    this._post_set_content();
  }
  has_content() {
    return this._content != null;
  }
  content() {
    return this._content;
  }
  _post_set_content() {
  }
  coreContent() {
    return this._content;
  }
  coreContentCloned() {
    return this._content;
  }
  // abstract clone_content(): T
  // update_eval_key(eval_key?: number){
  // 	this._eval_key = eval_key || performance.now();
  // }
  // eval_key(): number {
  // 	return this._eval_key;
  // }
  infos() {
    return [];
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Animation.js
var AnimationContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
  setTimelineBuilder(timeline_builder) {
    return this.set_content(timeline_builder);
  }
  timelineBuilder() {
    return this.content();
  }
  coreContentCloned() {
    if (this._content) {
      return this._content.clone();
    }
  }
  // infos() {
  // 	const node = this.node()
  // 	return [
  // 		`full path: ${node.path()}`,
  // 		`${node.cooks_count()} cooks`,
  // 		`cook time: ${node.cook_time()}`,
  // 		this.content(),
  // 	]
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Audio.js
var AudioContainer = class extends TypedContainer {
  setContent(content) {
    super.set_content(content);
  }
  setAudioBuilder(audioBuilder) {
    return this.set_content(audioBuilder);
  }
  audioBuilder() {
    return this.content();
  }
  coreContentCloned() {
    if (this._content) {
      return this._content.clone();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Event.js
var EventContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Geometry.js
var GeometryContainer = class extends TypedContainer {
  coreContentCloned() {
    if (this._content) {
      return this._content.clone();
    }
  }
  set_content(content) {
    super.set_content(content);
  }
  // pointsCount(): number {
  // 	if (this._content) {
  // 		return this._content.pointsCount();
  // 	} else {
  // 		return 0;
  // 	}
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Gl.js
var GlContainer = class extends TypedContainer {
  object() {
    return this._content;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Js.js
var JsContainer = class extends TypedContainer {
  object() {
    return this._content;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Manager.js
var ManagerContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Material.js
var MaterialContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
  coreContentCloned() {
    if (this._content) {
      const cloned = CoreMaterial.clone(this._node.scene(), this._content, {
        shareCustomUniforms: true,
        addCustomMaterials: true
      });
      return cloned;
    }
  }
  set_material(material) {
    if (this._content != null) {
      this._content.dispose();
    }
    this.set_content(material);
  }
  has_material() {
    return this.has_content();
  }
  material() {
    return this.content();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Object.js
var ObjectContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
  set_object(object) {
    return this.set_content(object);
  }
  has_object() {
    return this.has_content();
  }
  object() {
    return this.content();
  }
  // infos() {
  // 	const node = this.node()
  // 	return [
  // 		`full path: ${node.path()}`,
  // 		`${node.cooks_count()} cooks`,
  // 		`cook time: ${node.cook_time()}`,
  // 		this.content(),
  // 	]
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Texture.js
var TextureContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
  texture() {
    return this._content;
  }
  coreContent() {
    return this._content;
  }
  coreContentCloned() {
    var _a;
    const texture = (_a = this._content) == null ? void 0 : _a.clone();
    if (texture) {
      texture.needsUpdate = true;
    }
    return texture;
  }
  object() {
    return this.texture();
  }
  infos() {
    if (this._content != null) {
      return [this._content];
    }
  }
  resolution() {
    function _resolutionFromHTMLVideoElement(video) {
      return [video.videoWidth, video.videoHeight];
    }
    if (this._content) {
      const image = this._content.image;
      if (image) {
        if (image instanceof HTMLImageElement || image instanceof Image || image instanceof ImageData || image instanceof HTMLCanvasElement) {
          return [image.width, image.height];
        }
        if (image instanceof HTMLVideoElement) {
          return _resolutionFromHTMLVideoElement(image);
        }
        if (CoreType.isNumber(image.width) && CoreType.isNumber(image.height)) {
          return [image.width, image.height];
        }
      }
      const source = this._content.source;
      if (source) {
        if (source instanceof HTMLVideoElement) {
          return _resolutionFromHTMLVideoElement(source);
        }
        const data = source.data;
        if (data && CoreType.isNumber(data.width) && CoreType.isNumber(data.height)) {
          return [data.width, data.height];
        }
      }
    }
    return [-1, -1];
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/PostProcess.js
var PostProcessContainer = class extends TypedContainer {
  // _content: any;
  // constructor() {
  // 	super();
  // }
  set_content(content) {
    super.set_content(content);
  }
  render_pass() {
    return this._content;
  }
  object(options = {}) {
    return this.render_pass();
  }
  // infos() {
  // 	if (this._content) {
  // 		return [this._content];
  // 	}
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/Rop.js
var RopContainer = class extends TypedContainer {
  set_content(content) {
    super.set_content(content);
  }
  renderer() {
    return this._content;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/containers/utils/ContainerMap.js
var ContainerClassMap = {
  [NodeContext.ANIM]: AnimationContainer,
  [NodeContext.AUDIO]: AudioContainer,
  [NodeContext.COP]: TextureContainer,
  [NodeContext.EVENT]: EventContainer,
  [NodeContext.GL]: GlContainer,
  [NodeContext.JS]: JsContainer,
  [NodeContext.MANAGER]: ManagerContainer,
  [NodeContext.MAT]: MaterialContainer,
  [NodeContext.OBJ]: ObjectContainer,
  [NodeContext.ROP]: RopContainer,
  [NodeContext.POST]: PostProcessContainer,
  [NodeContext.SOP]: GeometryContainer
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/ContainerController.js
var TypedContainerController = class {
  constructor(node) {
    this.node = node;
    this._callbacks = [];
    this._callbacksTmp = [];
    this._container = this._createContainer();
  }
  container() {
    return this._container;
  }
  _createContainer() {
    const ContainerClass = ContainerClassMap[this.node.context()];
    return new ContainerClass(this.node);
  }
  _createContainerWithContent() {
    const container = this._createContainer();
    const ContentClass = ContainableClassMap[this.node.context()];
    const content = new ContentClass();
    container.set_content(content);
    return container;
  }
  firstNonBypassedNode() {
    var _a, _b;
    if ((_b = (_a = this.node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active()) {
      const inputNode = this.node.io.inputs.input(0);
      return inputNode;
    } else {
      return this.node;
    }
  }
  containerUnlessBypassed() {
    var _a, _b;
    if ((_b = (_a = this.node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active()) {
      this.node.states.error.clear();
      const inputNode = this.node.io.inputs.input(0);
      if (inputNode) {
        return inputNode.containerController.containerUnlessBypassed();
      } else {
        return this._createContainerWithContent();
      }
    } else {
      return this.container();
    }
  }
  async compute() {
    var _a, _b;
    if (this.node.disposed()) {
      console.warn(".compute() requested from a disposed node", this.node);
    }
    if ((_b = (_a = this.node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active()) {
      this.node.states.error.clear();
      const inputNode = this.node.io.inputs.input(0);
      if (inputNode) {
        const container = await this.requestInputContainer(0) || this._container;
        this.node.cookController.endCook();
        return container;
      } else {
        return this._createContainerWithContent();
      }
    }
    if (this.node.isDirty()) {
      return new Promise((resolve, reject) => {
        var _a2, _b2;
        this._callbacks.push(resolve);
        if ((_b2 = (_a2 = this.node.flags) == null ? void 0 : _a2.bypass) == null ? void 0 : _b2.active()) {
          throw "we should not be here";
        }
        this.node.cookController.cookMain();
      });
    }
    return this._container;
  }
  // async requestContainerTEST(): Promise<ContainerMap[NC]> {
  // 	if (this.node.flags?.bypass?.active()) {
  // 		const container = await this.requestInputContainer(0);
  // 		return container || this._container;
  // 	}
  // 	if (this.node.isDirty()) {
  // 		await this.node.cookController.cook_main();
  // 	}
  // 	return this._container;
  // }
  // TODO: should I merge this into the method above?
  // private process_container_request() {
  // 	if (this.node.flags?.bypass?.active()) {
  // 		const input_index = 0;
  // 		this.requestInputContainer(input_index).then((container) => {
  // 			this.node.removeDirtyState();
  // 			if (container) {
  // 				this.notify_requesters(container);
  // 			} else {
  // 				this.node.states.error.set('input invalid');
  // 			}
  // 		});
  // 	} else {
  // 		if (this.node.isDirty()) {
  // 			this.node.cookController.cook_main();
  // 		} else {
  // 			this.notify_requesters();
  // 		}
  // 	}
  // }
  async requestInputContainer(inputIndex) {
    const inputNode = this.node.io.inputs.input(inputIndex);
    if (inputNode) {
      return await inputNode.compute();
    } else {
      this.node.states.error.set(`input ${inputIndex} required`);
      this.notifyRequesters();
      return null;
    }
  }
  notifyRequesters(container) {
    this._callbacksTmp = this._callbacks.slice();
    this._callbacks.splice(0, this._callbacks.length);
    if (!container) {
      container = this.node.containerController.container();
    }
    let callback;
    while (callback = this._callbacksTmp.pop()) {
      callback(container);
    }
    this.node.scene().cookController.removeNode(this.node);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/cook/PerformanceController.js
var performance2 = Poly.performance.performanceManager();
var NodeCookPerformanceformanceController = class {
  constructor(cookController) {
    this.cookController = cookController;
    this._inputsStart = 0;
    this._inputsTime = 0;
    this._paramsStart = 0;
    this._paramsTime = 0;
    this._cookStart = 0;
    this._cookTime = 0;
    this._cooksCount = 0;
    this._data = {
      inputsTime: 0,
      paramsTime: 0,
      cookTime: 0
    };
  }
  cooksCount() {
    return this._cooksCount;
  }
  data() {
    this._data.inputsTime = this._inputsTime;
    this._data.paramsTime = this._paramsTime;
    this._data.cookTime = this._cookTime;
    return this._data;
  }
  active() {
    return this.cookController.performanceRecordStarted();
  }
  //
  // INPUTS
  //
  recordInputsStart() {
    if (this.active()) {
      this._inputsStart = performance2.now();
    }
  }
  recordInputsEnd() {
    if (this.active()) {
      this._inputsTime = performance2.now() - this._inputsStart;
    }
  }
  //
  // PARAMS
  //
  recordParamsStart() {
    if (this.active()) {
      this._paramsStart = performance2.now();
    }
  }
  recordParamsEnd() {
    if (this.active()) {
      this._paramsTime = performance2.now() - this._paramsStart;
    }
  }
  //
  // COOK
  //
  recordCookStart() {
    if (this.active()) {
      this._cookStart = performance2.now();
    }
  }
  recordCookEnd() {
    if (this.active()) {
      this._cookTime = performance2.now() - this._cookStart;
      this._cooksCount += 1;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/reactivity/NodeReactivity.js
var refByNodePath = /* @__PURE__ */ new Map();
function getNodeRef(nodePath) {
  return refByNodePath.get(nodePath);
}
function touchNodeRef(nodePath) {
  const _ref = getNodeRef(nodePath);
  if (!_ref) {
    return;
  }
  incrementRefSafely(_ref);
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/CookController.js
var ErrorType = ((ErrorType2) => {
  ErrorType2["FROM_INPUTS"] = "node inputs error";
  ErrorType2["INTERNAL"] = "node internal error";
  return ErrorType2;
})(ErrorType || {});
var NodeCookController = class {
  constructor(node) {
    this.node = node;
    this._cooking = false;
    this._performanceController = new NodeCookPerformanceformanceController(
      this
    );
    this._inputContainers = [];
    this._inputContents = [];
    this._EMPTY_ARRAY = [];
    this._inputsEvaluationRequired = true;
    this._corePerformance = this.node.scene().performance;
  }
  performanceRecordStarted() {
    return this._corePerformance.started();
  }
  dispose() {
    this._clearHooks();
  }
  disallowInputsEvaluation() {
    this._inputsEvaluationRequired = false;
  }
  isCooking() {
    return this._cooking === true;
  }
  _startCookIfNoErrors(inputContents) {
    if (this.node.states.error.active() || this.node.disposed() == true) {
      this.endCook();
    } else {
      try {
        this._performanceController.recordCookStart();
        const promise = this.node.cook(inputContents);
        if (promise != null) {
          promise.catch((e) => {
            this._onError(e, "node internal error", false);
          });
        }
      } catch (e) {
        this._onError(
          e,
          "node internal error"
          /* INTERNAL */
        );
      }
    }
  }
  async cookMain() {
    if (this.isCooking()) {
      return;
    }
    if (this.node.disposed() == true) {
      return;
    }
    this._initCookingState();
    this.node.states.error.clear();
    this.node.scene().cookController.addNode(this.node);
    try {
      this._inputContents.length = 0;
      if (this._inputsEvaluationRequired) {
        await this._evaluateInputs(this._inputContents);
      }
      if (this.node.params.paramsEvalRequired()) {
        await this._evaluateParams();
      }
      this._startCookIfNoErrors(this._inputContents);
    } catch (e) {
      this._onError(
        e,
        "node inputs error"
        /* FROM_INPUTS */
      );
    }
  }
  _onError(e, errorType, alwaysSet = true) {
    if (alwaysSet || !this.node.states.error.active()) {
      const processedError = this.node.processError(e);
      this.node.states.error.set(`${errorType}: '${processedError}'.`);
      Poly.warn(e);
    }
    this.endCook();
  }
  async cookMainWithoutInputs() {
    this.node.scene().cookController.addNode(this.node);
    if (this.isCooking()) {
      Poly.warn("cook_main_without_inputs already cooking", this.node.path());
      return;
    }
    this._initCookingState();
    this.node.states.error.clear();
    if (this.node.params.paramsEvalRequired()) {
      await this._evaluateParams();
    }
    this._startCookIfNoErrors(this._EMPTY_ARRAY);
  }
  endCook() {
    var _a, _b;
    this._finalizeCookPerformance();
    const dirtyTimestamp = this.node.dirtyController.dirtyTimestamp();
    const timestampUnchangedSinceCookStarted = dirtyTimestamp == null || dirtyTimestamp === this._cookingDirtyTimestamp;
    if (timestampUnchangedSinceCookStarted || ((_b = (_a = this.node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
      this.node.removeDirtyState();
      this._terminateCookProcess();
    } else {
      if (this.node.disposed() == true) {
        return;
      }
      Poly.log("COOK AGAIN", dirtyTimestamp, this._cookingDirtyTimestamp, this.node.path());
      this._cooking = false;
      this.cookMain();
    }
  }
  // private _lastFrameCooked: number | undefined;
  // private _scenePlayingAndNodeAlreadyCookedForCurrentFrame() {
  // 	if (this.node.scene().timeController.playing()) {
  // 		return this._lastFrameCooked == this.node.scene().frame();
  // 	}
  // 	return false;
  // }
  _initCookingState() {
    this._cooking = true;
    this._cookingDirtyTimestamp = this.node.dirtyController.dirtyTimestamp();
  }
  _terminateCookProcess() {
    var _a, _b;
    if (this.isCooking() || ((_b = (_a = this.node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
      this._cooking = false;
      this.node.containerController.notifyRequesters();
      this._runOnCookCompleteHooks();
      if (this.node.disposed() == true) {
        return;
      }
      touchNodeRef(this.node.path());
    }
  }
  async _evaluateInputs(inputContents) {
    this._performanceController.recordInputsStart();
    const ioOnputs = this.node.io.inputs;
    this._inputContainers.length = 0;
    if (this._inputsEvaluationRequired) {
      if (ioOnputs.isGraphNodeDirty()) {
        await ioOnputs.evalRequiredInputs(this._inputContainers);
      } else {
        ioOnputs.containersWithoutEvaluation(this._inputContainers);
      }
    }
    const inputs = ioOnputs.inputs();
    let inputContainer;
    for (let i = 0; i < inputs.length; i++) {
      inputContainer = this._inputContainers[i];
      if (inputContainer) {
        if (ioOnputs.cloneRequired(i)) {
          inputContents[i] = inputContainer.coreContentCloned();
        } else {
          inputContents[i] = inputContainer.coreContent();
        }
      }
    }
    this._performanceController.recordInputsEnd();
    return inputContents;
  }
  async _evaluateParams() {
    this._performanceController.recordParamsStart();
    await this.node.params.evalAll();
    this._performanceController.recordParamsEnd();
  }
  //
  //
  // PERFORMANCE
  //
  //
  cooksCount() {
    return this._performanceController.cooksCount();
  }
  cookTime() {
    return this._performanceController.data().cookTime;
  }
  _finalizeCookPerformance() {
    if (!this._corePerformance.started()) {
      return;
    }
    this._performanceController.recordCookEnd();
    this._corePerformance.recordNodeCookData(this.node, this._performanceController.data());
  }
  registerOnCookEnd(callbackName, callback) {
    this._onCookCompleteHookNames = this._onCookCompleteHookNames || [];
    this._onCookCompleteHooks = this._onCookCompleteHooks || [];
    this._onCookCompleteHookNames.push(callbackName);
    this._onCookCompleteHooks.push(callback);
  }
  _clearHooks() {
    if (!this._onCookCompleteHookNames || !this._onCookCompleteHooks) {
      return;
    }
    for (const hookName of this._onCookCompleteHookNames) {
      this.deregisterOnCookEnd(hookName);
    }
  }
  deregisterOnCookEnd(callbackName) {
    var _a;
    if (!this._onCookCompleteHookNames || !this._onCookCompleteHooks) {
      return;
    }
    const index = (_a = this._onCookCompleteHookNames) == null ? void 0 : _a.indexOf(callbackName);
    this._onCookCompleteHookNames.splice(index, 1);
    this._onCookCompleteHooks.splice(index, 1);
    if (this._onCookCompleteHookNames.length == 0) {
      this._onCookCompleteHookNames = void 0;
    }
    if (this._onCookCompleteHooks.length == 0) {
      this._onCookCompleteHooks = void 0;
    }
  }
  _runOnCookCompleteHooks() {
    if (this._onCookCompleteHooks) {
      const hooks2 = [...this._onCookCompleteHooks];
      for (let hook of hooks2) {
        hook();
      }
    }
  }
  onCookEndCallbackNames() {
    return this._onCookCompleteHookNames;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Boolean.js
var BooleanParam = class extends TypedNumericParam {
  static type() {
    return ParamType.BOOLEAN;
  }
  // TODO: be careful as this does not allow serialization of expressions as default value
  defaultValueSerialized() {
    if (CoreType.isString(this._default_value)) {
      return this._default_value;
    } else {
      return this.convert(this._default_value) || false;
    }
  }
  rawInputSerialized() {
    return this._raw_input;
  }
  valueSerialized() {
    return this.value;
  }
  _copyValue(param) {
    this.set(param.value);
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  convert(raw_val) {
    if (CoreType.isBoolean(raw_val)) {
      return raw_val;
    } else {
      if (CoreType.isNumber(raw_val)) {
        return raw_val >= 1;
      } else {
        if (CoreType.isString(raw_val)) {
          if (CoreString.isBoolean(raw_val)) {
            return CoreString.toBoolean(raw_val);
          } else {
            if (CoreString.isNumber(raw_val)) {
              const parsed = parseFloat(raw_val);
              return parsed >= 1;
            }
          }
        }
      }
    }
    return null;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Button.js
var ButtonParam = class extends TypedParam {
  static type() {
    return ParamType.BUTTON;
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return this._raw_input;
  }
  valueSerialized() {
    return this.value;
  }
  _copyValue(param) {
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return true;
  }
  static areValuesEqual(val1, val2) {
    return true;
  }
  async pressButton() {
    if (this.node.isDirty() || this.node.cookController.isCooking()) {
      await this.node.compute();
    }
    await this.options.executeCallback();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Color.js
var COMPONENT_NAMES_COLOR = ["r", "g", "b"];
var tmp2 = [0, 0, 0];
function colorEqualsStringNumber3(c, array) {
  return c.r == array[0] && c.g == array[1] && c.b == array[2];
}
function stringNumber3Equals(array1, array2) {
  return array1[0] == array2[0] && array1[1] == array2[1] && array1[2] == array2[2];
}
var ColorParam = class extends TypedMultipleParam {
  constructor() {
    super(...arguments);
    this._value = new Color();
    this._valuePreConversion = new Color();
    this._valueSerializedDirty = false;
    this._valueSerialized = [0, 0, 0];
    this._valuePreConversionSerialized = [0, 0, 0];
    this._copiedValue = [0, 0, 0];
  }
  static type() {
    return ParamType.COLOR;
  }
  componentNames() {
    return COMPONENT_NAMES_COLOR;
  }
  defaultValueSerialized() {
    if (CoreType.isArray(this._default_value)) {
      return this._default_value;
    } else {
      return this._default_value.toArray();
    }
  }
  _prefilterInvalidRawInput(rawInput) {
    if (rawInput instanceof Color) {
      rawInput.toArray(tmp2);
      return tmp2;
    }
    return super._prefilterInvalidRawInput(rawInput);
  }
  // rawInputSerialized() {
  // 	if (this._raw_input instanceof Color) {
  // 		return this._raw_input.toArray() as Number3;
  // 	} else {
  // 		const new_array: StringOrNumber3 = [this._raw_input[0], this._raw_input[1], this._raw_input[2]];
  // 		return new_array;
  // 	}
  // }
  valueSerialized() {
    this._updateValueSerializedIfRequired();
    return this._valueSerialized;
  }
  valuePreConversionSerialized() {
    this._updateValueSerializedIfRequired();
    return this._valuePreConversionSerialized;
  }
  _copyValue(param) {
    param.value.toArray(this._copiedValue);
    this.set(this._copiedValue);
  }
  // protected _prefilterInvalidRawInput(
  // 	raw_input: ParamInitValuesTypeMap[ParamType.COLOR]
  // ): ParamInitValuesTypeMap[ParamType.COLOR] {
  // 	return raw_input;
  // }
  _cloneRawInput(raw_input) {
    if (raw_input instanceof Color) {
      return raw_input.clone();
    } else {
      const new_array = [raw_input[0], raw_input[1], raw_input[2]];
      if (new_array[0] == null) {
        new_array[0] = new_array[0] || 0;
      }
      if (new_array[1] == null) {
        new_array[1] = new_array[1] || new_array[0];
      }
      if (new_array[2] == null) {
        new_array[2] = new_array[2] || new_array[1];
      }
      return new_array;
    }
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    if (raw_input1 instanceof Color) {
      if (raw_input2 instanceof Color) {
        return raw_input1.equals(raw_input2);
      } else {
        return colorEqualsStringNumber3(raw_input1, raw_input2);
      }
    } else {
      if (raw_input2 instanceof Color) {
        return colorEqualsStringNumber3(raw_input2, raw_input1);
      } else {
        return stringNumber3Equals(raw_input1, raw_input2);
      }
    }
  }
  static areValuesEqual(val1, val2) {
    return val1.equals(val2);
  }
  initComponents() {
    super.initComponents();
    this.r = this.components[0];
    this.g = this.components[1];
    this.b = this.components[2];
    this._valueSerializedDirty = true;
  }
  postOptionsInitialize() {
    this.setValueFromComponents();
  }
  _updateValueSerializedIfRequired() {
    if (!this._valueSerializedDirty) {
      return;
    }
    this._valueSerialized[0] = this._value.r;
    this._valueSerialized[1] = this._value.g;
    this._valueSerialized[2] = this._value.b;
    this._valuePreConversionSerialized[0] = this._valuePreConversion.r;
    this._valuePreConversionSerialized[1] = this._valuePreConversion.g;
    this._valuePreConversionSerialized[2] = this._valuePreConversion.b;
  }
  valuePreConversion() {
    return this._valuePreConversion;
  }
  async setConversion(conversion) {
    this.options.setOption("conversion", conversion);
    this.setDirty();
    await this.options.executeCallback();
  }
  setValueFromComponents() {
    this._valuePreConversion.r = this.r.value;
    this._valuePreConversion.g = this.g.value;
    this._valuePreConversion.b = this.b.value;
    this._value.copy(this._valuePreConversion);
    this._applyColorConversion();
    this._valueSerializedDirty = true;
  }
  _applyColorConversion() {
    const conversion = this.options.colorConversion();
    switch (conversion) {
      case ColorConversion.NONE: {
        return;
      }
      case ColorConversion.SRGB_TO_LINEAR: {
        this._value.convertSRGBToLinear();
        return;
      }
      case ColorConversion.LINEAR_TO_SRGB: {
        this._value.convertLinearToSRGB();
        return;
      }
    }
    TypeAssert.unreachable(conversion);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Folder.js
var FolderParam = class extends TypedParam {
  static type() {
    return ParamType.FOLDER;
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return this._raw_input;
  }
  valueSerialized() {
    return this.value;
  }
  _copyValue(param) {
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return true;
  }
  static areValuesEqual(val1, val2) {
    return true;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Integer.js
var IntegerParam = class _IntegerParam extends TypedNumericParam {
  static type() {
    return ParamType.INTEGER;
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return this._raw_input;
  }
  valueSerialized() {
    return this.value;
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  _prefilterInvalidRawInput(raw_input) {
    if (CoreType.isArray(raw_input)) {
      return raw_input[0];
    }
    if (CoreType.isString(raw_input) && CoreString.isNumber(raw_input)) {
      const num = parseInt(raw_input);
      if (num != null) {
        const converted = this.convert(num);
        if (converted != null) {
          return converted;
        }
      }
    }
    if (CoreType.isNumber(raw_input)) {
      const converted = this.convert(raw_input);
      if (converted != null) {
        return converted;
      }
    }
    return raw_input;
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  static convert(raw_val) {
    if (CoreType.isNumber(raw_val)) {
      return Math.round(raw_val);
    } else {
      if (CoreType.isBoolean(raw_val)) {
        return raw_val ? 1 : 0;
      } else {
        if (CoreString.isNumber(raw_val)) {
          const parsed = parseInt(raw_val);
          if (CoreType.isNumber(parsed)) {
            return parsed;
          }
        }
      }
      return null;
    }
  }
  convert(raw_val) {
    const result = _IntegerParam.convert(raw_val);
    if (result != null) {
      let validVal = this.options.ensureInRange(result);
      validVal = this.options.ensureValueInMenuEntries(validVal);
      return validVal;
    } else {
      return result;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Vector2.js
var COMPONENT_NAMES_VECTOR2 = ["x", "y"];
var tmp3 = [0, 0];
function vector2EqualsStringNumber2(v, array) {
  return v.x == array[0] && v.y == array[1];
}
function stringNumber2Equals(array1, array2) {
  return array1[0] == array2[0] && array1[1] == array2[1];
}
var Vector2Param = class extends TypedMultipleParam {
  constructor() {
    super(...arguments);
    this._value = new Vector2();
    this._copied_value = [0, 0];
  }
  static type() {
    return ParamType.VECTOR2;
  }
  componentNames() {
    return COMPONENT_NAMES_VECTOR2;
  }
  defaultValueSerialized() {
    if (CoreType.isArray(this._default_value)) {
      return this._default_value;
    } else {
      return this._default_value.toArray();
    }
  }
  _prefilterInvalidRawInput(rawInput) {
    if (rawInput instanceof Vector2) {
      rawInput.toArray(tmp3);
      return tmp3;
    }
    return super._prefilterInvalidRawInput(rawInput);
  }
  // get raw_input_serialized() {
  // 	if (this._raw_input instanceof Vector2) {
  // 		return this._raw_input.toArray() as Number2;
  // 	} else {
  // 		const new_array: StringOrNumber2 = [this._raw_input[0], this._raw_input[1]];
  // 		return new_array;
  // 	}
  // }
  valueSerialized() {
    return this.value.toArray();
  }
  _copyValue(param) {
    param.value.toArray(this._copied_value);
    this.set(this._copied_value);
  }
  _cloneRawInput(raw_input) {
    if (raw_input instanceof Vector2) {
      return raw_input.clone();
    } else {
      const new_array = [raw_input[0], raw_input[1]];
      if (new_array[0] == null) {
        new_array[0] = new_array[0] || 0;
      }
      if (new_array[1] == null) {
        new_array[1] = new_array[1] || new_array[0];
      }
      return new_array;
    }
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    if (raw_input1 instanceof Vector2) {
      if (raw_input2 instanceof Vector2) {
        return raw_input1.equals(raw_input2);
      } else {
        return vector2EqualsStringNumber2(raw_input1, raw_input2);
      }
    } else {
      if (raw_input2 instanceof Vector2) {
        return vector2EqualsStringNumber2(raw_input2, raw_input1);
      } else {
        return stringNumber2Equals(raw_input1, raw_input2);
      }
    }
  }
  static areValuesEqual(val1, val2) {
    return val1.equals(val2);
  }
  initComponents() {
    super.initComponents();
    this.x = this.components[0];
    this.y = this.components[1];
  }
  setValueFromComponents() {
    this._value.x = this.x.value;
    this._value.y = this.y.value;
  }
  // convert(input: any) {
  // 	if (CoreType.isArray(input)) {
  // 		return new Vector2().fromArray(input);
  // 	}
  // 	return new Vector2();
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Vector3.js
var COMPONENT_NAMES_VECTOR3 = ["x", "y", "z"];
var tmp4 = [0, 0, 0];
function vector3EqualsStringNumber3(v, array) {
  return v.x == array[0] && v.y == array[1] && v.z == array[2];
}
function stringNumber3Equals2(array1, array2) {
  return array1[0] == array2[0] && array1[1] == array2[1] && array1[2] == array2[2];
}
var Vector3Param = class extends TypedMultipleParam {
  constructor() {
    super(...arguments);
    this._value = new Vector3();
    this._copied_value = [0, 0, 0];
  }
  static type() {
    return ParamType.VECTOR3;
  }
  componentNames() {
    return COMPONENT_NAMES_VECTOR3;
  }
  defaultValueSerialized() {
    if (CoreType.isArray(this._default_value)) {
      return this._default_value;
    } else {
      return this._default_value.toArray();
    }
  }
  _prefilterInvalidRawInput(rawInput) {
    if (rawInput instanceof Vector3) {
      rawInput.toArray(tmp4);
      return tmp4;
    }
    return super._prefilterInvalidRawInput(rawInput);
  }
  // get raw_input_serialized() {
  // 	if (this._raw_input instanceof Vector3) {
  // 		return this._raw_input.toArray() as Number3;
  // 	} else {
  // 		const new_array: StringOrNumber3 = [this._raw_input[0], this._raw_input[1], this._raw_input[2]];
  // 		return new_array;
  // 	}
  // }
  valueSerialized() {
    return this.value.toArray();
  }
  _copyValue(param) {
    param.value.toArray(this._copied_value);
    this.set(this._copied_value);
  }
  _cloneRawInput(raw_input) {
    if (raw_input instanceof Vector3) {
      return raw_input.clone();
    } else {
      const new_array = [raw_input[0], raw_input[1], raw_input[2]];
      if (new_array[0] == null) {
        new_array[0] = new_array[0] || 0;
      }
      if (new_array[1] == null) {
        new_array[1] = new_array[1] || new_array[0];
      }
      if (new_array[2] == null) {
        new_array[2] = new_array[2] || new_array[1];
      }
      return new_array;
    }
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    if (raw_input1 instanceof Vector3) {
      if (raw_input2 instanceof Vector3) {
        return raw_input1.equals(raw_input2);
      } else {
        return vector3EqualsStringNumber3(raw_input1, raw_input2);
      }
    } else {
      if (raw_input2 instanceof Vector3) {
        return vector3EqualsStringNumber3(raw_input2, raw_input1);
      } else {
        return stringNumber3Equals2(raw_input1, raw_input2);
      }
    }
  }
  static areValuesEqual(val1, val2) {
    return val1.equals(val2);
  }
  initComponents() {
    super.initComponents();
    this.x = this.components[0];
    this.y = this.components[1];
    this.z = this.components[2];
  }
  // set_raw_input_from_components() {
  // 	if (this._raw_input instanceof Vector3) {
  // 		if (
  // 			CoreType.isNumber(this.x.raw_input) &&
  // 			CoreType.isNumber(this.y.raw_input) &&
  // 			CoreType.isNumber(this.z.raw_input)
  // 		) {
  // 			this._raw_input.x = this.x.raw_input;
  // 			this._raw_input.y = this.y.raw_input;
  // 			this._raw_input.z = this.z.raw_input;
  // 		} else {
  // 			this._raw_input = [this.x.raw_input, this.y.raw_input, this.z.raw_input];
  // 		}
  // 	} else {
  // 		this._raw_input[0] = this.x.raw_input;
  // 		this._raw_input[1] = this.y.raw_input;
  // 		this._raw_input[2] = this.z.raw_input;
  // 	}
  // }
  setValueFromComponents() {
    this._value.x = this.x.value;
    this._value.y = this.y.value;
    this._value.z = this.z.value;
  }
  // convert(input: ParamInitValuesTypeMap[ParamType.VECTOR3]) {
  // 	if (CoreType.isArray(input)) {
  // 		return new Vector3().fromArray(input);
  // 	}
  // 	return new Vector3();
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/Vector4.js
var COMPONENT_NAMES_VECTOR4 = ["x", "y", "z", "w"];
var tmp5 = [0, 0, 0, 0];
function vector2EqualsStringNumber4(v, array) {
  return v.x == array[0] && v.y == array[1] && v.z == array[2] && v.w == array[3];
}
function stringNumber4Equals(array1, array2) {
  return array1[0] == array2[0] && array1[1] == array2[1] && array1[2] == array2[2] && array1[3] == array2[3];
}
var Vector4Param = class extends TypedMultipleParam {
  constructor() {
    super(...arguments);
    this._value = new Vector4();
    this._copied_value = [0, 0, 0, 0];
  }
  static type() {
    return ParamType.VECTOR4;
  }
  componentNames() {
    return COMPONENT_NAMES_VECTOR4;
  }
  defaultValueSerialized() {
    if (CoreType.isArray(this._default_value)) {
      return this._default_value;
    } else {
      return this._default_value.toArray();
    }
  }
  _prefilterInvalidRawInput(rawInput) {
    if (rawInput instanceof Vector4) {
      rawInput.toArray(tmp5);
      return tmp5;
    }
    return super._prefilterInvalidRawInput(rawInput);
  }
  valueSerialized() {
    return this.value.toArray();
  }
  _copyValue(param) {
    param.value.toArray(this._copied_value);
    this.set(this._copied_value);
  }
  _cloneRawInput(rawInput) {
    if (rawInput instanceof Vector4) {
      return rawInput.clone();
    } else {
      const newArray = [rawInput[0], rawInput[1], rawInput[2], rawInput[3]];
      if (newArray[0] == null) {
        newArray[0] = newArray[0] || 0;
      }
      if (newArray[1] == null) {
        newArray[1] = newArray[1] || newArray[0];
      }
      if (newArray[2] == null) {
        newArray[2] = newArray[2] || newArray[1];
      }
      if (newArray[3] == null) {
        newArray[3] = newArray[3] || newArray[2];
      }
      return newArray;
    }
  }
  static areRawInputEqual(rawInput1, rawInput2) {
    if (rawInput1 instanceof Vector4) {
      if (rawInput2 instanceof Vector4) {
        return rawInput1.equals(rawInput2);
      } else {
        return vector2EqualsStringNumber4(rawInput1, rawInput2);
      }
    } else {
      if (rawInput2 instanceof Vector4) {
        return vector2EqualsStringNumber4(rawInput2, rawInput1);
      } else {
        return stringNumber4Equals(rawInput1, rawInput2);
      }
    }
  }
  static areValuesEqual(val1, val2) {
    return val1.equals(val2);
  }
  initComponents() {
    super.initComponents();
    this.x = this.components[0];
    this.y = this.components[1];
    this.z = this.components[2];
    this.w = this.components[3];
  }
  setValueFromComponents() {
    this._value.x = this.x.value;
    this._value.y = this.y.value;
    this._value.z = this.z.value;
    this._value.w = this.w.value;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/params/types/ParamConstructorByType.js
var ParamConstructorByType = {
  [ParamType.BOOLEAN]: BooleanParam,
  [ParamType.BUTTON]: ButtonParam,
  [ParamType.COLOR]: ColorParam,
  [ParamType.FLOAT]: FloatParam,
  [ParamType.FOLDER]: FolderParam,
  [ParamType.INTEGER]: IntegerParam,
  // [ParamType.OPERATOR_PATH]: OperatorPathParam,
  [ParamType.PARAM_PATH]: ParamPathParam,
  [ParamType.NODE_PATH]: NodePathParam,
  [ParamType.RAMP]: RampParam,
  [ParamType.STRING]: StringParam,
  [ParamType.VECTOR2]: Vector2Param,
  [ParamType.VECTOR3]: Vector3Param,
  [ParamType.VECTOR4]: Vector4Param
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/params/ParamsController.js
var NODE_SIMPLE_NAME = "params";
var _tmpAll = [];
var ParamsController = class {
  constructor(node) {
    this.node = node;
    this._param_create_mode = false;
    this._params_created = false;
    this._paramsByName = /* @__PURE__ */ new Map();
    this._paramsList = [];
    this._paramNames = [];
    this._non_spare_params = [];
    this._spare_params = [];
    this._non_spare_param_names = [];
    this._spare_param_names = [];
    this._params_added_since_last_params_eval = false;
    this._promises = [];
  }
  dispose() {
    if (this._params_node) {
      this._params_node.dispose();
    }
    arrayCopy(this.all, _tmpAll);
    for (const param of _tmpAll) {
      param.dispose();
    }
    this._post_create_params_hook_names = void 0;
    this._post_create_params_hooks = void 0;
    this._on_scene_load_hooks = void 0;
    this._on_scene_load_hook_names = void 0;
  }
  initDependencyNode() {
    if (!this._params_node) {
      this._params_node = new CoreGraphNode(this.node.scene(), NODE_SIMPLE_NAME);
      this.node.addGraphInput(this._params_node, false);
    }
  }
  init() {
    this.initDependencyNode();
    this._param_create_mode = true;
    this._initFromParamsConfig();
    this.node.createParams();
    this._postCreateParams();
  }
  _postCreateParams() {
    this._updateCaches();
    this._initParamAccessors();
    this._param_create_mode = false;
    this._params_created = true;
    this._runPostCreateParamsHooks();
  }
  postCreateSpareParams() {
    this._updateCaches();
    this._initParamAccessors();
    this.node.scene().referencesController.notifyParamsUpdated(this.node);
    this.node.emit(NodeEvent.PARAMS_UPDATED);
  }
  updateParams(options) {
    let hasCreatedAParam = false;
    let hasDeletedAParam = false;
    const addedParams = [];
    if (options.namesToDelete) {
      for (const param_name of options.namesToDelete) {
        if (this.has(param_name)) {
          this._deleteParam(param_name);
          hasDeletedAParam = true;
        }
      }
    }
    if (options.toAdd) {
      for (const paramData of options.toAdd) {
        const param = this.addParam(paramData.type, paramData.name, paramData.initValue, paramData.options);
        if (param) {
          if (paramData.rawInput != null) {
            param.set(paramData.rawInput);
          }
          hasCreatedAParam = true;
          addedParams.push(param);
        }
      }
    }
    if (hasDeletedAParam || hasCreatedAParam) {
      this.postCreateSpareParams();
    }
    for (const param of addedParams) {
      this.node.scene().missingExpressionReferencesController.checkForMissingParamReferences(param);
    }
  }
  _initFromParamsConfig() {
    var _a;
    const paramsConfig = this.node.paramsConfig;
    let init_values_used = false;
    if (paramsConfig) {
      const paramsInitValueOverrides = (_a = this.node.createOptions) == null ? void 0 : _a.paramsInitValueOverrides;
      const names = Object.keys(paramsConfig);
      for (const name of names) {
        const config = paramsConfig[name];
        let init_value;
        if (paramsInitValueOverrides) {
          init_value = paramsInitValueOverrides[name];
          init_values_used = true;
        }
        this.addParam(config.type, name, config.init_value, config.options, init_value);
      }
    }
    if (init_values_used) {
      this.node.setDirty();
    }
    if (this.node.createOptions) {
      this.node.createOptions.paramsInitValueOverrides = void 0;
    }
  }
  _initParamAccessors() {
    let currentNamesInAccessor = Object.getOwnPropertyNames(this.node.pv);
    this._removeUnneededAccessors(currentNamesInAccessor);
    currentNamesInAccessor = Object.getOwnPropertyNames(this.node.pv);
    const all = this.all;
    for (const param of all) {
      const isSpare = param.options.isSpare();
      const paramNotYetInAccessors = !currentNamesInAccessor.includes(param.name());
      try {
        if (paramNotYetInAccessors || isSpare) {
          Object.defineProperty(this.node.pv, param.name(), {
            get: () => {
              return param.value;
            },
            // only spare parameters can be removed
            configurable: isSpare
          });
          Object.defineProperty(this.node.p, param.name(), {
            get: () => {
              return param;
            },
            configurable: isSpare
          });
        }
      } catch (err) {
      }
    }
  }
  _removeUnneededAccessors(current_names_in_accessor) {
    const current_param_names = this._paramNames;
    const names_to_remove = [];
    for (const current_name_in_accessor of current_names_in_accessor) {
      if (!current_param_names.includes(current_name_in_accessor)) {
        names_to_remove.push(current_name_in_accessor);
      }
    }
    for (const name_to_remove of names_to_remove) {
      Object.defineProperty(this.node.pv, name_to_remove, {
        get: () => {
          return void 0;
        },
        configurable: true
      });
      Object.defineProperty(this.node.p, name_to_remove, {
        get: () => {
          return void 0;
        },
        configurable: true
      });
    }
  }
  get params_node() {
    return this._params_node;
  }
  get all() {
    return this._paramsList;
  }
  get non_spare() {
    return this._non_spare_params;
  }
  get spare() {
    return this._spare_params;
  }
  get names() {
    return this._paramNames;
  }
  get non_spare_names() {
    return this._non_spare_param_names;
  }
  get spare_names() {
    return this._spare_param_names;
  }
  set_with_type(paramName, value, type) {
    const param = this.paramWithType(paramName, type);
    if (param) {
      param.set(value);
    } else {
      Poly.warn(`param ${paramName} not found with type ${type}`);
    }
  }
  set_float(paramName, value) {
    this.set_with_type(paramName, value, ParamType.FLOAT);
  }
  set_vector3(paramName, value) {
    this.set_with_type(paramName, value, ParamType.VECTOR3);
  }
  has_param(paramName) {
    return this._paramsByName.has(paramName);
  }
  has(paramName) {
    return this.has_param(paramName);
  }
  get(paramName) {
    return this.param(paramName);
  }
  paramWithType(param_name, type) {
    const param = this.param(param_name);
    if (param && param.type() == type) {
      return param;
    }
  }
  getFloat(param_name) {
    return this.paramWithType(param_name, ParamType.FLOAT);
  }
  // get_operator_path(param_name: string): OperatorPathParam {
  // 	return this.paramWithType(param_name, ParamType.OPERATOR_PATH) as OperatorPathParam;
  // }
  value(paramName) {
    var _a;
    return (_a = this.param(paramName)) == null ? void 0 : _a.value;
  }
  valueWithType(paramName, type) {
    var _a;
    return (_a = this.paramWithType(paramName, type)) == null ? void 0 : _a.value;
  }
  boolean(paramName) {
    return this.valueWithType(paramName, ParamType.BOOLEAN);
  }
  float(paramName) {
    return this.valueWithType(paramName, ParamType.FLOAT);
  }
  integer(paramName) {
    return this.valueWithType(paramName, ParamType.INTEGER);
  }
  string(paramName) {
    return this.valueWithType(paramName, ParamType.STRING);
  }
  vector2(paramName) {
    return this.valueWithType(paramName, ParamType.VECTOR2);
  }
  vector3(paramName) {
    return this.valueWithType(paramName, ParamType.VECTOR3);
  }
  color(paramName) {
    return this.valueWithType(paramName, ParamType.COLOR);
  }
  param(paramName) {
    const p = this._paramsByName.get(paramName);
    if (p != null) {
      return p;
    } else {
      Poly.warn(
        `tried to access param '${paramName}' in node ${this.node.path()}, but existing params are: ${this.names} on node ${this.node.path()}`
      );
      return null;
    }
  }
  // param_cache_name(param_name: string) {
  // 	return `_param_${param_name}`;
  // }
  // delete_params(param_names: string[]) {
  // 	for (let param_name of param_names) {
  // 		this.delete_param(param_name);
  // 	}
  // }
  // call update_params instead
  _deleteParam(paramName) {
    const param = this._paramsByName.get(paramName);
    if (param) {
      if (this._params_node) {
        this._params_node.removeGraphInput(param);
      }
      param._setupNodeDependencies(null);
      this._paramsByName.delete(paramName);
      if (param.isMultiple() && param.components) {
        for (const component of param.components) {
          const childName = component.name();
          this._paramsByName.delete(childName);
        }
      }
      param.dispose();
      param.scene().graphNodesController.notifyParamPathChanged(param);
    } else {
      throw new Error(`param '${paramName}' does not exist on node ${this.node.path()}`);
    }
  }
  addParam(type, paramName, defaultValue2, options = {}, initData) {
    const isSpare = options["spare"] || false;
    if (this._param_create_mode === false && !isSpare) {
      Poly.warn(
        `node ${this.node.path()} (${this.node.type()}) param '${paramName}' cannot be created outside of createParams`
      );
    }
    if (this.node.scene() == null) {
      Poly.warn(`node ${this.node.path()} (${this.node.type()}) has no scene assigned`);
    }
    const constructor = ParamConstructorByType[type];
    if (constructor != null) {
      const existing_param = this._paramsByName.get(paramName);
      if (existing_param) {
        if (isSpare) {
          if (existing_param.type() != type) {
            this._deleteParam(existing_param.name());
          }
        } else {
          Poly.warn(`a param named ${paramName} already exists`, this.node);
        }
      }
      const param = new constructor(this.node.scene(), this.node, {
        serializerClass: this.node.scene().paramSerializerClass()
      });
      param.options.set(options);
      param.setName(paramName);
      param.setInitValue(defaultValue2);
      param.initComponents();
      if (initData == null) {
        param.set(defaultValue2);
      } else {
        if (param.options.isExpressionForEntities()) {
          param.set(defaultValue2);
        }
        if (initData.raw_input != null) {
          param.set(initData.raw_input);
        } else {
          if (initData.simple_data != null) {
            param.set(initData.simple_data);
          } else {
            if (initData.complex_data != null) {
              const raw_input = initData.complex_data.raw_input;
              if (raw_input) {
                param.set(raw_input);
              } else {
                param.set(defaultValue2);
              }
              const overriden_options = initData.complex_data.overriden_options;
              if (overriden_options != null) {
                const keys = Object.keys(overriden_options);
                for (const key of keys) {
                  param.options.setOption(key, overriden_options[key]);
                }
              }
            }
          }
        }
      }
      param.postOptionsInitialize();
      param._setupNodeDependencies(this.node);
      this._paramsByName.set(param.name(), param);
      if (param.isMultiple() && param.components) {
        for (const component of param.components) {
          this._paramsByName.set(component.name(), component);
        }
      }
      this._params_added_since_last_params_eval = true;
      param.scene().graphNodesController.notifyParamPathChanged(param);
      return param;
    }
  }
  _updateCaches() {
    this._paramsList.splice(0, this._paramsList.length);
    this._paramsByName.forEach((param) => {
      this._paramsList.push(param);
    });
    this._paramNames = this._paramsList.map((param) => param.name());
    this._non_spare_params = this._paramsList.filter((p) => !p.options.isSpare());
    this._spare_params = this._paramsList.filter((p) => p.options.isSpare());
    this._non_spare_param_names = this._non_spare_params.map((p) => p.name());
    this._spare_param_names = this._spare_params.map((p) => p.name());
  }
  async _evalParam(param) {
    if (param.isDirty()) {
      await param.compute();
      if (param.states.error.active() && param.disposed() == false) {
        this.node.states.error.set(`param '${param.name()}' error: ${param.states.error.message()}`);
      }
    }
  }
  async evalParams(params) {
    let dirtyParamsCount = 0;
    for (const param of params) {
      if (param.isDirty()) {
        dirtyParamsCount += 1;
      }
    }
    this._promises.length = dirtyParamsCount;
    let i = 0;
    for (const param of params) {
      if (param.isDirty()) {
        this._promises[i] = this._evalParam(param);
        i += 1;
      }
    }
    await Promise.all(this._promises);
    if (this.node.states.error.active()) {
      this.node._setContainer(null);
    }
  }
  paramsEvalRequired() {
    return this._params_node != null && (this._params_node.isDirty() || this._params_added_since_last_params_eval);
  }
  async evalAll() {
    var _a;
    if (this.paramsEvalRequired()) {
      await this.evalParams(this._paramsList);
      (_a = this._params_node) == null ? void 0 : _a.removeDirtyState();
      this._params_added_since_last_params_eval = false;
    }
  }
  //
  //
  // HOOKS
  //
  //
  onParamsCreated(hook_name, hook) {
    if (this._params_created) {
      hook();
    } else {
      if (this._post_create_params_hook_names && this._post_create_params_hook_names.includes(hook_name)) {
        Poly.error(`hook name ${hook_name} already exists`);
        return;
      }
      this._post_create_params_hook_names = this._post_create_params_hook_names || [];
      this._post_create_params_hook_names.push(hook_name);
      this._post_create_params_hooks = this._post_create_params_hooks || [];
      this._post_create_params_hooks.push(hook);
    }
  }
  addOnSceneLoadHook(param_name, method) {
    this._on_scene_load_hook_names = this._on_scene_load_hook_names || [];
    this._on_scene_load_hooks = this._on_scene_load_hooks || [];
    if (!this._on_scene_load_hook_names.includes(param_name)) {
      this._on_scene_load_hook_names.push(param_name);
      this._on_scene_load_hooks.push(method);
    } else {
      Poly.warn(`hook with name ${param_name} already exists`, this.node);
    }
  }
  _runPostCreateParamsHooks() {
    if (this._post_create_params_hooks) {
      for (const hook of this._post_create_params_hooks) {
        hook();
      }
    }
  }
  runOnSceneLoadHooks() {
    if (this._on_scene_load_hooks) {
      for (const hook of this._on_scene_load_hooks) {
        hook();
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/params/ParamsValueAccessor.js
var ParamsValueAccessor = class {
  constructor() {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/NodeConnection.js
var NODE_CONNECTION_TRIGGERED_EVENT_NAME = "triggered";
var NODE_CONNECTION_TRIGGERED_EVENT = { type: NODE_CONNECTION_TRIGGERED_EVENT_NAME };
var _TypedNodeConnection = class {
  constructor(_nodeSrc, _nodeDest, _outputIndex = 0, _inputIndex = 0) {
    this._nodeSrc = _nodeSrc;
    this._nodeDest = _nodeDest;
    this._outputIndex = _outputIndex;
    this._inputIndex = _inputIndex;
    if (this._outputIndex == null) {
      throw "bad output index";
    }
    if (this._inputIndex == null) {
      throw "bad input index";
    }
    this._id = _TypedNodeConnection._nextId++;
    if (this._nodeSrc.io.connections && this._nodeDest.io.connections) {
      this._nodeSrc.io.connections.addOutputConnection(this);
      this._nodeDest.io.connections.addInputConnection(this);
    }
  }
  id() {
    return this._id;
  }
  nodeSrc() {
    return this._nodeSrc;
  }
  nodeDest() {
    return this._nodeDest;
  }
  outputIndex() {
    return this._outputIndex;
  }
  inputIndex() {
    return this._inputIndex;
  }
  srcConnectionPoint() {
    const connectionPoints = this._nodeSrc.io.outputs.namedOutputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    return connectionPoints[this._outputIndex];
  }
  destConnectionPoint() {
    const connectionPoints = this._nodeDest.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    return connectionPoints[this._inputIndex];
  }
  disconnect(options = {}) {
    if (this._nodeSrc.io.connections && this._nodeDest.io.connections) {
      this._nodeSrc.io.connections.removeOutputConnection(this);
      this._nodeDest.io.connections.removeInputConnection(this);
    }
    if (options.setInput === true) {
      this._nodeDest.io.inputs.setInput(this._inputIndex, null, void 0, {
        ignoreLockedState: options.ignoreLockedState
      });
    }
  }
  _eventDispatcher() {
    return this.__eventDispatcher;
  }
  eventDispatcher() {
    return this.__eventDispatcher = this.__eventDispatcher || new EventDispatcher();
  }
};
var TypedNodeConnection = _TypedNodeConnection;
TypedNodeConnection._nextId = 0;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/utils/ClonedStatesController.js
var ClonedStatesController2 = class {
  constructor(inputsController) {
    this.inputsController = inputsController;
    this._cloneRequiredStates = [];
    this._overridden = false;
    this.node = inputsController.node;
  }
  initInputsClonedState(states) {
    if (isArray(states)) {
      this._clonedStates = states;
    } else {
      this._clonedState = states;
    }
    this.updateCloneRequiredState();
  }
  overrideClonedStateAllowed() {
    if (this._clonedStates) {
      for (const state of this._clonedStates) {
        if (state == InputCloneMode.FROM_NODE) {
          return true;
        }
      }
    }
    if (this._clonedState) {
      return this._clonedState == InputCloneMode.FROM_NODE;
    }
    return false;
  }
  // private get inputs_clonable_state(): InputCloneMode[] {
  // 	return (this._inputs_clonable_states = this._inputs_clonable_states || this.init_inputs_clonable_state());
  // }
  cloneRequiredState(index) {
    const result = this._cloneRequiredStates[index];
    return result;
  }
  cloneRequiredStates() {
    return this._cloneRequiredStates;
  }
  // inputs_clonable_state_with_override(): boolean[] {
  // 	// const list = [];
  // 	// const states = this.inputs_clonable_state();
  // 	// for (let i = 0; i < states.length; i++) {
  // 	// 	list.push(this.input_clonable_state_with_override(i));
  // 	// }
  // 	// return list;
  // 	return this._inputs_cloned_state;
  // }
  _getCloneRequiredState(index) {
    const states = this._clonedStates;
    if (states) {
      const state = states[index];
      if (state != null) {
        return this._cloneRequiredFromState(state);
      }
    }
    if (this._clonedState) {
      return this._cloneRequiredFromState(this._clonedState);
    }
    return true;
  }
  _cloneRequiredFromState(state) {
    switch (state) {
      case InputCloneMode.ALWAYS:
        return true;
      case InputCloneMode.NEVER:
        return false;
      case InputCloneMode.FROM_NODE:
        return !this._overridden;
    }
    return TypeAssert.unreachable(state);
  }
  // private _default_inputs_clonale_state_values() {
  // 	const list = [];
  // 	for (let i = 0; i < this.inputs_controller.max_inputs_count; i++) {
  // 		list.push(InputCloneMode.ALWAYS);
  // 	}
  // 	return list;
  // }
  overrideClonedState(state) {
    this._overridden = state;
    this.updateCloneRequiredState();
  }
  overriden() {
    return this._overridden;
  }
  updateCloneRequiredState() {
    if (this._clonedStates) {
      const states = [];
      for (let i = 0; i < this._clonedStates.length; i++) {
        states[i] = this._getCloneRequiredState(i);
      }
      this._cloneRequiredStates = states;
    } else {
      if (this._clonedState) {
        const max_inputs = this.inputsController.maxInputsCount();
        const states = [];
        for (let i = 0; i < max_inputs; i++) {
          states[i] = this._getCloneRequiredState(i);
        }
        this._cloneRequiredStates = states;
      }
    }
    if (this.node.parent()) {
      this.node.emit(NodeEvent.OVERRIDE_CLONABLE_STATE_UPDATE);
      this.node.setDirty();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/InputsController.js
var _existingInputIndices = [];
var MAX_INPUTS_COUNT_UNSET = 0;
var NodeInputsController = class {
  // private _user_inputs_clonable_states: InputCloneMode[] | undefined;
  // private _inputs_clonable_states: InputCloneMode[] | undefined;
  // private _inputs_cloned_state: boolean[] = [];
  // private _override_clonable_state: boolean = false;
  constructor(node) {
    this.node = node;
    this._graphNodeInputs = [];
    this._inputs = [];
    this._has_named_inputs = false;
    this._minInputsCount = 0;
    this._maxInputsCount = MAX_INPUTS_COUNT_UNSET;
    this._maxInputsCountOnInput = MAX_INPUTS_COUNT_UNSET;
    this._depends_on_inputs = true;
    this._singleInputIndexListenedTo = null;
  }
  // clonable
  dispose() {
    if (this._graphNode) {
      this._graphNode.dispose();
    }
    for (const graph_node of this._graphNodeInputs) {
      if (graph_node) {
        graph_node.dispose();
      }
    }
    this._on_update_hooks = void 0;
    this._on_update_hook_names = void 0;
  }
  setDependsOnInputs(depends_on_inputs) {
    this._depends_on_inputs = depends_on_inputs;
  }
  setMinCount(minInputsCount) {
    this._minInputsCount = minInputsCount;
  }
  minCount() {
    return this._minInputsCount;
  }
  setMaxCount(maxInputsCount) {
    if (this._maxInputsCount == MAX_INPUTS_COUNT_UNSET) {
      this._maxInputsCountOnInput = maxInputsCount;
    }
    this._maxInputsCount = maxInputsCount;
    this._initGraphNodeInputs();
    this._updateCloneRequiredState();
  }
  listenToSingleInputIndex(index) {
    this._singleInputIndexListenedTo = index;
  }
  onEnsureListenToSingleInputIndexUpdated(callback) {
    this._onEnsureListenToSingleInputIndexUpdatedCallback = callback;
  }
  namedInputConnectionPointsByName(name) {
    if (this._named_input_connection_points) {
      for (const connection_point of this._named_input_connection_points) {
        if (connection_point && connection_point.name() == name) {
          return connection_point;
        }
      }
    }
  }
  setNamedInputConnectionPoints(newConnectionPoints) {
    var _a;
    this._has_named_inputs = true;
    const connectionPointsToKeep = ((_a = this._named_input_connection_points) == null ? void 0 : _a.filter((cp) => cp == null ? void 0 : cp.inNodeDefinition())) || [];
    const allNewConnectionPoints = arrayShallowClone(connectionPointsToKeep);
    const currentNames = /* @__PURE__ */ new Set();
    for (const connectionPointToKeep of connectionPointsToKeep) {
      if (connectionPointToKeep) {
        currentNames.add(connectionPointToKeep.name());
      }
    }
    for (const newConnectionPoint of newConnectionPoints) {
      if (newConnectionPoint) {
        if (!currentNames.has(newConnectionPoint.name())) {
          currentNames.add(newConnectionPoint.name());
          allNewConnectionPoints.push(newConnectionPoint);
        }
      }
    }
    const connections = this.node.io.connections.inputConnections();
    if (connections) {
      for (const connection of connections) {
        if (connection) {
          if (connection.inputIndex() >= allNewConnectionPoints.length) {
            connection.disconnect({ setInput: true, ignoreLockedState: true });
          }
        }
      }
    }
    this._named_input_connection_points = allNewConnectionPoints;
    this.setMinCount(0);
    this.setMaxCount(this._named_input_connection_points.length);
    this._initGraphNodeInputs();
    this.node.emit(NodeEvent.NAMED_INPUTS_UPDATED);
  }
  // private _has_connected_inputs() {
  // 	for (let input of this._inputs) {
  // 		if (input != null) {
  // 			return true;
  // 		}
  // 	}
  // 	return false;
  // }
  // private _check_name_changed(connection_points: ConnectionPointTypeMap[NC][]) {
  // 	if (this._named_input_connection_points) {
  // 		if (this._named_input_connection_points.length != connection_points.length) {
  // 			return true;
  // 		} else {
  // 			for (let i = 0; i < this._named_input_connection_points.length; i++) {
  // 				if (this._named_input_connection_points[i]?.name != connection_points[i]?.name) {
  // 					return true;
  // 				}
  // 			}
  // 		}
  // 	}
  // 	return false;
  // }
  hasNamedInputs() {
    return this._has_named_inputs;
  }
  namedInputConnectionPoints() {
    return this._named_input_connection_points;
  }
  _initGraphNodeInputs() {
    for (let i = 0; i < this._maxInputsCount; i++) {
      this._graphNodeInputs[i] = this._graphNodeInputs[i] || this._createGraphNodeInput(i);
    }
  }
  _createGraphNodeInput(index) {
    const graphInputNode = new CoreGraphNode(this.node.scene(), `input_${index}`);
    this.graphNode().addGraphInput(graphInputNode, false);
    return graphInputNode;
  }
  graphNode() {
    return this._graphNode = this._graphNode || this._createGraphNode();
  }
  _createGraphNode() {
    const graphNode = new CoreGraphNode(this.node.scene(), "inputs");
    this.node.addGraphInput(graphNode, false);
    return graphNode;
  }
  maxInputsCount() {
    return this._maxInputsCount || 0;
  }
  maxInputsCountOverriden() {
    return this._maxInputsCount != this._maxInputsCountOnInput;
  }
  inputGraphNode(input_index) {
    return this._graphNodeInputs[input_index];
  }
  setCount(min, max) {
    if (max == null) {
      max = min;
    }
    this.setMinCount(min);
    this.setMaxCount(max);
    this._initConnectionControllerInputs();
  }
  _initConnectionControllerInputs() {
    this.node.io.connections.initInputs();
  }
  isGraphNodeDirty() {
    var _a;
    return ((_a = this._graphNode) == null ? void 0 : _a.isDirty()) || false;
  }
  _isAnyInputDirty() {
    for (const input of this._inputs) {
      if (input && input.isDirty()) {
        return true;
      }
    }
    return false;
  }
  containersWithoutEvaluation(target4) {
    target4.length = 0;
    for (let i = 0; i < this._inputs.length; i++) {
      const inputNode = this._inputs[i];
      let container = null;
      if (inputNode) {
        container = inputNode.containerController.containerUnlessBypassed();
      }
      target4.push(container);
    }
    return target4;
  }
  _existingInputIndices(target4) {
    target4.length = 0;
    if (this._maxInputsCount > 0) {
      for (let i = 0; i < this._inputs.length; i++) {
        if (this._inputs[i]) {
          target4.push(i);
        }
      }
    }
    return target4;
  }
  async evalRequiredInputs(target4) {
    var _a;
    target4.length = 0;
    if (this.node.disposed() == true) {
      return target4;
    }
    if (this._maxInputsCount > 0) {
      this._existingInputIndices(_existingInputIndices);
      if (_existingInputIndices.length < this._minInputsCount) {
        this.node.states.error.set("inputs are missing");
      } else {
        if (_existingInputIndices.length > 0) {
          if (this._onEnsureListenToSingleInputIndexUpdatedCallback) {
            await this._onEnsureListenToSingleInputIndexUpdatedCallback();
          }
          if (this._maxInputsCount == 1) {
            const container = await this.evalRequiredInput(0);
            target4.push(container);
          } else {
            const promises = [];
            if (this._singleInputIndexListenedTo != null) {
              promises.push(
                this.evalRequiredInput(this._singleInputIndexListenedTo)
              );
            } else {
              const lastExistingInputIndex = _existingInputIndices[_existingInputIndices.length - 1];
              for (let i = 0; i < this._inputs.length; i++) {
                const input = this._inputs[i];
                if (input) {
                  promises.push(this.evalRequiredInput(i));
                } else {
                  if (i <= lastExistingInputIndex) {
                    promises.push(void 0);
                  }
                }
              }
            }
            const results = await Promise.all(promises);
            for (const result of results) {
              target4.push(result);
            }
          }
          if (!this._isAnyInputDirty()) {
            (_a = this._graphNode) == null ? void 0 : _a.removeDirtyState();
          }
        }
      }
    }
    return target4;
  }
  async evalRequiredInput(inputIndex) {
    let container = void 0;
    const inputNode = this.input(inputIndex);
    if (inputNode) {
      container = await inputNode.compute();
      this._graphNodeInputs[inputIndex].removeDirtyState();
    }
    if (container && container.coreContent()) {
    } else {
      if (inputNode) {
        const inputErrorMessage = inputNode.states.error.message();
        if (inputErrorMessage && this.node.disposed() == false) {
          this.node.states.error.set(`input ${inputIndex} is invalid (error: ${inputErrorMessage})`);
        }
      }
    }
    return container;
  }
  getNamedInputIndex(name) {
    var _a;
    if (this._named_input_connection_points) {
      for (let i = 0; i < this._named_input_connection_points.length; i++) {
        if (((_a = this._named_input_connection_points[i]) == null ? void 0 : _a.name()) == name) {
          return i;
        }
      }
    }
    return -1;
  }
  getInputIndex(input_index_or_name) {
    if (CoreType.isString(input_index_or_name)) {
      if (this.hasNamedInputs()) {
        return this.getNamedInputIndex(input_index_or_name);
      } else {
        throw new Error(`node ${this.node.path()} has no named inputs`);
      }
    } else {
      return input_index_or_name;
    }
  }
  setInput(inputIndexOrName, node, outputIndexOrName, options) {
    const ignoreLockedState = (options == null ? void 0 : options.ignoreLockedState) || false;
    if (ignoreLockedState == false && this.node.insideALockedParent()) {
      const lockedParent = this.node.lockedParent();
      console.warn(
        `node '${this.node.path()}' cannot have its inputs changed, since it is inside '${lockedParent ? lockedParent.path() : ""}', which is locked`
      );
      return;
    }
    if (outputIndexOrName == null) {
      outputIndexOrName = 0;
    }
    const noExceptionOnInvalidInput = (options == null ? void 0 : options.noExceptionOnInvalidInput) || false;
    const inputIndex = this.getInputIndex(inputIndexOrName) || 0;
    if (inputIndex < 0) {
      const message = `invalid input (${inputIndexOrName}) for node ${this.node.path()}`;
      if (!noExceptionOnInvalidInput) {
        console.warn(message);
        throw new Error(message);
      } else {
        return;
      }
    }
    let outputIndex = 0;
    if (node) {
      if (node.io.outputs.hasNamedOutputs()) {
        outputIndex = node.io.outputs.getOutputIndex(outputIndexOrName);
        if (outputIndex == null || outputIndex < 0) {
          const connection_points = node.io.outputs.namedOutputConnectionPoints();
          const names = connection_points ? connection_points.map((cp) => cp.name()) : [];
          console.warn(
            `node ${node.path()} does not have an output named ${outputIndexOrName}. inputs are: ${names.join(
              ", "
            )}`
          );
          return;
        }
      }
      const nodeParent = node.parent();
      const currentNodeParent = this.node.parent();
      if (!(nodeParent && currentNodeParent && nodeParent.graphNodeId() == currentNodeParent.graphNodeId())) {
        console.warn(`node ${node.path()} does not have the same parent as ${this.node.path()}`);
        return;
      }
    }
    const graphInputNode = this._graphNodeInputs[inputIndex];
    if (graphInputNode == null) {
      const message = `no input at index ${inputIndex} (name: ${inputIndexOrName}) for node '${this.node.name()}' at path '${this.node.path()}'`;
      console.warn(message);
      throw new Error(message);
    }
    if (node && this.node.parent() != node.parent()) {
      return;
    }
    const oldInputNode = this._inputs[inputIndex];
    let oldOutputIndex = null;
    let oldConnection = void 0;
    if (this.node.io.connections) {
      oldConnection = this.node.io.connections.inputConnection(inputIndex);
    }
    if (oldConnection) {
      oldOutputIndex = oldConnection.outputIndex();
    }
    if (node !== oldInputNode || outputIndex != oldOutputIndex) {
      if (oldInputNode != null) {
        if (this._depends_on_inputs) {
          graphInputNode.removeGraphInput(oldInputNode);
        }
      }
      if (node != null) {
        const connectionResult = graphInputNode.addGraphInput(node);
        if (connectionResult) {
          if (!this._depends_on_inputs) {
            graphInputNode.removeGraphInput(node);
          }
          if (oldConnection) {
            oldConnection.disconnect({ setInput: false });
          }
          this._inputs[inputIndex] = node;
          new TypedNodeConnection(
            node,
            this.node,
            outputIndex,
            inputIndex
          );
        } else {
          console.warn(`cannot connect ${node.path()} to ${this.node.path()}`);
        }
      } else {
        this._inputs[inputIndex] = null;
        if (oldConnection) {
          oldConnection.disconnect({ setInput: false });
        }
      }
      this._run_on_set_input_hooks();
      graphInputNode.setSuccessorsDirty();
      this.node.emit(NodeEvent.INPUTS_UPDATED);
    }
  }
  // remove_input(node: BaseNodeByContextMap[NC]) {
  // 	const inputs = this.inputs();
  // 	let input: BaseNodeByContextMap[NC] | null;
  // 	for (let i = 0; i < inputs.length; i++) {
  // 		input = inputs[i];
  // 		if (input != null && node != null) {
  // 			if (input.graphNodeId() === node.graphNodeId()) {
  // 				this.setInput(i, null);
  // 			}
  // 		}
  // 	}
  // }
  input(input_index) {
    return this._inputs[input_index];
  }
  named_input(input_name) {
    if (this.hasNamedInputs()) {
      const input_index = this.getInputIndex(input_name);
      return this._inputs[input_index];
    } else {
      return null;
    }
  }
  named_input_connection_point(input_name) {
    if (this.hasNamedInputs() && this._named_input_connection_points) {
      const input_index = this.getInputIndex(input_name);
      return this._named_input_connection_points[input_index];
    }
  }
  has_named_input(name) {
    return this.getNamedInputIndex(name) >= 0;
  }
  hasInput(input_index) {
    return this._inputs[input_index] != null;
  }
  inputs() {
    return this._inputs;
  }
  initInputsClonedState(states) {
    if (!this._clonedStatesController) {
      this._clonedStatesController = new ClonedStatesController2(this);
      this._clonedStatesController.initInputsClonedState(states);
    }
  }
  overrideClonedStateAllowed() {
    var _a;
    return ((_a = this._clonedStatesController) == null ? void 0 : _a.overrideClonedStateAllowed()) || false;
  }
  overrideClonedState(state) {
    var _a;
    (_a = this._clonedStatesController) == null ? void 0 : _a.overrideClonedState(state);
  }
  clonedStateOverriden() {
    var _a;
    return ((_a = this._clonedStatesController) == null ? void 0 : _a.overriden()) || false;
  }
  cloneRequired(index) {
    var _a;
    const state = (_a = this._clonedStatesController) == null ? void 0 : _a.cloneRequiredState(index);
    if (state != null) {
      return state;
    }
    return true;
  }
  cloneRequiredStates() {
    var _a;
    const states = (_a = this._clonedStatesController) == null ? void 0 : _a.cloneRequiredStates();
    if (states != null) {
      return states;
    }
    return true;
  }
  _updateCloneRequiredState() {
    var _a;
    (_a = this._clonedStatesController) == null ? void 0 : _a.updateCloneRequiredState();
  }
  //
  //
  // HOOKS
  //
  //
  add_on_set_input_hook(name, hook) {
    this._on_update_hooks = this._on_update_hooks || [];
    this._on_update_hook_names = this._on_update_hook_names || [];
    if (!this._on_update_hook_names.includes(name)) {
      this._on_update_hooks.push(hook);
      this._on_update_hook_names.push(name);
    } else {
      console.warn(`hook with name ${name} already exists`, this.node);
    }
  }
  _run_on_set_input_hooks() {
    if (this._on_update_hooks) {
      for (const hook of this._on_update_hooks) {
        hook();
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/OutputsController.js
var _uniqOutputIndices = [];
var _usedOutputIndices = [];
var OutputsController = class {
  constructor(node) {
    this.node = node;
    this._has_outputs = false;
    this._has_named_outputs = false;
    this._connections = [];
    this._onPlayingStateChangeBound = this._onPlayingStateChange.bind(this);
    this._outputIndexCache = /* @__PURE__ */ new Map();
    this.node.scene().timeController.onPlayingStateChange(this._onPlayingStateChangeBound);
  }
  _onPlayingStateChange() {
    this._clearCache();
  }
  _clearCache() {
    this._outputIndexCache.clear();
  }
  dispose() {
    this.node.scene().timeController.removeOnPlayingStateChange(this._onPlayingStateChangeBound);
    if (this._named_output_connection_points) {
      this._named_output_connection_points.splice(0, this._named_output_connection_points.length);
    }
  }
  setHasOneOutput() {
    this._has_outputs = true;
  }
  setHasNoOutput() {
    this._has_outputs = false;
  }
  hasOutputs() {
    return this._has_outputs;
  }
  hasNamedOutputs() {
    return this._has_named_outputs;
  }
  hasNamedOutput(name) {
    return this.getNamedOutputIndex(name) >= 0;
  }
  namedOutputConnectionPoints() {
    return this._named_output_connection_points;
  }
  namedOutputConnection(index) {
    if (this._named_output_connection_points) {
      return this._named_output_connection_points[index];
    }
  }
  getNamedOutputIndex(name) {
    if (this._named_output_connection_points) {
      let i = 0;
      for (const connectionPoint of this._named_output_connection_points) {
        if (connectionPoint && connectionPoint.name() == name) {
          return i;
        }
        i++;
      }
    }
    return -1;
  }
  getOutputIndex(output_index_or_name) {
    let currentCache = this._outputIndexCache.get(output_index_or_name);
    if (currentCache == null) {
      currentCache = this._getOutputIndex(output_index_or_name);
      this._outputIndexCache.set(output_index_or_name, currentCache);
    }
    return currentCache;
  }
  _getOutputIndex(output_index_or_name) {
    if (output_index_or_name != null) {
      if (CoreType.isString(output_index_or_name)) {
        if (this.hasNamedOutputs()) {
          return this.getNamedOutputIndex(output_index_or_name);
        } else {
          console.warn(`node ${this.node.path()} has no named outputs`);
          return -1;
        }
      } else {
        return output_index_or_name;
      }
    }
    return -1;
  }
  namedOutputConnectionPointsByName(name) {
    if (this._named_output_connection_points) {
      for (const connection_point of this._named_output_connection_points) {
        if ((connection_point == null ? void 0 : connection_point.name()) == name) {
          return connection_point;
        }
      }
    }
  }
  setNamedOutputConnectionPoints(connection_points, set_dirty = true) {
    this._has_named_outputs = true;
    this.node.io.connections.outputConnections(this._connections);
    for (const connection of this._connections) {
      if (connection) {
        if (connection.outputIndex() >= connection_points.length) {
          connection.disconnect({ setInput: true });
        }
      }
    }
    this._named_output_connection_points = connection_points;
    if (set_dirty && this.node.scene()) {
      this.node.setDirty(this.node);
    }
    this.node.emit(NodeEvent.NAMED_OUTPUTS_UPDATED);
  }
  used_output_names() {
    var _a;
    const target4 = [];
    const connectionsController = this.node.io.connections;
    if (connectionsController) {
      connectionsController.outputConnections(this._connections);
      arrayUniq(
        this._connections.map((connection) => connection ? connection.outputIndex() : null),
        _uniqOutputIndices
      );
      _usedOutputIndices.length = 0;
      for (const index of _uniqOutputIndices) {
        if (CoreType.isNumber(index)) {
          _usedOutputIndices.push(index);
        }
      }
      const connectionPoints = this.namedOutputConnectionPoints();
      if (connectionPoints) {
        for (const index of _usedOutputIndices) {
          const name = (_a = connectionPoints[index]) == null ? void 0 : _a.name();
          if (name) {
            target4.push(name);
          }
        }
      }
    }
    return target4;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/ConnectionsController.js
var ConnectionsController = class {
  constructor(_node) {
    this._node = _node;
    this._outputConnections = /* @__PURE__ */ new Map();
  }
  initInputs() {
    const count = this._node.io.inputs.maxInputsCount();
    this._inputConnections = this._inputConnections || new Array(count);
    while (this._inputConnections.length < count) {
      this._inputConnections.push(void 0);
    }
  }
  dispose() {
    if (this._inputConnections) {
      this._inputConnections.splice(0, this._inputConnections.length);
    }
    if (this._outputConnections) {
      this._outputConnections.clear();
    }
  }
  //
  //
  // INPUT CONNECTIONS
  //
  //
  addInputConnection(connection) {
    if (this._inputConnections) {
      this._inputConnections[connection.inputIndex()] = connection;
    } else {
      console.warn(`input connections array not initialized`);
    }
  }
  removeInputConnection(connection) {
    if (this._inputConnections) {
      if (connection.inputIndex() < this._inputConnections.length) {
        this._inputConnections[connection.inputIndex()] = void 0;
        let all_connections_after_are_undefined = true;
        for (let i = connection.inputIndex(); i < this._inputConnections.length; i++) {
          if (this._inputConnections[i]) {
            all_connections_after_are_undefined = false;
          }
        }
        if (all_connections_after_are_undefined) {
          this._inputConnections = this._inputConnections.slice(0, connection.inputIndex());
        }
      } else {
        console.warn(`attempt to remove an input connection at index ${connection.inputIndex()}`);
      }
    } else {
      console.warn(`input connections array not initialized`);
    }
  }
  inputConnection(index) {
    if (this._inputConnections) {
      return this._inputConnections[index];
    }
  }
  firstInputConnection() {
    if (this._inputConnections) {
      for (const connection of this._inputConnections) {
        if (connection) {
          return connection;
        }
      }
    }
    return null;
  }
  inputConnections() {
    return this._inputConnections;
  }
  existingInputConnections() {
    const current_connections = this._inputConnections;
    if (current_connections) {
      while (current_connections.length > 1 && current_connections[current_connections.length - 1] === void 0) {
        current_connections.pop();
      }
    }
    return current_connections;
  }
  //
  //
  // OUTPUT CONNECTIONS
  //
  //
  addOutputConnection(connection) {
    const output_index = connection.outputIndex();
    const id = connection.id();
    let connections_by_id = this._outputConnections.get(output_index);
    if (!connections_by_id) {
      connections_by_id = /* @__PURE__ */ new Map();
      this._outputConnections.set(output_index, connections_by_id);
    }
    connections_by_id.set(id, connection);
  }
  removeOutputConnection(connection) {
    const output_index = connection.outputIndex();
    const id = connection.id();
    let connections_by_id = this._outputConnections.get(output_index);
    if (connections_by_id) {
      connections_by_id.delete(id);
    }
  }
  outputConnectionsByOutputIndex(outputIndex) {
    return this._outputConnections.get(outputIndex);
  }
  outputConnections(target4) {
    target4.length = 0;
    this._outputConnections.forEach((connections_by_id, output_index) => {
      connections_by_id.forEach((connection, id) => {
        if (connection) {
          target4.push(connection);
        }
      });
    });
    return target4;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/SavedConnectionPointsDataController.js
var SavedConnectionPointsDataController = class {
  constructor(_node) {
    this._node = _node;
  }
  set_in(data) {
    this._in = data;
  }
  set_out(data) {
    this._out = data;
  }
  clear() {
    this._in = void 0;
    this._out = void 0;
  }
  in() {
    return this._in;
  }
  out() {
    return this._out;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/connections/Gl.js
var GlConnectionPointType = ((GlConnectionPointType2) => {
  GlConnectionPointType2["BOOL"] = "bool";
  GlConnectionPointType2["INT"] = "int";
  GlConnectionPointType2["FLOAT"] = "float";
  GlConnectionPointType2["MAT3"] = "mat3";
  GlConnectionPointType2["MAT4"] = "mat4";
  GlConnectionPointType2["VEC2"] = "vec2";
  GlConnectionPointType2["VEC3"] = "vec3";
  GlConnectionPointType2["VEC4"] = "vec4";
  GlConnectionPointType2["SAMPLER_2D"] = "sampler2D";
  GlConnectionPointType2["SAMPLER_2D_ARRAY"] = "sampler2DArray";
  GlConnectionPointType2["SAMPLER_3D"] = "sampler3D";
  GlConnectionPointType2["SAMPLER_CUBE"] = "samplerCube";
  GlConnectionPointType2["SSS_MODEL"] = "SSSModel";
  GlConnectionPointType2["SDF_CONTEXT"] = "SDFContext";
  GlConnectionPointType2["SDF_MATERIAL"] = "SDFMaterial";
  return GlConnectionPointType2;
})(GlConnectionPointType || {});
var GlConnectionPointTypeToParamTypeMap = {
  [
    "bool"
    /* BOOL */
  ]: ParamType.BOOLEAN,
  // [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]
  // [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]
  // [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]
  [
    "int"
    /* INT */
  ]: ParamType.INTEGER,
  // [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];
  // [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];
  // [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];
  [
    "float"
    /* FLOAT */
  ]: ParamType.FLOAT,
  [
    "vec2"
    /* VEC2 */
  ]: ParamType.VECTOR2,
  [
    "vec3"
    /* VEC3 */
  ]: ParamType.VECTOR3,
  [
    "vec4"
    /* VEC4 */
  ]: ParamType.VECTOR4,
  [
    "mat3"
    /* MAT3 */
  ]: ParamType.BUTTON,
  [
    "mat4"
    /* MAT4 */
  ]: ParamType.BUTTON,
  [
    "sampler2D"
    /* SAMPLER_2D */
  ]: ParamType.RAMP,
  [
    "sampler2DArray"
    /* SAMPLER_2D_ARRAY */
  ]: ParamType.RAMP,
  [
    "sampler3D"
    /* SAMPLER_3D */
  ]: ParamType.RAMP,
  [
    "samplerCube"
    /* SAMPLER_CUBE */
  ]: ParamType.RAMP,
  [
    "SSSModel"
    /* SSS_MODEL */
  ]: ParamType.STRING,
  [
    "SDFContext"
    /* SDF_CONTEXT */
  ]: ParamType.STRING,
  [
    "SDFMaterial"
    /* SDF_MATERIAL */
  ]: ParamType.STRING
};
var GLParamTypeToConnectionPointTypeMap = {
  [ParamType.BOOLEAN]: "bool",
  [ParamType.COLOR]: "vec3",
  // [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]
  // [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]
  // [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]
  [ParamType.INTEGER]: "int",
  // [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];
  // [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];
  // [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];
  [ParamType.FLOAT]: "float",
  [ParamType.FOLDER]: void 0,
  [ParamType.VECTOR2]: "vec2",
  [ParamType.VECTOR3]: "vec3",
  [ParamType.VECTOR4]: "vec4",
  [ParamType.BUTTON]: void 0,
  // [ParamType.OPERATOR_PATH]: undefined,
  [ParamType.PARAM_PATH]: void 0,
  [ParamType.NODE_PATH]: void 0,
  [ParamType.RAMP]: void 0,
  [ParamType.STRING]: void 0
};
var GlConnectionPointInitValueMap = {
  [
    "bool"
    /* BOOL */
  ]: false,
  // [ConnectionPointType.BVEC2]: [ParamType.BOOLEAN, ParamType.BOOLEAN]
  // [ConnectionPointType.BVEC3]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]
  // [ConnectionPointType.BVEC4]: [ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN, ParamType.BOOLEAN]
  [
    "int"
    /* INT */
  ]: 0,
  // [ConnectionPointType.IVEC2]: [ParamType.INTEGER, ParamType.INTEGER];
  // [ConnectionPointType.IVEC3]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];
  // [ConnectionPointType.IVEC4]: [ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER, ParamType.INTEGER];
  [
    "float"
    /* FLOAT */
  ]: 0,
  [
    "vec2"
    /* VEC2 */
  ]: [0, 0],
  [
    "vec3"
    /* VEC3 */
  ]: [0, 0, 0],
  [
    "vec4"
    /* VEC4 */
  ]: [0, 0, 0, 0],
  [
    "mat3"
    /* MAT3 */
  ]: null,
  [
    "mat4"
    /* MAT4 */
  ]: null,
  [
    "sampler2D"
    /* SAMPLER_2D */
  ]: RampParam.DEFAULT_VALUE_JSON,
  [
    "sampler2DArray"
    /* SAMPLER_2D_ARRAY */
  ]: RampParam.DEFAULT_VALUE_JSON,
  [
    "sampler3D"
    /* SAMPLER_3D */
  ]: RampParam.DEFAULT_VALUE_JSON,
  [
    "samplerCube"
    /* SAMPLER_CUBE */
  ]: RampParam.DEFAULT_VALUE_JSON,
  [
    "SSSModel"
    /* SSS_MODEL */
  ]: "SSSModel()",
  [
    "SDFContext"
    /* SDF_CONTEXT */
  ]: "DefaultSDFContext()",
  [
    "SDFMaterial"
    /* SDF_MATERIAL */
  ]: "DefaultSDFMaterial()"
};
var GlConnectionPoint = class extends BaseConnectionPoint {
  // protected _init_value: any;
  constructor(_name, _type, _init_value) {
    super(_name, _type);
    this._name = _name;
    this._type = _type;
    this._init_value = _init_value;
    this._init_value = this._init_value || GlConnectionPointInitValueMap[this._type];
  }
  type() {
    return this._type;
  }
  are_types_matched(src_type, dest_type) {
    return src_type == dest_type;
  }
  get param_type() {
    return GlConnectionPointTypeToParamTypeMap[this._type];
  }
  get init_value() {
    return this._init_value;
  }
  toJSON() {
    return this._json = this._json || this._createJSON();
  }
  _createJSON() {
    return {
      name: this._name,
      type: this._type
      // isArray: false,
    };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/connections/Event.js
var EventConnectionPointType = ((EventConnectionPointType2) => {
  EventConnectionPointType2["BASE"] = "base";
  EventConnectionPointType2["DRAG"] = "drag";
  EventConnectionPointType2["KEYBOARD"] = "keyboard";
  EventConnectionPointType2["MOUSE"] = "mouse";
  EventConnectionPointType2["POINTER"] = "pointer";
  return EventConnectionPointType2;
})(EventConnectionPointType || {});
var EventConnectionPoint = class extends BaseConnectionPoint {
  constructor(_name, _type, _event_listener) {
    super(_name, _type);
    this._name = _name;
    this._type = _type;
    this._event_listener = _event_listener;
  }
  type() {
    return this._type;
  }
  get param_type() {
    return ParamType.FLOAT;
  }
  are_types_matched(src_type, dest_type) {
    if (dest_type == "base") {
      return true;
    } else {
      return src_type == dest_type;
    }
  }
  get event_listener() {
    return this._event_listener;
  }
  // get param_type(): IConnectionPointTypeToParamTypeMap[T] {
  // 	return ConnectionPointTypeToParamTypeMap[this._type];
  // }
  // get init_value() {
  // 	return this._init_value;
  // }
  toJSON() {
    return this._json = this._json || this._createJSON();
  }
  _createJSON() {
    return {
      name: this._name,
      type: this._type,
      isArray: false
    };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/connections/ConnectionMap.js
var DEFAULT_CONNECTION_POINT_ENUM_MAP = {
  [NodeContext.ANIM]: void 0,
  [NodeContext.AUDIO]: void 0,
  // [NodeContext.CAD]: undefined,
  [NodeContext.COP]: void 0,
  // [NodeContext.CSG]: undefined,
  [NodeContext.EVENT]: EventConnectionPointType.BASE,
  [NodeContext.GL]: GlConnectionPointType.FLOAT,
  [NodeContext.JS]: JsConnectionPointType.FLOAT,
  [NodeContext.MANAGER]: void 0,
  [NodeContext.MAT]: void 0,
  [NodeContext.OBJ]: void 0,
  [NodeContext.POST]: void 0,
  [NodeContext.ROP]: void 0,
  [NodeContext.SOP]: void 0
};
function createConnectionPoint(context, name, type) {
  switch (context) {
    case NodeContext.EVENT: {
      return new EventConnectionPoint(name, type);
    }
    case NodeContext.GL: {
      return new GlConnectionPoint(name, type);
    }
    case NodeContext.JS: {
      return new JsConnectionPoint(name, type);
    }
    default: {
      return void 0;
    }
  }
}
function paramTypeToConnectionPointTypeMap(context) {
  switch (context) {
    case NodeContext.EVENT: {
      return void 0;
    }
    case NodeContext.GL: {
      return GLParamTypeToConnectionPointTypeMap;
    }
    case NodeContext.JS: {
      return JsParamTypeToConnectionPointTypeMap;
    }
    default: {
      return void 0;
    }
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/ConnectionPointsSpareParamsController.js
var ConnectionPointsSpareParamsController = class {
  constructor(node, _context) {
    this.node = node;
    this._context = _context;
    this._raw_input_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._default_value_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._initialized = false;
  }
  initializeNode() {
    if (this._initialized) {
      console.warn("already initialized", this.node);
      return;
    }
    this._initialized = true;
    this.node.params.onParamsCreated("createInputsFromParams", this._createInputsFromParams.bind(this));
  }
  initialized() {
    return this._initialized;
  }
  _createInputsFromParams() {
    const connectionTypeMap = paramTypeToConnectionPointTypeMap(this._context);
    if (!connectionTypeMap) {
      return;
    }
    const connectionPoints = [];
    for (const paramName of this.node.params.names) {
      let addInput = true;
      if (this._inputlessParamNames && this._inputlessParamNames.length > 0 && this._inputlessParamNames.includes(paramName)) {
        addInput = false;
      }
      if (addInput) {
        if (this.node.params.has(paramName)) {
          const param = this.node.params.get(paramName);
          if (param && !param.parentParam()) {
            const connectionType = connectionTypeMap[param.type()];
            if (connectionType) {
              const connectionPoint = createConnectionPoint(
                this._context,
                param.name(),
                connectionType
              );
              if (connectionPoint) {
                connectionPoints.push(connectionPoint);
              }
            }
          }
        }
      }
    }
    this.node.io.inputs.setNamedInputConnectionPoints(connectionPoints);
  }
  setInputlessParamNames(names) {
    return this._inputlessParamNames = names;
  }
  //
  // Create spare params on gl nodes
  //
  createSpareParameters() {
    if (this.node.scene().loadingController.isLoading()) {
      return;
    }
    const current_param_names = this.node.params.spare_names;
    const params_update_options = {};
    for (const param_name of current_param_names) {
      if (this.node.params.has(param_name)) {
        const param = this.node.params.get(param_name);
        if (param) {
          this._raw_input_serialized_by_param_name.set(param_name, param.rawInputSerialized());
          this._default_value_serialized_by_param_name.set(param_name, param.defaultValueSerialized());
          params_update_options.namesToDelete = params_update_options.namesToDelete || [];
          params_update_options.namesToDelete.push(param_name);
        }
      }
    }
    const inputConnectionPoints = this.node.io.inputs.namedInputConnectionPoints();
    if (inputConnectionPoints) {
      let i = 0;
      for (const connection_point of inputConnectionPoints) {
        if (connection_point) {
          const isConnected = this.node.io.inputs.input(i) != null;
          const param_name = connection_point.name();
          const paramType = connection_point.param_type;
          if (paramType) {
            let init_value = connection_point.init_value;
            const last_param_init_value = this._default_value_serialized_by_param_name.get(param_name);
            let default_value_from_name = this.node.paramDefaultValue(param_name);
            if (default_value_from_name != null) {
              init_value = default_value_from_name;
            } else {
              if (last_param_init_value != null) {
                init_value = last_param_init_value;
              } else {
                init_value = connection_point.init_value;
              }
            }
            if (CoreType.isArray(connection_point.init_value)) {
              if (CoreType.isNumber(init_value)) {
                const array = new Array(connection_point.init_value.length);
                array.fill(init_value);
                init_value = array;
              } else if (CoreType.isArray(init_value)) {
                if (init_value.length == connection_point.init_value.length) {
                  if (last_param_init_value != null) {
                    init_value = connection_point.init_value;
                  }
                }
              }
            }
            if (init_value != null && paramType != ParamType.BUTTON) {
              params_update_options.toAdd = params_update_options.toAdd || [];
              params_update_options.toAdd.push({
                name: param_name,
                type: paramType,
                // TODO: I should really treat differently init_value and raw_input here
                initValue: objectClone(init_value),
                rawInput: objectClone(init_value),
                options: {
                  spare: true,
                  editable: !isConnected,
                  // computeOnDirty should be false for PARAM_PATH
                  // so that js/setParam and js/getParam can link to a parameter
                  // without having their parent node actor being recooked
                  computeOnDirty: paramType != ParamType.PARAM_PATH,
                  // dependentOnFoundParam should be false for PARAM_PATH
                  // so that js/setParam and js/getParam can link to a parameter
                  // without having their parent node actor being recooked
                  dependentOnFoundParam: false
                  // dependentOnFoundNode: true,
                }
              });
            }
          }
        }
        i++;
      }
    }
    this.node.params.updateParams(params_update_options);
    for (const spare_param of this.node.params.spare) {
      if (!spare_param.parentParam()) {
        const raw_input = this._raw_input_serialized_by_param_name.get(spare_param.name());
        if (raw_input) {
          spare_param.set(raw_input);
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/ConnectionPointsController.js
function arraysMatch(array0, array1) {
  if (array0.length != array1.length) {
    return false;
  }
  for (let i = 0; i < array0.length; i++) {
    if (array0[i] != array1[i]) {
      return false;
    }
  }
  return true;
}
var ConnectionPointsController = class {
  constructor(node, _context) {
    this.node = node;
    this._context = _context;
    this._create_spare_params_from_inputs = true;
    this._functions_overridden = false;
    this._input_name_function = (index) => {
      return `in${index}`;
    };
    this._output_name_function = (index) => {
      return index == 0 ? "val" : `val${index}`;
    };
    this._expected_input_types_function = () => {
      const type = this.first_input_connection_type() || this.default_connection_type();
      return [type, type];
    };
    this._expected_output_types_function = () => {
      return [this._expected_input_types_function()[0]];
    };
    this._update_signature_if_required_bound = this.update_signature_if_required.bind(this);
    this._initialized = false;
    this._successorsCopy = [];
    this._spare_params_controller = new ConnectionPointsSpareParamsController(this.node, this._context);
  }
  default_connection_type() {
    return DEFAULT_CONNECTION_POINT_ENUM_MAP[this._context];
  }
  createConnectionPoint(name, type) {
    return createConnectionPoint(this._context, name, type);
  }
  functions_overridden() {
    return this._functions_overridden;
  }
  initialized() {
    return this._initialized;
  }
  set_create_spare_params_from_inputs(state) {
    this._create_spare_params_from_inputs = state;
  }
  set_input_name_function(func) {
    this._initialize_if_required();
    this._input_name_function = func;
  }
  set_output_name_function(func) {
    this._initialize_if_required();
    this._output_name_function = func;
  }
  // set_default_input_type(type: ConnectionPointType) {
  // 	this._default_input_type = type;
  // }
  set_expected_input_types_function(func) {
    this._initialize_if_required();
    this._functions_overridden = true;
    this._expected_input_types_function = func;
  }
  set_expected_output_types_function(func) {
    this._initialize_if_required();
    this._functions_overridden = true;
    this._expected_output_types_function = func;
  }
  input_name(index) {
    return this._wrapped_input_name_function(index);
  }
  output_name(index) {
    return this._wrapped_output_name_function(index);
  }
  initializeNode() {
    if (this._initialized) {
      console.warn("already initialized", this.node);
      return;
    }
    this._initialized = true;
    this.node.io.inputs.add_on_set_input_hook(
      "_update_signature_if_required",
      this._update_signature_if_required_bound
    );
    this.node.params.addOnSceneLoadHook("_update_signature_if_required", this._update_signature_if_required_bound);
    this.node.params.onParamsCreated(
      "_update_signature_if_required_bound",
      this._update_signature_if_required_bound
    );
    this.node.addPostDirtyHook("_update_signature_if_required", this._update_signature_if_required_bound);
    if (!this._spare_params_controller.initialized()) {
      this._spare_params_controller.initializeNode();
    }
  }
  _initialize_if_required() {
    if (!this._initialized) {
      this.initializeNode();
    }
  }
  get spare_params() {
    return this._spare_params_controller;
  }
  update_signature_if_required() {
    if (!this.node.lifecycle.creationCompleted() || !this._inputsOutputsMatchExpectations()) {
      this.update_connection_types();
      this.node.removeDirtyState();
      if (!this.node.scene().loadingController.isLoading()) {
        this.make_successors_update_signatures();
      }
    }
  }
  make_successors_update_signatures() {
    const successors = this.node.graphAllSuccessors();
    arrayCopy(successors, this._successorsCopy);
    if (this.node.childrenAllowed()) {
      const subnet_inputs = this.node.nodesByType(NetworkChildNodeType.INPUT);
      const subnet_outputs = this.node.nodesByType(NetworkChildNodeType.OUTPUT);
      for (const subnet_input of subnet_inputs) {
        this._successorsCopy.push(subnet_input);
      }
      for (const subnet_output of subnet_outputs) {
        this._successorsCopy.push(subnet_output);
      }
    }
    for (const graphNode of this._successorsCopy) {
      const node = graphNode;
      if (node.io && node.io.has_connection_points_controller && node.io.connection_points.initialized()) {
        node.io.connection_points.update_signature_if_required();
      }
    }
  }
  update_connection_types() {
    const set_dirty = false;
    const expected_input_types = this._wrapped_expected_input_types_function();
    const expected_output_types = this._wrapped_expected_output_types_function();
    const named_input_connection_points = [];
    for (let i = 0; i < expected_input_types.length; i++) {
      const type = expected_input_types[i];
      const point = this.createConnectionPoint(this._wrapped_input_name_function(i), type);
      named_input_connection_points.push(point);
    }
    const named_output_connect_points = [];
    for (let i = 0; i < expected_output_types.length; i++) {
      const type = expected_output_types[i];
      const point = this.createConnectionPoint(this._wrapped_output_name_function(i), type);
      named_output_connect_points.push(point);
    }
    this.node.io.inputs.setNamedInputConnectionPoints(named_input_connection_points);
    this.node.io.outputs.setNamedOutputConnectionPoints(named_output_connect_points, set_dirty);
    if (this._create_spare_params_from_inputs) {
      this._spare_params_controller.createSpareParameters();
    }
  }
  _inputsOutputsMatchExpectations() {
    const namedInputConnections = this.node.io.inputs.namedInputConnectionPoints();
    const namedOutputConnections = this.node.io.outputs.namedOutputConnectionPoints();
    if (!(namedInputConnections && namedOutputConnections)) {
      return false;
    }
    const inputTypesMatch = arraysMatch(
      // make sure to test the expected ones against all except the inNodeDefinition ones
      namedInputConnections.filter((c) => !(c == null ? void 0 : c.inNodeDefinition())).map((c) => c == null ? void 0 : c.type()),
      this._wrapped_expected_input_types_function()
    );
    const outputTypesMatch = arraysMatch(
      namedOutputConnections.map((c) => c == null ? void 0 : c.type()),
      this._wrapped_expected_output_types_function()
    );
    const inputNamesMatch = arraysMatch(
      // make sure to test the expected ones against all except the inNodeDefinition ones
      namedInputConnections.filter((c) => !(c == null ? void 0 : c.inNodeDefinition())).map((c) => c == null ? void 0 : c.name()),
      namedInputConnections.filter((c) => !(c == null ? void 0 : c.inNodeDefinition())).map((c, i) => this._wrapped_input_name_function(i))
    );
    const outputNamesMatch = arraysMatch(
      namedOutputConnections.map((c) => c == null ? void 0 : c.name()),
      namedOutputConnections.map((c, i) => this._wrapped_output_name_function(i))
    );
    return inputTypesMatch && outputTypesMatch && inputNamesMatch && outputNamesMatch;
  }
  //
  //
  // WRAPPPED METHOD
  // the goal here is to use the types data saved in the scene file
  // when the scene is loading. That has 2 purposes:
  // - avoid an update cascade during loading, where nodes with many inputs are updated
  //	 several times.
  // - allow the subnet_input to load with the connection_points it had on save,
  //   which in turn allows connected nodes to not lose their connections.
  //
  _wrapped_expected_input_types_function() {
    if (this.node.scene().loadingController.isLoading()) {
      const in_data = this.node.io.saved_connection_points_data.in();
      if (in_data) {
        return in_data.map((d) => d.type);
      }
    }
    return this._expected_input_types_function();
  }
  _wrapped_expected_output_types_function() {
    if (this.node.scene().loadingController.isLoading()) {
      const out_data = this.node.io.saved_connection_points_data.out();
      if (out_data) {
        return out_data.map((d) => d.type);
      }
    }
    return this._expected_output_types_function();
  }
  _wrapped_input_name_function(index) {
    if (this.node.scene().loadingController.isLoading()) {
      const in_data = this.node.io.saved_connection_points_data.in();
      if (in_data) {
        return in_data[index].name;
      }
    }
    return this._input_name_function(index);
  }
  _wrapped_output_name_function(index) {
    if (this.node.scene().loadingController.isLoading()) {
      const out_data = this.node.io.saved_connection_points_data.out();
      if (out_data) {
        return out_data[index].name;
      }
    }
    return this._output_name_function(index);
  }
  // protected input_connection_type() {
  // 	return this.first_input_connection_type();
  // }
  // protected output_connection_type() {
  // 	return this.first_input_connection_type();
  // }
  first_input_connection_type() {
    return this.input_connection_type(0);
  }
  input_connection_type(index) {
    const connections = this.node.io.connections.inputConnections();
    if (!connections) {
      return;
    }
    const connection = connections[index];
    if (!connection) {
      return;
    }
    const connectionPoint = connection.srcConnectionPoint();
    if (!connectionPoint) {
      return;
    }
    return connectionPoint.type();
  }
  // input_connection_point_from_connection(connection: TypedNodeConnection<NC>): ConnectionPointTypeMap[NC] {
  // 	const node_dest = connection.node_dest;
  // 	const output_index = connection.output_index;
  // 	return node_dest.io.outputs.namedOutputConnectionPoints()[output_index] as ConnectionPointTypeMap[NC];
  // }
  // output_connection_point_from_connection(connection: TypedNodeConnection<NC>): ConnectionPointTypeMap[NC] {
  // 	const node_src = connection.node_src;
  // 	const output_index = connection.output_index;
  // 	return node_src.io.outputs.namedOutputConnectionPoints()[output_index] as ConnectionPointTypeMap[NC];
  // }
  // connection_point_type_from_connection(connection: TypedNodeConnection<NC>): ConnectionPointEnumMap[NC] {
  // 	return connection.dest_connection_point()?.type as ConnectionPointEnumMap[NC];
  // 	// const connection_point = this.output_connection_point_from_connection(connection)!;
  // 	// return connection_point.type as ConnectionPointEnumMap[NC];
  // }
  // connection_point_name_from_connection(connection: TypedNodeConnection<NC>): string {
  // 	return connection.dest_connection_point()!.name
  // 	// const connection_point = this.output_connection_point_from_connection(connection)!;
  // 	// return connection_point.name;
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/IOController.js
var IOController = class {
  constructor(node) {
    this.node = node;
    this._connections = new ConnectionsController(this.node);
  }
  dispose() {
    this.inputs.dispose();
    this.outputs.dispose();
    this.connections.dispose();
  }
  get connections() {
    return this._connections;
  }
  //
  //
  // inputs
  //
  //
  get inputs() {
    return this._inputs = this._inputs || new NodeInputsController(this.node);
  }
  hasInputs() {
    return this._inputs != null;
  }
  //
  //
  // outputs
  //
  //
  get outputs() {
    return this._outputs = this._outputs || new OutputsController(this.node);
  }
  has_outputs() {
    return this._outputs != null;
  }
  //
  //
  // connection_points
  //
  //
  get connection_points() {
    return this._connection_points = this._connection_points || new ConnectionPointsController(this.node, this.node.context());
  }
  get has_connection_points_controller() {
    return this._connection_points != null;
  }
  //
  //
  // saved connection points data
  //
  //
  get saved_connection_points_data() {
    return this._saved_connection_points_data = this._saved_connection_points_data || new SavedConnectionPointsDataController(this.node);
  }
  clear_saved_connection_points_data() {
    if (this._saved_connection_points_data) {
      this._saved_connection_points_data.clear();
      this._saved_connection_points_data = void 0;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/params/ParamsAccessor.js
var ParamsAccessor = class {
  constructor() {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/_Base.js
var DEFAULT_DATA_TYPE = "default";
var TypedNode = class extends CoreGraphNode {
  // get processing_context(): ProcessingContext {
  // 	return (this._processing_context = this._processing_context || new ProcessingContext(this));
  // }
  constructor(scene, nodeName = "BaseNode", createOptions) {
    super(scene, nodeName);
    this.createOptions = createOptions;
    this.containerController = new TypedContainerController(this);
    this.pv = new ParamsValueAccessor();
    this.p = new ParamsAccessor();
    this._initialized = false;
    const serializerClass = createOptions == null ? void 0 : createOptions.serializerClass;
    if (serializerClass) {
      this._serializer = new serializerClass(this);
    }
  }
  copy_param_values(node) {
    const non_spare = this.params.non_spare;
    for (const param of non_spare) {
      const other_param = node.params.get(param.name());
      if (other_param) {
        param.copyValue(other_param);
      }
    }
  }
  dataType() {
    return DEFAULT_DATA_TYPE;
  }
  get parentController() {
    return this._parentController = this._parentController || new HierarchyParentController(this);
  }
  static displayedInputNames() {
    return void 0;
  }
  displayedInputNames() {
    return this.constructor.displayedInputNames();
  }
  childrenControllerContext() {
    return this._childrenControllerContext;
  }
  _create_childrenController() {
    if (this._childrenControllerContext) {
      return new HierarchyChildrenController(this, this._childrenControllerContext);
    }
  }
  get childrenController() {
    return this._childrenController = this._childrenController || this._create_childrenController();
  }
  childrenAllowed() {
    return this._childrenControllerContext != null;
  }
  sceneReadonly() {
    return false;
  }
  get uiData() {
    return this._uiData = this._uiData || new UIData(this);
  }
  get states() {
    return this._states = this._states || new NodeStatesController(this);
  }
  get lifecycle() {
    return this._lifecycle = this._lifecycle || new NodeLifeCycleController(this);
  }
  get serializer() {
    return this._serializer;
  }
  get cookController() {
    return this._cookController = this._cookController || new NodeCookController(this);
  }
  get io() {
    return this._io = this._io || new IOController(this);
  }
  get nameController() {
    return this._nameController = this._nameController || new NameController(this);
  }
  /**
   * sets the name of a node. Note that if a sibling node already has that name, it will be updated to be unique.
   *
   */
  setName(name) {
    this.nameController.setName(name);
  }
  _setCoreName(name) {
    this._name = name;
  }
  get params() {
    return this._paramsController = this._paramsController || new ParamsController(this);
  }
  initializeBaseAndNode() {
    var _a;
    if (!this._initialized) {
      this._initialized = true;
      (_a = this.displayNodeController) == null ? void 0 : _a.initializeNode();
      this.initializeBaseNode();
      this.initializeNode();
      if (this.polyNodeController) {
        this.polyNodeController.initializeNode();
      }
    } else {
      console.warn("node already initialized");
    }
  }
  initializeBaseNode() {
  }
  initializeNode() {
  }
  static type() {
    throw "type to be overriden";
  }
  /**
   * returns the type of the node.
   *
   */
  type() {
    const c = this.constructor;
    return c.type();
  }
  static context() {
    console.error("node has no node_context", this);
    throw "context requires override";
  }
  /**
   * returns the context.
   *
   */
  context() {
    const c = this.constructor;
    return c.context();
  }
  static requireWebGL2() {
    return false;
  }
  requireWebGL2() {
    const c = this.constructor;
    return c.requireWebGL2();
  }
  setParent(parent) {
    this.parentController.setParent(parent);
  }
  /**
   * returns the parent.
   *
   */
  parent() {
    return this.parentController.parent();
  }
  insideALockedParent() {
    return this.lockedParent() != null;
  }
  lockedOrInsideALockedParent() {
    var _a;
    return ((_a = this.polyNodeController) == null ? void 0 : _a.locked()) || this.insideALockedParent();
  }
  selfOrLockedParent() {
    var _a;
    if ((_a = this.polyNodeController) == null ? void 0 : _a.locked()) {
      return this;
    }
    return this.lockedParent();
  }
  lockedParent() {
    const parent = this.parent();
    if (!parent) {
      return null;
    }
    if (parent.polyNodeController && parent.polyNodeController.locked()) {
      return parent;
    }
    return parent.lockedParent();
  }
  firstAncestorWithContext(context) {
    return this.parentController.firstAncestorWithContext(context);
  }
  root() {
    return this._scene.root();
  }
  /**
   * returns the path.
   *
   */
  path(relative_to_parent) {
    return this.parentController.path(relative_to_parent);
  }
  // params
  createParams() {
  }
  addParam(type, name, default_value, options) {
    var _a;
    return (_a = this._paramsController) == null ? void 0 : _a.addParam(type, name, default_value, options);
  }
  paramDefaultValue(name) {
    return null;
  }
  // cook
  cook(inputContents) {
    return null;
  }
  /**
   * registers a callback that will be run every time the node finishes cooking.
   *
   */
  onCookEnd(callbackName, callback) {
    this.cookController.registerOnCookEnd(callbackName, callback);
  }
  /**
   * returns a promise that will be resolved when the node finishes cooking.
   *
   */
  async compute() {
    var _a, _b;
    if (this.isDirty() || ((_b = (_a = this.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
      return await this.containerController.compute();
    } else {
      return this.containerController.container();
    }
  }
  _setContainer(content) {
    this.containerController.container().set_content(content);
    this.cookController.endCook(
      /*message*/
    );
  }
  /**
   * create a node.
   *
   */
  createNode(nodeClass, options) {
    var _a;
    return (_a = this.childrenController) == null ? void 0 : _a.createNode(nodeClass, options);
  }
  createOperationContainer(type, operation_container_name, options) {
    var _a;
    return (_a = this.childrenController) == null ? void 0 : _a.createOperationContainer(type, operation_container_name, options);
  }
  /**
   * removes a child node
   *
   */
  removeNode(node) {
    var _a;
    (_a = this.childrenController) == null ? void 0 : _a.removeNode(node);
  }
  dispose() {
    super.dispose();
    this.setParent(null);
    if (this._nameController) {
      this._nameController.dispose();
      this._nameController = void 0;
    }
    if (this._io) {
      this._io.dispose();
      this._io = void 0;
    }
    if (this._lifecycle) {
      this._lifecycle.dispose();
      this._lifecycle = void 0;
    }
    if (this.displayNodeController) {
      this.displayNodeController.dispose();
    }
    if (this._childrenController) {
      this._childrenController.dispose();
      this._childrenController = void 0;
    }
    if (this._paramsController) {
      this._paramsController.dispose();
      this._paramsController = void 0;
    }
    if (this._cookController) {
      this._cookController.dispose();
      this._cookController = void 0;
    }
    if (this._serializer) {
      this._serializer.dispose();
      this._serializer = void 0;
    }
    if (this._uiData) {
      this._uiData.dispose();
      this._uiData = void 0;
    }
  }
  /**
   * returns the list of children
   *
   */
  children() {
    var _a;
    return ((_a = this.childrenController) == null ? void 0 : _a.children()) || [];
  }
  /**
   * returns a child node
   *
   */
  node(path) {
    var _a;
    return ((_a = this.parentController) == null ? void 0 : _a.findNode(path)) || null;
  }
  /**
   * returns a sibling node
   *
   */
  nodeSibling(name) {
    var _a;
    const parent = this.parent();
    if (parent) {
      const node = (_a = parent.childrenController) == null ? void 0 : _a.childByName(name);
      if (node) {
        return node;
      }
    }
    return null;
  }
  /**
   * returns the children matching the type
   *
   */
  nodesByType(type) {
    var _a;
    return ((_a = this.childrenController) == null ? void 0 : _a.nodesByType(type)) || [];
  }
  /**
   * sets a node as input
   *
   */
  setInput(inputIndexOrName, node, outputIndexOrName, options) {
    this.io.inputs.setInput(inputIndexOrName, node, outputIndexOrName, options);
  }
  emit(event_name, data = null) {
    this.scene().dispatchController.dispatch(this, event_name, data);
  }
  _eventsDispatcher() {
    return this.__eventsDispatcher = this.__eventsDispatcher || new EventDispatcher();
  }
  dispatchEvent(event) {
    this._eventsDispatcher().dispatchEvent(event);
  }
  addEventListener(type, listener) {
    this._eventsDispatcher().addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this._eventsDispatcher().removeEventListener(type, listener);
  }
  // serializer
  toJSON(includeParamComponents = false) {
    if (!this._serializer) {
      return;
    }
    return this._serializer.toJSON(includeParamComponents);
  }
  // modules
  requiredModules() {
  }
  usedAssembler() {
  }
  integrationData() {
  }
  // error processing
  processError(e) {
    return e;
  }
  updateObjectOnAdd(object, parent) {
  }
  updateObjectOnRemove(object, parent) {
  }
};

export {
  ParamType,
  ColorConversion,
  RampParam,
  ParamTemplate,
  ParamConfig,
  NodeParamsConfig,
  NodeEvent,
  ObjectType,
  registerObjectType,
  AttribClass,
  ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP,
  AttribClassMenuEntriesWithoutCoreGroup,
  TypeAssert,
  CoreObjectType,
  isObject3D,
  verticesFromObject,
  BaseParamConfig,
  MaterialUserDataUniforms,
  assignOnBeforeCompileDataAndFunction,
  OnBeforeCompileDataHandler,
  OnBeforeCompileDataConverter,
  CustomMaterialName,
  cloneMaterial,
  applyCustomMaterials,
  applyRenderHook,
  REVISION,
  FrontSide2 as FrontSide,
  BackSide,
  DoubleSide,
  NoBlending,
  LinearFilter,
  UnsignedByteType,
  UnsignedIntType,
  UnsignedInt248Type,
  DepthStencilFormat,
  LinearEncoding,
  sRGBEncoding,
  BasicDepthPacking,
  EventDispatcher2 as EventDispatcher,
  Vector22 as Vector2,
  Texture2 as Texture,
  Vector42 as Vector4,
  WebGLRenderTarget,
  Vector32 as Vector3,
  Matrix42 as Matrix4,
  Color2 as Color,
  Material2 as Material,
  BufferAttribute2 as BufferAttribute,
  BufferGeometry2 as BufferGeometry,
  Mesh2 as Mesh,
  ShaderMaterial,
  Camera,
  PerspectiveCamera,
  DepthTexture,
  Scene2 as Scene,
  Uniform,
  ThreeMeshBVHHelper,
  mergeGeometries,
  CoreInstancer,
  BaseCoreObject,
  TransformTargetType,
  TRANSFORM_TARGET_TYPES,
  RotationOrder,
  ROTATION_ORDERS,
  rotateGeometry,
  CoreTransform,
  ObjectTransformSpace,
  ObjectTransformMode,
  OBJECT_TRANSFORM_SPACES,
  OBJECT_TRANSFORM_MODES,
  OBJECT_TRANSFORM_SPACE_MENU_ENTRIES,
  applyTransformWithSpaceToObject,
  pointsFromCoreObjects,
  pointsCountFromObject,
  pointsFromObject,
  pointsFromObjectFromGroup,
  CoreGroup,
  OPERATIONS_COMPOSER_NODE_TYPE,
  BaseSopOperation,
  ThreejsCoreObject,
  primitivesFromObject,
  corePointClassFactory,
  coreVertexClassFactory,
  corePrimitiveClassFactory,
  coreObjectClassFactory,
  coreObjectInstanceFactory,
  TypedNumericParam,
  NodePathParam,
  ParamPathParam,
  StringParam,
  TypedMultipleParam,
  FlagsController,
  FlagsControllerD,
  FlagsControllerDB,
  FlagsControllerDBO,
  InputCloneMode,
  NODE_CONNECTION_TRIGGERED_EVENT,
  GlConnectionPointType,
  TypedNode
};
/*! Bundled license information:

three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2023 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)
*/
//# sourceMappingURL=chunk-FUAFRKQ7.js.map
