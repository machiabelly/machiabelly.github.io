import {
  BaseBuilderParamConfig,
  CustomMaterialMeshParamConfig,
  FogParamConfig,
  PCSSController,
  PCSSParamConfig,
  TypedBuilderMatNode,
  UniformFogController,
  UniformsTransparencyController,
  UniformsTransparencyParamConfig,
  WireframeShaderMaterialController,
  WireframeShaderMaterialParamsConfig,
  materialMeshAssemblerCustomMaterialRequested
} from "./chunk-KR5F7M52.js";
import "./chunk-BKKMVJB3.js";
import "./chunk-LTBPBA52.js";
import {
  AOMapParamConfig,
  AdvancedCommonController,
  AdvancedCommonParamConfig,
  AdvancedFolderParamConfig,
  AlphaMapParamConfig,
  BaseTextureMapController,
  BooleanParamOptions,
  BumpMapParamConfig,
  DefaultFolderParamConfig,
  DisplacementMapParamConfig,
  EmissiveMapParamConfig,
  EnvMapParamConfig,
  LightMapParamConfig,
  MapParamConfig,
  MatType,
  MetalnessRoughnessMapParamConfig,
  NodePathOptions,
  NormalMapParamConfig,
  TextureAOMapController,
  TextureAlphaMapController,
  TextureBumpMapController,
  TextureDisplacementMapController,
  TextureEmissiveMapController,
  TextureEnvMapController,
  TextureLightMapController,
  TextureMapController,
  TextureMetalnessRoughnessMapController,
  TextureNormalMapController,
  TexturesFolderParamConfig
} from "./chunk-DPUZQYKG.js";
import "./chunk-EGRHWZRV.js";
import {
  ColorConversion,
  NodeParamsConfig,
  ParamConfig
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import {
  AssemblerName,
  Poly
} from "./chunk-O564GFGZ.js";
import {
  Color,
  MeshPhysicalMaterial,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/MeshPhysicalController.js
var ATTENUATION_DISTANCE_MIN = 1e-4;
function MeshPhysicalParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.clearcoat = ParamConfig.FLOAT(0, { separatorBefore: true });
      this.useClearCoatMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(MeshPhysicalController));
      this.clearcoatMap = ParamConfig.NODE_PATH("", NodePathOptions(MeshPhysicalController, "useClearCoatMap"));
      this.useClearCoatNormalMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(MeshPhysicalController));
      this.clearcoatNormalMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(MeshPhysicalController, "useClearCoatNormalMap")
      );
      this.clearcoatNormalScale = ParamConfig.VECTOR2([1, 1], { visibleIf: { useClearCoatNormalMap: 1 } });
      this.clearcoatRoughness = ParamConfig.FLOAT(0);
      this.useClearCoatRoughnessMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(MeshPhysicalController));
      this.clearcoatRoughnessMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(MeshPhysicalController, "useClearCoatRoughnessMap")
      );
      this.useSheen = ParamConfig.BOOLEAN(0, {
        separatorBefore: true
      });
      this.sheen = ParamConfig.FLOAT(0, {
        range: [0, 1],
        rangeLocked: [true, false],
        visibleIf: { useSheen: 1 }
      });
      this.sheenRoughness = ParamConfig.FLOAT(1, {
        range: [0, 1],
        rangeLocked: [true, false],
        visibleIf: { useSheen: 1 }
      });
      this.sheenColor = ParamConfig.COLOR([1, 1, 1], {
        visibleIf: { useSheen: 1 }
      });
      this.useIridescence = ParamConfig.BOOLEAN(0, {
        separatorBefore: true
      });
      this.iridescence = ParamConfig.FLOAT(1, {
        range: [0, 10],
        rangeLocked: [true, false],
        visibleIf: { useIridescence: 1 }
      });
      this.iridescenceIOR = ParamConfig.FLOAT(1.3, {
        range: [1, 10],
        rangeLocked: [false, false],
        visibleIf: { useIridescence: 1 }
      });
      this.iridescenceThicknessRange = ParamConfig.VECTOR2([0, 1], {
        visibleIf: { useIridescence: 1 }
      });
      this.useIridescenceMap = ParamConfig.BOOLEAN(0, {
        ...BooleanParamOptions(MeshPhysicalController),
        visibleIf: { useIridescence: 1 }
      });
      this.iridescenceMap = ParamConfig.NODE_PATH("", {
        ...NodePathOptions(MeshPhysicalController, "useIridescenceMap"),
        visibleIf: { useIridescence: 1, useIridescenceMap: 1 }
      });
      this.useIridescenceThicknessMap = ParamConfig.BOOLEAN(0, {
        ...BooleanParamOptions(MeshPhysicalController),
        visibleIf: { useIridescence: 1 }
      });
      this.iridescenceThicknessMap = ParamConfig.NODE_PATH("", {
        ...NodePathOptions(MeshPhysicalController, "useIridescenceThicknessMap"),
        visibleIf: { useIridescence: 1, useIridescenceThicknessMap: 1 }
      });
      this.transmission = ParamConfig.FLOAT(0, {
        separatorBefore: true,
        range: [0, 1]
      });
      this.useTransmissionMap = ParamConfig.BOOLEAN(0);
      this.transmissionMap = ParamConfig.NODE_PATH("", { visibleIf: { useTransmissionMap: 1 } });
      this.ior = ParamConfig.FLOAT(1.5, {
        range: [1, 2.3333],
        rangeLocked: [true, true]
      });
      this.thickness = ParamConfig.FLOAT(0.01, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      this.useThicknessMap = ParamConfig.BOOLEAN(0);
      this.thicknessMap = ParamConfig.NODE_PATH("", { visibleIf: { useThicknessMap: 1 } });
      this.attenuationDistance = ParamConfig.FLOAT(100, {
        range: [ATTENUATION_DISTANCE_MIN, 100],
        rangeLocked: [true, false],
        step: 0.01
      });
      this.attenuationColor = ParamConfig.COLOR([1, 1, 1]);
    }
  };
}
function isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return material.clearcoatRoughness != null;
}
var TextureClearCoatMapParamsConfig = class extends MeshPhysicalParamConfig(NodeParamsConfig) {
};
var tmpMeshPhysicalForIOR = new MeshPhysicalMaterial();
var tmpN2 = [0, 0];
var tmpN3 = [0, 0, 0];
var MeshPhysicalController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
    this._sheenColorClone = new Color();
    this._iridescenceRange = [0, 0];
  }
  initializeNode() {
    this.add_hooks(this.node.p.useClearCoatMap, this.node.p.clearcoatMap);
    this.add_hooks(this.node.p.useClearCoatNormalMap, this.node.p.clearcoatNormalMap);
    this.add_hooks(this.node.p.useClearCoatRoughnessMap, this.node.p.clearcoatRoughnessMap);
    this.add_hooks(this.node.p.useTransmissionMap, this.node.p.transmissionMap);
    this.add_hooks(this.node.p.useThicknessMap, this.node.p.thicknessMap);
    this.add_hooks(this.node.p.useIridescenceMap, this.node.p.iridescenceMap);
  }
  static async update(node) {
    const container = await node.compute();
    const material = container.material();
    if (!isValidMaterial(material)) {
      return;
    }
    node.controllers.physical.updateMaterial(material);
  }
  async updateMaterial(material) {
    const pv = this.node.pv;
    const mat = material;
    tmpMeshPhysicalForIOR.ior = pv.ior;
    mat.reflectivity = tmpMeshPhysicalForIOR.reflectivity;
    mat.clearcoat = pv.clearcoat;
    if (mat.clearcoatNormalScale != null) {
      mat.clearcoatNormalScale.copy(pv.clearcoatNormalScale);
    }
    mat.clearcoatRoughness = pv.clearcoatRoughness;
    if (isBooleanTrue(pv.useSheen)) {
      this._sheenColorClone.copy(pv.sheenColor);
      mat.sheen = pv.sheen;
      mat.sheenRoughness = pv.sheenRoughness;
      mat.sheenColor = this._sheenColorClone;
    } else {
      mat.sheen = 0;
    }
    if (isBooleanTrue(pv.useIridescence)) {
      mat.iridescence = pv.iridescence;
      mat.iridescenceIOR = pv.iridescenceIOR;
      mat.iridescenceThicknessRange = pv.iridescenceThicknessRange.toArray(this._iridescenceRange);
    } else {
      mat.iridescence = 0;
    }
    mat.transmission = pv.transmission;
    mat.thickness = pv.thickness;
    mat.attenuationDistance = pv.attenuationDistance;
    mat.attenuationColor = pv.attenuationColor;
    await Promise.all([
      this._update(material, "clearcoatMap", this.node.p.useClearCoatMap, this.node.p.clearcoatMap),
      this._update(
        material,
        "clearcoatNormalMap",
        this.node.p.useClearCoatNormalMap,
        this.node.p.clearcoatNormalMap
      ),
      this._update(
        material,
        "clearcoatRoughnessMap",
        this.node.p.useClearCoatRoughnessMap,
        this.node.p.clearcoatRoughnessMap
      ),
      this._update(material, "transmissionMap", this.node.p.useTransmissionMap, this.node.p.transmissionMap),
      this._update(material, "thicknessMap", this.node.p.useThicknessMap, this.node.p.thicknessMap),
      this._update(material, "iridescenceMap", this.node.p.useIridescenceMap, this.node.p.iridescenceMap),
      this._update(
        material,
        "iridescenceThicknessMap",
        this.node.p.useIridescenceThicknessMap,
        this.node.p.iridescenceThicknessMap
      )
    ]);
  }
  getTextures(material, record) {
    record.set("clearcoatMap", material.clearcoatMap);
    record.set("clearcoatNormalMap", material.clearcoatNormalMap);
    record.set("clearcoatRoughnessMap", material.clearcoatRoughnessMap);
    record.set("transmissionMap", material.transmissionMap);
    record.set("thicknessMap", material.thicknessMap);
    record.set("iridescenceMap", material.iridescenceMap);
    record.set("iridescenceThicknessMap", material.iridescenceThicknessMap);
  }
  setParamsFromMaterial(material, record) {
    const clearcoatMap = () => {
      const mapNode = record.get("clearcoatMap");
      this.node.p.useClearCoatMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.clearcoatMap.setNode(mapNode, { relative: true });
      }
    };
    const clearcoatNormalMap = () => {
      const mapNode = record.get("clearcoatNormalMap");
      this.node.p.useClearCoatNormalMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.clearcoatNormalMap.setNode(mapNode, { relative: true });
      }
    };
    const clearcoatRoughnessMap = () => {
      const mapNode = record.get("clearcoatRoughnessMap");
      this.node.p.useClearCoatRoughnessMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.clearcoatRoughnessMap.setNode(mapNode, { relative: true });
      }
    };
    const transmissionMap = () => {
      const mapNode = record.get("transmissionMap");
      this.node.p.useTransmissionMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.transmissionMap.setNode(mapNode, { relative: true });
      }
    };
    const thicknessMap = () => {
      const mapNode = record.get("thicknessMap");
      this.node.p.useThicknessMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.thicknessMap.setNode(mapNode, { relative: true });
      }
    };
    const iridescenceMap = () => {
      const mapNode = record.get("iridescenceMap");
      this.node.p.useIridescenceMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.iridescenceMap.setNode(mapNode, { relative: true });
      }
    };
    const iridescenceThicknessMap = () => {
      const mapNode = record.get("iridescenceThicknessMap");
      this.node.p.useIridescenceThicknessMap.set(mapNode != null);
      if (mapNode) {
        this.node.p.iridescenceThicknessMap.setNode(mapNode, { relative: true });
      }
    };
    clearcoatMap();
    clearcoatNormalMap();
    clearcoatRoughnessMap();
    transmissionMap();
    thicknessMap();
    iridescenceMap();
    iridescenceThicknessMap();
    const p = this.node.p;
    p.ior.set(material.ior);
    p.clearcoat.set(material.clearcoat);
    material.clearcoatNormalScale.toArray(tmpN2);
    p.clearcoatNormalScale.set(tmpN2);
    p.clearcoatRoughness.set(material.clearcoatRoughness);
    material.sheenColor.toArray(tmpN3);
    p.sheenColor.set(tmpN3);
    p.sheenColor.setConversion(ColorConversion.NONE);
    p.sheen.set(material.sheen);
    p.sheenRoughness.set(material.sheenRoughness);
    p.transmission.set(material.transmission);
    p.thickness.set(material.thickness);
    p.attenuationDistance.set(material.attenuationDistance);
    material.attenuationColor.toArray(tmpN3);
    p.attenuationColor.set(tmpN3);
    p.attenuationColor.setConversion(ColorConversion.NONE);
    p.iridescence.set(material.iridescence);
    p.iridescenceIOR.set(material.iridescenceIOR);
    p.iridescenceThicknessRange.set(material.iridescenceThicknessRange);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/MeshPhysicalBuilder.js
function AdvancedMeshPhysicalParamConfig(Base) {
  return class Mixin extends PCSSParamConfig(
    FogParamConfig(WireframeShaderMaterialParamsConfig(AdvancedCommonParamConfig(BaseBuilderParamConfig(Base))))
  ) {
  };
}
var MeshPhysicalBuilderMatParamsConfig = class extends CustomMaterialMeshParamConfig(
  AdvancedMeshPhysicalParamConfig(
    /* advanced */
    AdvancedFolderParamConfig(
      MeshPhysicalParamConfig(
        MetalnessRoughnessMapParamConfig(
          NormalMapParamConfig(
            LightMapParamConfig(
              EnvMapParamConfig(
                EmissiveMapParamConfig(
                  DisplacementMapParamConfig(
                    BumpMapParamConfig(
                      AOMapParamConfig(
                        AlphaMapParamConfig(
                          MapParamConfig(
                            /* textures */
                            TexturesFolderParamConfig(
                              UniformsTransparencyParamConfig(
                                DefaultFolderParamConfig(NodeParamsConfig)
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
};
var ParamsConfig = new MeshPhysicalBuilderMatParamsConfig();
var MeshPhysicalBuilderMatNode = class extends TypedBuilderMatNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.controllers = {
      advancedCommon: new AdvancedCommonController(this),
      alphaMap: new TextureAlphaMapController(this),
      aoMap: new TextureAOMapController(this),
      bumpMap: new TextureBumpMapController(this),
      displacementMap: new TextureDisplacementMapController(this),
      emissiveMap: new TextureEmissiveMapController(this),
      envMap: new TextureEnvMapController(this),
      uniformFog: new UniformFogController(this),
      lightMap: new TextureLightMapController(this),
      map: new TextureMapController(this),
      metalnessRoughnessMap: new TextureMetalnessRoughnessMapController(this),
      normalMap: new TextureNormalMapController(this),
      physical: new MeshPhysicalController(this),
      PCSS: new PCSSController(this),
      uniformTransparency: new UniformsTransparencyController(this),
      wireframeShader: new WireframeShaderMaterialController(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return MatType.MESH_PHYSICAL_BUILDER;
  }
  usedAssembler() {
    return AssemblerName.GL_MESH_PHYSICAL;
  }
  _createAssemblerController() {
    return Poly.assemblersRegister.assembler(this, this.usedAssembler());
  }
  customMaterialRequested(customName) {
    return materialMeshAssemblerCustomMaterialRequested(this, customName);
  }
  createMaterial() {
    const material = super.createMaterial();
    material.isMeshStandardMaterial = true;
    material.isMeshPhysicalMaterial = true;
    return material;
  }
  async cook() {
    this._material = this._material || this.createMaterial();
    await Promise.all(this.controllersPromises(this._material));
    this.compileIfRequired(this._material);
    this.setMaterial(this._material);
  }
};
export {
  MeshPhysicalBuilderMatNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_mat_MeshPhysicalBuilder.js.map
