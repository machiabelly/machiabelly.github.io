import {
  corePrimitiveClassFactory,
  pointsCountFromObject
} from "./chunk-FUAFRKQ7.js";
import {
  ActorEvaluatorGenerator,
  arrayToSet
} from "./chunk-O564GFGZ.js";
import {
  Object3D,
  computed,
  ref,
  watch
} from "./chunk-6OBTIB4K.js";
import {
  NodeContext
} from "./chunk-PQDBXNT6.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Js.js
var JsType = ((JsType2) => {
  JsType2["ANIMATION_MIXER"] = "animationMixer";
  JsType2["ANIMATION_MIXER_UPDATE"] = "animationMixerUpdate";
  JsType2["ATTRIBUTE"] = "attribute";
  JsType2["CODE"] = "code";
  JsType2["CURSOR"] = "cursor";
  JsType2["FOR_LOOP"] = "forLoop";
  JsType2["GEOLOCATION_CURRENT_POSITION"] = "geolocationCurrentPosition";
  JsType2["GET_INSTANCE_ATTRIBUTE"] = "getInstanceAttribute";
  JsType2["GET_INSTANCE_PROPERTY"] = "getInstanceProperty";
  JsType2["GET_OBJECT_ATTRIBUTE"] = "getObjectAttribute";
  JsType2["GET_OBJECT_PROPERTY"] = "getObjectProperty";
  JsType2["GET_OBJECT_USER_DATA"] = "getObjectUserData";
  JsType2["GET_NODE"] = "getNode";
  JsType2["GET_PARAM"] = "getParam";
  JsType2["GET_POINT_ATTRIBUTE"] = "getPointAttribute";
  JsType2["GET_POINT_PROPERTY"] = "getPointProperty";
  JsType2["GET_PRIMITIVE_ATTRIBUTE"] = "getPrimitiveAttribute";
  JsType2["GLOBALS"] = "globals";
  JsType2["GLOBALS_AMBIENT_LIGHT"] = "globalsAmbientLight";
  JsType2["GLOBALS_AREA_LIGHT"] = "globalsAreaLight";
  JsType2["GLOBALS_DIRECTIONAL_LIGHT"] = "globalsDirectionalLight";
  JsType2["GLOBALS_HEMISPHERE_LIGHT"] = "globalsHemisphereLight";
  JsType2["GLOBALS_POINT_LIGHT"] = "globalsPointLight";
  JsType2["GLOBALS_SPOT_LIGHT"] = "globalsSpotLight";
  JsType2["IMPORT_ATTRIBUTE"] = "importAttribute";
  JsType2["KEYFRAMES"] = "keyframes";
  JsType2["ON_CHILD_ATTRIBUTE_UPDATE"] = "onChildAttributeUpdate";
  JsType2["ON_KEY"] = "onKey";
  JsType2["ON_KEYDOWN"] = "onKeydown";
  JsType2["ON_KEYPRESS"] = "onKeypress";
  JsType2["ON_KEYUP"] = "onKeyup";
  JsType2["ON_MAPBOX_CAMERA_MOVE"] = "onMapboxCameraMove";
  JsType2["ON_MAPBOX_CAMERA_MOVE_START"] = "onMapboxCameraMoveStart";
  JsType2["ON_MAPBOX_CAMERA_MOVE_END"] = "onMapboxCameraMoveEnd";
  JsType2["ON_OBJECT_ATTRIBUTE_UPDATE"] = "onObjectAttributeUpdate";
  JsType2["ON_OBJECT_BEFORE_DELETE"] = "onObjectBeforeDelete";
  JsType2["ON_OBJECT_CLICK"] = "onObjectClick";
  JsType2["ON_OBJECT_CLICK_GPU"] = "onObjectClickGPU";
  JsType2["ON_OBJECT_CONTEXT_MENU"] = "onObjectContextMenu";
  JsType2["ON_OBJECT_CONTEXT_MENU_GPU"] = "onObjectContextMenuGPU";
  JsType2["ON_OBJECT_DISPATCH_EVENT"] = "onObjectDispatchEvent";
  JsType2["ON_OBJECT_HOVER"] = "onObjectHover";
  JsType2["ON_OBJECT_HOVER_GPU"] = "onObjectHoverGPU";
  JsType2["ON_OBJECT_LONG_PRESS"] = "onObjectLongPress";
  JsType2["ON_OBJECT_LONG_PRESS_GPU"] = "onObjectLongPressGPU";
  JsType2["ON_OBJECT_MOUSE_CLICK"] = "onObjectMouseClick";
  JsType2["ON_OBJECT_POINTERDOWN"] = "onObjectPointerdown";
  JsType2["ON_OBJECT_POINTERDOWN_GPU"] = "onObjectPointerdownGPU";
  JsType2["ON_OBJECT_POINTERUP"] = "onObjectPointerup";
  JsType2["ON_OBJECT_POINTERUP_GPU"] = "onObjectPointerupGPU";
  JsType2["ON_OBJECT_SWIPE"] = "onObjectSwipe";
  JsType2["ON_OBJECT_SWIPE_GPU"] = "onObjectSwipeGPU";
  JsType2["ON_OBJECT_SWIPEDOWN"] = "onObjectSwipedown";
  JsType2["ON_OBJECT_SWIPELEFT"] = "onObjectSwipeleft";
  JsType2["ON_OBJECT_SWIPERIGHT"] = "onObjectSwiperight";
  JsType2["ON_OBJECT_SWIPEUP"] = "onObjectSwipeup";
  JsType2["ON_POINTERDOWN"] = "onPointerdown";
  JsType2["ON_POINTERUP"] = "onPointerup";
  JsType2["ON_SCENE_PAUSE"] = "onScenePause";
  JsType2["ON_SCENE_PLAY"] = "onScenePlay";
  JsType2["ON_SCENE_RESET"] = "onSceneReset";
  JsType2["ON_SCROLL"] = "onScroll";
  JsType2["ON_MANUAL_TRIGGER"] = "onManualTrigger";
  JsType2["ON_TICK"] = "onTick";
  JsType2["ON_PERFORMANCE_CHANGE"] = "onPerformanceChange";
  JsType2["ON_VIDEO_EVENT"] = "onVideoEvent";
  JsType2["ON_VIEWER_CONTROLS_EVENT"] = "onViewerControlsEvent";
  JsType2["ON_WEBXR_CONTROLLER_EVENT"] = "onWebXRControllerEvent";
  JsType2["OUTPUT"] = "output";
  JsType2["OUTPUT_AMBIENT_LIGHT"] = "outputAmbientLight";
  JsType2["OUTPUT_AREA_LIGHT"] = "outputAreaLight";
  JsType2["OUTPUT_DIRECTIONAL_LIGHT"] = "outputDirectionalLight";
  JsType2["OUTPUT_HEMISPHERE_LIGHT"] = "outputHemisphereLight";
  JsType2["OUTPUT_POINT_LIGHT"] = "outputPointLight";
  JsType2["OUTPUT_SPOT_LIGHT"] = "outputSpotLight";
  JsType2["PARAM"] = "param";
  JsType2["RAY_FROM_CURSOR"] = "rayFromCursor";
  JsType2["RAY_FROM_CAMERA"] = "rayFromCamera";
  JsType2["SDF_2D_BOX"] = "SDF2DBox";
  JsType2["SDF_2D_CIRCLE"] = "SDF2DCircle";
  JsType2["SDF_2D_CROSS"] = "SDF2DCross";
  JsType2["SDF_2D_HEART"] = "SDF2DHeart";
  JsType2["SDF_2D_ROUNDED_X"] = "SDF2DRoundedX";
  JsType2["SDF_BOX"] = "SDFBox";
  JsType2["SDF_ELONGATE"] = "SDFElongate";
  JsType2["SDF_ONION"] = "SDFOnion";
  JsType2["SDF_PLANE"] = "SDFPlane";
  JsType2["SDF_REVOLUTION"] = "SDFRevolution";
  JsType2["SDF_SPHERE"] = "SDFSphere";
  JsType2["SDF_TORUS"] = "SDFTorus";
  JsType2["SDF_TRANSFORM"] = "SDFTransform";
  JsType2["SDF_TUBE"] = "SDFTube";
  JsType2["SET_INSTANCE_ATTRIBUTE"] = "setInstanceAttribute";
  JsType2["SET_INSTANCE_LOOK_AT"] = "setInstanceLookAt";
  JsType2["SET_INSTANCE_POSITION"] = "setInstancePosition";
  JsType2["SET_INSTANCE_QUATERNION"] = "setInstanceQuaternion";
  JsType2["SET_INSTANCE_SCALE"] = "setInstanceScale";
  JsType2["SET_OBJECT_ATTRIBUTE"] = "setObjectAttribute";
  JsType2["SET_OBJECT_LOOK_AT"] = "setObjectLookAt";
  JsType2["SET_OBJECT_POSITION"] = "setObjectPosition";
  JsType2["SET_OBJECT_QUATERNION"] = "setObjectQuaternion";
  JsType2["SET_OBJECT_ROTATION"] = "setObjectRotation";
  JsType2["SET_OBJECT_SCALE"] = "setObjectScale";
  JsType2["SET_PARAM"] = "setParam";
  JsType2["SET_PHYSICS_RBD_POSITION"] = "setPhysicsRBDPosition";
  JsType2["SET_PLAYER_INPUT"] = "setPlayerInput";
  JsType2["SET_POINT_ATTRIBUTE"] = "setPointAttribute";
  JsType2["SET_POINT_POSITION"] = "setPointPosition";
  JsType2["SET_SOFT_BODY_CONSTRAINT_POSITION"] = "setSoftBodyConstraintPosition";
  JsType2["SET_SOFT_BODY_POSITION"] = "setSoftBodyPosition";
  JsType2["SET_SOFT_BODY_VELOCITY"] = "setSoftBodyVelocity";
  JsType2["SET_WFC_SOFT_CONSTRAINT"] = "setWFCSoftConstraint";
  JsType2["WFC_BUILD"] = "WFCBuild";
  return JsType2;
})(JsType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/utils/NodeFinder.js
var JsNodeFinder = class {
  static findOutputNodes(node) {
    const output = node.nodesByType(JsType.OUTPUT);
    const outputAmbientLight = node.nodesByType(JsType.OUTPUT_AMBIENT_LIGHT);
    const outputAreaLight = node.nodesByType(JsType.OUTPUT_AREA_LIGHT);
    const outputDirectionalLight = node.nodesByType(JsType.OUTPUT_DIRECTIONAL_LIGHT);
    const outputHemisphereLight = node.nodesByType(JsType.OUTPUT_HEMISPHERE_LIGHT);
    const outputPointLight = node.nodesByType(JsType.OUTPUT_POINT_LIGHT);
    const outputSpotLight = node.nodesByType(JsType.OUTPUT_SPOT_LIGHT);
    return output.concat(outputAmbientLight).concat(outputAreaLight).concat(outputDirectionalLight).concat(outputHemisphereLight).concat(outputPointLight).concat(outputSpotLight);
  }
  static findParamGeneratingNodes(node) {
    var _a;
    const list = [];
    (_a = node.childrenController) == null ? void 0 : _a.traverseChildren(
      (child) => {
        const childJsNode = child;
        if (childJsNode.paramsGenerating()) {
          list.push(childJsNode);
        }
      },
      (child) => {
        if (!child.childrenController) {
          return child.context() == NodeContext.GL;
        } else {
          return child.context() == NodeContext.GL && child.childrenController.context == NodeContext.GL;
        }
      }
    );
    return list;
  }
  // static findVaryingNodes(node: BaseJsParentNode) {
  // 	const nodes = node.nodesByType(JsType.VARYING_WRITE);
  // 	return nodes;
  // }
  static findAttributeExportNodes(node) {
    const nodes = node.nodesByType(JsType.ATTRIBUTE);
    return nodes.filter((node2) => {
      return node2.isExporting();
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/assemblers/_BaseEvaluator.js
var BaseEvaluator = class {
  constructor(node) {
    this.node = node;
    this._watchStopHandles = [];
    this.scene = node.scene();
    this.timeController = this.scene.timeController;
  }
  onDispose(callback) {
    this._onDisposeCallbacks = this._onDisposeCallbacks || [];
    this._onDisposeCallbacks.push(callback);
  }
  dispose() {
    const _disposeWatchEffects = () => {
      if (!this._watchStopHandles) {
        return;
      }
      let watchStopHandle;
      while (watchStopHandle = this._watchStopHandles.pop()) {
        watchStopHandle();
      }
    };
    const _runOnDisposeCallback = () => {
      if (!this._onDisposeCallbacks) {
        return;
      }
      let callback;
      while (callback = this._onDisposeCallbacks.pop()) {
        callback();
      }
    };
    _runOnDisposeCallback();
    _disposeWatchEffects();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/assemblers/actor/ActorEvaluator.js
var EVALUATOR_METHOD_NAMES = [
  JsType.ON_KEY,
  JsType.ON_KEYDOWN,
  JsType.ON_KEYPRESS,
  JsType.ON_KEYUP,
  // JsType.ON_MANUAL_TRIGGER,
  JsType.ON_MAPBOX_CAMERA_MOVE,
  JsType.ON_MAPBOX_CAMERA_MOVE_START,
  JsType.ON_MAPBOX_CAMERA_MOVE_END,
  JsType.ON_OBJECT_ATTRIBUTE_UPDATE,
  // JsType.ON_OBJECT_CLICK,
  // 'onClick',
  JsType.ON_OBJECT_DISPATCH_EVENT,
  // JsType.ON_OBJECT_HOVER,
  // JsType.ON_OBJECT_POINTERDOWN,
  // JsType.ON_OBJECT_POINTERUP,
  JsType.ON_PERFORMANCE_CHANGE,
  JsType.ON_POINTERDOWN,
  "onPointermove",
  JsType.ON_POINTERUP,
  JsType.ON_SCENE_PAUSE,
  JsType.ON_SCENE_PLAY,
  JsType.ON_SCENE_RESET,
  JsType.ON_TICK,
  JsType.ON_VIDEO_EVENT,
  JsType.ON_WEBXR_CONTROLLER_EVENT
];
var ActorEvaluator = class extends BaseEvaluator {
  constructor(node, object3D) {
    super(node);
    this.node = node;
    this.object3D = object3D;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/utils/Common.js
var FUNC_POINTS_COUNT_FROM_OBJECT = `pointsCountFromObject`;
var FUNC_CORE_PRIMITIVE_CLASS_FACTORY = `corePrimitiveClassFactory`;

// node_modules/@polygonjs/polygonjs/dist/src/core/actor/ActorCompilationController.js
var FUNCTION_ARGS_DICT = {
  [FUNC_POINTS_COUNT_FROM_OBJECT]: pointsCountFromObject,
  [FUNC_CORE_PRIMITIVE_CLASS_FACTORY]: corePrimitiveClassFactory,
  ActorEvaluator,
  computed,
  ref,
  watch
};
var FUNCTION_ARG_NAMES = Object.keys(FUNCTION_ARGS_DICT);
var FUNCTION_ARGS = FUNCTION_ARG_NAMES.map((argName) => FUNCTION_ARGS_DICT[argName]);
var ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT_NAME = "ActorCompilationController-DUMMY";
function _createDummyObject() {
  const object = new Object3D();
  object.name = ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT_NAME;
  return object;
}
var ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT = _createDummyObject();
var ActorCompilationController = class {
  constructor(node) {
    this.node = node;
    this._evaluatorGenerator = new ActorEvaluatorGenerator(
      (object) => new ActorEvaluator(this.node, object)
    );
  }
  compileIfRequired() {
    var _a;
    if ((_a = this.node.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      this.compile();
    }
    this._evaluatorGenerator.clearObjects();
  }
  evaluatorGenerator() {
    return this._evaluatorGenerator;
  }
  functionData() {
    return this._functionData;
  }
  _resetFunctionData() {
    this._functionData = void 0;
  }
  updateFromFunctionData(functionData) {
    this._functionData = functionData;
    const { functionBody, variableNames, variablesByName, functionNames, functionsByName, paramConfigs, eventDatas } = this._functionData;
    const wrappedBody = `
			try {
				${functionBody}
			} catch(e) {
				console.log(e);
				_setErrorFromError(e)
				return null
			}`;
    const _setErrorFromError = (e) => {
      this.node.states.error.set(e.message);
    };
    const variables = [];
    const functions = [];
    for (const variableName of variableNames) {
      const variable = variablesByName[variableName];
      variables.push(variable);
    }
    for (const functionName of functionNames) {
      const _func = functionsByName[functionName];
      functions.push(_func);
    }
    const paramConfigUniformNames = paramConfigs.map((pc) => pc.uniformName());
    paramConfigs.forEach((p) => p.applyToNode(this.node));
    const functionCreationArgs = [
      ...FUNCTION_ARG_NAMES,
      "_setErrorFromError",
      ...variableNames,
      ...functionNames,
      // ...FUNCTION_UTILS.names,
      ...paramConfigUniformNames,
      wrappedBody
    ];
    const functionEvalArgs = () => [
      ...FUNCTION_ARGS,
      _setErrorFromError,
      // it is currently preferable to create a unique set of variables
      // for each evaluator
      ...variables.map((v) => v.clone()),
      ...functions
      // ...FUNCTION_UTILS.functions,
    ];
    try {
      const _function = new Function(...functionCreationArgs);
      const _createEvaluator = (object) => {
        const evaluatorClass = _function(...functionEvalArgs());
        const evaluator = new evaluatorClass(this.node, object);
        return evaluator;
      };
      const evaluatorGenerator = new ActorEvaluatorGenerator((object) => {
        const evaluator = _createEvaluator(object);
        return this.node.scene().dispatchController.processActorEvaluator(evaluator) || evaluator;
      });
      const dummyEvaluator = _createEvaluator(ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT);
      evaluatorGenerator.setExpectedEvaluatorMethodNames(dummyEvaluator);
      evaluatorGenerator.eventDatas = evaluatorGenerator.eventDatas || /* @__PURE__ */ new Set();
      arrayToSet(eventDatas, evaluatorGenerator.eventDatas);
      this._setEvaluatorGenerator(evaluatorGenerator);
    } catch (e) {
      console.warn(e);
      console.log(`failed to compile actor node ${this.node.path()}`);
      console.log({ functionData });
      this.node.states.error.set("failed to compile");
    }
  }
  _setEvaluatorGenerator(evaluatorGenerator) {
    this.node.scene().actorsManager.unregisterEvaluatorGenerator(this._evaluatorGenerator);
    this._evaluatorGenerator.clearObjects();
    this._evaluatorGenerator = evaluatorGenerator;
    this.node.scene().actorsManager.registerEvaluatorGenerator(evaluatorGenerator);
  }
  compile() {
    const assemblerController = this.node.assemblerController();
    if (!assemblerController) {
      return;
    }
    this.node.states.error.clear();
    assemblerController.assembler.updateFunction();
    const paramNodes = JsNodeFinder.findParamGeneratingNodes(this.node);
    try {
      const functionData = assemblerController.assembler.createFunctionData(paramNodes);
      if (!functionData) {
        this._resetFunctionData();
        return;
      }
      this.updateFromFunctionData(functionData);
      assemblerController.post_compile();
    } catch (err) {
      console.log(err);
      this._resetFunctionData();
    }
    this._runOnCompilationCompletedCallbacks();
  }
  addOnCompilationCompleted(callback) {
    this._onCompilationCompletedCallbacks = this._onCompilationCompletedCallbacks || /* @__PURE__ */ new Set();
    this._onCompilationCompletedCallbacks.add(callback);
  }
  removeOnCompilationCompleted(callback) {
    if (!this._onCompilationCompletedCallbacks) {
      return;
    }
    this._onCompilationCompletedCallbacks.delete(callback);
    if (this._onCompilationCompletedCallbacks.size == 0) {
      this._onCompilationCompletedCallbacks = void 0;
    }
  }
  _runOnCompilationCompletedCallbacks() {
    if (!this._onCompilationCompletedCallbacks) {
      return;
    }
    this._onCompilationCompletedCallbacks.forEach((callback) => callback());
  }
};

export {
  JsType,
  EVALUATOR_METHOD_NAMES,
  ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT,
  ActorCompilationController
};
//# sourceMappingURL=chunk-SY7VELMA.js.map
