import {
  ColorConversion,
  NodeParamsConfig,
  ParamConfig,
  TypedNode
} from "./chunk-FUAFRKQ7.js";
import {
  TypedNodePathParamValue
} from "./chunk-RVFV2LA3.js";
import {
  Poly,
  arrayCompact
} from "./chunk-O564GFGZ.js";
import {
  AdditiveBlending,
  BackSide,
  DoubleSide,
  FrontSide,
  MultiplyBlending,
  NoBlending,
  NormalBlending,
  ObjectSpaceNormalMap,
  SubtractiveBlending,
  TangentSpaceNormalMap,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import {
  NodeContext
} from "./chunk-PQDBXNT6.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/_Base.js
var TypedMatNode = class extends TypedNode {
  constructor() {
    super(...arguments);
    this._cookWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);
  }
  static context() {
    return NodeContext.MAT;
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.io.outputs.setHasOneOutput();
    this.addPostDirtyHook("_cookWhenDirty", () => {
      setTimeout(this._cookWhenDirtyBound, 0);
    });
  }
  async _cookMainWithoutInputsWhenDirty() {
    await this.cookController.cookMainWithoutInputs();
  }
  setMaterial(material) {
    Poly.onSceneUpdatedHooks.runHooks();
    this._setContainer(material);
  }
};
var PrimitiveMatNode = class extends TypedMatNode {
  constructor() {
    super(...arguments);
    this.controllersList = [];
  }
  __materialSync__() {
    return this._material = this._material || this.createMaterial();
  }
  async material() {
    const container = await this.compute();
    return container.material();
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.nameController.add_post_set_fullPath_hook(this.set_material_name.bind(this));
  }
  set_material_name() {
    if (this._material) {
      this._material.name = this.path();
    }
  }
  setMaterial(material) {
    this._material = material;
    super.setMaterial(material);
  }
  getTextures(material, record) {
    for (const controller of this.controllersList) {
      controller.getTextures(material, record);
    }
  }
  setParamsFromMaterial(material, record) {
    for (const controller of this.controllersList) {
      controller.setParamsFromMaterial(material, record);
    }
  }
  controllersPromises(material) {
    const promises = this.controllersList.map((controller) => controller.updateMaterial(material));
    const compactPromises = [];
    arrayCompact(promises, compactPromises);
    return compactPromises;
  }
  initializeNode() {
    this.params.onParamsCreated("init controllers", () => {
      for (const controller of this.controllersList) {
        controller.initializeNode();
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/_BaseController.js
var BaseController = class {
  constructor(node) {
    this.node = node;
  }
  // add_params() {}
  initializeNode() {
  }
  setParamsFromMaterial(material, record) {
  }
  getTextures(material, record) {
  }
  // get material() {
  // 	return this.node.material;
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/helpers/MaterialSideHelper.js
function updateMaterialSide(mat, params) {
  const singleSide = isBooleanTrue(params.front) ? FrontSide : BackSide;
  const newSide = isBooleanTrue(params.doubleSided) ? DoubleSide : singleSide;
  if (newSide != mat.side) {
    mat.side = newSide;
    mat.forceSinglePass = !isBooleanTrue(params.doubleSided);
    mat.needsUpdate = true;
  }
}
function updateNodeSide(mat, params) {
  switch (mat.side) {
    case FrontSide: {
      params.doubleSided.set(false);
      params.front.set(true);
      return;
    }
    case BackSide: {
      params.doubleSided.set(false);
      params.front.set(false);
      return;
    }
    case DoubleSide: {
      params.doubleSided.set(true);
      params.front.set(true);
      return;
    }
  }
}
function updateMaterialSideWithShadow(mat, params) {
  updateMaterialSide(mat, params);
  if (isBooleanTrue(params.overrideShadowSide)) {
    const singleSide = isBooleanTrue(params.shadowFront) ? FrontSide : BackSide;
    const newSide = isBooleanTrue(params.shadowDoubleSided) ? DoubleSide : singleSide;
    if (newSide != mat.shadowSide) {
      mat.shadowSide = newSide;
      mat.needsUpdate = true;
    }
  } else {
    mat.shadowSide = null;
  }
  const customMaterials = mat.customMaterials;
  if (customMaterials) {
    const customNames = Object.keys(customMaterials);
    for (const customName of customNames) {
      const customMaterial = customMaterials[customName];
      if (customMaterial) {
        updateMaterialSideWithShadow(customMaterial, params);
      }
    }
  }
}
function updateNodeSideWithShadow(mat, params) {
  updateNodeSide(mat, params);
  if (mat.shadowSide != null) {
    params.overrideShadowSide.set(true);
    switch (mat.shadowSide) {
      case FrontSide: {
        params.shadowDoubleSided.set(false);
        params.shadowFront.set(true);
        return;
      }
      case BackSide: {
        params.shadowDoubleSided.set(false);
        params.shadowFront.set(false);
        return;
      }
      case DoubleSide: {
        params.shadowDoubleSided.set(true);
        params.shadowFront.set(true);
        return;
      }
    }
  }
  const customMaterials = mat.customMaterials;
  if (customMaterials) {
    const customNames = Object.keys(customMaterials);
    for (const customName of customNames) {
      const customMaterial = customMaterials[customName];
      if (customMaterial) {
        updateNodeSideWithShadow(customMaterial, params);
      }
    }
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/AdvancedCommonController.js
var BLENDING_VALUES = {
  NoBlending,
  NormalBlending,
  AdditiveBlending,
  SubtractiveBlending,
  MultiplyBlending
};
var BLENDING_VALUE_NAMES = Object.keys(BLENDING_VALUES);
function AdvancedCommonParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.doubleSided = ParamConfig.BOOLEAN(0);
      this.front = ParamConfig.BOOLEAN(1, { visibleIf: { doubleSided: false } });
      this.overrideShadowSide = ParamConfig.BOOLEAN(0);
      this.shadowDoubleSided = ParamConfig.BOOLEAN(0, { visibleIf: { overrideShadowSide: true } });
      this.shadowFront = ParamConfig.BOOLEAN(1, { visibleIf: { overrideShadowSide: true, shadowDoubleSided: false } });
      this.colorWrite = ParamConfig.BOOLEAN(1, {
        separatorBefore: true,
        cook: false,
        callback: (node, param) => {
          AdvancedCommonController.update(node);
        }
      });
      this.depthWrite = ParamConfig.BOOLEAN(1, {
        cook: false,
        callback: (node, param) => {
          AdvancedCommonController.update(node);
        }
      });
      this.depthTest = ParamConfig.BOOLEAN(1, {
        cook: false,
        callback: (node, param) => {
          AdvancedCommonController.update(node);
        }
      });
      this.premultipliedAlpha = ParamConfig.BOOLEAN(false, {
        separatorAfter: true
      });
      this.blending = ParamConfig.INTEGER(NormalBlending, {
        menu: {
          entries: BLENDING_VALUE_NAMES.map((name) => {
            return { name, value: BLENDING_VALUES[name] };
          })
        }
      });
      this.dithering = ParamConfig.BOOLEAN(0);
      this.polygonOffset = ParamConfig.BOOLEAN(false, { separatorBefore: true });
      this.polygonOffsetFactor = ParamConfig.INTEGER(0, { range: [0, 1e3], visibleIf: { polygonOffset: 1 } });
      this.polygonOffsetUnits = ParamConfig.INTEGER(0, { range: [0, 1e3], visibleIf: { polygonOffset: 1 } });
    }
  };
}
var AdvancedCommonParamsConfig = class extends AdvancedCommonParamConfig(NodeParamsConfig) {
};
var AdvancedCommonController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!material) {
      return;
    }
    node.controllers.advancedCommon.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    updateMaterialSideWithShadow(material, pv);
    material.colorWrite = pv.colorWrite;
    material.depthWrite = pv.depthWrite;
    material.depthTest = pv.depthTest;
    material.blending = pv.blending;
    material.premultipliedAlpha = pv.premultipliedAlpha;
    material.dithering = pv.dithering;
    material.polygonOffset = pv.polygonOffset;
    if (material.polygonOffset) {
      material.polygonOffsetFactor = pv.polygonOffsetFactor;
      material.polygonOffsetUnits = pv.polygonOffsetUnits;
      material.needsUpdate = true;
    }
  }
  setParamsFromMaterial(material, record) {
    const p = this.node.p;
    updateNodeSideWithShadow(material, p);
    p.colorWrite.set(material.colorWrite);
    p.depthWrite.set(material.depthWrite);
    p.depthTest.set(material.depthTest);
    p.blending.set(material.blending);
    p.premultipliedAlpha.set(material.premultipliedAlpha);
    p.dithering.set(material.dithering);
    p.polygonOffset.set(material.polygonOffset);
    if (material.polygonOffset) {
      p.polygonOffsetFactor.set(material.polygonOffsetFactor);
      p.polygonOffsetUnits.set(material.polygonOffsetUnits);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/_BaseTextureController.js
function BooleanParamOptions(controller_class) {
  return {
    cook: false,
    callback: (node, param) => {
      controller_class.update(node);
    }
  };
}
function NodePathOptions(controller, use_map_name, options) {
  return {
    visibleIf: { [use_map_name]: 1 },
    nodeSelection: { context: NodeContext.COP, types: options == null ? void 0 : options.types },
    cook: false,
    callback: (node, param) => {
      controller.update(node);
    }
  };
}
var CALLBACK_NAME = "TextureController";
var BaseTextureMapController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
    this.updateBound = this.update.bind(this);
  }
  add_hooks(use_map_param, path_param) {
    use_map_param.addPostDirtyHook(CALLBACK_NAME, this.updateBound);
    path_param.addPostDirtyHook(CALLBACK_NAME, this.updateBound);
  }
  static async update(node) {
  }
  async update() {
  }
  async _update(material, mat_attrib_name, use_map_param, path_param) {
    const mat = material;
    const attr_name = mat_attrib_name;
    await this._update_texture_on_material(mat, attr_name, use_map_param, path_param);
  }
  //
  //
  // FOR CASES WHERE THE TEXTURE IS ON THE MATERIAL
  //
  //
  async _update_texture_on_material(material, mat_attrib_name, use_map_param, path_param) {
    await this._update_required_attribute(
      material,
      material,
      mat_attrib_name,
      use_map_param,
      path_param,
      this._apply_texture_on_material.bind(this),
      this._remove_texture_from_material.bind(this)
    );
  }
  _apply_texture_on_material(material, texture_owner, mat_attrib_name, newTexture) {
    const currentTexture = texture_owner[mat_attrib_name];
    let textureChangeRequired = false;
    if (currentTexture) {
      if (currentTexture.uuid != newTexture.uuid) {
        textureChangeRequired = true;
      }
    }
    if (currentTexture == null || textureChangeRequired) {
      texture_owner[mat_attrib_name] = newTexture;
      material.needsUpdate = true;
    }
    Poly.onSceneUpdatedHooks.runHooks();
  }
  _remove_texture_from_material(material, texture_owner, mat_attrib_name) {
    if (texture_owner[mat_attrib_name]) {
      texture_owner[mat_attrib_name] = null;
      material.needsUpdate = true;
    }
    Poly.onSceneUpdatedHooks.runHooks();
  }
  //
  //
  // MAIN ALGO to decide if texture should be updated
  //
  //
  async _update_required_attribute(material, texture_owner, mat_attrib_name, use_map_param, path_param, update_callback, remove_callback) {
    if (use_map_param.isDirty()) {
      await use_map_param.compute();
    }
    const use_map = use_map_param.value;
    if (use_map) {
      if (path_param.isDirty()) {
        await path_param.compute();
      }
      const texture_node = path_param.value.nodeWithContext(NodeContext.COP);
      if (texture_node) {
        const container = await texture_node.compute();
        const texture = container.texture();
        if (texture) {
          await update_callback(material, texture_owner, mat_attrib_name, texture);
          return;
        }
      }
    }
    remove_callback(material, texture_owner, mat_attrib_name);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureMapController.js
function MapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useMap = ParamConfig.BOOLEAN(0, {
        ...BooleanParamOptions(TextureMapController),
        separatorBefore: true
      });
      this.map = ParamConfig.NODE_PATH("", NodePathOptions(TextureMapController, "useMap"));
    }
  };
}
function _isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return true;
}
var TextureMapParamsConfig = class extends MapParamConfig(NodeParamsConfig) {
};
var TextureMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useMap, this.node.p.map);
  }
  static async update(node) {
    node.controllers.map.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial(material)) {
      console.warn("invalid mat for TextureMapController", material);
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "map", this.node.p.useMap, this.node.p.map);
  }
  getTextures(material, record) {
    record.set("map", material.map);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("map");
    this.node.p.useMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.map.setNode(mapNode, { relative: true });
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureAlphaMapController.js
function AlphaMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useAlphaMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureAlphaMapController)
      });
      this.alphaMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureAlphaMapController, "useAlphaMap"));
    }
  };
}
function _isValidMaterial2(material) {
  if (!material) {
    return false;
  }
  return true;
}
var TextureAlphaMapParamsConfig = class extends AlphaMapParamConfig(NodeParamsConfig) {
};
var TextureAlphaMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useAlphaMap, this.node.p.alphaMap);
  }
  static async update(node) {
    node.controllers.alphaMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial2(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "alphaMap", this.node.p.useAlphaMap, this.node.p.alphaMap);
  }
  getTextures(material, record) {
    record.set("alphaMap", material.alphaMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("aoMap");
    this.node.p.useAlphaMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.alphaMap.setNode(mapNode, { relative: true });
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureEnvMapController.js
var ENV_MAP_OPERATION_DEFAULT_PARAMS = {
  useEnvMap: false,
  envMap: new TypedNodePathParamValue(""),
  envMapIntensity: 1
};
var DEFAULT_PARAMS = ENV_MAP_OPERATION_DEFAULT_PARAMS;
function EnvMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useEnvMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS.useEnvMap, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureEnvMapController)
      });
      this.envMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureEnvMapController, "useEnvMap"));
      this.envMapIntensity = ParamConfig.FLOAT(DEFAULT_PARAMS.envMapIntensity, { visibleIf: { useEnvMap: 1 } });
    }
  };
}
function isValidEnvMapMaterial(material) {
  if (!material) {
    return false;
  }
  return material.isMeshStandardMaterial || material.isMeshPhysicalMaterial;
}
var TextureEnvMapParamsConfig = class extends EnvMapParamConfig(NodeParamsConfig) {
};
var TextureEnvMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useEnvMap, this.node.p.envMap);
  }
  static async update(node) {
    node.controllers.envMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!isValidEnvMapMaterial(material)) {
      return;
    }
    this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "envMap", this.node.p.useEnvMap, this.node.p.envMap);
    material.envMapIntensity = this.node.pv.envMapIntensity;
  }
  getTextures(material, record) {
    record.set("envMap", material.envMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("envMap");
    this.node.p.useEnvMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.envMap.setNode(mapNode, { relative: true });
    }
    this.node.p.envMapIntensity.set(material.envMapIntensity);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureBumpMapController.js
function BumpMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useBumpMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureBumpMapController)
      });
      this.bumpMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureBumpMapController, "useBumpMap"));
      this.bumpScale = ParamConfig.FLOAT(1, {
        range: [0, 1],
        rangeLocked: [false, false],
        ...NodePathOptions(TextureBumpMapController, "useBumpMap")
      });
      this.bumpBias = ParamConfig.FLOAT(0, {
        range: [0, 1],
        rangeLocked: [false, false],
        ...NodePathOptions(TextureBumpMapController, "useBumpMap")
      });
    }
  };
}
function _isValidMaterial3(material) {
  if (!material) {
    return false;
  }
  return material.bumpScale != null;
}
var TextureBumpMapParamsConfig = class extends BumpMapParamConfig(NodeParamsConfig) {
};
var TextureBumpMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useBumpMap, this.node.p.bumpMap);
  }
  static async update(node) {
    node.controllers.bumpMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial3(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "bumpMap", this.node.p.useBumpMap, this.node.p.bumpMap);
    material.bumpScale = this.node.pv.bumpScale;
  }
  getTextures(material, record) {
    record.set("bumpMap", material.bumpMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("emissiveMap");
    this.node.p.useBumpMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.bumpMap.setNode(mapNode, { relative: true });
    }
    this.node.p.bumpScale.set(material.bumpScale);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureNormalMapController.js
var NormalMapMode = ((NormalMapMode2) => {
  NormalMapMode2["TANGENT"] = "tangent";
  NormalMapMode2["OBJECT"] = "object";
  return NormalMapMode2;
})(NormalMapMode || {});
var NORMAL_MAP_MODES = [
  "tangent",
  "object"
  /* OBJECT */
];
var NormalMapModeByName = {
  [
    "tangent"
    /* TANGENT */
  ]: TangentSpaceNormalMap,
  [
    "object"
    /* OBJECT */
  ]: ObjectSpaceNormalMap
};
var NormalNameByMode = {
  [TangentSpaceNormalMap]: "tangent",
  [ObjectSpaceNormalMap]: "object"
  /* OBJECT */
};
function NormalMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useNormalMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureNormalMapController)
      });
      this.normalMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureNormalMapController, "useNormalMap"));
      this.normalMapType = ParamConfig.INTEGER(0, {
        visibleIf: { useNormalMap: 1 },
        menu: {
          entries: NORMAL_MAP_MODES.map((name, value) => {
            return { name, value };
          })
        }
      });
      this.normalScale = ParamConfig.VECTOR2([1, 1], { visibleIf: { useNormalMap: 1 } });
      this.normalScaleMult = ParamConfig.FLOAT(1, {
        range: [0, 1],
        rangeLocked: [false, false],
        visibleIf: { useNormalMap: 1 }
      });
    }
  };
}
function isTextureNormalMapMaterial(material) {
  if (!material) {
    return false;
  }
  return material.normalScale != null;
}
var TextureNormalMapParamsConfig = class extends NormalMapParamConfig(NodeParamsConfig) {
};
var tmpN2 = [0, 0];
var TextureNormalMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useNormalMap, this.node.p.normalMap);
  }
  static async update(node) {
    node.controllers.normalMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!isTextureNormalMapMaterial(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    const { p, pv } = this.node;
    await this._update(material, "normalMap", p.useNormalMap, p.normalMap);
    const normalMapType = NormalMapModeByName[NORMAL_MAP_MODES[pv.normalMapType]];
    const mat = material;
    mat.normalMapType = normalMapType;
    mat.normalScale.copy(pv.normalScale).multiplyScalar(pv.normalScaleMult);
  }
  getTextures(material, record) {
    record.set("normalMap", material.normalMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("normalMap");
    const p = this.node.p;
    p.useNormalMap.set(mapNode != null);
    if (mapNode) {
      p.normalMap.setNode(mapNode, { relative: true });
    }
    material.normalScale.toArray(tmpN2);
    p.normalScale.set(tmpN2);
    p.normalMapType.set(NORMAL_MAP_MODES.indexOf(NormalNameByMode[material.normalMapType]));
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureEmissiveMapController.js
function EmissiveMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.emissive = ParamConfig.COLOR([0, 0, 0], { separatorBefore: true });
      this.useEmissiveMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureEmissiveMapController));
      this.emissiveMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureEmissiveMapController, "useEmissiveMap"));
      this.emissiveIntensity = ParamConfig.FLOAT(1);
    }
  };
}
function _isValidMaterial4(material) {
  if (!material) {
    return false;
  }
  return material.emissive != null;
}
var TextureEmissiveMapParamsConfig = class extends EmissiveMapParamConfig(NodeParamsConfig) {
};
var tmpN3 = [0, 0, 0];
var TextureEmissiveMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useEmissiveMap, this.node.p.emissiveMap);
  }
  static async update(node) {
    node.controllers.emissiveMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial4(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "emissiveMap", this.node.p.useEmissiveMap, this.node.p.emissiveMap);
    material.emissive.copy(this.node.pv.emissive);
    material.emissiveIntensity = this.node.pv.emissiveIntensity;
  }
  getTextures(material, record) {
    record.set("emissiveMap", material.emissiveMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("emissiveMap");
    this.node.p.useEmissiveMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.emissiveMap.setNode(mapNode, { relative: true });
    }
    material.emissive.toArray(tmpN3);
    this.node.p.emissive.set(tmpN3);
    this.node.p.emissive.setConversion(ColorConversion.NONE);
    this.node.p.emissiveIntensity.set(material.emissiveIntensity);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureMetalnessRoughnessMapController.js
var METALNESS_ROUGHNESS_OPERATION_DEFAULT_PARAMS = {
  useMetalnessMap: false,
  metalnessMap: new TypedNodePathParamValue(""),
  metalness: 0,
  useRoughnessMap: false,
  roughnessMap: new TypedNodePathParamValue(""),
  roughness: 1
};
var DEFAULT_PARAMS2 = METALNESS_ROUGHNESS_OPERATION_DEFAULT_PARAMS;
function MetalnessRoughnessMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useMetalnessMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS2.useMetalnessMap, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureMetalnessRoughnessMapController)
      });
      this.metalnessMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(TextureMetalnessRoughnessMapController, "useMetalnessMap")
      );
      this.metalness = ParamConfig.FLOAT(DEFAULT_PARAMS2.metalness);
      this.useRoughnessMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS2.useRoughnessMap, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureMetalnessRoughnessMapController)
      });
      this.roughnessMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(TextureMetalnessRoughnessMapController, "useRoughnessMap")
      );
      this.roughness = ParamConfig.FLOAT(DEFAULT_PARAMS2.roughness);
    }
  };
}
function _isValidMaterial5(material) {
  if (!material) {
    return false;
  }
  return material.metalness != null;
}
var TextureMetalnessMapParamsConfig = class extends MetalnessRoughnessMapParamConfig(NodeParamsConfig) {
};
var TextureMetalnessRoughnessMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useMetalnessMap, this.node.p.metalnessMap);
  }
  static async update(node) {
    node.controllers.metalnessRoughnessMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial5(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    material.metalness = this.node.pv.metalness;
    material.roughness = this.node.pv.roughness;
    await Promise.all([
      this._update(material, "metalnessMap", this.node.p.useMetalnessMap, this.node.p.metalnessMap),
      this._update(material, "roughnessMap", this.node.p.useRoughnessMap, this.node.p.roughnessMap)
    ]);
  }
  getTextures(material, record) {
    record.set("metalnessMap", material.metalnessMap);
    record.set("roughnessMap", material.roughnessMap);
  }
  setParamsFromMaterial(material, record) {
    const metalnessMapNode = record.get("metalnessMap");
    const roughnessMapNode = record.get("roughnessMap");
    this.node.p.useMetalnessMap.set(metalnessMapNode != null);
    this.node.p.useRoughnessMap.set(roughnessMapNode != null);
    if (metalnessMapNode) {
      this.node.p.metalnessMap.setNode(metalnessMapNode, { relative: true });
    }
    if (roughnessMapNode) {
      this.node.p.roughnessMap.setNode(roughnessMapNode, { relative: true });
    }
    this.node.p.metalness.set(material.metalness);
    this.node.p.roughness.set(material.roughness);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureLightMapController.js
function LightMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useLightMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureLightMapController)
      });
      this.lightMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureLightMapController, "useLightMap"));
      this.lightMapIntensity = ParamConfig.FLOAT(1, {
        visibleIf: { useLightMap: 1 }
      });
    }
  };
}
function _isValidMaterial6(material) {
  if (!material) {
    return false;
  }
  return material.lightMapIntensity != null;
}
var TextureLightMapParamsConfig = class extends LightMapParamConfig(NodeParamsConfig) {
};
var TextureLightMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useLightMap, this.node.p.lightMap);
  }
  static async update(node) {
    node.controllers.lightMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial6(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "lightMap", this.node.p.useLightMap, this.node.p.lightMap);
    material.lightMapIntensity = this.node.pv.lightMapIntensity;
  }
  getTextures(material, record) {
    record.set("lightMap", material.lightMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("lightMap");
    this.node.p.useLightMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.lightMap.setNode(mapNode, { relative: true });
    }
    this.node.p.lightMapIntensity.set(material.lightMapIntensity);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureDisplacementMapController.js
function DisplacementMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useDisplacementMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureDisplacementMapController)
      });
      this.displacementMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(TextureDisplacementMapController, "useDisplacementMap")
      );
      this.displacementScale = ParamConfig.FLOAT(1, {
        range: [0, 1],
        rangeLocked: [false, false],
        ...NodePathOptions(TextureDisplacementMapController, "useDisplacementMap")
      });
      this.displacementBias = ParamConfig.FLOAT(0, {
        range: [0, 1],
        rangeLocked: [false, false],
        ...NodePathOptions(TextureDisplacementMapController, "useDisplacementMap")
      });
    }
  };
}
function _isValidMaterial7(material) {
  if (!material) {
    return false;
  }
  return material.displacementScale != null;
}
var TextureDisplacementMapParamsConfig = class extends DisplacementMapParamConfig(NodeParamsConfig) {
};
var TextureDisplacementMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useDisplacementMap, this.node.p.displacementMap);
  }
  static async update(node) {
    node.controllers.displacementMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial7(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "displacementMap", this.node.p.useDisplacementMap, this.node.p.displacementMap);
    material.displacementScale = this.node.pv.displacementScale;
    material.displacementBias = this.node.pv.displacementBias;
  }
  getTextures(material, record) {
    record.set("displacementMap", material.displacementMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("emissiveMap");
    this.node.p.useDisplacementMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.displacementMap.setNode(mapNode, { relative: true });
    }
    this.node.p.displacementScale.set(material.displacementScale);
    this.node.p.displacementBias.set(material.displacementBias);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureAOMapController.js
function AOMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useAOMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureAOMapController)
      });
      this.aoMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureAOMapController, "useAOMap"));
      this.aoMapIntensity = ParamConfig.FLOAT(1, { range: [0, 1], rangeLocked: [false, false], visibleIf: { useAOMap: 1 } });
    }
  };
}
function _isValidMaterial8(material) {
  if (!material) {
    return false;
  }
  return material.aoMapIntensity != null;
}
var TextureAOMapParamsConfig = class extends AOMapParamConfig(NodeParamsConfig) {
};
var TextureAOMapController = class extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useAOMap, this.node.p.aoMap);
  }
  static async update(node) {
    node.controllers.aoMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial8(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "aoMap", this.node.p.useAOMap, this.node.p.aoMap);
    material.aoMapIntensity = this.node.pv.aoMapIntensity;
  }
  getTextures(material, record) {
    record.set("aoMap", material.aoMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("aoMap");
    this.node.p.useAOMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.aoMap.setNode(mapNode, { relative: true });
    }
    this.node.p.aoMapIntensity.set(material.aoMapIntensity);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/DefaultFolder.js
function DefaultFolderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.default = ParamConfig.FOLDER(null);
    }
  };
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TexturesFolder.js
function TexturesFolderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.textures = ParamConfig.FOLDER(null);
    }
  };
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/AdvancedFolder.js
function AdvancedFolderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.advanced = ParamConfig.FOLDER(null);
    }
  };
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Mat.js
var MatType = ((MatType2) => {
  MatType2["LINE_BASIC"] = "lineBasic";
  MatType2["LINE_BASIC_BUILDER"] = "lineBasicBuilder";
  MatType2["MESH_BASIC"] = "meshBasic";
  MatType2["MESH_BASIC_BUILDER"] = "meshBasicBuilder";
  MatType2["MESH_DEPTH_BUILDER"] = "meshDepthBuilder";
  MatType2["MESH_DISTANCE_BUILDER"] = "meshDistanceBuilder";
  MatType2["MESH_LAMBERT"] = "meshLambert";
  MatType2["MESH_LAMBERT_BUILDER"] = "meshLambertBuilder";
  MatType2["MESH_MATCAP"] = "meshMatcap";
  MatType2["MESH_NORMAL"] = "meshNormal";
  MatType2["MESH_PHONG"] = "meshPhong";
  MatType2["MESH_PHONG_BUILDER"] = "meshPhongBuilder";
  MatType2["MESH_PHYSICAL"] = "meshPhysical";
  MatType2["MESH_PHYSICAL_BUILDER"] = "meshPhysicalBuilder";
  MatType2["MESH_STANDARD"] = "meshStandard";
  MatType2["MESH_STANDARD_BUILDER"] = "meshStandardBuilder";
  MatType2["MESH_TOON"] = "meshToon";
  MatType2["MESH_TOON_BUILDER"] = "meshToonBuilder";
  MatType2["POINTS"] = "points";
  MatType2["POINTS_BUILDER"] = "pointsBuilder";
  MatType2["RAY_MARCHING_BUILDER"] = "rayMarchingBuilder";
  MatType2["SHADOW"] = "shadow";
  MatType2["SKY"] = "sky";
  MatType2["VOLUME"] = "volume";
  MatType2["VOLUME_BUILDER"] = "volumeBuilder";
  return MatType2;
})(MatType || {});

export {
  PrimitiveMatNode,
  BaseController,
  AdvancedCommonParamConfig,
  AdvancedCommonController,
  BooleanParamOptions,
  NodePathOptions,
  BaseTextureMapController,
  MapParamConfig,
  TextureMapController,
  AlphaMapParamConfig,
  TextureAlphaMapController,
  EnvMapParamConfig,
  TextureEnvMapController,
  BumpMapParamConfig,
  TextureBumpMapController,
  NormalMapParamConfig,
  TextureNormalMapController,
  EmissiveMapParamConfig,
  TextureEmissiveMapController,
  MetalnessRoughnessMapParamConfig,
  TextureMetalnessRoughnessMapController,
  LightMapParamConfig,
  TextureLightMapController,
  DisplacementMapParamConfig,
  TextureDisplacementMapController,
  AOMapParamConfig,
  TextureAOMapController,
  DefaultFolderParamConfig,
  TexturesFolderParamConfig,
  AdvancedFolderParamConfig,
  MatType
};
//# sourceMappingURL=chunk-DPUZQYKG.js.map
