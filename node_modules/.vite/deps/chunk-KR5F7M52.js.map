{
  "version": 3,
  "sources": ["../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/UniformsTransparencyController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/assemblers/materials/MaterialPersistedConfig.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/_BaseBuilder.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/UniformsFogController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/WireframeShaderMaterialController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSS.glsl.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSSGetShadow.glsl.js", "../../@polygonjs/polygonjs/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/PCSSController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/customMaterials/_CustomMaterialBase.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/customMaterials/CustomMaterialMesh.js"],
  "sourcesContent": ["\"use strict\";\nimport { BaseController } from \"./_BaseController\";\nimport { TypedMatNode } from \"../_Base\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { isBooleanTrue } from \"../../../../core/BooleanValue\";\nexport function UniformsTransparencyParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param sets the material to transparent */\n      this.transparent = ParamConfig.BOOLEAN(0);\n      /** @param sets the material opacity */\n      this.opacity = ParamConfig.FLOAT(1);\n      /** @param sets the min alpha below which the material is invisible */\n      this.alphaTest = ParamConfig.FLOAT(0);\n    }\n  };\n}\nclass TransparencyParamsConfig extends UniformsTransparencyParamConfig(NodeParamsConfig) {\n}\nclass TransparencyMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class UniformsTransparencyController extends BaseController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  static async update(node) {\n    const material = await node.material();\n    if (!material) {\n      return;\n    }\n    node.controllers.uniformTransparency.updateMaterial(material);\n  }\n  updateMaterial(material) {\n    const pv = this.node.pv;\n    this._updateTransparency(material, pv);\n  }\n  _updateTransparency(mat, pv) {\n    mat.transparent = isBooleanTrue(pv.transparent);\n    this._updateCommon(mat, pv);\n  }\n  _updateCommon(mat, pv) {\n    const shaderMaterial = mat;\n    if (shaderMaterial.uniforms && shaderMaterial.uniforms.opacity) {\n      shaderMaterial.uniforms.opacity.value = pv.opacity;\n    }\n    mat.opacity = pv.opacity;\n    if (shaderMaterial.uniforms && shaderMaterial.uniforms.alphaTest) {\n      shaderMaterial.uniforms.alphaTest.value = pv.alphaTest;\n    }\n    mat.alphaTest = pv.alphaTest;\n    const customMaterials = mat.customMaterials;\n    if (customMaterials) {\n      const customNames = Object.keys(customMaterials);\n      for (const customName of customNames) {\n        const customMaterial = customMaterials[customName];\n        if (customMaterial) {\n          this._updateCommon(customMaterial, pv);\n        }\n      }\n    }\n  }\n}\n", "\"use strict\";\nimport { BasePersistedConfig } from \"../../../../utils/BasePersistedConfig\";\nimport {\n  assignOnBeforeCompileDataAndFunction,\n  OnBeforeCompileDataConverter\n} from \"./OnBeforeCompile\";\nfunction _removeShaders(data) {\n  const onBeforeCompileDataJSONWithoutShaders = {\n    paramConfigs: data.paramConfigs,\n    timeDependent: data.timeDependent,\n    resolutionDependent: data.resolutionDependent,\n    raymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent\n  };\n  return onBeforeCompileDataJSONWithoutShaders;\n}\nfunction _addShaders(data, options) {\n  const onBeforeCompileDataJSON = {\n    paramConfigs: data.paramConfigs,\n    timeDependent: data.timeDependent,\n    resolutionDependent: data.resolutionDependent,\n    raymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent,\n    fragmentShader: options.fragment,\n    vertexShader: options.vertex\n  };\n  return onBeforeCompileDataJSON;\n}\nfunction _shaderKey(shaderType, customMaterialName) {\n  return customMaterialName ? `${customMaterialName}.${shaderType}` : shaderType;\n}\nexport class MaterialPersistedConfig extends BasePersistedConfig {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  async toData() {\n    const assemblerController = this.node.assemblerController();\n    if (!assemblerController) {\n      return;\n    }\n    const assembler = assemblerController.assembler;\n    const onBeforeCompileData = assembler.onBeforeCompileData();\n    if (!onBeforeCompileData) {\n      return;\n    }\n    const onBeforeCompileDataJSON = OnBeforeCompileDataConverter.toJSON(onBeforeCompileData);\n    const onBeforeCompileDataJSONWithoutShaders = _removeShaders(onBeforeCompileDataJSON);\n    const shaders = {\n      [_shaderKey(\"vertex\")]: onBeforeCompileDataJSON.vertexShader,\n      [_shaderKey(\"fragment\")]: onBeforeCompileDataJSON.fragmentShader\n    };\n    const customMaterialsData = {};\n    const material = await this.node.material();\n    if (!material) {\n      return;\n    }\n    const customMaterials = material.customMaterials;\n    if (customMaterials) {\n      assembler.traverseCustomAssemblers((customAssembler, customMaterialName) => {\n        const customOnBeforeCompileData = customAssembler.onBeforeCompileData();\n        if (customOnBeforeCompileData) {\n          const customMaterial = customMaterials[customMaterialName];\n          if (customMaterial) {\n            const customMaterialData = this._materialToJson(customMaterial, {\n              node: this.node,\n              suffix: customMaterialName\n            });\n            if (customMaterialData) {\n              const data2 = OnBeforeCompileDataConverter.toJSON(customOnBeforeCompileData);\n              const dataWithoutShaders = _removeShaders(data2);\n              customMaterialsData[customMaterialName] = {\n                material: customMaterialData,\n                onBeforeCompileDataJSONWithoutShaders: dataWithoutShaders\n              };\n              shaders[_shaderKey(\"vertex\", customMaterialName)] = data2.vertexShader;\n              shaders[_shaderKey(\"fragment\", customMaterialName)] = data2.fragmentShader;\n            }\n          }\n        }\n      });\n    }\n    const materialData = this._materialToJson(material, {\n      node: this.node,\n      suffix: \"main\"\n    });\n    if (!materialData) {\n      console.warn(\"failed to save material from node\", this.node.path());\n    }\n    const data = {\n      material: materialData || {},\n      onBeforeCompileDataJSONWithoutShaders,\n      // uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),\n      // uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),\n      // param_uniform_pairs: param_uniform_pairs,\n      customMaterials: customMaterialsData,\n      shaders\n    };\n    return data;\n  }\n  load(data) {\n    const assemblerController = this.node.assemblerController();\n    if (assemblerController) {\n      return;\n    }\n    this._material = this._loadMaterial(data.material);\n    if (!this._material) {\n      return;\n    }\n    const shaders = data.shaders;\n    if (!shaders) {\n      console.warn(`${this.node.path()}: persisted config has no shaders`);\n      return;\n    }\n    const onBeforeCompileDataJSON = _addShaders(\n      data.onBeforeCompileDataJSONWithoutShaders,\n      {\n        vertex: shaders[_shaderKey(\"vertex\")],\n        fragment: shaders[_shaderKey(\"fragment\")]\n      }\n    );\n    const onBeforeCompileData = OnBeforeCompileDataConverter.fromJSON(onBeforeCompileDataJSON);\n    const material = this._material;\n    assignOnBeforeCompileDataAndFunction(this.node.scene(), material, onBeforeCompileData);\n    for (let paramConfig of onBeforeCompileData.paramConfigs) {\n      paramConfig.applyToNode(this.node);\n    }\n    this._material.customMaterials = this._material.customMaterials || {};\n    if (data.customMaterials) {\n      const customMatNames = Object.keys(data.customMaterials);\n      for (const customMatName of customMatNames) {\n        const customMatData = data.customMaterials[customMatName];\n        const customMat = this._loadMaterial(customMatData.material);\n        if (customMat) {\n          const onBeforeCompileDataJSON2 = _addShaders(\n            customMatData.onBeforeCompileDataJSONWithoutShaders,\n            {\n              vertex: shaders[_shaderKey(\"vertex\", customMatName)],\n              fragment: shaders[_shaderKey(\"fragment\", customMatName)]\n            }\n          );\n          const customOnBeforeCompileData = OnBeforeCompileDataConverter.fromJSON(onBeforeCompileDataJSON2);\n          customOnBeforeCompileData.paramConfigs = onBeforeCompileData.paramConfigs;\n          assignOnBeforeCompileDataAndFunction(this.node.scene(), customMat, customOnBeforeCompileData);\n          this._material.customMaterials[customMatName] = customMat;\n        }\n      }\n    }\n  }\n  material() {\n    return this._material;\n  }\n}\n", "\"use strict\";\nimport { PrimitiveMatNode } from \"./_Base\";\nimport { NodeParamsConfig, ParamConfig } from \"../utils/params/ParamsConfig\";\nimport { MaterialPersistedConfig } from \"../gl/code/assemblers/materials/MaterialPersistedConfig\";\nimport { NodeContext } from \"../../poly/NodeContext\";\nimport { isBooleanTrue } from \"../../../core/BooleanValue\";\nexport function BaseBuilderParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param if toggled on, the shader will be built from the gl nodes of another material. This can be useful to have multiple materials use the same gl network, but still set the uniforms differently */\n      this.setBuilderNode = ParamConfig.BOOLEAN(0, {\n        callback: (node) => {\n          TypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node);\n        }\n      });\n      /** @param builder node */\n      this.builderNode = ParamConfig.NODE_PATH(\"\", {\n        visibleIf: { setBuilderNode: true },\n        callback: (node) => {\n          TypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node);\n        }\n      });\n    }\n  };\n}\nclass MatBuilderParamsConfig extends BaseBuilderParamConfig(NodeParamsConfig) {\n}\nexport class TypedBuilderMatNode extends PrimitiveMatNode {\n  constructor() {\n    super(...arguments);\n    this._childrenControllerContext = NodeContext.GL;\n    this.persisted_config = new MaterialPersistedConfig(this);\n  }\n  //\n  //\n  // MATERIAL\n  //\n  //\n  createMaterial() {\n    var _a;\n    let material;\n    if (this.persisted_config) {\n      material = this.persisted_config.material();\n    }\n    if (!material) {\n      material = (_a = this.assemblerController()) == null ? void 0 : _a.assembler.createMaterial();\n    }\n    return material;\n  }\n  //\n  //\n  // ASSEMBLER\n  //\n  //\n  assemblerController() {\n    return this._assemblerController = this._assemblerController || this._createAssemblerController();\n  }\n  customMaterialRequested(customName) {\n    return true;\n  }\n  createNode(node_class, options) {\n    return super.createNode(node_class, options);\n  }\n  children() {\n    return super.children();\n  }\n  nodesByType(type) {\n    return super.nodesByType(type);\n  }\n  childrenAllowed() {\n    if (this.assemblerController()) {\n      return super.childrenAllowed();\n    }\n    return false;\n  }\n  sceneReadonly() {\n    return this.assemblerController() == null;\n  }\n  //\n  //\n  // COMPILATION\n  //\n  //\n  compileIfRequired(material) {\n    var _a;\n    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {\n      try {\n        this._compile(material);\n      } catch (err) {\n        const message = err.message || \"failed to compile\";\n        this.states.error.set(message);\n      }\n    }\n  }\n  _compile(material) {\n    const assemblerController = this.assemblerController();\n    if (material && assemblerController) {\n      assemblerController.assembler.setGlParentNode(this);\n      this._setAssemblerGlParentNode(assemblerController);\n      assemblerController.assembler.compileMaterial(material);\n      assemblerController.post_compile();\n    }\n  }\n  _setAssemblerGlParentNode(assemblerController) {\n    if (!isBooleanTrue(this.pv.setBuilderNode)) {\n      return;\n    }\n    const resolvedNode = this.pv.builderNode.nodeWithContext(NodeContext.MAT);\n    if (!resolvedNode) {\n      return;\n    }\n    const resolvedBuilderNode = resolvedNode;\n    if (!resolvedBuilderNode.assemblerController()) {\n      this.states.error.set(`resolved node '${resolvedNode.path()}' is not a builder node`);\n      return;\n    }\n    if (resolvedBuilderNode.type() != this.type()) {\n      this.states.error.set(\n        `resolved node '${resolvedNode.path()}' does not have the same type '${resolvedNode.type()}' as current node '${this.type()}'`\n      );\n      return;\n    }\n    assemblerController.assembler.setGlParentNode(resolvedBuilderNode);\n  }\n  static PARAM_CALLBACK_setCompileRequired(node) {\n    node.PARAM_CALLBACK_setCompileRequired();\n  }\n  PARAM_CALLBACK_setCompileRequired() {\n    var _a;\n    (_a = this.assemblerController()) == null ? void 0 : _a.setCompilationRequired(true);\n  }\n}\n", "\"use strict\";\nimport { BaseController } from \"./_BaseController\";\nimport { TypedMatNode } from \"../_Base\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { isBooleanTrue } from \"../../../../core/BooleanValue\";\nexport function FogParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle on if you have a fog in the scene and the material should be affected by it */\n      this.useFog = ParamConfig.BOOLEAN(0);\n    }\n  };\n}\nclass FogUniformsParamsConfig extends FogParamConfig(NodeParamsConfig) {\n}\nfunction isValidFogMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.fog != null;\n}\nclass FogUniformsMatNode extends TypedMatNode {\n}\nexport class UniformFogController extends BaseController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  static async update(node) {\n    const material = await node.material();\n    if (!isValidFogMaterial(material)) {\n      return;\n    }\n    node.controllers.uniformFog.updateMaterial(material);\n  }\n  updateMaterial(material) {\n    const pv = this.node.pv;\n    material.fog = isBooleanTrue(pv.useFog);\n  }\n  getTextures(material, record) {\n  }\n  setParamsFromMaterial(material, record) {\n    this.node.p.useFog.set(material.fog);\n  }\n}\n", "\"use strict\";\nimport { BaseController } from \"./_BaseController\";\nimport { TypedMatNode } from \"../_Base\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { isBooleanTrue } from \"../../../../core/BooleanValue\";\nexport function WireframeShaderMaterialParamsConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle on to set material to wireframe */\n      this.wireframe = ParamConfig.BOOLEAN(0);\n      /** @param wireframe line width */\n      this.wireframeLinewidth = ParamConfig.FLOAT(1, {\n        range: [0, 5],\n        rangeLocked: [true, false],\n        visibleIf: { wireframe: 1 }\n      });\n    }\n  };\n}\nclass WireframeShaderParamsConfig extends WireframeShaderMaterialParamsConfig(NodeParamsConfig) {\n}\nclass WireframedShaderMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class WireframeShaderMaterialController extends BaseController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  static async update(node) {\n    const material = await node.material();\n    if (!material) {\n      return;\n    }\n    node.controllers.wireframeShader.updateMaterial(material);\n  }\n  updateMaterial(material) {\n    const pv = this.node.pv;\n    const shaderMaterial = material;\n    if (shaderMaterial.wireframe != null) {\n      shaderMaterial.wireframe = isBooleanTrue(pv.wireframe);\n      shaderMaterial.wireframeLinewidth = pv.wireframeLinewidth;\n      shaderMaterial.needsUpdate = true;\n    }\n  }\n}\n", "export default \"#define LIGHT_WORLD_SIZE 0.005\\n// #define LIGHT_FRUSTUM_WIDTH 1.0\\n// #define PCSS_FILTER_SIZE 1.0\\n#define LIGHT_SIZE_UV (PCSS_FILTER_SIZE * LIGHT_WORLD_SIZE)\\n#define NEAR_PLANE 9.5\\n\\n#define NUM_SAMPLES 17\\n#define NUM_RINGS 11\\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\\n\\nvec2 poissonDisk[NUM_SAMPLES];\\n\\nvoid initPoissonSamples( const in vec2 randomSeed ) {\\n\tfloat ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\\n\tfloat INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\\n\\n\t// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\\n\tfloat angle = rand( randomSeed ) * PI2;\\n\tfloat radius = INV_NUM_SAMPLES;\\n\tfloat radiusStep = radius;\\n\\n\tfor( int i = 0; i < NUM_SAMPLES; i ++ ) {\\n\t\tpoissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\\n\t\tradius += radiusStep;\\n\t\tangle += ANGLE_STEP;\\n\t}\\n}\\n\\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\\n\treturn (zReceiver - zBlocker) / zBlocker;\\n}\\n\\nfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\\n\t// This uses similar triangles to compute what\\n\t// area of the shadow map we should search\\n\tfloat searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\\n\tfloat blockerDepthSum = 0.0;\\n\tint numBlockers = 0;\\n\\n\tfor( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\\n\t\tfloat shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\\n\t\tif ( shadowMapDepth < zReceiver ) {\\n\t\t\tblockerDepthSum += shadowMapDepth;\\n\t\t\tnumBlockers ++;\\n\t\t}\\n\t}\\n\\n\tif( numBlockers == 0 ) return -1.0;\\n\\n\treturn blockerDepthSum / float( numBlockers );\\n}\\n\\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\\n\tfloat sum = 0.0;\\n\tfloat depth;\\n\t#pragma unroll_loop_start\\n\tfor( int i = 0; i < 17; i ++ ) {\\n\t\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\\n\t\tif( zReceiver <= depth ) sum += 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#pragma unroll_loop_start\\n\tfor( int i = 0; i < 17; i ++ ) {\\n\t\tdepth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\\n\t\tif( zReceiver <= depth ) sum += 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\treturn sum / ( 2.0 * float( 17 ) );\\n}\\n\\nfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\\n\tvec2 uv = coords.xy;\\n\tfloat zReceiver = coords.z; // Assumed to be eye-space z in this code\\n\\n\tinitPoissonSamples( uv );\\n\t// STEP 1: blocker search\\n\tfloat avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\\n\\n\t//There are no occluders so early out (this saves filtering)\\n\tif( avgBlockerDepth == -1.0 ) return 1.0;\\n\\n\t// STEP 2: penumbra size\\n\tfloat penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\\n\tfloat filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\\n\\n\t// STEP 3: filtering\\n\t//return avgBlockerDepth;\\n\treturn PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\\n}\";\n", "export default \"return PCSS( shadowMap, shadowCoord );\";\n", "export default /* glsl */`\n#if NUM_SPOT_LIGHT_COORDS > 0\n\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n\n#endif\n\n#if NUM_SPOT_LIGHT_MAPS > 0\n\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n\n#endif\n\n#ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): create uniforms for area light shadows\n\n\t#endif\n\t*/\n\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n\t}\n\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\n\t}\n\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\n\t\tfloat occlusion = 1.0;\n\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\n\t\tfloat hard_shadow = step( compare , distribution.x ); // Hard Shadow\n\n\t\tif (hard_shadow != 1.0 ) {\n\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality\n\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed\n\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\n\t\t}\n\t\treturn occlusion;\n\n\t}\n\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n\t\tfloat shadow = 1.0;\n\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\n\t\tif ( frustumTest ) {\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#else // no percentage-closer filtering:\n\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n\t\t#endif\n\n\t\t}\n\n\t\treturn shadow;\n\n\t}\n\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\n\t// 2D texture:\n\t//\n\t// xzXZ\n\t//  y Y\n\t//\n\t// Y - Positive y direction\n\t// y - Negative y direction\n\t// X - Positive x direction\n\t// x - Negative x direction\n\t// Z - Positive z direction\n\t// z - Negative z direction\n\t//\n\t// Source and test bed:\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n\t\t// Number of texels to avoid at the edge of each square\n\n\t\tvec3 absV = abs( v );\n\n\t\t// Intersect unit cube\n\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\n\t\t// Apply scale to avoid seams\n\n\t\t// two texels less per square (one texel will do for NEAREST)\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n\t\t// Unwrap\n\n\t\t// space: -1 ... 1 range for each square\n\t\t//\n\t\t// #X##\t\tdim    := ( 4 , 2 )\n\t\t//  # #\t\tcenter := ( 1 , 1 )\n\n\t\tvec2 planar = v.xy;\n\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\n\t\tif ( absV.z >= almostOne ) {\n\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\n\t\t} else if ( absV.x >= almostOne ) {\n\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\n\t\t} else if ( absV.y >= almostOne ) {\n\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\n\t\t}\n\n\t\t// Transform to UV space\n\n\t\t// scale := 0.5 / dim\n\t\t// translate := ( center + 0.5 ) / dim\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n\t}\n\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\n\t\t// the vector from the light to the world-space position of the fragment.\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\n\t\t// dp = normalized distance from light to fragment position\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n\t\tdp += shadowBias;\n\n\t\t// bd3D = base direction 3D\n\t\tvec3 bd3D = normalize( lightToPosition );\n\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\n\t\t#else // no percentage-closer filtering\n\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n\t\t#endif\n\n\t}\n\n#endif\n`;\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseController } from \"./_BaseController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { isBooleanTrue } from \"../../../../core/BooleanValue\";\nimport PCSS from \"./shadows/pcss/glsl/PCSS.glsl\";\nimport PCSSGetShadow from \"./shadows/pcss/glsl/PCSSGetShadow.glsl\";\nimport SHADOW_MAP_PARS_FRAGMENT from \"three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\";\nimport { ThreeToGl } from \"../../../../core/ThreeToGl\";\nexport function PCSSParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param if on, the material will blur shadows cast on this object. Note that you should adjust the near parameter of the light shadow to get the result visible */\n      this.shadowPCSS = ParamConfig.BOOLEAN(0, {\n        callback: (node) => {\n          PCSSController.PARAM_CALLBACK_setRecompileRequired(node);\n        },\n        separatorBefore: true\n      });\n      /** @param shadowPCSSFilterSize PCSS Shadow filter size */\n      this.shadowPCSSFilterSize = ParamConfig.FLOAT(1, {\n        visibleIf: { shadowPCSS: 1 },\n        range: [0, 10],\n        rangeLocked: [true, false]\n      });\n    }\n  };\n}\nclass PCSSParamsConfig extends PCSSParamConfig(NodeParamsConfig) {\n}\nfunction isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return true;\n}\nclass PCSSMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class PCSSController extends BaseController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  static filterFragmentShader(node, fragmentShader) {\n    const PCSSWithDefines = `\n#define PCSS_FILTER_SIZE ${ThreeToGl.float(node.pv.shadowPCSSFilterSize)}\n${PCSS}\n`;\n    let shadowParsFragmentModified = SHADOW_MAP_PARS_FRAGMENT;\n    shadowParsFragmentModified = shadowParsFragmentModified.replace(\n      \"#ifdef USE_SHADOWMAP\",\n      `#ifdef USE_SHADOWMAP\n${PCSSWithDefines}\n\t\t\t\t`\n    );\n    shadowParsFragmentModified = shadowParsFragmentModified.replace(\n      \"#if defined( SHADOWMAP_TYPE_PCF )\",\n      `\n\t\t\t\t${PCSSGetShadow}\n\t\t\t\t#if defined( SHADOWMAP_TYPE_PCF )`\n    );\n    fragmentShader = fragmentShader.replace(\"#include <shadowmap_pars_fragment>\", shadowParsFragmentModified);\n    return fragmentShader;\n  }\n  static async update(node) {\n    const material = await node.material();\n    if (!isValidMaterial(material)) {\n      return;\n    }\n    node.controllers.PCSS.updateMaterial(material);\n  }\n  async update() {\n    PCSSController.update(this.node);\n  }\n  updateMaterial(material) {\n    var _a, _b;\n    const matNode = this.node;\n    if (!matNode.assemblerController) {\n      return;\n    }\n    const callbackName = \"PCSS\";\n    if (isBooleanTrue(this.node.pv.shadowPCSS)) {\n      (_a = matNode.assemblerController()) == null ? void 0 : _a.addFilterFragmentShaderCallback(\n        callbackName,\n        (fragmentShader) => PCSSController.filterFragmentShader(this.node, fragmentShader)\n      );\n    } else {\n      (_b = matNode.assemblerController()) == null ? void 0 : _b.removeFilterFragmentShaderCallback(callbackName);\n    }\n  }\n  // static async update(node: PCSSMapMatNode) {\n  // \tnode.controllers.PCSS.update();\n  // }\n  static PARAM_CALLBACK_setRecompileRequired(node) {\n    node.controllers.PCSS.update();\n  }\n}\n", "\"use strict\";\nfunction customMaterialBaseSetRecompileRequired(node) {\n  var _a;\n  (_a = node.assemblerController()) == null ? void 0 : _a.setCompilationRequired();\n}\nexport const CUSTOM_MAT_PARAM_OPTIONS = {\n  callback: (node) => customMaterialBaseSetRecompileRequired(node)\n};\n", "\"use strict\";\nimport { TypeAssert } from \"../../../../poly/Assert\";\nimport { NodeParamsConfig } from \"../../../utils/params/ParamsConfig\";\nimport { CustomMaterialName } from \"../../../../../core/geometry/Material\";\nimport { ParamConfig } from \"../../../utils/params/ParamsConfig\";\nimport { BaseBuilderParamConfig } from \"../../_BaseBuilder\";\nimport { isBooleanTrue } from \"../../../../../core/Type\";\nimport { TypedMatNode } from \"../../_Base\";\nimport { CUSTOM_MAT_PARAM_OPTIONS } from \"./_CustomMaterialBase\";\nexport function CustomMaterialMeshParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle on to choose which customMaterials will be generated */\n      this.overrideCustomMaterials = ParamConfig.BOOLEAN(0, {\n        ...CUSTOM_MAT_PARAM_OPTIONS,\n        separatorBefore: true,\n        separatorAfter: true\n      });\n      /** @param distance material used for shadows from points lights */\n      this.createCustomMatDistance = ParamConfig.BOOLEAN(1, {\n        visibleIf: { overrideCustomMaterials: 1 },\n        ...CUSTOM_MAT_PARAM_OPTIONS\n      });\n      /** @param depth material used for shadows from spot lights and directional lights */\n      this.createCustomMatDepth = ParamConfig.BOOLEAN(1, {\n        visibleIf: { overrideCustomMaterials: 1 },\n        ...CUSTOM_MAT_PARAM_OPTIONS\n      });\n      /** @param depth DOF */\n      this.createCustomMatDepthDOF = ParamConfig.BOOLEAN(1, {\n        visibleIf: { overrideCustomMaterials: 1 },\n        ...CUSTOM_MAT_PARAM_OPTIONS,\n        separatorAfter: true\n      });\n    }\n  };\n}\nclass CustomMaterialMeshParamsConfig extends CustomMaterialMeshParamConfig(BaseBuilderParamConfig(NodeParamsConfig)) {\n}\nclass CustomMaterialMatNode extends TypedMatNode {\n}\nexport function materialMeshAssemblerCustomMaterialRequested(node, customName) {\n  const param = node.p.overrideCustomMaterials;\n  if (!param) {\n    console.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);\n    return true;\n  }\n  if (!isBooleanTrue(node.pv.overrideCustomMaterials)) {\n    return true;\n  }\n  switch (customName) {\n    case CustomMaterialName.DISTANCE: {\n      return isBooleanTrue(node.pv.createCustomMatDistance);\n    }\n    case CustomMaterialName.DEPTH: {\n      return isBooleanTrue(node.pv.createCustomMatDepth);\n    }\n    case CustomMaterialName.DEPTH_DOF: {\n      return isBooleanTrue(node.pv.createCustomMatDepthDOF);\n    }\n  }\n  TypeAssert.unreachable(customName);\n}\n"],
  "mappings": "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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACSlB,SAAS,gBAAgB,MAA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",
  "names": []
}
