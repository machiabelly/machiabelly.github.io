{
  "version": 3,
  "sources": ["../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/_Base.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/animationNames.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/arg.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/argc.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/bbox.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/blob.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/cameraName.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/cameraNames.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/camerasCount.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/centroid.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/ch.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/chsop.js", "../../@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Anim.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/copy.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/copRes.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/isDeviceMobile.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/isDeviceTouch.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/len.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/join.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/js.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/object.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/objectsCount.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/objectName.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/objectNames.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/opdigits.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/opname.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/padzero.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/playerMode.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/point.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/pointsCount.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/smoothstep.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/smootherstep.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/solverIteration.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/strCharsCount.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/strConcat.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/strIndex.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/strSub.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/viewerSize.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/windowSize.js", "../../@polygonjs/polygonjs/dist/src/engine/expressions/methods/Common.js", "../../@polygonjs/polygonjs/dist/src/engine/poly/registers/expressions/All.js"],
  "sourcesContent": ["\"use strict\";\nimport { CoreWalker } from \"../../../core/Walker\";\nimport { DecomposedPath } from \"../../../core/DecomposedPath\";\nimport { MethodDependency } from \"../MethodDependency\";\nimport { Poly } from \"../../Poly\";\nimport { CoreType } from \"../../../core/Type\";\nexport class BaseMethod {\n  constructor(param) {\n    this.param = param;\n  }\n  node() {\n    return this._node = this._node || this.param.node;\n  }\n  static requiredArguments() {\n    console.warn(\"Expression.Method._Base.required_arguments virtual method call. Please override\");\n    return [];\n  }\n  static optionalArguments() {\n    return [];\n  }\n  static minAllowedArgumentsCount() {\n    return this.requiredArguments().length;\n  }\n  static maxAllowedArgumentsCount() {\n    return this.minAllowedArgumentsCount() + this.optionalArguments().length;\n  }\n  static allowedArgumentsCount(count) {\n    return count >= this.minAllowedArgumentsCount() && count <= this.maxAllowedArgumentsCount();\n  }\n  processArguments(args) {\n    throw \"Expression.Method._Base.process_arguments virtual method call. Please override\";\n  }\n  async getReferencedNodeContainer(indexOrPath) {\n    var _a, _b;\n    const referencedNode = this.getReferencedNode(indexOrPath);\n    if (referencedNode) {\n      let container;\n      if (referencedNode.isDirty() || ((_b = (_a = referencedNode.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {\n        container = await referencedNode.compute();\n      } else {\n        container = referencedNode.containerController.container();\n      }\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent != null) {\n          return container;\n        }\n      }\n      throw `referenced node invalid: ${referencedNode.path()}`;\n    } else {\n      throw `invalid input (${indexOrPath})`;\n    }\n  }\n  getReferencedParam(path, decomposedPath) {\n    const node = this.node();\n    if (node) {\n      return CoreWalker.findParam(node, path, decomposedPath);\n    }\n    return null;\n  }\n  findReferencedGraphNode(indexOrPath, decomposedPath) {\n    const is_index = CoreType.isNumber(indexOrPath);\n    if (is_index) {\n      const index = indexOrPath;\n      const node = this.node();\n      if (node) {\n        const input_graph_node = node.io.inputs.inputGraphNode(index);\n        return input_graph_node;\n      }\n    } else {\n      const path = indexOrPath;\n      return this.getReferencedNode(path, decomposedPath);\n    }\n    return null;\n  }\n  // caching the node by path here prevents having expressions such as points_count(0)\n  // evaluate to an error when the input is disconnected\n  // private _node_by_path: Map<string | number, BaseNodeType | null | undefined> = new Map();\n  getReferencedNode(indexOrPath, decomposedPath) {\n    let node = null;\n    const current_node = this.node();\n    if (CoreType.isString(indexOrPath)) {\n      if (current_node) {\n        const path = indexOrPath;\n        node = CoreWalker.findNode(current_node, path, decomposedPath);\n      }\n    } else {\n      if (current_node) {\n        const index = indexOrPath;\n        node = current_node.io.inputs.input(index);\n      }\n    }\n    return node || null;\n  }\n  findDependency(arg) {\n    return null;\n  }\n  createDependencyFromIndexOrPath(args) {\n    if (this.param.disposed() == true) {\n      return null;\n    }\n    const { indexOrPath } = args;\n    const decomposedPath = new DecomposedPath();\n    const node = indexOrPath != null ? this.findReferencedGraphNode(indexOrPath, decomposedPath) : args.node;\n    if (node) {\n      return this.createDependency(node, args, decomposedPath);\n    } else {\n      Poly.warn(`node not found for path '${indexOrPath}' from param '${this.param.path()}'`);\n    }\n    return null;\n  }\n  createDependency(node, pathArgs, decomposedPath) {\n    const dependency = MethodDependency.create(this.param, pathArgs, node, decomposedPath);\n    return dependency;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class AnimationNamesExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"number\", \"object index (optional)\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  processArguments(args) {\n    return new Promise(async (resolve, reject) => {\n      if (args.length == 1 || args.length == 2) {\n        const index_or_path = args[0];\n        let objectIndex = parseInt(args[1]);\n        if (isNaN(objectIndex) || objectIndex == null) {\n          objectIndex = 0;\n        }\n        let container;\n        try {\n          container = await this.getReferencedNodeContainer(index_or_path);\n        } catch (e) {\n          reject(e);\n          return;\n        }\n        if (container) {\n          const coreContent = container.coreContent();\n          if (coreContent) {\n            const object = coreContent.threejsObjects()[objectIndex];\n            if (object) {\n              const animations = object.animations;\n              if (!animations) {\n                return [];\n              }\n              const animationNames = new Array(animations.length);\n              let i = 0;\n              for (const animation of animations) {\n                animationNames[i] = animation.name;\n                i++;\n              }\n              resolve(animationNames);\n            }\n          } else {\n            resolve([]);\n          }\n        }\n      } else {\n        resolve([]);\n      }\n    });\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class ArgExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"arguments list\"],\n      [\"number\", \"index\"]\n    ];\n  }\n  async processArguments(args) {\n    if (args.length == 2) {\n      const argumentsList = args[0];\n      const index = args[1];\n      const val = argumentsList.split(\" \")[index];\n      return val;\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class ArgcExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"arguments list\"]];\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const argumentsList = args[0];\n      const val = argumentsList.split(\" \").length;\n      return val;\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { Vector3, Box3 } from \"three\";\nconst tmpBox = new Box3();\nconst VECTOR_NAMES = [\"min\", \"max\", \"size\", \"center\"];\nconst COMPONENT_NAMES = [\"x\", \"y\", \"z\"];\nexport class BboxExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"string\", \"vector name, min, max, size or center\"],\n      [\"string\", \"component_name, x,y or z\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length >= 1) {\n      const index_or_path = args[0];\n      const vector_name = args[1];\n      const component_name = args[2];\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const value = this._get_value_from_container(container, vector_name, component_name);\n        return value;\n      }\n    }\n    return 0;\n  }\n  _get_value_from_container(container, vector_name, component_name) {\n    const coreGroup = container.coreContent();\n    if (coreGroup) {\n      coreGroup.boundingBox(tmpBox);\n    } else {\n      tmpBox.makeEmpty();\n    }\n    if (!vector_name) {\n      return tmpBox;\n    }\n    if (VECTOR_NAMES.indexOf(vector_name) >= 0) {\n      let vector = new Vector3();\n      switch (vector_name) {\n        case \"size\":\n          tmpBox.getSize(vector);\n          break;\n        case \"center\":\n          tmpBox.getCenter(vector);\n          break;\n        default:\n          vector = tmpBox[vector_name];\n      }\n      if (!component_name) {\n        return vector;\n      }\n      if (COMPONENT_NAMES.indexOf(component_name) >= 0) {\n        return vector[component_name];\n      } else {\n        return -1;\n      }\n    } else {\n      return -1;\n    }\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nasync function blobFromUrl(url) {\n  const response = await fetch(url);\n  const blob = await response.blob();\n  const urlCreator = window.URL || window.webkitURL;\n  const blobUrl = urlCreator.createObjectURL(blob);\n  return blobUrl;\n}\nexport class BlobExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"url\"]];\n  }\n  async processArguments(args) {\n    if (args.length >= 1) {\n      const url = args[0];\n      return await blobFromUrl(url);\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nimport { Poly } from \"../../Poly\";\nimport { BaseMethod } from \"./_Base\";\nexport class CameraNameExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"number\", \"object index\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 2) {\n      const index_or_path = args[0];\n      let objectIndex = parseInt(args[1]);\n      if (isNaN(objectIndex)) {\n        objectIndex = 0;\n      }\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent) {\n          const object = coreContent.threejsObjects().filter((object2) => Poly.camerasRegister.objectRegistered(object2))[objectIndex];\n          if (object) {\n            return object.name;\n          }\n        }\n      }\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nimport { Poly } from \"../../Poly\";\nimport { BaseMethod } from \"./_Base\";\nexport class CameraNamesExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const index_or_path = args[0];\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent) {\n          const objects = coreContent.threejsObjects().filter((object) => Poly.camerasRegister.objectRegistered(object));\n          const list = new Array(objects.length);\n          let i = 0;\n          for (const object of objects) {\n            list[i] = object.name;\n            i++;\n          }\n          return list;\n        }\n      }\n    }\n    return [];\n  }\n}\n", "\"use strict\";\nimport { Poly } from \"../../Poly\";\nimport { BaseMethod } from \"./_Base\";\nexport class CamerasCountExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const index_or_path = args[0];\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent) {\n          const count = coreContent.threejsObjects().filter((object) => Poly.camerasRegister.objectRegistered(object)).length;\n          return count;\n        }\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { Box3, Vector3 } from \"three\";\nconst tmpBox = new Box3();\nconst tmpCenter = new Vector3();\nexport class CentroidExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"string\", \"component_name, x,y or z\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length >= 1) {\n      const index_or_path = args[0];\n      const component_name = args[1];\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreGroup = container.coreContent();\n        if (coreGroup) {\n          coreGroup.boundingBox(tmpBox);\n          tmpBox.getCenter(tmpCenter);\n          if (component_name) {\n            const value = tmpCenter[component_name];\n            if (value != null) {\n              return value;\n            } else {\n              return 0;\n            }\n          } else {\n            return tmpCenter;\n          }\n        }\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { CoreType } from \"./../../../core/Type\";\nimport { BaseMethod } from \"./_Base\";\nimport { DecomposedPath } from \"../../../core/DecomposedPath\";\nexport class ChExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to param\"]];\n  }\n  findDependency(args) {\n    const { indexOrPath } = args;\n    if (indexOrPath == null) {\n      return null;\n    }\n    if (!CoreType.isString(indexOrPath)) {\n      return null;\n    }\n    const decomposedPath = new DecomposedPath();\n    const param = this.getReferencedParam(indexOrPath, decomposedPath);\n    if (param) {\n      this._referencedParam = param;\n      return this.createDependency(param, { indexOrPath }, decomposedPath);\n    }\n    return null;\n  }\n  async processArguments(args) {\n    return new Promise(async (resolve, reject) => {\n      let val = 0;\n      if (args.length == 1) {\n        const path = args[0];\n        const ref = this._referencedParam || this.getReferencedParam(path);\n        if (ref) {\n          if (ref.isDirty()) {\n            await ref.compute();\n          }\n          const result = ref.value;\n          if (result != null) {\n            val = result;\n            resolve(val);\n          }\n        } else {\n          reject(0);\n        }\n      }\n    });\n  }\n}\n", "\"use strict\";\nimport { CoreType } from \"./../../../core/Type\";\nimport { TypedParamPathParamValue, TypedNodePathParamValue } from \"./../../../core/Walker\";\nimport { BaseMethod } from \"./_Base\";\nimport { DecomposedPath } from \"../../../core/DecomposedPath\";\nexport class ChsopExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to param\"]];\n  }\n  findDependency(args) {\n    const { indexOrPath } = args;\n    if (indexOrPath == null) {\n      return null;\n    }\n    if (!CoreType.isString(indexOrPath)) {\n      return null;\n    }\n    const decomposedPath = new DecomposedPath();\n    const param = this.getReferencedParam(indexOrPath, decomposedPath);\n    if (param) {\n      this._referencedParam = param;\n      return this.createDependency(param, { indexOrPath }, decomposedPath);\n    }\n    return null;\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const path = args[0];\n      const param = this._referencedParam || this.getReferencedParam(path);\n      if (param) {\n        if (param.isDirty()) {\n          await param.compute();\n        }\n        const paramValue = param.value;\n        if (paramValue instanceof TypedParamPathParamValue || paramValue instanceof TypedNodePathParamValue) {\n          const result = paramValue.graphNodePath();\n          if (result != null) {\n            return result;\n          }\n        }\n      }\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nexport var AnimType = /* @__PURE__ */ ((AnimType2) => {\n  AnimType2[\"COPY\"] = \"copy\";\n  AnimType2[\"EASING\"] = \"easing\";\n  AnimType2[\"PLAY\"] = \"play\";\n  AnimType2[\"TARGET\"] = \"target\";\n  return AnimType2;\n})(AnimType || {});\n", "\"use strict\";\nimport { SopType } from \"./../../poly/registers/nodes/types/Sop\";\nimport { BaseMethod } from \"./_Base\";\nimport { CoreWalker } from \"../../../core/Walker\";\nimport { AnimType } from \"../../poly/registers/nodes/types/Anim\";\nfunction isCopyNode(node) {\n  return node && node.type() == SopType.COPY && node.type() == AnimType.COPY;\n}\nexport class CopyExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to copy\"],\n      [\"integer\", \"default value\"]\n    ];\n  }\n  static optionalArguments() {\n    return [[\"string\", \"attribute name (optional)\"]];\n  }\n  findDependency(args) {\n    if (args.indexOrPath == null) {\n      return null;\n    }\n    const node = this.findReferencedGraphNode(args.indexOrPath);\n    if (isCopyNode(node)) {\n      const stampNode = node.stampNode();\n      return this.createDependency(stampNode, { indexOrPath: args.indexOrPath });\n    }\n    return null;\n  }\n  processArguments(args) {\n    return new Promise((resolve, reject) => {\n      if (args.length >= 1) {\n        const path = args[0];\n        const defaultValue = args[1] || 0;\n        const attributeName = args[2];\n        const currentNode = this.node();\n        const node = currentNode ? CoreWalker.findNode(currentNode, path) : null;\n        let value;\n        if (isCopyNode(node)) {\n          value = node.stampValue(attributeName);\n        }\n        if (value == null) {\n          value = defaultValue;\n        }\n        resolve(value);\n      } else {\n        resolve(0);\n      }\n    });\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { Vector2 } from \"three\";\nconst COMPONENT_NAME_0 = [0, \"0\", \"x\"];\nconst COMPONENT_NAME_1 = [1, \"1\", \"y\"];\nexport class CopResExpression extends BaseMethod {\n  constructor() {\n    super(...arguments);\n    this._resolution = new Vector2();\n  }\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"string\", \"component_name: x or y\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 1 || args.length == 2) {\n      const indexOrPath = args[0];\n      const componentName = args[1];\n      const container = await this.getReferencedNodeContainer(indexOrPath);\n      if (container) {\n        const resolution = container.resolution();\n        if (componentName) {\n          if (COMPONENT_NAME_0.includes(componentName)) {\n            return resolution[0];\n          } else {\n            if (COMPONENT_NAME_1.includes(componentName)) {\n              return resolution[1];\n            }\n          }\n        } else {\n          this._resolution.set(resolution[0], resolution[1]);\n          return this._resolution;\n        }\n      }\n      this._resolution.set(1, 1);\n      return args.length == 1 ? 1 : this._resolution;\n    }\n    return 1;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { CoreUserAgent } from \"../../../core/UserAgent\";\nexport class isDeviceMobileExpression extends BaseMethod {\n  static requiredArguments() {\n    return [];\n  }\n  async processArguments(args) {\n    return CoreUserAgent.isMobile();\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { CoreUserAgent } from \"../../../core/UserAgent\";\nexport class isDeviceTouchExpression extends BaseMethod {\n  static requiredArguments() {\n    return [];\n  }\n  async processArguments(args) {\n    return CoreUserAgent.isTouchDevice();\n  }\n}\n", "\"use strict\";\nimport { CoreType } from \"./../../../core/Type\";\nimport { BaseMethod } from \"./_Base\";\nexport class LenExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"array_or_string\", \"array or string to count elements of\"]];\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const arg = args[0];\n      if (CoreType.isString(arg) || CoreType.isArray(arg)) {\n        return arg.length;\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { CoreType } from \"../../../core/Type\";\nimport { BaseMethod } from \"./_Base\";\nexport class JoinExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"array\", \"array to join the elements of\"],\n      [\"separator\", \"separator used to join the elements\"]\n    ];\n  }\n  async processArguments(args) {\n    if (args.length == 1 || args.length == 2) {\n      const arg = args[0];\n      let separator = args[1];\n      if (separator == null) {\n        separator = \" \";\n      }\n      if (CoreType.isArray(arg)) {\n        return arg.join(separator);\n      }\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class JsExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"javascript expression\"]];\n  }\n  async processArguments(args) {\n    let val = 0;\n    if (args.length == 1) {\n      const arg = args[0];\n      this._function = this._function || this._create_function(arg);\n      if (this._function) {\n        try {\n          val = this._function(this.param.scene(), this.param.node, this.param);\n        } catch (e) {\n          console.warn(`expression error`);\n          console.warn(e);\n        }\n      }\n    }\n    return val;\n  }\n  _create_function(content) {\n    return new Function(\"scene\", \"node\", \"param\", `return ${content}`);\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class ObjectExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"string\", \"attribute name\"],\n      [\"index\", \"object index\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  processArguments(args) {\n    return new Promise(async (resolve, reject) => {\n      if (args.length == 2 || args.length == 3) {\n        const indexOrPath = args[0];\n        const attribName = args[1];\n        const objectIndex = args[2] || 0;\n        let container = null;\n        try {\n          container = await this.getReferencedNodeContainer(indexOrPath);\n        } catch (e) {\n          reject(e);\n        }\n        if (container) {\n          const value = this._get_value_from_container(container, attribName, objectIndex);\n          resolve(value);\n        }\n      } else {\n        console.warn(`${args.length} given when 2 or 3 expected`);\n        resolve(0);\n      }\n    });\n  }\n  _get_value_from_container(container, attrib_name, point_index) {\n    const core_group = container.coreContent();\n    if (core_group) {\n      const coreObject = core_group.allCoreObjects()[point_index];\n      if (coreObject) {\n        return coreObject.attribValue(attrib_name);\n      } else {\n        return 0;\n      }\n    } else {\n      return null;\n    }\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class ObjectsCountExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const index_or_path = args[0];\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreGroup = container.coreContent();\n        if (coreGroup) {\n          const objectsCount = coreGroup.allObjects().length;\n          return objectsCount;\n        }\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class ObjectNameExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"number\", \"object index\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 2) {\n      const index_or_path = args[0];\n      let objectIndex = parseInt(args[1]);\n      if (isNaN(objectIndex)) {\n        objectIndex = 0;\n      }\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent) {\n          const object = coreContent.allObjects()[objectIndex];\n          if (object) {\n            return object.name;\n          }\n        }\n      }\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class ObjectNamesExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const index_or_path = args[0];\n      const container = await this.getReferencedNodeContainer(index_or_path);\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent) {\n          const objects = coreContent.allObjects();\n          const list = new Array(objects.length);\n          let i = 0;\n          for (const object of objects) {\n            list[i] = object.name;\n            i++;\n          }\n          return list;\n        }\n      }\n    }\n    return [];\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { stringTailDigits } from \"../../../core/String\";\nexport class OpdigitsExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    const { indexOrPath } = args;\n    if (indexOrPath == null) {\n      return null;\n    }\n    const graph_node = this.findReferencedGraphNode(indexOrPath);\n    if (graph_node) {\n      const node = graph_node;\n      if (node.nameController) {\n        const nameNode = node.nameController.graphNode();\n        return this.createDependency(nameNode, { indexOrPath });\n      }\n    }\n    return null;\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const index_or_path = args[0];\n      const node = this.getReferencedNode(index_or_path);\n      if (node) {\n        const name = node.name();\n        return stringTailDigits(name);\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class OpnameExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    const { indexOrPath } = args;\n    if (indexOrPath == null) {\n      return null;\n    }\n    const graphNode = this.findReferencedGraphNode(indexOrPath);\n    if (graphNode) {\n      const node = graphNode;\n      if (node.nameController) {\n        const nameNode = node.nameController.graphNode();\n        return this.createDependency(nameNode, { indexOrPath });\n      }\n    }\n    return null;\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const index_or_path = args[0];\n      const node = this.getReferencedNode(index_or_path);\n      if (node) {\n        return node.name();\n      }\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class PadzeroExpression extends BaseMethod {\n  static requiredArguments() {\n    return [[\"string\", \"number\"]];\n  }\n  async processArguments(args) {\n    const pad = args[0] || 2;\n    const srcNumber = args[1] || 0;\n    const unpadded = `${srcNumber}`;\n    return unpadded.padStart(pad, \"0\");\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { Poly } from \"../../Poly\";\nexport class PlayerModeExpression extends BaseMethod {\n  static requiredArguments() {\n    return [];\n  }\n  async processArguments(args) {\n    return Poly.playerMode();\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nconst EXPECTED_ARGS_COUNT = 3;\nconst _pointsSrc = [];\nexport class PointExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      [\"string\", \"path to node\"],\n      [\"string\", \"attribute name\"],\n      [\"index\", \"point index\"]\n    ];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  processArguments(args) {\n    return new Promise(async (resolve, reject) => {\n      if (args.length == EXPECTED_ARGS_COUNT) {\n        const index_or_path = args[0];\n        const attrib_name = args[1];\n        const point_index = args[2];\n        let container = null;\n        try {\n          container = await this.getReferencedNodeContainer(index_or_path);\n        } catch (e) {\n          reject(e);\n        }\n        if (container) {\n          const value = this._get_value_from_container(container, attrib_name, point_index);\n          resolve(value);\n        }\n      } else {\n        console.warn(`${args.length} given when expected ${EXPECTED_ARGS_COUNT}`);\n        resolve(0);\n      }\n    });\n  }\n  _get_value_from_container(container, attrib_name, point_index) {\n    const coreGroup = container.coreContent();\n    if (coreGroup) {\n      coreGroup.points(_pointsSrc);\n      const point = _pointsSrc[point_index];\n      if (point) {\n        return point.attribValue(attrib_name);\n      } else {\n        return 0;\n      }\n    } else {\n      return null;\n    }\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class PointsCountExpression extends BaseMethod {\n  // npoints(0)\n  // npoints('../REF_bbox')\n  static requiredArguments() {\n    return [[\"string\", \"path to node\"]];\n  }\n  findDependency(args) {\n    return this.createDependencyFromIndexOrPath(args);\n  }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const indexOrPath = args[0];\n      const container = await this.getReferencedNodeContainer(indexOrPath);\n      if (container) {\n        const coreContent = container.coreContent();\n        if (coreContent) {\n          return coreContent.pointsCount();\n        }\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { MathUtils } from \"three\";\nexport class SmoothstepExpression extends BaseMethod {\n  static requiredArguments() {\n    return [, [\"x\", \"value\"], [\"min\", \"range min\"], [\"max\", \"range max\"]];\n  }\n  async processArguments(args) {\n    if (args.length == 3) {\n      const x = args[0];\n      const rangeMin = args[1];\n      const rangeMax = args[2];\n      return MathUtils.smoothstep(x, rangeMin, rangeMax);\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { MathUtils } from \"three\";\nexport class SmootherstepExpression extends BaseMethod {\n  static requiredArguments() {\n    return [, [\"x\", \"value\"], [\"min\", \"range min\"], [\"max\", \"range max\"]];\n  }\n  async processArguments(args) {\n    if (args.length == 3) {\n      const x = args[0];\n      const rangeMin = args[1];\n      const rangeMax = args[2];\n      return MathUtils.smootherstep(x, rangeMin, rangeMax);\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { NetworkNodeType } from \"./../../poly/NodeContext\";\nimport { BaseMethod } from \"./_Base\";\nfunction isSolverNode(node) {\n  return node && node.type() == NetworkNodeType.SOLVER;\n}\nexport class SolverIterationExpression extends BaseMethod {\n  static requiredArguments() {\n    return [];\n  }\n  static optionalArguments() {\n    return [[\"string\", \"path to solver node\"]];\n  }\n  _solverNode() {\n    const solverNode = this.param.node.parentController.findParent(\n      (parent) => parent.type() == NetworkNodeType.SOLVER\n    );\n    return solverNode;\n  }\n  findDependency(args) {\n    const { indexOrPath } = args;\n    const node = indexOrPath ? this.findReferencedGraphNode(indexOrPath) : this._solverNode();\n    if (isSolverNode(node)) {\n      const solverStamp = node.iterationStamp();\n      return this.createDependency(solverStamp, { indexOrPath, node });\n    }\n    return null;\n  }\n  async processArguments(args) {\n    const nodePath = args[0] || \"..\";\n    const foundNode = await this.getReferencedNode(nodePath);\n    if (foundNode && isSolverNode(foundNode)) {\n      const foundSolverNode = foundNode;\n      const value = foundSolverNode.iterationStamp().iteration();\n      return value;\n    } else {\n      return 0;\n    }\n  }\n}\n", "\"use strict\";\nimport { CoreType } from \"./../../../core/Type\";\nimport { BaseMethod } from \"./_Base\";\nexport class StrCharsCountExpression extends BaseMethod {\n  // str_chars_count('bla') => 3\n  static requiredArguments() {\n    return [[\"string\", \"string to count characters of\"]];\n  }\n  // findDependency(index_or_path: number | string): null {\n  // \treturn null\n  // \t// return this.createDependencyFromIndexOrPath(index_or_path)\n  // }\n  async processArguments(args) {\n    if (args.length == 1) {\n      const string = args[0];\n      if (CoreType.isString(string)) {\n        return string.length;\n      }\n    }\n    return 0;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class StrConcatExpression extends BaseMethod {\n  static requiredArguments() {\n    return [\n      // ['string', 'string to get range from'],\n      // ['integer', 'range start'],\n      // ['integer', 'range size'],\n    ];\n  }\n  // findDependency(index_or_path: number | string): null {\n  // \treturn null\n  // \t// return this.createDependencyFromIndexOrPath(index_or_path)\n  // }\n  async processArguments(args) {\n    let value = \"\";\n    for (let arg of args) {\n      if (arg == null) {\n        arg = \"\";\n      }\n      value += `${arg}`;\n    }\n    return value;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nexport class StrIndexExpression extends BaseMethod {\n  // str_chars_count('bla') => 3\n  static requiredArguments() {\n    return [\n      [\"string\", \"string to get index from\"],\n      [\"string\", \"char to find index of\"]\n    ];\n  }\n  // findDependency(index_or_path: number | string): null {\n  // \treturn null\n  // \t// return this.createDependencyFromIndexOrPath(index_or_path)\n  // }\n  async processArguments(args) {\n    if (args.length == 2) {\n      const string = args[0];\n      const sub_string = args[1];\n      return string.indexOf(sub_string);\n    }\n    return -1;\n  }\n}\n", "\"use strict\";\nimport { CoreType } from \"../../../core/Type\";\nimport { BaseMethod } from \"./_Base\";\nfunction toString(arg) {\n  if (arg == null) {\n    return \"\";\n  }\n  return CoreType.isString(arg) ? arg : `${arg}`;\n}\nfunction toInt(arg, defaultVal) {\n  if (arg == null) {\n    return defaultVal;\n  }\n  return CoreType.isNumber(arg) ? arg : parseInt(arg);\n}\nexport class StrSubExpression extends BaseMethod {\n  // str_chars_count('bla') => 3\n  static requiredArguments() {\n    return [\n      [\"string\", \"string to get range from\"],\n      [\"integer\", \"range start\"],\n      [\"integer\", \"range size\"]\n    ];\n  }\n  // findDependency(index_or_path: number | string): MethodDependency | null {\n  // \treturn null;\n  // \t// return this.createDependencyFromIndexOrPath(index_or_path)\n  // }\n  async processArguments(args) {\n    const string = toString(args[0]);\n    const rangeStart = toInt(args[1], 0);\n    let rangeSize = toInt(args[2], 1);\n    if (string) {\n      return string.substring(rangeStart, rangeStart + rangeSize);\n    }\n    return \"\";\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { Vector2 } from \"three\";\nexport class ViewerSizeExpression extends BaseMethod {\n  constructor() {\n    super(...arguments);\n    this._size = new Vector2();\n  }\n  static requiredArguments() {\n    return [[]];\n  }\n  findDependency(indexOrPath) {\n    this.param.addGraphInput(this.param.scene().viewersRegister.graphNode());\n    return null;\n  }\n  async processArguments(args) {\n    var _a;\n    (_a = this.param.scene().viewersRegister.lastRenderedViewer()) == null ? void 0 : _a.size(this._size);\n    return this._size;\n  }\n}\n", "\"use strict\";\nimport { BaseMethod } from \"./_Base\";\nimport { Vector2 } from \"three\";\nexport class WindowSizeExpression extends BaseMethod {\n  constructor() {\n    super(...arguments);\n    this._windowSize = new Vector2();\n  }\n  static requiredArguments() {\n    return [[]];\n  }\n  findDependency(indexOrPath) {\n    this.param.addGraphInput(this.param.scene().windowController.graphNode());\n    return null;\n  }\n  async processArguments(args) {\n    this._windowSize.set(window.innerWidth, window.innerHeight);\n    return this._windowSize;\n  }\n}\n", "\"use strict\";\nexport var ExpressionType = /* @__PURE__ */ ((ExpressionType2) => {\n  ExpressionType2[\"animationNames\"] = \"animationNames\";\n  ExpressionType2[\"arg\"] = \"arg\";\n  ExpressionType2[\"argc\"] = \"argc\";\n  ExpressionType2[\"bbox\"] = \"bbox\";\n  ExpressionType2[\"blob\"] = \"blob\";\n  ExpressionType2[\"cameraName\"] = \"cameraName\";\n  ExpressionType2[\"cameraNames\"] = \"cameraNames\";\n  ExpressionType2[\"camerasCount\"] = \"camerasCount\";\n  ExpressionType2[\"centroid\"] = \"centroid\";\n  ExpressionType2[\"ch\"] = \"ch\";\n  ExpressionType2[\"chsop\"] = \"chsop\";\n  ExpressionType2[\"copy\"] = \"copy\";\n  ExpressionType2[\"copRes\"] = \"copRes\";\n  ExpressionType2[\"isDeviceMobile\"] = \"isDeviceMobile\";\n  ExpressionType2[\"isDeviceTouch\"] = \"isDeviceTouch\";\n  ExpressionType2[\"len\"] = \"len\";\n  ExpressionType2[\"join\"] = \"join\";\n  ExpressionType2[\"js\"] = \"js\";\n  ExpressionType2[\"object\"] = \"object\";\n  ExpressionType2[\"objectsCount\"] = \"objectsCount\";\n  ExpressionType2[\"objectName\"] = \"objectName\";\n  ExpressionType2[\"objectNames\"] = \"objectNames\";\n  ExpressionType2[\"opdigits\"] = \"opdigits\";\n  ExpressionType2[\"opname\"] = \"opname\";\n  ExpressionType2[\"padzero\"] = \"padzero\";\n  ExpressionType2[\"playerMode\"] = \"playerMode\";\n  ExpressionType2[\"point\"] = \"point\";\n  ExpressionType2[\"pointsCount\"] = \"pointsCount\";\n  ExpressionType2[\"smoothstep\"] = \"smoothstep\";\n  ExpressionType2[\"smootherstep\"] = \"smootherstep\";\n  ExpressionType2[\"solverIteration\"] = \"solverIteration\";\n  ExpressionType2[\"strCharsCount\"] = \"strCharsCount\";\n  ExpressionType2[\"strConcat\"] = \"strConcat\";\n  ExpressionType2[\"strIndex\"] = \"strIndex\";\n  ExpressionType2[\"strSub\"] = \"strSub\";\n  ExpressionType2[\"viewerSize\"] = \"viewerSize\";\n  ExpressionType2[\"windowSize\"] = \"windowSize\";\n  return ExpressionType2;\n})(ExpressionType || {});\n", "\"use strict\";\nimport { AnimationNamesExpression } from \"../../../expressions/methods/animationNames\";\nimport { ArgExpression } from \"../../../expressions/methods/arg\";\nimport { ArgcExpression } from \"../../../expressions/methods/argc\";\nimport { BboxExpression } from \"../../../expressions/methods/bbox\";\nimport { BlobExpression } from \"../../../expressions/methods/blob\";\nimport { CameraNameExpression } from \"../../../expressions/methods/cameraName\";\nimport { CameraNamesExpression } from \"../../../expressions/methods/cameraNames\";\nimport { CamerasCountExpression } from \"../../../expressions/methods/camerasCount\";\nimport { CentroidExpression } from \"../../../expressions/methods/centroid\";\nimport { ChExpression } from \"../../../expressions/methods/ch\";\nimport { ChsopExpression } from \"../../../expressions/methods/chsop\";\nimport { CopyExpression } from \"../../../expressions/methods/copy\";\nimport { CopResExpression } from \"../../../expressions/methods/copRes\";\nimport { isDeviceMobileExpression } from \"../../../expressions/methods/isDeviceMobile\";\nimport { isDeviceTouchExpression } from \"../../../expressions/methods/isDeviceTouch\";\nimport { LenExpression } from \"../../../expressions/methods/len\";\nimport { JoinExpression } from \"../../../expressions/methods/join\";\nimport { JsExpression } from \"../../../expressions/methods/js\";\nimport { ObjectExpression } from \"../../../expressions/methods/object\";\nimport { ObjectsCountExpression } from \"../../../expressions/methods/objectsCount\";\nimport { ObjectNameExpression } from \"../../../expressions/methods/objectName\";\nimport { ObjectNamesExpression } from \"../../../expressions/methods/objectNames\";\nimport { OpdigitsExpression } from \"../../../expressions/methods/opdigits\";\nimport { OpnameExpression } from \"../../../expressions/methods/opname\";\nimport { PadzeroExpression } from \"../../../expressions/methods/padzero\";\nimport { PlayerModeExpression } from \"../../../expressions/methods/playerMode\";\nimport { PointExpression } from \"../../../expressions/methods/point\";\nimport { PointsCountExpression } from \"../../../expressions/methods/pointsCount\";\nimport { SmoothstepExpression } from \"../../../expressions/methods/smoothstep\";\nimport { SmootherstepExpression } from \"../../../expressions/methods/smootherstep\";\nimport { SolverIterationExpression } from \"../../../expressions/methods/solverIteration\";\nimport { StrCharsCountExpression } from \"../../../expressions/methods/strCharsCount\";\nimport { StrConcatExpression } from \"../../../expressions/methods/strConcat\";\nimport { StrIndexExpression } from \"../../../expressions/methods/strIndex\";\nimport { StrSubExpression } from \"../../../expressions/methods/strSub\";\nimport { ViewerSizeExpression } from \"../../../expressions/methods/viewerSize\";\nimport { WindowSizeExpression } from \"../../../expressions/methods/windowSize\";\nimport { ExpressionType } from \"../../../expressions/methods/Common\";\nexport class AllExpressionsRegister {\n  static run(poly) {\n    poly.expressionsRegister.register(AnimationNamesExpression, ExpressionType.animationNames);\n    poly.expressionsRegister.register(ArgExpression, ExpressionType.arg);\n    poly.expressionsRegister.register(ArgcExpression, ExpressionType.argc);\n    poly.expressionsRegister.register(BboxExpression, ExpressionType.bbox);\n    poly.expressionsRegister.register(BlobExpression, ExpressionType.blob);\n    poly.expressionsRegister.register(CameraNameExpression, ExpressionType.cameraName);\n    poly.expressionsRegister.register(CameraNamesExpression, ExpressionType.cameraNames);\n    poly.expressionsRegister.register(CamerasCountExpression, ExpressionType.camerasCount);\n    poly.expressionsRegister.register(CentroidExpression, ExpressionType.centroid);\n    poly.expressionsRegister.register(ChExpression, ExpressionType.ch);\n    poly.expressionsRegister.register(ChsopExpression, ExpressionType.chsop);\n    poly.expressionsRegister.register(CopyExpression, ExpressionType.copy);\n    poly.expressionsRegister.register(CopResExpression, ExpressionType.copRes);\n    poly.expressionsRegister.register(isDeviceMobileExpression, ExpressionType.isDeviceMobile);\n    poly.expressionsRegister.register(isDeviceTouchExpression, ExpressionType.isDeviceTouch);\n    poly.expressionsRegister.register(LenExpression, ExpressionType.len);\n    poly.expressionsRegister.register(JoinExpression, ExpressionType.join);\n    poly.expressionsRegister.register(JsExpression, ExpressionType.js);\n    poly.expressionsRegister.register(ObjectExpression, ExpressionType.object);\n    poly.expressionsRegister.register(ObjectsCountExpression, ExpressionType.objectsCount);\n    poly.expressionsRegister.register(ObjectNameExpression, ExpressionType.objectName);\n    poly.expressionsRegister.register(ObjectNamesExpression, ExpressionType.objectNames);\n    poly.expressionsRegister.register(OpdigitsExpression, ExpressionType.opdigits);\n    poly.expressionsRegister.register(OpnameExpression, ExpressionType.opname);\n    poly.expressionsRegister.register(PadzeroExpression, ExpressionType.padzero);\n    poly.expressionsRegister.register(PlayerModeExpression, ExpressionType.playerMode);\n    poly.expressionsRegister.register(PointExpression, ExpressionType.point);\n    poly.expressionsRegister.register(PointsCountExpression, ExpressionType.pointsCount);\n    poly.expressionsRegister.register(SmoothstepExpression, ExpressionType.smoothstep);\n    poly.expressionsRegister.register(SmootherstepExpression, ExpressionType.smootherstep);\n    poly.expressionsRegister.register(SolverIterationExpression, ExpressionType.solverIteration);\n    poly.expressionsRegister.register(StrCharsCountExpression, ExpressionType.strCharsCount);\n    poly.expressionsRegister.register(StrConcatExpression, ExpressionType.strConcat);\n    poly.expressionsRegister.register(StrIndexExpression, ExpressionType.strIndex);\n    poly.expressionsRegister.register(StrSubExpression, ExpressionType.strSub);\n    poly.expressionsRegister.register(ViewerSizeExpression, ExpressionType.viewerSize);\n    poly.expressionsRegister.register(WindowSizeExpression, ExpressionType.windowSize);\n  }\n}\n"],
  "mappings": "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",
  "names": ["tmpBox"]
}
