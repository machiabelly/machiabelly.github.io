import {
  SopType
} from "./chunk-OBFUH3H6.js";
import {
  CoreUserAgent
} from "./chunk-CHIZUGOH.js";
import {
  CoreWalker,
  DecomposedPath,
  MethodDependency,
  TypedNodePathParamValue,
  TypedParamPathParamValue,
  stringTailDigits
} from "./chunk-RVFV2LA3.js";
import {
  Poly
} from "./chunk-O564GFGZ.js";
import {
  Box3,
  CoreType,
  MathUtils,
  Vector2,
  Vector3
} from "./chunk-6OBTIB4K.js";
import {
  NetworkNodeType
} from "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/_Base.js
var BaseMethod = class {
  constructor(param) {
    this.param = param;
  }
  node() {
    return this._node = this._node || this.param.node;
  }
  static requiredArguments() {
    console.warn("Expression.Method._Base.required_arguments virtual method call. Please override");
    return [];
  }
  static optionalArguments() {
    return [];
  }
  static minAllowedArgumentsCount() {
    return this.requiredArguments().length;
  }
  static maxAllowedArgumentsCount() {
    return this.minAllowedArgumentsCount() + this.optionalArguments().length;
  }
  static allowedArgumentsCount(count) {
    return count >= this.minAllowedArgumentsCount() && count <= this.maxAllowedArgumentsCount();
  }
  processArguments(args) {
    throw "Expression.Method._Base.process_arguments virtual method call. Please override";
  }
  async getReferencedNodeContainer(indexOrPath) {
    var _a, _b;
    const referencedNode = this.getReferencedNode(indexOrPath);
    if (referencedNode) {
      let container;
      if (referencedNode.isDirty() || ((_b = (_a = referencedNode.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
        container = await referencedNode.compute();
      } else {
        container = referencedNode.containerController.container();
      }
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent != null) {
          return container;
        }
      }
      throw `referenced node invalid: ${referencedNode.path()}`;
    } else {
      throw `invalid input (${indexOrPath})`;
    }
  }
  getReferencedParam(path, decomposedPath) {
    const node = this.node();
    if (node) {
      return CoreWalker.findParam(node, path, decomposedPath);
    }
    return null;
  }
  findReferencedGraphNode(indexOrPath, decomposedPath) {
    const is_index = CoreType.isNumber(indexOrPath);
    if (is_index) {
      const index = indexOrPath;
      const node = this.node();
      if (node) {
        const input_graph_node = node.io.inputs.inputGraphNode(index);
        return input_graph_node;
      }
    } else {
      const path = indexOrPath;
      return this.getReferencedNode(path, decomposedPath);
    }
    return null;
  }
  // caching the node by path here prevents having expressions such as points_count(0)
  // evaluate to an error when the input is disconnected
  // private _node_by_path: Map<string | number, BaseNodeType | null | undefined> = new Map();
  getReferencedNode(indexOrPath, decomposedPath) {
    let node = null;
    const current_node = this.node();
    if (CoreType.isString(indexOrPath)) {
      if (current_node) {
        const path = indexOrPath;
        node = CoreWalker.findNode(current_node, path, decomposedPath);
      }
    } else {
      if (current_node) {
        const index = indexOrPath;
        node = current_node.io.inputs.input(index);
      }
    }
    return node || null;
  }
  findDependency(arg) {
    return null;
  }
  createDependencyFromIndexOrPath(args) {
    if (this.param.disposed() == true) {
      return null;
    }
    const { indexOrPath } = args;
    const decomposedPath = new DecomposedPath();
    const node = indexOrPath != null ? this.findReferencedGraphNode(indexOrPath, decomposedPath) : args.node;
    if (node) {
      return this.createDependency(node, args, decomposedPath);
    } else {
      Poly.warn(`node not found for path '${indexOrPath}' from param '${this.param.path()}'`);
    }
    return null;
  }
  createDependency(node, pathArgs, decomposedPath) {
    const dependency = MethodDependency.create(this.param, pathArgs, node, decomposedPath);
    return dependency;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/animationNames.js
var AnimationNamesExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index (optional)"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise(async (resolve, reject) => {
      if (args.length == 1 || args.length == 2) {
        const index_or_path = args[0];
        let objectIndex = parseInt(args[1]);
        if (isNaN(objectIndex) || objectIndex == null) {
          objectIndex = 0;
        }
        let container;
        try {
          container = await this.getReferencedNodeContainer(index_or_path);
        } catch (e) {
          reject(e);
          return;
        }
        if (container) {
          const coreContent = container.coreContent();
          if (coreContent) {
            const object = coreContent.threejsObjects()[objectIndex];
            if (object) {
              const animations = object.animations;
              if (!animations) {
                return [];
              }
              const animationNames = new Array(animations.length);
              let i = 0;
              for (const animation of animations) {
                animationNames[i] = animation.name;
                i++;
              }
              resolve(animationNames);
            }
          } else {
            resolve([]);
          }
        }
      } else {
        resolve([]);
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/arg.js
var ArgExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "arguments list"],
      ["number", "index"]
    ];
  }
  async processArguments(args) {
    if (args.length == 2) {
      const argumentsList = args[0];
      const index = args[1];
      const val = argumentsList.split(" ")[index];
      return val;
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/argc.js
var ArgcExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "arguments list"]];
  }
  async processArguments(args) {
    if (args.length == 1) {
      const argumentsList = args[0];
      const val = argumentsList.split(" ").length;
      return val;
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/bbox.js
var tmpBox = new Box3();
var VECTOR_NAMES = ["min", "max", "size", "center"];
var COMPONENT_NAMES = ["x", "y", "z"];
var BboxExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "vector name, min, max, size or center"],
      ["string", "component_name, x,y or z"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length >= 1) {
      const index_or_path = args[0];
      const vector_name = args[1];
      const component_name = args[2];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const value = this._get_value_from_container(container, vector_name, component_name);
        return value;
      }
    }
    return 0;
  }
  _get_value_from_container(container, vector_name, component_name) {
    const coreGroup = container.coreContent();
    if (coreGroup) {
      coreGroup.boundingBox(tmpBox);
    } else {
      tmpBox.makeEmpty();
    }
    if (!vector_name) {
      return tmpBox;
    }
    if (VECTOR_NAMES.indexOf(vector_name) >= 0) {
      let vector = new Vector3();
      switch (vector_name) {
        case "size":
          tmpBox.getSize(vector);
          break;
        case "center":
          tmpBox.getCenter(vector);
          break;
        default:
          vector = tmpBox[vector_name];
      }
      if (!component_name) {
        return vector;
      }
      if (COMPONENT_NAMES.indexOf(component_name) >= 0) {
        return vector[component_name];
      } else {
        return -1;
      }
    } else {
      return -1;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/blob.js
async function blobFromUrl(url) {
  const response = await fetch(url);
  const blob = await response.blob();
  const urlCreator = window.URL || window.webkitURL;
  const blobUrl = urlCreator.createObjectURL(blob);
  return blobUrl;
}
var BlobExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "url"]];
  }
  async processArguments(args) {
    if (args.length >= 1) {
      const url = args[0];
      return await blobFromUrl(url);
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/cameraName.js
var CameraNameExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 2) {
      const index_or_path = args[0];
      let objectIndex = parseInt(args[1]);
      if (isNaN(objectIndex)) {
        objectIndex = 0;
      }
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent) {
          const object = coreContent.threejsObjects().filter((object2) => Poly.camerasRegister.objectRegistered(object2))[objectIndex];
          if (object) {
            return object.name;
          }
        }
      }
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/cameraNames.js
var CameraNamesExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 1) {
      const index_or_path = args[0];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent) {
          const objects = coreContent.threejsObjects().filter((object) => Poly.camerasRegister.objectRegistered(object));
          const list = new Array(objects.length);
          let i = 0;
          for (const object of objects) {
            list[i] = object.name;
            i++;
          }
          return list;
        }
      }
    }
    return [];
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/camerasCount.js
var CamerasCountExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 1) {
      const index_or_path = args[0];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent) {
          const count = coreContent.threejsObjects().filter((object) => Poly.camerasRegister.objectRegistered(object)).length;
          return count;
        }
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/centroid.js
var tmpBox2 = new Box3();
var tmpCenter = new Vector3();
var CentroidExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "component_name, x,y or z"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length >= 1) {
      const index_or_path = args[0];
      const component_name = args[1];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreGroup = container.coreContent();
        if (coreGroup) {
          coreGroup.boundingBox(tmpBox2);
          tmpBox2.getCenter(tmpCenter);
          if (component_name) {
            const value = tmpCenter[component_name];
            if (value != null) {
              return value;
            } else {
              return 0;
            }
          } else {
            return tmpCenter;
          }
        }
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/ch.js
var ChExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to param"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    if (!CoreType.isString(indexOrPath)) {
      return null;
    }
    const decomposedPath = new DecomposedPath();
    const param = this.getReferencedParam(indexOrPath, decomposedPath);
    if (param) {
      this._referencedParam = param;
      return this.createDependency(param, { indexOrPath }, decomposedPath);
    }
    return null;
  }
  async processArguments(args) {
    return new Promise(async (resolve, reject) => {
      let val = 0;
      if (args.length == 1) {
        const path = args[0];
        const ref = this._referencedParam || this.getReferencedParam(path);
        if (ref) {
          if (ref.isDirty()) {
            await ref.compute();
          }
          const result = ref.value;
          if (result != null) {
            val = result;
            resolve(val);
          }
        } else {
          reject(0);
        }
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/chsop.js
var ChsopExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to param"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    if (!CoreType.isString(indexOrPath)) {
      return null;
    }
    const decomposedPath = new DecomposedPath();
    const param = this.getReferencedParam(indexOrPath, decomposedPath);
    if (param) {
      this._referencedParam = param;
      return this.createDependency(param, { indexOrPath }, decomposedPath);
    }
    return null;
  }
  async processArguments(args) {
    if (args.length == 1) {
      const path = args[0];
      const param = this._referencedParam || this.getReferencedParam(path);
      if (param) {
        if (param.isDirty()) {
          await param.compute();
        }
        const paramValue = param.value;
        if (paramValue instanceof TypedParamPathParamValue || paramValue instanceof TypedNodePathParamValue) {
          const result = paramValue.graphNodePath();
          if (result != null) {
            return result;
          }
        }
      }
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Anim.js
var AnimType = ((AnimType2) => {
  AnimType2["COPY"] = "copy";
  AnimType2["EASING"] = "easing";
  AnimType2["PLAY"] = "play";
  AnimType2["TARGET"] = "target";
  return AnimType2;
})(AnimType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/copy.js
function isCopyNode(node) {
  return node && node.type() == SopType.COPY && node.type() == AnimType.COPY;
}
var CopyExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to copy"],
      ["integer", "default value"]
    ];
  }
  static optionalArguments() {
    return [["string", "attribute name (optional)"]];
  }
  findDependency(args) {
    if (args.indexOrPath == null) {
      return null;
    }
    const node = this.findReferencedGraphNode(args.indexOrPath);
    if (isCopyNode(node)) {
      const stampNode = node.stampNode();
      return this.createDependency(stampNode, { indexOrPath: args.indexOrPath });
    }
    return null;
  }
  processArguments(args) {
    return new Promise((resolve, reject) => {
      if (args.length >= 1) {
        const path = args[0];
        const defaultValue = args[1] || 0;
        const attributeName = args[2];
        const currentNode = this.node();
        const node = currentNode ? CoreWalker.findNode(currentNode, path) : null;
        let value;
        if (isCopyNode(node)) {
          value = node.stampValue(attributeName);
        }
        if (value == null) {
          value = defaultValue;
        }
        resolve(value);
      } else {
        resolve(0);
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/copRes.js
var COMPONENT_NAME_0 = [0, "0", "x"];
var COMPONENT_NAME_1 = [1, "1", "y"];
var CopResExpression = class extends BaseMethod {
  constructor() {
    super(...arguments);
    this._resolution = new Vector2();
  }
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "component_name: x or y"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 1 || args.length == 2) {
      const indexOrPath = args[0];
      const componentName = args[1];
      const container = await this.getReferencedNodeContainer(indexOrPath);
      if (container) {
        const resolution = container.resolution();
        if (componentName) {
          if (COMPONENT_NAME_0.includes(componentName)) {
            return resolution[0];
          } else {
            if (COMPONENT_NAME_1.includes(componentName)) {
              return resolution[1];
            }
          }
        } else {
          this._resolution.set(resolution[0], resolution[1]);
          return this._resolution;
        }
      }
      this._resolution.set(1, 1);
      return args.length == 1 ? 1 : this._resolution;
    }
    return 1;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/isDeviceMobile.js
var isDeviceMobileExpression = class extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  async processArguments(args) {
    return CoreUserAgent.isMobile();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/isDeviceTouch.js
var isDeviceTouchExpression = class extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  async processArguments(args) {
    return CoreUserAgent.isTouchDevice();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/len.js
var LenExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["array_or_string", "array or string to count elements of"]];
  }
  async processArguments(args) {
    if (args.length == 1) {
      const arg = args[0];
      if (CoreType.isString(arg) || CoreType.isArray(arg)) {
        return arg.length;
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/join.js
var JoinExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["array", "array to join the elements of"],
      ["separator", "separator used to join the elements"]
    ];
  }
  async processArguments(args) {
    if (args.length == 1 || args.length == 2) {
      const arg = args[0];
      let separator = args[1];
      if (separator == null) {
        separator = " ";
      }
      if (CoreType.isArray(arg)) {
        return arg.join(separator);
      }
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/js.js
var JsExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "javascript expression"]];
  }
  async processArguments(args) {
    let val = 0;
    if (args.length == 1) {
      const arg = args[0];
      this._function = this._function || this._create_function(arg);
      if (this._function) {
        try {
          val = this._function(this.param.scene(), this.param.node, this.param);
        } catch (e) {
          console.warn(`expression error`);
          console.warn(e);
        }
      }
    }
    return val;
  }
  _create_function(content) {
    return new Function("scene", "node", "param", `return ${content}`);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/object.js
var ObjectExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "attribute name"],
      ["index", "object index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise(async (resolve, reject) => {
      if (args.length == 2 || args.length == 3) {
        const indexOrPath = args[0];
        const attribName = args[1];
        const objectIndex = args[2] || 0;
        let container = null;
        try {
          container = await this.getReferencedNodeContainer(indexOrPath);
        } catch (e) {
          reject(e);
        }
        if (container) {
          const value = this._get_value_from_container(container, attribName, objectIndex);
          resolve(value);
        }
      } else {
        console.warn(`${args.length} given when 2 or 3 expected`);
        resolve(0);
      }
    });
  }
  _get_value_from_container(container, attrib_name, point_index) {
    const core_group = container.coreContent();
    if (core_group) {
      const coreObject = core_group.allCoreObjects()[point_index];
      if (coreObject) {
        return coreObject.attribValue(attrib_name);
      } else {
        return 0;
      }
    } else {
      return null;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/objectsCount.js
var ObjectsCountExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 1) {
      const index_or_path = args[0];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreGroup = container.coreContent();
        if (coreGroup) {
          const objectsCount = coreGroup.allObjects().length;
          return objectsCount;
        }
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/objectName.js
var ObjectNameExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["number", "object index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 2) {
      const index_or_path = args[0];
      let objectIndex = parseInt(args[1]);
      if (isNaN(objectIndex)) {
        objectIndex = 0;
      }
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent) {
          const object = coreContent.allObjects()[objectIndex];
          if (object) {
            return object.name;
          }
        }
      }
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/objectNames.js
var ObjectNamesExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 1) {
      const index_or_path = args[0];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent) {
          const objects = coreContent.allObjects();
          const list = new Array(objects.length);
          let i = 0;
          for (const object of objects) {
            list[i] = object.name;
            i++;
          }
          return list;
        }
      }
    }
    return [];
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/opdigits.js
var OpdigitsExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    const graph_node = this.findReferencedGraphNode(indexOrPath);
    if (graph_node) {
      const node = graph_node;
      if (node.nameController) {
        const nameNode = node.nameController.graphNode();
        return this.createDependency(nameNode, { indexOrPath });
      }
    }
    return null;
  }
  async processArguments(args) {
    if (args.length == 1) {
      const index_or_path = args[0];
      const node = this.getReferencedNode(index_or_path);
      if (node) {
        const name = node.name();
        return stringTailDigits(name);
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/opname.js
var OpnameExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    const graphNode = this.findReferencedGraphNode(indexOrPath);
    if (graphNode) {
      const node = graphNode;
      if (node.nameController) {
        const nameNode = node.nameController.graphNode();
        return this.createDependency(nameNode, { indexOrPath });
      }
    }
    return null;
  }
  async processArguments(args) {
    if (args.length == 1) {
      const index_or_path = args[0];
      const node = this.getReferencedNode(index_or_path);
      if (node) {
        return node.name();
      }
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/padzero.js
var PadzeroExpression = class extends BaseMethod {
  static requiredArguments() {
    return [["string", "number"]];
  }
  async processArguments(args) {
    const pad = args[0] || 2;
    const srcNumber = args[1] || 0;
    const unpadded = `${srcNumber}`;
    return unpadded.padStart(pad, "0");
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/playerMode.js
var PlayerModeExpression = class extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  async processArguments(args) {
    return Poly.playerMode();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/point.js
var EXPECTED_ARGS_COUNT = 3;
var _pointsSrc = [];
var PointExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "attribute name"],
      ["index", "point index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise(async (resolve, reject) => {
      if (args.length == EXPECTED_ARGS_COUNT) {
        const index_or_path = args[0];
        const attrib_name = args[1];
        const point_index = args[2];
        let container = null;
        try {
          container = await this.getReferencedNodeContainer(index_or_path);
        } catch (e) {
          reject(e);
        }
        if (container) {
          const value = this._get_value_from_container(container, attrib_name, point_index);
          resolve(value);
        }
      } else {
        console.warn(`${args.length} given when expected ${EXPECTED_ARGS_COUNT}`);
        resolve(0);
      }
    });
  }
  _get_value_from_container(container, attrib_name, point_index) {
    const coreGroup = container.coreContent();
    if (coreGroup) {
      coreGroup.points(_pointsSrc);
      const point = _pointsSrc[point_index];
      if (point) {
        return point.attribValue(attrib_name);
      } else {
        return 0;
      }
    } else {
      return null;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/pointsCount.js
var PointsCountExpression = class extends BaseMethod {
  // npoints(0)
  // npoints('../REF_bbox')
  static requiredArguments() {
    return [["string", "path to node"]];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length == 1) {
      const indexOrPath = args[0];
      const container = await this.getReferencedNodeContainer(indexOrPath);
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent) {
          return coreContent.pointsCount();
        }
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/smoothstep.js
var SmoothstepExpression = class extends BaseMethod {
  static requiredArguments() {
    return [, ["x", "value"], ["min", "range min"], ["max", "range max"]];
  }
  async processArguments(args) {
    if (args.length == 3) {
      const x = args[0];
      const rangeMin = args[1];
      const rangeMax = args[2];
      return MathUtils.smoothstep(x, rangeMin, rangeMax);
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/smootherstep.js
var SmootherstepExpression = class extends BaseMethod {
  static requiredArguments() {
    return [, ["x", "value"], ["min", "range min"], ["max", "range max"]];
  }
  async processArguments(args) {
    if (args.length == 3) {
      const x = args[0];
      const rangeMin = args[1];
      const rangeMax = args[2];
      return MathUtils.smootherstep(x, rangeMin, rangeMax);
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/solverIteration.js
function isSolverNode(node) {
  return node && node.type() == NetworkNodeType.SOLVER;
}
var SolverIterationExpression = class extends BaseMethod {
  static requiredArguments() {
    return [];
  }
  static optionalArguments() {
    return [["string", "path to solver node"]];
  }
  _solverNode() {
    const solverNode = this.param.node.parentController.findParent(
      (parent) => parent.type() == NetworkNodeType.SOLVER
    );
    return solverNode;
  }
  findDependency(args) {
    const { indexOrPath } = args;
    const node = indexOrPath ? this.findReferencedGraphNode(indexOrPath) : this._solverNode();
    if (isSolverNode(node)) {
      const solverStamp = node.iterationStamp();
      return this.createDependency(solverStamp, { indexOrPath, node });
    }
    return null;
  }
  async processArguments(args) {
    const nodePath = args[0] || "..";
    const foundNode = await this.getReferencedNode(nodePath);
    if (foundNode && isSolverNode(foundNode)) {
      const foundSolverNode = foundNode;
      const value = foundSolverNode.iterationStamp().iteration();
      return value;
    } else {
      return 0;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/strCharsCount.js
var StrCharsCountExpression = class extends BaseMethod {
  // str_chars_count('bla') => 3
  static requiredArguments() {
    return [["string", "string to count characters of"]];
  }
  // findDependency(index_or_path: number | string): null {
  // 	return null
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  async processArguments(args) {
    if (args.length == 1) {
      const string = args[0];
      if (CoreType.isString(string)) {
        return string.length;
      }
    }
    return 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/strConcat.js
var StrConcatExpression = class extends BaseMethod {
  static requiredArguments() {
    return [
      // ['string', 'string to get range from'],
      // ['integer', 'range start'],
      // ['integer', 'range size'],
    ];
  }
  // findDependency(index_or_path: number | string): null {
  // 	return null
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  async processArguments(args) {
    let value = "";
    for (let arg of args) {
      if (arg == null) {
        arg = "";
      }
      value += `${arg}`;
    }
    return value;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/strIndex.js
var StrIndexExpression = class extends BaseMethod {
  // str_chars_count('bla') => 3
  static requiredArguments() {
    return [
      ["string", "string to get index from"],
      ["string", "char to find index of"]
    ];
  }
  // findDependency(index_or_path: number | string): null {
  // 	return null
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  async processArguments(args) {
    if (args.length == 2) {
      const string = args[0];
      const sub_string = args[1];
      return string.indexOf(sub_string);
    }
    return -1;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/strSub.js
function toString(arg) {
  if (arg == null) {
    return "";
  }
  return CoreType.isString(arg) ? arg : `${arg}`;
}
function toInt(arg, defaultVal) {
  if (arg == null) {
    return defaultVal;
  }
  return CoreType.isNumber(arg) ? arg : parseInt(arg);
}
var StrSubExpression = class extends BaseMethod {
  // str_chars_count('bla') => 3
  static requiredArguments() {
    return [
      ["string", "string to get range from"],
      ["integer", "range start"],
      ["integer", "range size"]
    ];
  }
  // findDependency(index_or_path: number | string): MethodDependency | null {
  // 	return null;
  // 	// return this.createDependencyFromIndexOrPath(index_or_path)
  // }
  async processArguments(args) {
    const string = toString(args[0]);
    const rangeStart = toInt(args[1], 0);
    let rangeSize = toInt(args[2], 1);
    if (string) {
      return string.substring(rangeStart, rangeStart + rangeSize);
    }
    return "";
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/viewerSize.js
var ViewerSizeExpression = class extends BaseMethod {
  constructor() {
    super(...arguments);
    this._size = new Vector2();
  }
  static requiredArguments() {
    return [[]];
  }
  findDependency(indexOrPath) {
    this.param.addGraphInput(this.param.scene().viewersRegister.graphNode());
    return null;
  }
  async processArguments(args) {
    var _a;
    (_a = this.param.scene().viewersRegister.lastRenderedViewer()) == null ? void 0 : _a.size(this._size);
    return this._size;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/windowSize.js
var WindowSizeExpression = class extends BaseMethod {
  constructor() {
    super(...arguments);
    this._windowSize = new Vector2();
  }
  static requiredArguments() {
    return [[]];
  }
  findDependency(indexOrPath) {
    this.param.addGraphInput(this.param.scene().windowController.graphNode());
    return null;
  }
  async processArguments(args) {
    this._windowSize.set(window.innerWidth, window.innerHeight);
    return this._windowSize;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/methods/Common.js
var ExpressionType = ((ExpressionType2) => {
  ExpressionType2["animationNames"] = "animationNames";
  ExpressionType2["arg"] = "arg";
  ExpressionType2["argc"] = "argc";
  ExpressionType2["bbox"] = "bbox";
  ExpressionType2["blob"] = "blob";
  ExpressionType2["cameraName"] = "cameraName";
  ExpressionType2["cameraNames"] = "cameraNames";
  ExpressionType2["camerasCount"] = "camerasCount";
  ExpressionType2["centroid"] = "centroid";
  ExpressionType2["ch"] = "ch";
  ExpressionType2["chsop"] = "chsop";
  ExpressionType2["copy"] = "copy";
  ExpressionType2["copRes"] = "copRes";
  ExpressionType2["isDeviceMobile"] = "isDeviceMobile";
  ExpressionType2["isDeviceTouch"] = "isDeviceTouch";
  ExpressionType2["len"] = "len";
  ExpressionType2["join"] = "join";
  ExpressionType2["js"] = "js";
  ExpressionType2["object"] = "object";
  ExpressionType2["objectsCount"] = "objectsCount";
  ExpressionType2["objectName"] = "objectName";
  ExpressionType2["objectNames"] = "objectNames";
  ExpressionType2["opdigits"] = "opdigits";
  ExpressionType2["opname"] = "opname";
  ExpressionType2["padzero"] = "padzero";
  ExpressionType2["playerMode"] = "playerMode";
  ExpressionType2["point"] = "point";
  ExpressionType2["pointsCount"] = "pointsCount";
  ExpressionType2["smoothstep"] = "smoothstep";
  ExpressionType2["smootherstep"] = "smootherstep";
  ExpressionType2["solverIteration"] = "solverIteration";
  ExpressionType2["strCharsCount"] = "strCharsCount";
  ExpressionType2["strConcat"] = "strConcat";
  ExpressionType2["strIndex"] = "strIndex";
  ExpressionType2["strSub"] = "strSub";
  ExpressionType2["viewerSize"] = "viewerSize";
  ExpressionType2["windowSize"] = "windowSize";
  return ExpressionType2;
})(ExpressionType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/expressions/All.js
var AllExpressionsRegister = class {
  static run(poly) {
    poly.expressionsRegister.register(AnimationNamesExpression, ExpressionType.animationNames);
    poly.expressionsRegister.register(ArgExpression, ExpressionType.arg);
    poly.expressionsRegister.register(ArgcExpression, ExpressionType.argc);
    poly.expressionsRegister.register(BboxExpression, ExpressionType.bbox);
    poly.expressionsRegister.register(BlobExpression, ExpressionType.blob);
    poly.expressionsRegister.register(CameraNameExpression, ExpressionType.cameraName);
    poly.expressionsRegister.register(CameraNamesExpression, ExpressionType.cameraNames);
    poly.expressionsRegister.register(CamerasCountExpression, ExpressionType.camerasCount);
    poly.expressionsRegister.register(CentroidExpression, ExpressionType.centroid);
    poly.expressionsRegister.register(ChExpression, ExpressionType.ch);
    poly.expressionsRegister.register(ChsopExpression, ExpressionType.chsop);
    poly.expressionsRegister.register(CopyExpression, ExpressionType.copy);
    poly.expressionsRegister.register(CopResExpression, ExpressionType.copRes);
    poly.expressionsRegister.register(isDeviceMobileExpression, ExpressionType.isDeviceMobile);
    poly.expressionsRegister.register(isDeviceTouchExpression, ExpressionType.isDeviceTouch);
    poly.expressionsRegister.register(LenExpression, ExpressionType.len);
    poly.expressionsRegister.register(JoinExpression, ExpressionType.join);
    poly.expressionsRegister.register(JsExpression, ExpressionType.js);
    poly.expressionsRegister.register(ObjectExpression, ExpressionType.object);
    poly.expressionsRegister.register(ObjectsCountExpression, ExpressionType.objectsCount);
    poly.expressionsRegister.register(ObjectNameExpression, ExpressionType.objectName);
    poly.expressionsRegister.register(ObjectNamesExpression, ExpressionType.objectNames);
    poly.expressionsRegister.register(OpdigitsExpression, ExpressionType.opdigits);
    poly.expressionsRegister.register(OpnameExpression, ExpressionType.opname);
    poly.expressionsRegister.register(PadzeroExpression, ExpressionType.padzero);
    poly.expressionsRegister.register(PlayerModeExpression, ExpressionType.playerMode);
    poly.expressionsRegister.register(PointExpression, ExpressionType.point);
    poly.expressionsRegister.register(PointsCountExpression, ExpressionType.pointsCount);
    poly.expressionsRegister.register(SmoothstepExpression, ExpressionType.smoothstep);
    poly.expressionsRegister.register(SmootherstepExpression, ExpressionType.smootherstep);
    poly.expressionsRegister.register(SolverIterationExpression, ExpressionType.solverIteration);
    poly.expressionsRegister.register(StrCharsCountExpression, ExpressionType.strCharsCount);
    poly.expressionsRegister.register(StrConcatExpression, ExpressionType.strConcat);
    poly.expressionsRegister.register(StrIndexExpression, ExpressionType.strIndex);
    poly.expressionsRegister.register(StrSubExpression, ExpressionType.strSub);
    poly.expressionsRegister.register(ViewerSizeExpression, ExpressionType.viewerSize);
    poly.expressionsRegister.register(WindowSizeExpression, ExpressionType.windowSize);
  }
};
export {
  AllExpressionsRegister
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_poly_registers_expressions_All.js.map
