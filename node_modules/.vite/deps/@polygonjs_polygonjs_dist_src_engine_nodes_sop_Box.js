import {
  TypedSopNode
} from "./chunk-XJZFUBTR.js";
import {
  SopType
} from "./chunk-OBFUH3H6.js";
import {
  BaseSopOperation,
  CoreTransform,
  InputCloneMode,
  NodeParamsConfig,
  ObjectType,
  ParamConfig
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import "./chunk-O564GFGZ.js";
import {
  Box3,
  BoxGeometry,
  Vector3
} from "./chunk-6OBTIB4K.js";
import "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/Box.js
var tmpBox = new Box3();
var tmpSize = new Vector3();
var tmpCenter = new Vector3();
function _roundDivision(division) {
  return Math.max(1, Math.floor(division));
}
var BoxSopOperation = class extends BaseSopOperation {
  constructor() {
    super(...arguments);
    this._coreTransform = new CoreTransform();
  }
  static type() {
    return "box";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const geometry = inputCoreGroup ? this._cookWithInput(inputCoreGroup, params) : this._cookWithoutInput(params);
    const object = BaseSopOperation.createObject(geometry, ObjectType.MESH);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    const { divisions, size, sizes } = params;
    const geometry = new BoxGeometry(
      size * sizes.x,
      size * sizes.y,
      size * sizes.z,
      _roundDivision(divisions.x),
      _roundDivision(divisions.y),
      _roundDivision(divisions.z)
    );
    geometry.translate(params.center.x, params.center.y, params.center.z);
    geometry.computeVertexNormals();
    return geometry;
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const divisions = params.divisions;
    const geometry = new BoxGeometry(
      tmpSize.x,
      tmpSize.y,
      tmpSize.z,
      _roundDivision(divisions.x),
      _roundDivision(divisions.y),
      _roundDivision(divisions.z)
    );
    const matrix = this._coreTransform.translationMatrix(tmpCenter);
    geometry.applyMatrix4(matrix);
    return geometry;
  }
};
BoxSopOperation.DEFAULT_PARAMS = {
  sizes: new Vector3(1, 1, 1),
  size: 1,
  divisions: new Vector3(1, 1, 1),
  center: new Vector3(0, 0, 0)
};
BoxSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/Box.js
var DEFAULT = BoxSopOperation.DEFAULT_PARAMS;
var BoxSopParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.size = ParamConfig.FLOAT(DEFAULT.size, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    this.sizes = ParamConfig.VECTOR3(DEFAULT.sizes);
    this.divisions = ParamConfig.VECTOR3(DEFAULT.divisions);
    this.center = ParamConfig.VECTOR3(DEFAULT.center);
  }
};
var ParamsConfig = new BoxSopParamsConfig();
var BoxSopNode = class extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.BOX;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(BoxSopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new BoxSopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
};
export {
  BoxSopNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_sop_Box.js.map
