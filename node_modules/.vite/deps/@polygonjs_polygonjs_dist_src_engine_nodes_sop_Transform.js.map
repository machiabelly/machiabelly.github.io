{
  "version": 3,
  "sources": ["../../@polygonjs/polygonjs/dist/src/engine/operations/sop/Transform.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/sop/Transform.js"],
  "sourcesContent": ["\"use strict\";\nimport { BaseSopOperation } from \"./_Base\";\nimport { TypeAssert } from \"../../../engine/poly/Assert\";\nimport {\n  CoreTransform,\n  ROTATION_ORDERS,\n  RotationOrder,\n  TransformTargetType,\n  TRANSFORM_TARGET_TYPES\n} from \"../../../core/Transform\";\nimport { InputCloneMode } from \"../../../engine/poly/InputCloneMode\";\nimport { coreObjectClassFactory } from \"../../../core/geometry/CoreObjectFactory\";\nimport { MathUtils, Vector3, Matrix4, Euler, Quaternion } from \"three\";\nimport {\n  OBJECT_TRANSFORM_SPACES,\n  OBJECT_TRANSFORM_MODES,\n  ObjectTransformMode,\n  ObjectTransformSpace,\n  applyTransformWithSpaceToObject\n} from \"../../../core/TransformSpace\";\nimport { isObject3D } from \"../../../core/geometry/ObjectContent\";\nimport { CoreMask } from \"../../../core/geometry/Mask\";\nimport { SopType } from \"../../poly/registers/nodes/types/Sop\";\nimport { pointsFromObjectFromGroup } from \"../../../core/geometry/entities/point/CorePointUtils\";\nconst _r = new Vector3();\nconst _euler = new Euler();\nconst _q = new Quaternion();\nconst _s = new Vector3();\nconst _mat4 = new Matrix4();\nconst _pointPos = new Vector3();\nconst _points = [];\nexport class TransformSopOperation extends BaseSopOperation {\n  constructor() {\n    super(...arguments);\n    this._coreTransform = new CoreTransform();\n  }\n  static type() {\n    return SopType.TRANSFORM;\n  }\n  cook(inputCoreGroups, params) {\n    const coreGroup = inputCoreGroups[0];\n    const selectedObjects = CoreMask.filterObjects(coreGroup, params);\n    for (const inputObject of selectedObjects) {\n      this._applyTransform(inputObject, coreGroup, params);\n    }\n    coreGroup.resetBoundingBox();\n    return coreGroup;\n  }\n  _applyTransform(object, coreGroup, params) {\n    if (isObject3D(object)) {\n      this._applyTransformWithTransformTargetType(object, coreGroup, params);\n    } else {\n      this._applyTransformWithoutTransformTargetType(object, params);\n    }\n  }\n  _applyTransformWithoutTransformTargetType(object, params) {\n    this._updateObject(object, params);\n  }\n  _applyTransformWithTransformTargetType(object, coreGroup, params) {\n    const mode = TRANSFORM_TARGET_TYPES[params.applyOn];\n    switch (mode) {\n      case TransformTargetType.GEOMETRY: {\n        return this._updateGeometry(object, params);\n      }\n      case TransformTargetType.OBJECT: {\n        return this._updateObject(object, params);\n      }\n    }\n    TypeAssert.unreachable(mode);\n  }\n  // private _applyCadTransform(objects: CadCoreObject<CadGeometryType>[]|undefined, params: TransformSopParams) {\n  // \tif(!objects){\n  // \t\treturn\n  // \t}\n  // \tfor(let object of objects){\n  // \t\tcadTransform(object, params.t, params.r, params.scale)\n  // \t}\n  // }\n  _updateGeometry(object, params) {\n    const matrix = this._matrix(params);\n    const pointGroup = params.pointGroup;\n    if (pointGroup.trim() === \"\") {\n      const geometry = object.geometry;\n      if (geometry) {\n        geometry.translate(-params.pivot.x, -params.pivot.y, -params.pivot.z);\n        geometry.applyMatrix4(matrix);\n        geometry.translate(params.pivot.x, params.pivot.y, params.pivot.z);\n      }\n    } else {\n      pointsFromObjectFromGroup(object, pointGroup, _points);\n      for (const point of _points) {\n        const position = point.position(_pointPos).sub(params.pivot);\n        position.applyMatrix4(matrix);\n        point.setPosition(position.add(params.pivot));\n      }\n    }\n  }\n  _updateObject(object, params) {\n    const objectMode = OBJECT_TRANSFORM_MODES[params.objectMode];\n    switch (objectMode) {\n      case ObjectTransformMode.SET: {\n        return this._setMatrix(object, params);\n      }\n      case ObjectTransformMode.MULT: {\n        return this._multMatrix(object, params);\n      }\n    }\n    TypeAssert.unreachable(objectMode);\n  }\n  _setMatrix(object, params) {\n    const order = ROTATION_ORDERS[params.rotationOrder];\n    _r.copy(params.r).multiplyScalar(MathUtils.DEG2RAD);\n    _euler.set(_r.x, _r.y, _r.z, order);\n    _q.setFromEuler(_euler);\n    _s.copy(params.s).multiplyScalar(params.scale);\n    _mat4.compose(params.t, _q, _s);\n    coreObjectClassFactory(object).applyMatrix(\n      object,\n      _mat4,\n      TRANSFORM_TARGET_TYPES[params.applyOn],\n      ObjectTransformSpace.LOCAL,\n      ObjectTransformMode.SET\n    );\n  }\n  // private _objectPosition = new Vector3();\n  _multMatrix(object, params) {\n    const matrix = this._matrix(params);\n    const transformSpace = OBJECT_TRANSFORM_SPACES[params.objectTransformSpace];\n    applyTransformWithSpaceToObject(object, matrix, transformSpace, ObjectTransformMode.MULT);\n  }\n  _matrix(params) {\n    return this._coreTransform.matrix(\n      params.t,\n      params.r,\n      params.s,\n      params.scale,\n      ROTATION_ORDERS[params.rotationOrder]\n    );\n  }\n}\nTransformSopOperation.DEFAULT_PARAMS = {\n  applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY),\n  group: \"\",\n  objectMode: OBJECT_TRANSFORM_MODES.indexOf(ObjectTransformMode.SET),\n  objectTransformSpace: OBJECT_TRANSFORM_SPACES.indexOf(ObjectTransformSpace.PARENT),\n  pointGroup: \"\",\n  rotationOrder: ROTATION_ORDERS.indexOf(RotationOrder.XYZ),\n  t: new Vector3(0, 0, 0),\n  r: new Vector3(0, 0, 0),\n  s: new Vector3(1, 1, 1),\n  scale: 1,\n  pivot: new Vector3(0, 0, 0)\n};\nTransformSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n", "\"use strict\";\nimport { TypedSopNode } from \"./_Base\";\nimport { ROTATION_ORDERS, TransformTargetType, TRANSFORM_TARGET_TYPES } from \"../../../core/Transform\";\nimport { TransformSopOperation } from \"../../operations/sop/Transform\";\nimport { NodeParamsConfig, ParamConfig } from \"../utils/params/ParamsConfig\";\nimport { SopType } from \"../../poly/registers/nodes/types/Sop\";\nimport {\n  OBJECT_TRANSFORM_MODES,\n  OBJECT_TRANSFORM_SPACE_MENU_ENTRIES,\n  ObjectTransformMode\n} from \"../../../core/TransformSpace\";\nconst DEFAULT = TransformSopOperation.DEFAULT_PARAMS;\nclass TransformSopParamConfig extends NodeParamsConfig {\n  constructor() {\n    super(...arguments);\n    /** @param sets if this node should transform objects or geometries */\n    this.applyOn = ParamConfig.INTEGER(DEFAULT.applyOn, {\n      menu: {\n        entries: TRANSFORM_TARGET_TYPES.map((name, value) => ({ name, value }))\n      }\n    });\n    /** @param group to assign the material to */\n    this.group = ParamConfig.STRING(DEFAULT.group, {\n      objectMask: true\n    });\n    /** @param if applyOn is set to object, the transform can then be applied in 2 different ways on those objects. Either the .position, .rotation and .scale attributes are set, or the matrix is set directly. */\n    this.objectMode = ParamConfig.INTEGER(DEFAULT.objectMode, {\n      visibleIf: { applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT) },\n      menu: {\n        entries: OBJECT_TRANSFORM_MODES.map((name, value) => {\n          return { name, value };\n        })\n      }\n    });\n    /** @param defines how the objects are transformed */\n    this.objectTransformSpace = ParamConfig.INTEGER(0, {\n      visibleIf: {\n        applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT),\n        objectMode: OBJECT_TRANSFORM_MODES.indexOf(ObjectTransformMode.MULT)\n      },\n      menu: {\n        entries: OBJECT_TRANSFORM_SPACE_MENU_ENTRIES\n      }\n    });\n    /** @param group to assign the material to */\n    this.pointGroup = ParamConfig.STRING(DEFAULT.pointGroup, {\n      visibleIf: { applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY) }\n    });\n    // transform\n    /** @param rotation order */\n    this.rotationOrder = ParamConfig.INTEGER(DEFAULT.rotationOrder, {\n      separatorBefore: true,\n      menu: {\n        entries: ROTATION_ORDERS.map((order, v) => {\n          return { name: order, value: v };\n        })\n      }\n    });\n    /** @param translate */\n    this.t = ParamConfig.VECTOR3(DEFAULT.t);\n    /** @param rotation */\n    this.r = ParamConfig.VECTOR3(DEFAULT.r);\n    /** @param scale */\n    this.s = ParamConfig.VECTOR3(DEFAULT.s);\n    /** @param scale (as a float) */\n    this.scale = ParamConfig.FLOAT(DEFAULT.scale, {\n      range: [0, 2],\n      step: 0.01\n    });\n    // look_at = ParamConfig.OPERATOR_PATH('');\n    // up = ParamConfig.VECTOR3([0, 1, 0]);\n    /** @param pivot */\n    this.pivot = ParamConfig.VECTOR3(DEFAULT.pivot, {\n      visibleIf: { applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY) }\n    });\n  }\n}\nconst ParamsConfig = new TransformSopParamConfig();\nexport class TransformSopNode extends TypedSopNode {\n  constructor() {\n    super(...arguments);\n    this.paramsConfig = ParamsConfig;\n  }\n  static type() {\n    return SopType.TRANSFORM;\n  }\n  initializeNode() {\n    this.io.inputs.setCount(1);\n    this.io.inputs.initInputsClonedState(TransformSopOperation.INPUT_CLONED_STATE);\n  }\n  setApplyOn(type) {\n    this.p.applyOn.set(TRANSFORM_TARGET_TYPES.indexOf(type));\n  }\n  applyOn() {\n    return TRANSFORM_TARGET_TYPES[this.pv.applyOn];\n  }\n  setObjectMode(mode) {\n    this.p.objectMode.set(OBJECT_TRANSFORM_MODES.indexOf(mode));\n  }\n  cook(inputCoreGroups) {\n    this._operation = this._operation || new TransformSopOperation(this.scene(), this.states, this);\n    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);\n    this.setCoreGroup(coreGroup);\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
