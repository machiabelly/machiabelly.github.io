import {
  CoreMask
} from "./chunk-W3H7NWH6.js";
import {
  TypedSopNode
} from "./chunk-XJZFUBTR.js";
import {
  SopType
} from "./chunk-OBFUH3H6.js";
import "./chunk-VPW6KKKV.js";
import {
  ThreeToGl
} from "./chunk-BKKMVJB3.js";
import "./chunk-EGRHWZRV.js";
import {
  BaseSopOperation,
  GlConnectionPointType,
  InputCloneMode,
  NodeParamsConfig,
  ParamConfig,
  TypedNode,
  applyCustomMaterials,
  applyRenderHook,
  cloneMaterial
} from "./chunk-FUAFRKQ7.js";
import {
  TypedNodePathParamValue
} from "./chunk-RVFV2LA3.js";
import {
  MapUtils
} from "./chunk-O564GFGZ.js";
import {
  ShaderMaterial,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import {
  NodeContext
} from "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/globals/_Base.js
var GlobalsBaseController = class {
  handleGlobalsNode(globalsNode, outputName, shadersCollectionController) {
  }
  handleGlobalVar(globalsNode, outputName, glType, shadersCollectionController) {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Gl.js
var GlType = ((GlType2) => {
  GlType2["ADJACENT_POINTS_ATTRIB_SMOOTH"] = "adjacentPointsAttribSmooth";
  GlType2["ADJACENT_UV_ATTRIB_SMOOTH"] = "adjacentUvAttribSmooth";
  GlType2["ATTRIBUTE"] = "attribute";
  GlType2["COMPUTE_NORMALS"] = "computeNormals";
  GlType2["CONSTANT"] = "constant";
  GlType2["FOR_LOOP"] = "forLoop";
  GlType2["IF_THEN"] = "ifThen";
  GlType2["GLOBALS"] = "globals";
  GlType2["NOISE"] = "noise";
  GlType2["OUTPUT"] = "output";
  GlType2["PARAM"] = "param";
  GlType2["RAMP"] = "ramp";
  GlType2["SDF_2D_BOX"] = "SDF2DBox";
  GlType2["SDF_2D_CIRCLE"] = "SDF2DCircle";
  GlType2["SDF_2D_CROSS"] = "SDF2DCross";
  GlType2["SDF_2D_HEART"] = "SDF2DHeart";
  GlType2["SDF_2D_ROUNDED_X"] = "SDF2DRoundedX";
  GlType2["SDF_2D_STAIRS"] = "SDF2DStairs";
  GlType2["SDF_BOX"] = "SDFBox";
  GlType2["SDF_BOX_FRAME"] = "SDFBoxFrame";
  GlType2["SDF_BOX_ROUND"] = "SDFBoxRound";
  GlType2["SDF_CAPSULE"] = "SDFCapsule";
  GlType2["SDF_CAPSULE_VERTICAL"] = "SDFCapsuleVertical";
  GlType2["SDF_CONE"] = "SDFCone";
  GlType2["SDF_CONE_ROUND"] = "SDFConeRound";
  GlType2["SDF_ELONGATE"] = "SDFElongate";
  GlType2["SDF_FRACTAL_MANDELBROT"] = "SDFFractalMandelbrot";
  GlType2["SDF_GRADIENT"] = "SDFGradient";
  GlType2["SDF_HEXAGONAL_PRISM"] = "SDFHexagonalPrism";
  GlType2["SDF_HORSE_SHOE"] = "SDFHorseShoe";
  GlType2["SDF_LINK"] = "SDFLink";
  GlType2["SDF_OCTAHEDRON"] = "SDFOctahedron";
  GlType2["SDF_OCTOGONAL_PRISM"] = "SDFOctogonalPrism";
  GlType2["SDF_ONION"] = "SDFOnion";
  GlType2["SDF_PLANE"] = "SDFPlane";
  GlType2["SDF_PYRAMID"] = "SDFPyramid";
  GlType2["SDF_QUAD"] = "SDFQuad";
  GlType2["SDF_REPEAT_POLAR"] = "SDFRepeatPolar";
  GlType2["SDF_REVOLUTION"] = "SDFRevolution";
  GlType2["SDF_RHOMBUS"] = "SDFRhombus";
  GlType2["SDF_RHOMBUS_TRIACONTAHEDRON"] = "SDFRhombusTriacontahedron";
  GlType2["SDF_SOLID_ANGLE"] = "SDFSolidAngle";
  GlType2["SDF_SPHERE"] = "SDFSphere";
  GlType2["SDF_SPHERE_CUT"] = "SDFSphereCut";
  GlType2["SDF_SPHERE_HOLLOW"] = "SDFSphereHollow";
  GlType2["SDF_TORUS"] = "SDFTorus";
  GlType2["SDF_TRANSFORM"] = "SDFTransform";
  GlType2["SDF_TRIANGULAR_PRISM"] = "SDFTriangularPrism";
  GlType2["SDF_TRIANGLE"] = "SDFTriangle";
  GlType2["SDF_TUBE"] = "SDFTube";
  GlType2["SDF_TWIST"] = "SDFTwist";
  GlType2["SDF_CONTEXT"] = "SDFContext";
  GlType2["SDF_MATERIAL"] = "SDFMaterial";
  GlType2["TEXTURE"] = "texture";
  GlType2["TEXTURE_DISPLACEMENT"] = "textureDisplacement";
  GlType2["TEXTURE_SDF"] = "textureSDF";
  GlType2["VARYING_READ"] = "varyingRead";
  GlType2["VARYING_WRITE"] = "varyingWrite";
  GlType2["VERTEX_ANIMATION_TEXTURE"] = "vertexAnimationTexture";
  GlType2["VERTEX_ANIMATION_TEXTURE_INTERPOLATED"] = "vertexAnimationTextureInterpolated";
  return GlType2;
})(GlType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/ParamsEditableStateController.js
var ParamsEditableStateController = class {
  constructor(node) {
    this.node = node;
    this._initialized = false;
    this._checkParamsEditableStateBound = this._checkParamsEditableState.bind(this);
  }
  initializeNode() {
    if (this._initialized) {
      console.warn("already initialized", this.node);
      return;
    }
    this._initialized = true;
    this.node.io.inputs.add_on_set_input_hook(
      "_checkParamsEditableStateBound",
      this._checkParamsEditableStateBound
    );
  }
  initialized() {
    return this._initialized;
  }
  _checkParamsEditableState() {
    if (!this._paramsMatchEditableState()) {
      this.updateParamsEditableStateIfNeeded();
    }
  }
  _paramsMatchEditableState() {
    let i = 0;
    const params = this.node.params;
    const connectionPoints = this.node.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return false;
    }
    for (const connectionPoint of connectionPoints) {
      if (connectionPoint) {
        const isConnected = this.node.io.inputs.input(i) != null;
        const paramName = connectionPoint == null ? void 0 : connectionPoint.name();
        const hasParam = params.has(paramName);
        if (hasParam) {
          const param = params.get(paramName);
          if (param) {
            const expectedEditableState = !isConnected;
            const currentEditableState = param.options.editable();
            if (expectedEditableState != currentEditableState) {
              return false;
            }
          }
        }
      }
      i++;
    }
    return true;
  }
  updateParamsEditableStateIfNeeded() {
    let i = 0;
    const params = this.node.params;
    const connectionPoints = this.node.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    for (const connectionPoint of connectionPoints) {
      if (connectionPoint) {
        const isConnected = this.node.io.inputs.input(i) != null;
        const paramName = connectionPoint == null ? void 0 : connectionPoint.name();
        if (params.has(paramName)) {
          const param = params.get(paramName);
          if (param) {
            const requiredState = !isConnected;
            param.options.setEditableState(requiredState);
          }
        }
      }
      i++;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/_Base.js
var GL_VAR_NAME_PREFIX = "v_POLY";
var TypedGlNode = class extends TypedNode {
  constructor() {
    super(...arguments);
    this._paramsEditableStatesController = new ParamsEditableStateController(this);
  }
  static context() {
    return NodeContext.GL;
  }
  initializeBaseNode() {
    this.uiData.setLayoutHorizontal();
    this.io.connections.initInputs();
    this.io.connection_points.spare_params.initializeNode();
    this._paramsEditableStatesController.initializeNode();
  }
  cook() {
    console.warn("gl node cooking");
  }
  _setMatToRecompile() {
    var _a, _b;
    (_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.setCompilationRequiredAndDirty(this);
  }
  materialNode() {
    const parent = this.parent();
    if (parent) {
      if (parent.context() == NodeContext.GL) {
        return parent == null ? void 0 : parent.materialNode();
      } else {
        return parent;
      }
    }
  }
  //
  //
  // VARIABLES
  //
  //
  glVarName(varName) {
    const nodes = [this];
    let currentNode = this;
    while (currentNode.parent() && currentNode.parent() != this.materialNode()) {
      const parent = currentNode.parent();
      if (parent) {
        nodes.unshift(parent);
        currentNode = parent;
      }
    }
    const baseGlVarNames = nodes.map((node) => node._glVarNameBase());
    return `${GL_VAR_NAME_PREFIX}_${baseGlVarNames.join("_")}_${varName}`;
  }
  _glVarNameBase() {
    return this.name();
  }
  variableForInputParam(param) {
    return this.variableForInput(param.name());
  }
  variableForInput(inputName) {
    var _a;
    const input_index = this.io.inputs.getInputIndex(inputName);
    const connection = this.io.connections.inputConnection(input_index);
    if (connection) {
      const input_node = connection.nodeSrc();
      const outputConnectionPoints = input_node.io.outputs.namedOutputConnectionPoints();
      if (outputConnectionPoints) {
        const output_connection_point = outputConnectionPoints[connection.outputIndex()];
        if (output_connection_point) {
          const output_name = output_connection_point.name();
          return input_node.glVarName(output_name);
        } else {
          console.warn(`no output called '${inputName}' for gl node ${input_node.path()}`);
          throw "variable_for_input ERROR";
        }
      }
    } else {
      if (this.params.has(inputName)) {
        return ThreeToGl.any((_a = this.params.get(inputName)) == null ? void 0 : _a.value);
      } else {
        const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
        if (inputConnectionPoints) {
          const connection_point = inputConnectionPoints[input_index];
          return ThreeToGl.any(connection_point.init_value);
        }
      }
    }
    throw "variable_for_input ERROR";
  }
  //
  //
  // ADDED LINES
  //
  //
  setLines(shaders_collection_controller) {
  }
  reset_code() {
    var _a;
    (_a = this._param_configs_controller) == null ? void 0 : _a.reset();
  }
  //
  //
  // PARAM CONFIGS
  //
  //
  setParamConfigs() {
  }
  param_configs() {
    var _a;
    return (_a = this._param_configs_controller) == null ? void 0 : _a.list();
  }
  paramsGenerating() {
    return false;
  }
  //
  //
  // INPUT
  //
  //
  paramDefaultValue(name) {
    return null;
  }
};
var ParamlessGlParamsConfig = class extends NodeParamsConfig {
};
var ParamsConfig = new ParamlessGlParamsConfig();

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/Attribute.js
var ATTRIBUTE_NODE_AVAILABLE_GL_TYPES = [
  GlConnectionPointType.FLOAT,
  GlConnectionPointType.VEC2,
  GlConnectionPointType.VEC3,
  GlConnectionPointType.VEC4
];
var AttributeGlParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.name = ParamConfig.STRING("attribute1");
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    this.texportWhenConnected = ParamConfig.BOOLEAN(0, { hidden: true });
    this.exportWhenConnected = ParamConfig.BOOLEAN(0, { visibleIf: { texportWhenConnected: 1 } });
  }
};
var ParamsConfig2 = new AttributeGlParamsConfig();
var _AttributeGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig2;
    this._bound_setExportWhenConnectedStatus = this._setExportWhenConnectedStatus.bind(this);
  }
  static type() {
    return GlType.ATTRIBUTE;
  }
  // private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompileIfIsExporting.bind(this));
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(() => {
      var _a, _b;
      if ((_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.allow_attribute_exports()) {
        return [ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]];
      } else {
        return [];
      }
    });
    this.io.connection_points.set_input_name_function((index) => {
      return _AttributeGlNode.INPUT_NAME;
    });
    this.io.connection_points.set_expected_output_types_function(() => [
      ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]
    ]);
    this.lifecycle.onAfterAdded(this._bound_setExportWhenConnectedStatus);
    this.params.addOnSceneLoadHook("prepare params", this._bound_setExportWhenConnectedStatus);
  }
  _setExportWhenConnectedStatus() {
    var _a, _b;
    if ((_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.allow_attribute_exports()) {
      this.p.texportWhenConnected.set(1);
    }
  }
  setAttribSize(size) {
    this.p.type.set(size - 1);
  }
  // createParams() {}
  // inputless_params_names(): string[] {
  // 	return ['type'];
  // }
  inputName() {
    return _AttributeGlNode.INPUT_NAME;
  }
  outputName() {
    return _AttributeGlNode.OUTPUT_NAME;
  }
  // TODO:
  // ideally glVarName should know which shader it is being called in.
  // so that if it is in a vertex shader, it can return the name of the attribute directly.
  // and if it is in a fragment, it would behave as usual.
  // override glVarName() {
  // 	// if (name) {
  // 	// 	return super.glVarName(name);
  // 	// }
  // 	// return this.varyingName();
  // }
  varyingName() {
    return `v_POLY_attribute_${this.pv.name}`;
  }
  // private create_inputs_from_params() {
  // 	if (this.materialNode().allow_attribute_exports) {
  // 		// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);
  // 		this.io.inputs.setNamedInputConnectionPoints([
  // 			new TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),
  // 		]);
  // 		// this._init_graph_node_inputs();
  // 	}
  // }
  setLines(shadersCollectionController) {
    const assembler = shadersCollectionController.assembler();
    assembler.setNodeLinesAttribute(this, shadersCollectionController);
  }
  // update_output_type(constructor) {
  // 	const named_output = new constructor(Attribute.output_name());
  // 	this.set_named_outputs([named_output]);
  // }
  // update_input_type(constructor) {
  // 	const named_input = new constructor(Attribute.input_name());
  // 	this.set_named_inputs([named_input]);
  // 	this._init_graph_node_inputs();
  // }
  attributeName() {
    return this.pv.name.trim();
  }
  glType() {
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!outputConnectionPoints) {
      return GlConnectionPointType.FLOAT;
    }
    return outputConnectionPoints[0].type();
  }
  setGlType(type) {
    this.p.type.set(ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.indexOf(type));
  }
  //
  //
  // Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles
  //
  //
  connected_input_node() {
    return this.io.inputs.named_input(_AttributeGlNode.INPUT_NAME);
  }
  connected_input_connection_point() {
    return this.io.inputs.named_input_connection_point(_AttributeGlNode.INPUT_NAME);
  }
  // connected_input(): NamedConnection {
  // 	const connection_point = this.connected_input_connection_point();
  // 	if (connection_point) {
  // 		return this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];
  // 	}
  // }
  output_connection_point() {
    return this.io.outputs.namedOutputConnectionPointsByName(this.outputName());
  }
  // connected_output(): NamedConnection {
  // 	const output = this.named_output(0);
  // 	if (output) {
  // 		return output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]
  // 	}
  // }
  isImporting() {
    return this.io.outputs.used_output_names().length > 0;
  }
  isExporting() {
    if (isBooleanTrue(this.pv.exportWhenConnected)) {
      const input_node = this.io.inputs.named_input(_AttributeGlNode.INPUT_NAME);
      return input_node != null;
    } else {
      return false;
    }
  }
  _setMatToRecompileIfIsExporting() {
    if (isBooleanTrue(this.pv.exportWhenConnected)) {
      this._setMatToRecompile();
    }
  }
  //
  //
  // SIGNATURE
  //
  //
  // private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {
  // 	if (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {
  // 		this.update_input_and_output_types();
  // 		this.removeDirtyState();
  // 		this.make_output_nodes_dirty();
  // 	}
  // 	this.materialNode()?.assembler_controller.set_compilation_required_and_dirty(this);
  // }
  // private update_input_and_output_types() {
  // 	const set_dirty = false;
  // 	this.io.outputs.setNamedOutputConnectionPoints(
  // 		[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],
  // 		set_dirty
  // 	);
  // 	if (this.materialNode()?.assembler_controller.allow_attribute_exports()) {
  // 		this.io.inputs.setNamedInputConnectionPoints([
  // 			new TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),
  // 		]);
  // 	}
  // }
};
var AttributeGlNode = _AttributeGlNode;
AttributeGlNode.INPUT_NAME = "in";
AttributeGlNode.OUTPUT_NAME = "val";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/utils/GLDefinitionCollection.js
var TypedGLDefinitionCollection = class {
  constructor(_definitions = []) {
    this._definitions = _definitions;
    this._errored = false;
  }
  get errored() {
    return this._errored;
  }
  get error_message() {
    return this._error_message;
  }
  uniq() {
    const definitions_by_name = /* @__PURE__ */ new Map();
    const names = [];
    for (const definition of this._definitions) {
      if (!this._errored) {
        const name = definition.name();
        const existing = definitions_by_name.get(name);
        if (existing) {
          if (existing.data_type != definition.data_type) {
            this._errored = true;
            this._error_message = `attempt to create '${definition.name()}' with types '${definition.data_type}' by node '${definition.node.path()}', when there is already an existing with type ${existing.data_type} from node '${existing.node.path()}'`;
            console.warn("emitting error message:", this._error_message);
          }
        } else {
          definitions_by_name.set(name, definition);
          names.push(name);
        }
      }
    }
    const uniq_definitions = [];
    for (const name of names) {
      const definition = definitions_by_name.get(name);
      if (definition) {
        uniq_definitions.push(definition);
      }
    }
    return uniq_definitions;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/utils/GLDefinition.js
var GLDefinitionType = ((GLDefinitionType2) => {
  GLDefinitionType2["ATTRIBUTE"] = "attribute";
  GLDefinitionType2["FUNCTION"] = "function";
  GLDefinitionType2["PRECISION"] = "precision";
  GLDefinitionType2["UNIFORM"] = "uniform";
  GLDefinitionType2["VARYING"] = "varying";
  return GLDefinitionType2;
})(GLDefinitionType || {});
var TypedGLDefinition = class {
  // constructor(protected _node: BaseGlNodeType, protected _name: string) {}
  constructor(_definition_type, _data_type, _node, _name) {
    this._definition_type = _definition_type;
    this._data_type = _data_type;
    this._node = _node;
    this._name = _name;
  }
  get definition_type() {
    return this._definition_type;
  }
  get data_type() {
    return this._data_type;
  }
  get node() {
    return this._node;
  }
  name() {
    return this._name;
  }
  collection_instance() {
    return new TypedGLDefinitionCollection();
  }
};
var AttributeGLDefinition = class extends TypedGLDefinition {
  constructor(_node, _data_type, _name) {
    super("attribute", _data_type, _node, _name);
    this._node = _node;
    this._data_type = _data_type;
    this._name = _name;
  }
  get line() {
    return `attribute ${this.data_type} ${this.name()}`;
  }
};
var VaryingGLDefinition = class extends TypedGLDefinition {
  constructor(_node, _data_type, _name) {
    super("varying", _data_type, _node, _name);
    this._node = _node;
    this._data_type = _data_type;
    this._name = _name;
  }
  get line() {
    return `varying ${this.data_type} ${this.name()}`;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/shaders/ShaderName.js
var ShaderName = ((ShaderName2) => {
  ShaderName2["VERTEX"] = "vertex";
  ShaderName2["FRAGMENT"] = "fragment";
  ShaderName2["LEAVES_FROM_NODES_SHADER"] = "leaves_from_nodes_shader";
  return ShaderName2;
})(ShaderName || {});
var JsFunctionName = ((JsFunctionName2) => {
  JsFunctionName2["MAIN"] = "main";
  JsFunctionName2["VELOCITY"] = "velocity";
  JsFunctionName2["COLLIDER"] = "collider";
  return JsFunctionName2;
})(JsFunctionName || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/assemblers/materials/common/GlobalOutput.js
var GlobalsOutput = ((GlobalsOutput2) => {
  GlobalsOutput2["TIME"] = "time";
  GlobalsOutput2["RESOLUTION"] = "resolution";
  GlobalsOutput2["MV_POSITION"] = "mvPosition";
  GlobalsOutput2["GL_POSITION"] = "gl_Position";
  GlobalsOutput2["GL_FRAGCOORD"] = "gl_FragCoord";
  GlobalsOutput2["GL_POINTCOORD"] = "gl_PointCoord";
  GlobalsOutput2["GL_POINTSIZE"] = "gl_PointSize";
  GlobalsOutput2["WORLD_POSITION"] = "worldPosition";
  GlobalsOutput2["WORLD_NORMAL"] = "worldNormal";
  GlobalsOutput2["MODEL_MATRIX"] = "modelMatrix";
  GlobalsOutput2["MODEL_VIEW_MATRIX"] = "modelViewMatrix";
  GlobalsOutput2["NORMAL_MATRIX"] = "normalMatrix";
  return GlobalsOutput2;
})(GlobalsOutput || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/globals/Common.js
var GlobalsBaseControllerType = ((GlobalsBaseControllerType2) => {
  GlobalsBaseControllerType2["GEOMETRY"] = "geometry";
  GlobalsBaseControllerType2["TEXTURE"] = "texture";
  return GlobalsBaseControllerType2;
})(GlobalsBaseControllerType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/globals/Geometry.js
var VARIABLE_CONFIG_DEFAULT_BY_NAME = {
  position: "vec3( position )"
};
var _GlobalsGeometryHandler = class extends GlobalsBaseController {
  type() {
    return GlobalsBaseControllerType.GEOMETRY;
  }
  handleGlobalsNode(globals_node, output_name, shaders_collection_controller) {
    const connection_point = globals_node.io.outputs.namedOutputConnectionPointsByName(output_name);
    if (!connection_point) {
      return;
    }
    const glType = connection_point.type();
    this.handleGlobalVar(globals_node, output_name, glType, shaders_collection_controller);
  }
  handleGlobalVar(globals_node, output_name, glType, shaders_collection_controller) {
    var _a, _b;
    const var_name = globals_node.glVarName(output_name);
    const definition = new VaryingGLDefinition(globals_node, glType, var_name);
    shaders_collection_controller.addDefinitions(globals_node, [definition]);
    const assembler = (_b = (_a = globals_node.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler;
    if (!assembler) {
      return;
    }
    const shader_config = assembler.shader_config(shaders_collection_controller.currentShaderName());
    if (!shader_config) {
      return;
    }
    const dependencies = shader_config.dependencies();
    const body_lines = [];
    const worldPositionLine = `${var_name} = modelMatrix * vec4( position, 1.0 )`;
    const worldNormalLine = `${var_name} = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal )`;
    switch (output_name) {
      case GlobalsOutput.WORLD_POSITION: {
        body_lines.push(worldPositionLine);
        break;
      }
      case GlobalsOutput.WORLD_NORMAL: {
        body_lines.push(worldNormalLine);
        break;
      }
      default: {
        body_lines.push(`${var_name} = ${glType}(${output_name})`);
      }
    }
    for (const dependency of dependencies) {
      shaders_collection_controller.addDefinitions(globals_node, [definition], dependency);
      shaders_collection_controller.addBodyLines(globals_node, body_lines, dependency);
    }
    if (dependencies.length == 0) {
      shaders_collection_controller.addBodyLines(globals_node, body_lines);
    }
  }
  static variable_config_default(variable_name) {
    return VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];
  }
  variable_config_default(variable_name) {
    return _GlobalsGeometryHandler.variable_config_default(variable_name);
  }
  // variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{
  // 	return null
  // }
  readAttribute(node, gl_type, attrib_name, shaders_collection_controller) {
    return _GlobalsGeometryHandler.readAttribute(node, gl_type, attrib_name, shaders_collection_controller);
  }
  static readAttribute(node, gl_type, attrib_name, shaders_collection_controller) {
    var _a, _b;
    if (_GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {
      shaders_collection_controller.addDefinitions(
        node,
        [new AttributeGLDefinition(node, gl_type, attrib_name)],
        ShaderName.VERTEX
      );
    } else {
    }
    const shader_name = shaders_collection_controller.currentShaderName();
    switch (shader_name) {
      case ShaderName.VERTEX: {
        return attrib_name;
      }
      case ShaderName.FRAGMENT: {
        if (!(node instanceof AttributeGlNode)) {
          return;
        }
        const attribNode = node;
        const var_name = attribNode.varyingName();
        const varying_definition = new VaryingGLDefinition(node, gl_type, var_name);
        const definitions_by_shader_name = /* @__PURE__ */ new Map();
        definitions_by_shader_name.set(ShaderName.FRAGMENT, []);
        const body_lines_by_shader_name = /* @__PURE__ */ new Map();
        body_lines_by_shader_name.set(ShaderName.FRAGMENT, []);
        MapUtils.pushOnArrayAtEntry(definitions_by_shader_name, shader_name, varying_definition);
        const set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;
        const shader_config = (_b = (_a = node.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler.shader_config(shader_name);
        if (shader_config) {
          const dependencies = shader_config.dependencies();
          for (const dependency of dependencies) {
            MapUtils.pushOnArrayAtEntry(definitions_by_shader_name, dependency, varying_definition);
            MapUtils.pushOnArrayAtEntry(body_lines_by_shader_name, dependency, set_varying_body_line);
          }
          definitions_by_shader_name.forEach((definitions, shader_name2) => {
            shaders_collection_controller.addDefinitions(node, definitions, shader_name2);
          });
          body_lines_by_shader_name.forEach((body_lines, shader_name2) => {
            shaders_collection_controller.addBodyLines(node, body_lines, shader_name2);
          });
        }
        return var_name;
      }
    }
  }
  handle_attribute_node(node, gl_type, attrib_name, shaders_collection_controller) {
    return _GlobalsGeometryHandler.readAttribute(node, gl_type, attrib_name, shaders_collection_controller);
  }
};
var GlobalsGeometryHandler = _GlobalsGeometryHandler;
GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES = [
  "position",
  "color",
  "normal",
  "uv",
  "uv2",
  "morphTarget0",
  "morphTarget1",
  "morphTarget2",
  "morphTarget3",
  "skinIndex",
  "skinWeight"
];
GlobalsGeometryHandler.IF_RULE = {
  uv: "defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )"
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/Material.js
var _nextId = 0;
var MaterialSopOperation = class extends BaseSopOperation {
  constructor() {
    super(...arguments);
    this._materialSopOperationId = _nextId++;
    this._globalsHandler = new GlobalsGeometryHandler();
    this._onMaterialUpdateBound = this._onMaterialUpdate.bind(this);
    this._oldMatByOldNewId = /* @__PURE__ */ new Map();
    this._materialByUuid = /* @__PURE__ */ new Map();
  }
  static type() {
    return "material";
  }
  async cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    this._oldMatByOldNewId.clear();
    await this._applyMaterials(coreGroup, params);
    this._swapTextures(coreGroup, params);
    return coreGroup;
  }
  async _getMaterial(params) {
    var _a, _b, _c, _d;
    const materialNode = params.material.nodeWithContext(NodeContext.MAT, (_a = this.states) == null ? void 0 : _a.error);
    if (materialNode) {
      this._watchMaterialNode(materialNode);
      const material = await materialNode.material();
      const baseBuilderMatNode = materialNode;
      if (baseBuilderMatNode.assemblerController) {
        (_b = baseBuilderMatNode.assemblerController()) == null ? void 0 : _b.setAssemblerGlobalsHandler(this._globalsHandler);
      }
      if (!material) {
        (_c = this.states) == null ? void 0 : _c.error.set(`material invalid. (error: '${materialNode.states.error.message()}')`);
      }
      return material;
    } else {
      (_d = this.states) == null ? void 0 : _d.error.set(`no material node found`);
    }
  }
  _watchMaterialNode(materialNode) {
    if (this._watchedMaterialNode == materialNode) {
      return;
    }
    const hookName = this._watchHookName();
    materialNode.addPostDirtyHook(hookName, this._onMaterialUpdateBound);
    materialNode.cookController.registerOnCookEnd(hookName, this._onMaterialUpdateBound);
    if (this._watchedMaterialNode) {
      this._watchedMaterialNode.removePostDirtyHook(hookName);
      this._watchedMaterialNode.cookController.deregisterOnCookEnd(hookName);
    }
    this._watchedMaterialNode = materialNode;
  }
  async _onMaterialUpdate() {
    if (!this._watchedMaterialNode) {
      return;
    }
    const container = await this._watchedMaterialNode.compute();
    const material = container.material();
    if (material != this._watchedMaterialNodeMaterial) {
      this._watchedMaterialNodeMaterial = material;
      if (this._node) {
        this._node.p.material.setDirty();
      }
    }
  }
  _watchHookName() {
    return `MaterialSopOperationId-${this._materialSopOperationId}`;
  }
  async _applyMaterials(coreGroup, params) {
    if (!isBooleanTrue(params.assignMat)) {
      return;
    }
    const material = await this._getMaterial(params);
    if (!material) {
      return;
    }
    const selectedObjects = CoreMask.filterThreejsObjects(coreGroup, params);
    for (let selectedObject of selectedObjects) {
      this._applyMaterial(selectedObject, material, params);
    }
    return coreGroup;
  }
  _swapTextures(coreGroup, params) {
    if (!isBooleanTrue(params.swapCurrentTex)) {
      return;
    }
    this._materialByUuid.clear();
    const objects = CoreMask.filterObjects(coreGroup, params, coreGroup.allCoreObjects());
    for (let object of objects) {
      const mat = object.material;
      this._materialByUuid.set(mat.uuid, mat);
    }
    this._materialByUuid.forEach((mat, mat_uuid) => {
      this._swapTexture(mat, params);
    });
  }
  _applyMaterial(object, srcMaterial, params) {
    const usedMaterial = isBooleanTrue(params.cloneMat) ? cloneMaterial(this.scene(), srcMaterial, {
      shareCustomUniforms: params.shareCustomUniforms,
      addCustomMaterials: true
    }) : srcMaterial;
    if (srcMaterial instanceof ShaderMaterial && usedMaterial instanceof ShaderMaterial) {
      for (let uniform_name in srcMaterial.uniforms) {
        usedMaterial.uniforms[uniform_name] = srcMaterial.uniforms[uniform_name];
      }
    }
    if (object.isGroup) {
      return;
    }
    const object_with_material = object;
    this._oldMatByOldNewId.set(usedMaterial.uuid, object_with_material.material);
    object_with_material.material = usedMaterial;
    applyRenderHook(object, usedMaterial);
    applyCustomMaterials(object, usedMaterial);
  }
  _swapTexture(target_mat, params) {
    if (params.texSrc0 == "" || params.texDest0 == "") {
      return;
    }
    let src_mat = this._oldMatByOldNewId.get(target_mat.uuid);
    src_mat = src_mat || target_mat;
    const src_tex = src_mat[params.texSrc0];
    if (src_tex) {
      target_mat[params.texDest0] = src_tex;
      const uniforms = target_mat.uniforms;
      if (uniforms) {
        const uniforms_map = uniforms[params.texDest0];
        if (uniforms_map) {
          uniforms[params.texDest0] = { value: src_tex };
        }
      }
    }
  }
};
MaterialSopOperation.DEFAULT_PARAMS = {
  group: "",
  assignMat: true,
  material: new TypedNodePathParamValue(""),
  cloneMat: false,
  shareCustomUniforms: true,
  swapCurrentTex: false,
  texSrc0: "emissiveMap",
  texDest0: "map"
};
MaterialSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/Material.js
var DEFAULT = MaterialSopOperation.DEFAULT_PARAMS;
var MaterialSopParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.group = ParamConfig.STRING(DEFAULT.group, {
      objectMask: true
    });
    this.assignMat = ParamConfig.BOOLEAN(DEFAULT.assignMat);
    this.material = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.MAT
      },
      dependentOnFoundNode: false,
      visibleIf: { assignMat: 1 }
    });
    this.cloneMat = ParamConfig.BOOLEAN(DEFAULT.cloneMat, {
      visibleIf: { assignMat: 1 },
      separatorBefore: true
    });
    this.shareCustomUniforms = ParamConfig.BOOLEAN(DEFAULT.shareCustomUniforms, { visibleIf: { assignMat: 1, cloneMat: 1 } });
    this.swapCurrentTex = ParamConfig.BOOLEAN(DEFAULT.swapCurrentTex);
    this.texSrc0 = ParamConfig.STRING(DEFAULT.texSrc0, { visibleIf: { swapCurrentTex: 1 } });
    this.texDest0 = ParamConfig.STRING(DEFAULT.texDest0, { visibleIf: { swapCurrentTex: 1 } });
  }
};
var ParamsConfig3 = new MaterialSopParamsConfig();
var MaterialSopNode = class extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig3;
  }
  static type() {
    return SopType.MATERIAL;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(MaterialSopOperation.INPUT_CLONED_STATE);
  }
  async cook(inputCoreGroups) {
    this._operation = this._operation || new MaterialSopOperation(this._scene, this.states, this);
    const coreGroup = await this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
};
export {
  MaterialSopNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_sop_Material.js.map
