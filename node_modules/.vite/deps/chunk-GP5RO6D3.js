import {
  CoreTransform,
  NodeParamsConfig,
  ParamConfig,
  ROTATION_ORDERS,
  RotationOrder
} from "./chunk-FUAFRKQ7.js";
import {
  Poly
} from "./chunk-O564GFGZ.js";
import {
  Group,
  Matrix4,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Obj.js
var ObjType = ((ObjType2) => {
  ObjType2["GEO"] = "geo";
  ObjType2["CUBE_CAMERA"] = "cubeCamera";
  ObjType2["AUDIO_LISTENER"] = "audioListener";
  ObjType2["POSITIONAL_AUDIO"] = "positionalAudio";
  ObjType2["SCENE"] = "scene";
  return ObjType2;
})(ObjType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/utils/TransformController.js
function TransformedParamConfig(Base, default_params) {
  const matrixAutoUpdate = (default_params == null ? void 0 : default_params.matrixAutoUpdate) || false;
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.transform = ParamConfig.FOLDER();
      this.keepPosWhenParenting = ParamConfig.BOOLEAN(0);
      this.rotationOrder = ParamConfig.INTEGER(ROTATION_ORDERS.indexOf(RotationOrder.XYZ), {
        menu: {
          entries: ROTATION_ORDERS.map((order, v) => {
            return { name: order, value: v };
          })
        }
      });
      this.t = ParamConfig.VECTOR3([0, 0, 0]);
      this.r = ParamConfig.VECTOR3([0, 0, 0]);
      this.s = ParamConfig.VECTOR3([1, 1, 1]);
      this.scale = ParamConfig.FLOAT(1);
      this.matrixAutoUpdate = ParamConfig.BOOLEAN(matrixAutoUpdate ? 1 : 0);
      this.updateTransformFromObject = ParamConfig.BUTTON(null, {
        callback: (node) => {
          TransformController.PARAM_CALLBACK_update_transform_from_object(node);
        }
      });
    }
    // tlookAt = ParamConfig.BOOLEAN(0);
    // lookAtPos = ParamConfig.VECTOR3([0, 0, 0], {
    // 	visibleIf: {tlookAt: 1},
    // });
    // look_at = ParamConfig.OPERATOR_PATH('', {
    // 	visibleIf: {tlookAt: 1},
    // 	nodeSelection: {context: NodeContext.OBJ},
    // });
    // up = ParamConfig.VECTOR3([0, 1, 0], {
    // 	visibleIf: {tlookAt: 1},
    // });
  };
}
var TransformedParamsConfig = class extends TransformedParamConfig(NodeParamsConfig) {
};
var HOOK_NAME = "_cook_main_without_inputs_when_dirty";
var TransformController = class {
  constructor(node) {
    this.node = node;
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
    this._core_transform = new CoreTransform();
    this._keep_pos_when_parenting_m_object = new Matrix4();
    this._keep_pos_when_parenting_m_new_parent_inv = new Matrix4();
  }
  initializeNode() {
    if (!this.node.dirtyController.hasHook(HOOK_NAME)) {
      this.node.dirtyController.addPostDirtyHook(HOOK_NAME, this._cook_main_without_inputs_when_dirty_bound);
    }
  }
  async _cook_main_without_inputs_when_dirty() {
    await this.node.cookController.cookMainWithoutInputs();
  }
  update() {
    this.update_transform_with_matrix();
    const object = this.node.object;
    object.matrixAutoUpdate = isBooleanTrue(this.node.pv.matrixAutoUpdate);
    Poly.onSceneUpdatedHooks.runHooks();
  }
  update_transform_with_matrix(matrix) {
    const object = this.node.object;
    if (matrix != null && !matrix.equals(object.matrix)) {
      object.matrix.copy(matrix);
      object.dispatchEvent({ type: "change" });
    } else {
      this._update_matrix_from_params_with_core_transform();
    }
  }
  _update_matrix_from_params_with_core_transform() {
    const object = this.node.object;
    let prev_auto_update = object.matrixAutoUpdate;
    if (prev_auto_update) {
      object.matrixAutoUpdate = false;
    }
    const matrix = this._core_transform.matrix(
      this.node.pv.t,
      this.node.pv.r,
      this.node.pv.s,
      this.node.pv.scale,
      ROTATION_ORDERS[this.node.pv.rotationOrder]
    );
    object.matrix.identity();
    object.applyMatrix4(matrix);
    this._apply_look_at();
    object.updateMatrix();
    if (prev_auto_update) {
      object.matrixAutoUpdate = true;
    }
    object.dispatchEvent({ type: "change" });
  }
  // private _look_at_target_t = new Vector3();
  // private _look_at_target_q = new Quaternion();
  // private _look_at_target_s = new Vector3();
  _apply_look_at() {
  }
  set_params_from_matrix(matrix, options = {}) {
    CoreTransform.setParamsFromMatrix(matrix, this.node, options);
  }
  //
  //
  // KEEP POS WHEN PARENTING
  //
  //
  static update_node_transform_params_if_required(node, new_parent_object) {
    node.transformController.update_node_transform_params_if_required(new_parent_object);
  }
  update_node_transform_params_if_required(new_parent_object) {
    if (!isBooleanTrue(this.node.pv.keepPosWhenParenting)) {
      return;
    }
    if (!this.node.scene().loadingController.loaded()) {
      return;
    }
    if (new_parent_object == this.node.object.parent) {
      return;
    }
    const object = this.node.object;
    object.updateMatrixWorld(true);
    new_parent_object.updateMatrixWorld(true);
    this._keep_pos_when_parenting_m_object.copy(object.matrixWorld);
    this._keep_pos_when_parenting_m_new_parent_inv.copy(new_parent_object.matrixWorld);
    this._keep_pos_when_parenting_m_new_parent_inv.invert();
    this._keep_pos_when_parenting_m_object.premultiply(this._keep_pos_when_parenting_m_new_parent_inv);
    CoreTransform.setParamsFromMatrix(this._keep_pos_when_parenting_m_object, this.node, { scale: true });
  }
  update_node_transform_params_from_object(update_matrix = false) {
    const object = this.node.object;
    if (update_matrix) {
      object.updateMatrix();
    }
    CoreTransform.setParamsFromMatrix(object.matrix, this.node, { scale: true });
  }
  //
  //
  // CALLBACK
  //
  //
  static PARAM_CALLBACK_update_transform_from_object(node) {
    node.transformController.update_node_transform_params_from_object();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/utils/HierarchyController.js
var HierarchyController = class _HierarchyController {
  constructor(node) {
    this.node = node;
  }
  initializeNode() {
    this.node.io.inputs.setCount(0, 1);
    this.node.io.inputs.setDependsOnInputs(false);
    this.node.io.outputs.setHasOneOutput();
    this.node.io.inputs.add_on_set_input_hook("on_input_updated:update_parent", () => {
      this.on_input_updated();
    });
  }
  static on_input_updated(node) {
    const parent_object = node.root().getParentForNode(node);
    if (node.transformController && parent_object) {
      TransformController.update_node_transform_params_if_required(node, parent_object);
    }
    if (node.io.inputs.input(0) != null) {
      node.root().addToParentTransform(node);
    } else {
      node.root().removeFromParentTransform(node);
    }
  }
  on_input_updated() {
    _HierarchyController.on_input_updated(this.node);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/utils/ObjChildrenDisplayController.js
var DISPLAY_PARAM_NAME = "display";
var ObjChildrenDisplayController = class {
  constructor(node) {
    this.node = node;
    this._childrenUuids = /* @__PURE__ */ new Set();
    this._sopGroup = this._createSopGroup();
    this._newSpecializedObjects = [];
    this._newObjectsAreDifferent = false;
    this._scene = this.node.scene();
  }
  _createSopGroup() {
    const group = new Group();
    group.matrixAutoUpdate = false;
    return group;
  }
  sopGroup() {
    return this._sopGroup;
  }
  setSopGroupName() {
    this._sopGroup.name = `${this.node.name()}:sopGroup`;
  }
  dispose() {
    this._clearHooks();
  }
  displayNodeControllerCallbacks() {
    return {
      onDisplayNodeRemove: () => {
        this.removeChildren();
      },
      onDisplayNodeSet: () => {
        setTimeout(() => {
          this.requestDisplayNodeContainer();
        }, 0);
      },
      onDisplayNodeUpdate: () => {
        if (!this.node.scene().loadingController.loaded()) {
          return;
        }
        this.requestDisplayNodeContainer();
      }
    };
  }
  initializeNode() {
    var _a;
    this.node.object.add(this.sopGroup());
    this.node.nameController.add_post_set_fullPath_hook(this.setSopGroupName.bind(this));
    this._createSopGroup();
    const displayFlag = (_a = this.node.flags) == null ? void 0 : _a.display;
    if (displayFlag) {
      displayFlag.onUpdate(() => {
        this._updateSopGroupHierarchy();
        if (displayFlag.active()) {
          this.requestDisplayNodeContainer();
        }
      });
    }
  }
  _updateSopGroupHierarchy() {
    var _a;
    const displayFlag = (_a = this.node.flags) == null ? void 0 : _a.display;
    if (displayFlag) {
      const sopGroup = this.sopGroup();
      if (this.usedInScene()) {
        sopGroup.visible = true;
        this.node.object.add(sopGroup);
        sopGroup.updateMatrix();
      } else {
        sopGroup.visible = false;
        this.node.object.remove(sopGroup);
      }
      Poly.onSceneUpdatedHooks.runHooks();
    }
  }
  usedInScene() {
    var _a, _b;
    const node = this.node;
    if (node.disposed() == true) {
      return false;
    }
    const usedInScene = node.usedInScene();
    if (!usedInScene) {
      return false;
    }
    const displayFlagOn = ((_b = (_a = node.flags) == null ? void 0 : _a.display) == null ? void 0 : _b.active()) || false;
    if (!displayFlagOn) {
      return false;
    }
    const params = node.params;
    const hasActiveParam = params.has(DISPLAY_PARAM_NAME);
    const isActiveParamOn = node.params.boolean(DISPLAY_PARAM_NAME);
    const paramActiveOn = !hasActiveParam || isActiveParamOn;
    return paramActiveOn;
  }
  async requestDisplayNodeContainer() {
    if (!this._scene.loadingController.loaded()) {
      return;
    }
    if (this.usedInScene()) {
      await this._setContentUnderSopGroup();
    }
  }
  removeChildren() {
    if (this._sopGroup.children.length == 0) {
      return;
    }
    let child;
    Poly.onObjectsAddRemoveHooks.runOnRemoveHooks(this._scene, this._sopGroup);
    while (child = this._sopGroup.children[0]) {
      this._sopGroup.remove(child);
    }
    this._childrenUuids.clear();
    this._notifyCamerasController();
  }
  async _setContentUnderSopGroup() {
    var _a;
    const displayNode = this.node.displayNodeController.displayNode();
    if (displayNode && ((_a = displayNode.parent()) == null ? void 0 : _a.graphNodeId()) == this.node.graphNodeId()) {
      const container = await displayNode.compute();
      const coreGroup = container.coreContent();
      if (coreGroup) {
        const newObjects = coreGroup.threejsObjects();
        const _checkObjectsHaveChanged = () => {
          const objectsCountChanged = newObjects.length != this._childrenUuids.size;
          if (objectsCountChanged) {
            return true;
          }
          for (const object of newObjects) {
            if (!this._childrenUuids.has(object.uuid)) {
              return true;
            }
          }
          return false;
        };
        this._newObjectsAreDifferent = _checkObjectsHaveChanged();
        this._newSpecializedObjects.length = 0;
        this._addSpecializedObjects(displayNode, coreGroup, this._newSpecializedObjects);
        if (this._newObjectsAreDifferent) {
          this.removeChildren();
          const addObject = (object) => {
            this._sopGroup.add(object);
            object.updateMatrix();
            this._childrenUuids.add(object.uuid);
          };
          for (const object of newObjects) {
            addObject(object);
          }
          for (const object of this._newSpecializedObjects) {
            addObject(object);
          }
        }
        this._notifyCamerasController();
        this._runOnSopGroupUpdatedHooks();
        if (this._scene.loadingController.loaded()) {
          Poly.onObjectsAddRemoveHooks.runOnAddHooks(this._scene, this._sopGroup);
          Poly.onSceneUpdatedHooks.runHooks();
        }
        return;
      }
    }
    this.removeChildren();
    this._runOnSopGroupUpdatedHooks();
    if (this._scene.loadingController.loaded()) {
      Poly.onSceneUpdatedHooks.runHooks();
    }
  }
  _notifyCamerasController() {
    this._scene.camerasController.updateFromChangeInObject(this._sopGroup);
  }
  _addSpecializedObjects(displayNode, coreGroup, newObjects) {
  }
  registerOnSopGroupUpdated(callbackName, callback) {
    this._onSopGroupUpdatedHookNames = this._onSopGroupUpdatedHookNames || [];
    this._onSopGroupUpdatedHooks = this._onSopGroupUpdatedHooks || [];
    this._onSopGroupUpdatedHookNames.push(callbackName);
    this._onSopGroupUpdatedHooks.push(callback);
  }
  _clearHooks() {
    if (!this._onSopGroupUpdatedHookNames || !this._onSopGroupUpdatedHooks) {
      return;
    }
    for (const hookName of this._onSopGroupUpdatedHookNames) {
      this.deregisterOnSopGroupUpdated(hookName);
    }
  }
  deregisterOnSopGroupUpdated(callbackName) {
    var _a;
    if (!this._onSopGroupUpdatedHookNames || !this._onSopGroupUpdatedHooks) {
      return;
    }
    const index = (_a = this._onSopGroupUpdatedHookNames) == null ? void 0 : _a.indexOf(callbackName);
    this._onSopGroupUpdatedHookNames.splice(index, 1);
    this._onSopGroupUpdatedHooks.splice(index, 1);
    if (this._onSopGroupUpdatedHookNames.length == 0) {
      this._onSopGroupUpdatedHookNames = void 0;
    }
    if (this._onSopGroupUpdatedHooks.length == 0) {
      this._onSopGroupUpdatedHooks = void 0;
    }
  }
  _runOnSopGroupUpdatedHooks() {
    if (this._onSopGroupUpdatedHooks) {
      const hooks = [...this._onSopGroupUpdatedHooks];
      for (const hook of hooks) {
        hook();
      }
    }
  }
  onSopGroupUpdatedCallbackNames() {
    return this._onSopGroupUpdatedHookNames;
  }
};

export {
  ObjType,
  TransformedParamConfig,
  TransformController,
  ObjChildrenDisplayController,
  HierarchyController
};
//# sourceMappingURL=chunk-GP5RO6D3.js.map
