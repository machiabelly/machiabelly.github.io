import {
  CoreType,
  NoColorSpace,
  NoToneMapping,
  Vector3,
  WebGLRenderTarget,
  WebGLRenderer
} from "./chunk-6OBTIB4K.js";

// node_modules/@polygonjs/polygonjs/dist/src/core/render/Common.js
var PowerPreference = ((PowerPreference2) => {
  PowerPreference2["HIGH"] = "high-performance";
  PowerPreference2["LOW"] = "low-power";
  PowerPreference2["DEFAULT"] = "default";
  return PowerPreference2;
})(PowerPreference || {});
var POWER_PREFERENCES = [
  "high-performance",
  "low-power",
  "default"
  /* DEFAULT */
];
var RendererPrecision = ((RendererPrecision2) => {
  RendererPrecision2["HIGH"] = "highp";
  RendererPrecision2["MEDIUM"] = "mediump";
  RendererPrecision2["LOW"] = "lowp";
  return RendererPrecision2;
})(RendererPrecision || {});
var RENDERER_PRECISIONS = [
  "highp",
  "mediump",
  "lowp"
  /* LOW */
];
var WEBGL_RENDERER_DEFAULT_PARAMS = {
  alpha: true,
  precision: "highp",
  premultipliedAlpha: true,
  antialias: true,
  preserveDrawingBuffer: false,
  powerPreference: "default",
  depth: true,
  stencil: true,
  logarithmicDepthBuffer: false
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/RenderersController.js
var CONTEXT_OPTIONS = {
  // powerPreference: 'high-performance', // attempt to fix issues in safari
  // antialias: false, // leave that to the renderer node
  // preserveDrawingBuffer: true, // this could only be useful to capture static images
};
var WebGLContext = ((WebGLContext2) => {
  WebGLContext2["WEBGL"] = "webgl";
  WebGLContext2["WEBGL2"] = "webgl2";
  WebGLContext2["EXPERIMENTAL_WEBGL"] = "experimental-webgl";
  WebGLContext2["EXPERIMENTAL_WEBGL2"] = "experimental-webgl2";
  return WebGLContext2;
})(WebGLContext || {});
var nextRendererId = 0;
var _RenderersController = class {
  constructor() {
    this._printDebug = false;
    this._requireWebGL2 = false;
    this._webGLContextByCanvas = /* @__PURE__ */ new Map();
    this._defaultRendererByCanvas = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._webGLContextByCanvas.clear();
    this._defaultRendererByCanvas.forEach((renderer) => {
      renderer.dispose();
    });
    this._defaultRendererByCanvas.clear();
  }
  setPrintDebug(state = true) {
    this._printDebug = state;
  }
  printDebug() {
    return this._printDebug;
  }
  printDebugMessage(message) {
    if (!this._printDebug) {
      return;
    }
    console.warn("[Poly debug]", message);
  }
  setRequireWebGL2() {
    if (!this._requireWebGL2) {
      this._requireWebGL2 = true;
    }
  }
  webGL2Available(canvas) {
    if (this._webgl2_available === void 0) {
      this._webgl2_available = this._getWebGL2Available(canvas);
    }
    return this._webgl2_available;
  }
  _getWebGL2Available(canvas) {
    canvas = canvas || document.createElement("canvas");
    return (window.WebGL2RenderingContext && canvas.getContext(
      "webgl2"
      /* WEBGL2 */
    )) != null;
  }
  defaultWebGLRendererForCanvas(canvas) {
    let renderer = this._defaultRendererByCanvas.get(canvas);
    if (!renderer) {
      const context = this.getRenderingContext(canvas);
      renderer = this.createWebGLRenderer({ ...WEBGL_RENDERER_DEFAULT_PARAMS, canvas, context });
      this._defaultRendererByCanvas.set(canvas, renderer);
    }
    return renderer;
  }
  // disposeWebGLRendererForCanvas(canvas: HTMLCanvasElement) {
  // 	const renderer = this._defaultRendererByCanvas.get(canvas);
  // 	if (renderer) {
  // 		renderer.dispose();
  // 		this._defaultRendererByCanvas.delete(canvas);
  // 	}
  // }
  createWebGLRenderer(params) {
    const renderer = new WebGLRenderer(params);
    this.assignIdToRenderer(renderer);
    this.printDebugMessage([`create renderer:`, params]);
    return renderer;
  }
  assignIdToRenderer(renderer) {
    if (renderer._polygonId != null) {
      return;
    }
    const nextId = nextRendererId += 1;
    renderer._polygonId = nextId;
  }
  rendererId(renderer) {
    const id = renderer._polygonId;
    if (id == null) {
      console.error("renderer has no _polygonId");
      return;
    }
    return id;
  }
  getRenderingContext(canvas) {
    let gl = this._webGLContextByCanvas.get(canvas);
    if (gl) {
      return gl;
    }
    gl = this._getRenderingContextWebgl(canvas, true);
    if (!gl) {
      console.warn("failed to create webgl2 context");
    }
    if (!gl) {
      gl = this._getRenderingContextWebgl(canvas, false);
    }
    if (!gl) {
      console.error("failed to create webgl context");
      return null;
    }
    if (gl._polygonjsContextId == null) {
      gl._polygonjsContextId = _RenderersController._nextGlContextId++;
    }
    this._webGLContextByCanvas.set(canvas, gl);
    return gl;
  }
  _getRenderingContextWebgl(canvas, webgl2) {
    let contextName;
    if (this.webGL2Available(canvas)) {
      contextName = "webgl2";
    } else {
      contextName = webgl2 ? "webgl2" : "webgl";
    }
    let gl = canvas.getContext(contextName, CONTEXT_OPTIONS);
    if (gl) {
      this.printDebugMessage(`create gl context: ${contextName}.`);
    } else {
      contextName = webgl2 ? "experimental-webgl2" : "experimental-webgl";
      this.printDebugMessage(`create gl context: ${contextName}.`);
      gl = canvas.getContext(contextName, CONTEXT_OPTIONS);
    }
    return gl;
  }
  createRenderTarget(width, height, parameters) {
    if (this.webGL2Available()) {
      const multiSampleRenderTarget = new WebGLRenderTarget(width, height, parameters);
      multiSampleRenderTarget.samples = 2;
      return multiSampleRenderTarget;
    } else {
      return new WebGLRenderTarget(width, height, parameters);
    }
  }
  linearRenderer() {
    return this._linearRenderer = this._linearRenderer || this._createLinearRenderer();
  }
  _createLinearRenderer() {
    const canvas = document.createElement("canvas");
    const gl = this.getRenderingContext(canvas);
    if (!gl) {
      return;
    }
    const renderer = this.createWebGLRenderer({
      // antialias: true,
      // stencil: true,
      // depth: false,
      alpha: true,
      premultipliedAlpha: true,
      canvas,
      context: gl
    });
    renderer.outputColorSpace = NoColorSpace;
    renderer.toneMapping = NoToneMapping;
    return renderer;
  }
};
var RenderersController = _RenderersController;
RenderersController._nextGlContextId = 0;

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/PolyLibsController.js
var PolyLibsController = class {
  constructor() {
    this._rootPrefix = "";
    this._root = "/three/js/libs";
    this._KTX2Path = "/ktx2";
    this._DRACOPath = "/draco";
    this._DRACOGLTFPath = "/draco/gltf";
    this._XATLASPath = "/xatlas";
    this._OCCTPath = "/occt";
    this._ManifoldPath = "/manifold";
  }
  root() {
    if (this._root) {
      if (this._rootPrefix.length > 0) {
        const root2 = this._root.replace(/^(\.)/, "");
        return `${this._rootPrefix}${root2}`;
      } else {
        return this._root;
      }
    }
  }
  setRoot(url) {
    this._root = url;
  }
  setRootPrefix(prefix) {
    this._rootPrefix = prefix;
  }
  KTX2Path() {
    return this._KTX2Path;
  }
  // setDRACOPath(path: string | null) {
  // 	this._DRACOPath = path;
  // }
  DRACOPath() {
    return this._DRACOPath;
  }
  // setDRACOGLTFPath(path: string | null) {
  // 	this._DRACOGLTFPath = path;
  // }
  DRACOGLTFPath() {
    return this._DRACOGLTFPath;
  }
  // setDRACOGLTFPath(path: string | null) {
  // 	this._DRACOGLTFPath = path;
  // }
  XATLASPath() {
    return this._XATLASPath;
  }
  OCCTPath() {
    return this._OCCTPath;
  }
  ManifoldPath() {
    return this._ManifoldPath;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/BlobsController.js
var BlobsController = class {
  constructor(poly) {
    this.poly = poly;
  }
  recording() {
    return !this.poly.playerMode();
  }
  clear() {
  }
  clearBlobsForNode(node) {
  }
  async setVirtualFile(file, uniqueId) {
  }
  async fetchBlobGlobal(url) {
  }
  traverse(callback) {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/AssetUrlsController.js
var AssetUrlsController = class {
  setMap(map) {
    this._map = map;
  }
  remapedUrl(url) {
    if (!this._map) {
      return;
    }
    const elements = url.split("?");
    const preQuery = elements[0];
    const query = elements[1];
    const remapedUrl = this._map[preQuery];
    if (remapedUrl) {
      if (query) {
        return `${remapedUrl}?${query}`;
      } else {
        return remapedUrl;
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/PerformanceController.js
var PolyPerformanceformanceController = class {
  setPerformanceManager(p) {
    this._performanceManager = p;
  }
  performanceManager() {
    return this._performanceManager || window.performance;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/ScenesRegister.js
var ScenesRegister = class {
  constructor() {
    this._scenes = /* @__PURE__ */ new Set();
    this._registerTimeByScene = /* @__PURE__ */ new Map();
  }
  registerScene(scene) {
    if (this._scenes.has(scene)) {
      console.warn("scene was already registered");
      return;
    }
    this._scenes.add(scene);
    this._registerTimeByScene.set(scene, performance.now());
    this._updateCache();
  }
  deregisterScene(scene) {
    this._scenes.delete(scene);
    this._registerTimeByScene.delete(scene);
    this._updateCache();
  }
  dispose() {
    const scenes = this.scenes();
    for (const scene of scenes) {
      scene.dispose();
    }
  }
  lastRegisteredScene() {
    return this._lastRegisteredScene;
  }
  scenes() {
    const scenes = [];
    this._scenes.forEach((scene) => scenes.push(scene));
    return scenes;
  }
  _updateCache() {
    this._lastRegisteredScene = void 0;
    this._registerTimeByScene.forEach((registerTime, scene) => {
      if (this._lastRegisteredScene == void 0) {
        this._lastRegisteredScene = scene;
      } else {
        const lastRegisterTime = this._registerTimeByScene.get(this._lastRegisteredScene);
        if (registerTime != null && lastRegisterTime != null) {
          if (registerTime > lastRegisterTime) {
            this._lastRegisteredScene = scene;
          }
        }
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/thirdParty/Mapbox.js
var PolyThirdPartyMapboxController = class {
  setToken(token) {
    this._token = token;
  }
  setGetTokenFunction(tokenFunc) {
    this._getTokenFunc = tokenFunc;
  }
  async token() {
    if (this._token) {
      return this._token;
    }
    if (this._getTokenFunc) {
      return await this._getTokenFunc();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/thirdParty/MarkerTracking.js
var PolyMarkerTrackingController = class {
  constructor() {
    this._controller = null;
  }
  setConfig(config) {
    this._config = config;
  }
  barCodeUrl(type, value) {
    if (this._config) {
      return this._config.barcodeUrl(type, value);
    }
  }
  barCodeTypes() {
    var _a;
    return ((_a = this._config) == null ? void 0 : _a.barCodes.types) || [""];
  }
  config() {
    return this._config;
  }
  hasController() {
    return this._config != null;
  }
  createController(options) {
    if (!this._config) {
      return;
    }
    const controller = this._config.createController(options);
    this._controller = controller;
    return controller;
  }
  controller() {
    return this._controller;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/ThirdPartyController.js
var PolyThirdPartyController = class {
  markerTracking() {
    return this._markerTracking = this._markerTracking || new PolyMarkerTrackingController();
  }
  mapbox() {
    return this._mapbox = this._mapbox || new PolyThirdPartyMapboxController();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/Event.js
var ObjectEvent = ((ObjectEvent2) => {
  ObjectEvent2["BEFORE_DELETE"] = "beforeDelete";
  return ObjectEvent2;
})(ObjectEvent || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/MapUtils.js
function mapFirstKey(map) {
  for (const [k] of map) {
    return k;
  }
}
function pushOnArrayAtEntry(map, key, newElement) {
  if (map.has(key)) {
    map.get(key).push(newElement);
  } else {
    map.set(key, [newElement]);
  }
}
function popFromArrayAtEntry(map, key, elementToRemove, removeFromMapIfEmpty = true) {
  if (map.has(key)) {
    const array = map.get(key);
    const index = array.indexOf(elementToRemove);
    if (index >= 0) {
      array.splice(index, 1);
      if (removeFromMapIfEmpty && array.length == 0) {
        map.delete(key);
      }
    }
  }
}
function addToSetAtEntry(map, key, newElement) {
  if (map.has(key)) {
    map.get(key).add(newElement);
  } else {
    const set = /* @__PURE__ */ new Set();
    set.add(newElement);
    map.set(key, set);
  }
}
function mapValuesToArray(map, target) {
  target.length = 0;
  map.forEach((v) => {
    target.push(v);
  });
  return target;
}
function removeFromSetAtEntry(map, key, elementToRemove) {
  if (map.has(key)) {
    const set = map.get(key);
    set.delete(elementToRemove);
    if (set.size == 0) {
      map.delete(key);
    }
  }
}
function unshiftOnArrayAtEntry(map, key, newElement) {
  if (map.has(key)) {
    map.get(key).unshift(newElement);
  } else {
    map.set(key, [newElement]);
  }
}
function concatOnArrayAtEntry(map, key, newElements) {
  if (map.has(key)) {
    let array = map.get(key);
    for (const element of newElements) {
      array.push(element);
    }
  } else {
    map.set(key, newElements);
  }
}
function mapGroupBy(array, callback) {
  const map = /* @__PURE__ */ new Map();
  array.forEach((element) => {
    const key = callback(element);
    pushOnArrayAtEntry(map, key, element);
  });
  return map;
}
function mapIncrementAtEntry(map, key, initValue) {
  let entry = map.get(key);
  if (entry == null) {
    entry = initValue;
  }
  entry++;
  map.set(key, entry);
  return entry;
}
var MapUtils = class {
};
MapUtils.pushOnArrayAtEntry = pushOnArrayAtEntry;
MapUtils.addToSetAtEntry = addToSetAtEntry;
MapUtils.popFromArrayAtEntry = popFromArrayAtEntry;
MapUtils.removeFromSetAtEntry = removeFromSetAtEntry;
MapUtils.unshiftOnArrayAtEntry = unshiftOnArrayAtEntry;
MapUtils.concatOnArrayAtEntry = concatOnArrayAtEntry;
MapUtils.groupBy = mapGroupBy;
MapUtils.incrementAtEntry = mapIncrementAtEntry;
MapUtils.firstKey = mapFirstKey;

// node_modules/@polygonjs/polygonjs/dist/src/core/SetUtils.js
var i = 0;
function setToArray(set, target) {
  target.length = set.size;
  i = 0;
  set.forEach((elem) => {
    target[i] = elem;
    i++;
  });
  return target;
}
function setUnion(set0, set1, target) {
  target.clear();
  set0.forEach((val) => target.add(val));
  set1.forEach((val) => target.add(val));
  return target;
}
function setIntersection(set0, set1, target) {
  target.clear();
  set0.forEach((val) => {
    if (set1.has(val)) {
      target.add(val);
    }
  });
  set1.forEach((val) => {
    if (set0.has(val)) {
      target.add(val);
    }
  });
  return target;
}
function setDifference(set0, set1, target) {
  target.clear();
  set0.forEach((val) => {
    if (!set1.has(val)) {
      target.add(val);
    }
  });
  return target;
}

// node_modules/@polygonjs/polygonjs/node_modules/three/src/math/MathUtils.js
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function smoothstep(x, min, max) {
  if (x <= min)
    return 0;
  if (x >= max)
    return 1;
  x = (x - min) / (max - min);
  return x * x * (3 - 2 * x);
}
function smootherstep(x, min, max) {
  if (x <= min)
    return 0;
  if (x >= max)
    return 1;
  x = (x - min) / (max - min);
  return x * x * x * (x * (x * 6 - 15) + 10);
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/math/Easing.js
var easeI = function(power) {
  return function(t) {
    return Math.pow(t, power);
  };
};
var easeO = function(power) {
  return function(t) {
    return 1 - Math.abs(Math.pow(t - 1, power));
  };
};
var easeIO = function(power) {
  return function(t) {
    return t < 0.5 ? easeI(power)(t * 2) / 2 : easeO(power)(t * 2 - 1) / 2 + 0.5;
  };
};
var easeI2 = easeI(2);
var easeO2 = easeO(2);
var easeIO2 = easeIO(2);
var easeI3 = easeI(3);
var easeO3 = easeO(3);
var easeIO3 = easeIO(3);
var easeI4 = easeI(4);
var easeO4 = easeO(4);
var easeIO4 = easeIO(4);
function easeSinI(t) {
  return 1 + Math.sin(Math.PI / 2 * t - Math.PI / 2);
}
function easeSinO(t) {
  return Math.sin(Math.PI / 2 * t);
}
function easeSinIO(t) {
  return (1 + Math.sin(Math.PI * t - Math.PI / 2)) / 2;
}
function easeElasticI(t) {
  return t == 0 ? 0 : (0.04 - 0.04 / t) * Math.sin(25 * t) + 1;
}
function easeElasticO(t) {
  return t == 1 ? 1 : 0.04 * t / --t * Math.sin(25 * t);
}
function easeElasticIO(t) {
  return t == 0.5 ? 0 : (t -= 0.5) < 0 ? (0.02 + 0.01 / t) * Math.sin(50 * t) : (0.02 - 0.01 / t) * Math.sin(50 * t) + 1;
}
var Easing = {
  // linear: ease_io(1),
  // ease_i: function (t: number, power: number) {
  // 	return ease_i(power)(t);
  // },
  // ease_o: function (t: number, power: number) {
  // 	return ease_o(power)(t);
  // },
  // ease_io: function (t: number, power: number) {
  // 	return ease_io(power)(t);
  // },
  easeI2,
  easeO2,
  easeIO2,
  easeI3,
  easeO3,
  easeIO3,
  easeI4,
  easeO4,
  easeIO4,
  // easeInQuart: EaseIn(4),
  // easeOutQuart: EaseOut(4),
  // easeInOutQuart: EaseInOut(4),
  // easeInQuint: EaseIn(5),
  // easeOutQuint: EaseOut(5),
  // easeInOutQuint: EaseInOut(5)
  easeSinI,
  easeSinO,
  easeSinIO,
  easeElasticI,
  easeElasticO,
  easeElasticIO
};

// node_modules/@polygonjs/polygonjs/dist/src/core/math/_Module.js
var RAND_A = 12.9898;
var RAND_B = 78.233;
var RAND_C = 43758.5453;
var degToRad2 = degToRad;
var radToDeg2 = radToDeg;
function clamp(val, min, max) {
  if (val < min) {
    return min;
  } else if (val > max) {
    return max;
  } else {
    return val;
  }
}
var smoothstep2 = smoothstep;
var smootherstep2 = smootherstep;
function fit(val, srcMin, srcMax, destMin, destMax) {
  const src_range = srcMax - srcMin;
  const dest_range = destMax - destMin;
  const r = (val - srcMin) / src_range;
  return r * dest_range + destMin;
}
function fit01(val, destMin, destMax) {
  return fit(val, 0, 1, destMin, destMax);
}
function fitClamp(val, srcMin, srcMax, destMin, destMax) {
  const r = fit(val, srcMin, srcMax, destMin, destMax);
  return clamp(r, destMin, destMax);
}
function mix(num0, num1, blend) {
  return (1 - blend) * num0 + blend * num1;
}
var fract = (number) => number - Math.floor(number);
var DEFAULT_Y = 136574;
var _vec = { x: 0, y: DEFAULT_Y };
function randFloat(x, y = DEFAULT_Y) {
  _vec.x = x;
  _vec.y = y;
  return randVec2(_vec);
}
function randVec2(uv) {
  const dt = uv.x * RAND_A + uv.y * RAND_B;
  const sn = dt % Math.PI;
  return fract(Math.sin(sn) * RAND_C);
}
function rand(number) {
  if (CoreType.isNumber(number)) {
    return randFloat(number);
  } else {
    return randVec2(number);
  }
}
function round(number, stepSize) {
  const stepsCount = number / stepSize;
  const roundedStepsCount = number < 0 ? Math.ceil(stepsCount) : Math.floor(stepsCount);
  return roundedStepsCount * stepSize;
}
function highestEven(number) {
  return 2 * Math.ceil(number * 0.5);
}
function nearestPower2(num) {
  return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2)));
}
function pow2Inverse(num) {
  return Math.log(num) / Math.log(2);
}
var _triangleMid = new Vector3();
var _triangleMidToCorner = new Vector3();
function lerpFloat(current, target, blend) {
  return current * (1 - blend) + target * blend;
}
var CoreMath = class {
};
CoreMath.Easing = Easing;
CoreMath.degToRad = degToRad2;
CoreMath.radToDeg = radToDeg2;
CoreMath.clamp = clamp;
CoreMath.smoothstep = smoothstep2;
CoreMath.smootherstep = smootherstep2;
CoreMath.fit01 = fit01;
CoreMath.fit = fit;
CoreMath.fitClamp = fitClamp;
CoreMath.mix = mix;
CoreMath.fract = fract;
CoreMath.rand = rand;
CoreMath.round = round;
CoreMath.highestEven = highestEven;
CoreMath.nearestPower2 = nearestPower2;
CoreMath.pow2Inverse = pow2Inverse;
CoreMath.randFloat = randFloat;
CoreMath.randVec2 = randVec2;
CoreMath.lerpFloat = lerpFloat;

// node_modules/@polygonjs/polygonjs/dist/src/core/ArrayUtils.js
var _tmp = /* @__PURE__ */ new Set();
var _tmp0 = /* @__PURE__ */ new Set();
var _tmp1 = /* @__PURE__ */ new Set();
function range(start, end, step, target) {
  if (end == null) {
    end = start;
    start = 0;
  }
  const length = Math.floor((end - start) / step);
  target.length = length;
  for (let i2 = 0; i2 < length; i2++) {
    target[i2] = start + i2 * step;
  }
  return target;
}
function rangeWithEnd(end) {
  const target = [];
  range(0, end, 1, target);
  return target;
}
function arrayUniq(array, target) {
  target.length = 0;
  for (const element of array) {
    if (!target.includes(element)) {
      target.push(element);
    }
  }
  return target;
}
function uniqWithoutPreservingOrder(array, target) {
  arrayToSet(array, _tmp);
  return setToArray(_tmp, target);
}
function arrayCompact(array, target) {
  target.length = 0;
  for (const elem of array) {
    if (elem != null) {
      target.push(elem);
    }
  }
  return target;
}
function arrayMin(array) {
  let min = array[0];
  for (const element of array) {
    if (element < min) {
      min = element;
    }
  }
  return min;
}
function arrayMax(array) {
  let max = array[0];
  for (const element of array) {
    if (element > max) {
      max = element;
    }
  }
  return max;
}
function arraySum(array) {
  let sum = 0;
  for (const element of array) {
    sum += element;
  }
  return sum;
}
function arrayChunk(array, chunkSize) {
  const newArray = [];
  let newSubArray = [];
  newArray.push(newSubArray);
  for (let i2 = 0; i2 < array.length; i2++) {
    if (newSubArray.length == chunkSize) {
      newSubArray = [];
      newArray.push(newSubArray);
    }
    newSubArray.push(array[i2]);
  }
  return newArray;
}
function arrayUnion(array0, array1, target) {
  setUnion(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
function arrayIntersection(array0, array1, target) {
  setIntersection(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
function arrayDifference(array0, array1, target) {
  setDifference(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
function arrayToSet(array, target) {
  target.clear();
  for (const elem of array) {
    target.add(elem);
  }
  return target;
}
function arrayIsEqual(array0, array1) {
  if (array0.length != array1.length) {
    return false;
  }
  const count = array0.length;
  for (let i2 = 0; i2 < count; i2++) {
    if (array0[i2] != array1[i2]) {
      return false;
    }
  }
  return true;
}
function arraySortBy(array, callback) {
  if (array.length == 0) {
    return [];
  }
  const elementsByValue = /* @__PURE__ */ new Map();
  const valuesSet = /* @__PURE__ */ new Set();
  for (const elem of array) {
    const value = callback(elem);
    valuesSet.add(value);
    MapUtils.pushOnArrayAtEntry(elementsByValue, value, elem);
  }
  const values = new Array(valuesSet.size);
  let i2 = 0;
  valuesSet.forEach((value) => {
    values[i2] = value;
    i2++;
  });
  if (CoreType.isString(values[0])) {
    values.sort();
  } else {
    values.sort((a, b) => a - b);
  }
  const sorted_elements = new Array(array.length);
  i2 = 0;
  for (const value of values) {
    const elements_for_value = elementsByValue.get(value);
    if (elements_for_value) {
      for (const element of elements_for_value) {
        sorted_elements[i2] = element;
        i2++;
      }
    }
  }
  return sorted_elements;
}
function arrayShallowClone(array) {
  return [...array];
}
function arrayMap(array, callback, target) {
  target.length = 0;
  for (const item of array) {
    target.push(callback(item));
  }
  return target;
}
var ArrayUtils = class {
};
ArrayUtils.shallowClone = arrayShallowClone;
ArrayUtils.min = arrayMin;
ArrayUtils.max = arrayMax;
ArrayUtils.sum = arraySum;
ArrayUtils.compact = arrayCompact;
ArrayUtils.uniq = arrayUniq;
ArrayUtils.uniqWithoutPreservingOrder = uniqWithoutPreservingOrder;
ArrayUtils.chunk = arrayChunk;
ArrayUtils.union = arrayUnion;
ArrayUtils.intersection = arrayIntersection;
ArrayUtils.toSet = arrayToSet;
ArrayUtils.isEqual = arrayIsEqual;
ArrayUtils.sortBy = arraySortBy;
ArrayUtils.range = range;
function arrayPushItems(srcArray, target) {
  for (const item of srcArray) {
    target.push(item);
  }
}
function arrayCopy(srcArray, targetArray) {
  targetArray.length = 0;
  arrayPushItems(srcArray, targetArray);
}

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear;

// node_modules/lodash-es/eq.js
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_default(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
  var data = this.__data__, index = assocIndexOf_default(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet;

// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;

// node_modules/lodash-es/_stackClear.js
function stackClear() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear;

// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete;

// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet;

// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal;

// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;

// node_modules/lodash-es/_Symbol.js
var Symbol = root_default.Symbol;
var Symbol_default = Symbol;

// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
  try {
    value[symToStringTag] = void 0;
    var unmasked = true;
  } catch (e) {
  }
  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}
var getRawTag_default = getRawTag;

// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
  return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;

// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;

// node_modules/lodash-es/isObject.js
function isObject(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject;

// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction;

// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;

// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {
    }
    try {
      return func + "";
    } catch (e) {
    }
  }
  return "";
}
var toSource_default = toSource;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;

// node_modules/lodash-es/_getValue.js
function getValue(object, key) {
  return object == null ? void 0 : object[key];
}
var getValue_default = getValue;

// node_modules/lodash-es/_getNative.js
function getNative(object, key) {
  var value = getValue_default(object, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;

// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;

// node_modules/lodash-es/_hashClear.js
function hashClear() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear;

// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED ? void 0 : result;
  }
  return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;

// node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
  return this;
}
var hashSet_default = hashSet;

// node_modules/lodash-es/_Hash.js
function Hash(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear;

// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;

// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
  var data = getMapData_default(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet;

// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet;

// node_modules/lodash-es/_Stack.js
function Stack(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;

// node_modules/lodash-es/_arrayEach.js
function arrayEach(array, iteratee) {
  var index = -1, length = array == null ? 0 : array.length;
  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}
var arrayEach_default = arrayEach;

// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e) {
  }
}();
var defineProperty_default = defineProperty;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue;

// node_modules/lodash-es/_assignValue.js
var objectProto6 = Object.prototype;
var hasOwnProperty5 = objectProto6.hasOwnProperty;
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty5.call(object, key) && eq_default(objValue, value)) || value === void 0 && !(key in object)) {
    baseAssignValue_default(object, key, value);
  }
}
var assignValue_default = assignValue;

// node_modules/lodash-es/_copyObject.js
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});
  var index = -1, length = props.length;
  while (++index < length) {
    var key = props[index];
    var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object, key, newValue);
    } else {
      assignValue_default(object, key, newValue);
    }
  }
  return object;
}
var copyObject_default = copyObject;

// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
  var index = -1, result = Array(n);
  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}
var baseTimes_default = baseTimes;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;

// node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty6 = objectProto7.hasOwnProperty;
var propertyIsEnumerable = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_default = isArguments;

// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;

// node_modules/lodash-es/stubFalse.js
function stubFalse() {
  return false;
}
var stubFalse_default = stubFalse;

// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag2] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;

// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary;

// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty7 = objectProto8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty7.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys;

// node_modules/lodash-es/_isPrototype.js
var objectProto9 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto9;
  return value === proto;
}
var isPrototype_default = isPrototype;

// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;

// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty8 = objectProto10.hasOwnProperty;
function baseKeys(object) {
  if (!isPrototype_default(object)) {
    return nativeKeys_default(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty8.call(object, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;

// node_modules/lodash-es/keys.js
function keys(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object) : baseKeys_default(object);
}
var keys_default = keys;

// node_modules/lodash-es/_baseAssign.js
function baseAssign(object, source) {
  return object && copyObject_default(source, keys_default(source), object);
}
var baseAssign_default = baseAssign;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
function baseKeysIn(object) {
  if (!isObject_default(object)) {
    return nativeKeysIn_default(object);
  }
  var isProto = isPrototype_default(object), result = [];
  for (var key in object) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty9.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn;

// node_modules/lodash-es/keysIn.js
function keysIn(object) {
  return isArrayLike_default(object) ? arrayLikeKeys_default(object, true) : baseKeysIn_default(object);
}
var keysIn_default = keysIn;

// node_modules/lodash-es/_baseAssignIn.js
function baseAssignIn(object, source) {
  return object && copyObject_default(source, keysIn_default(source), object);
}
var baseAssignIn_default = baseAssignIn;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var Buffer2 = moduleExports3 ? root_default.Buffer : void 0;
var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_copyArray.js
function copyArray(source, array) {
  var index = -1, length = source.length;
  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}
var copyArray_default = copyArray;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array, predicate) {
  var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter;

// node_modules/lodash-es/stubArray.js
function stubArray() {
  return [];
}
var stubArray_default = stubArray;

// node_modules/lodash-es/_getSymbols.js
var objectProto12 = Object.prototype;
var propertyIsEnumerable2 = objectProto12.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter_default(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable2.call(object, symbol);
  });
};
var getSymbols_default = getSymbols;

// node_modules/lodash-es/_copySymbols.js
function copySymbols(source, object) {
  return copyObject_default(source, getSymbols_default(source), object);
}
var copySymbols_default = copySymbols;

// node_modules/lodash-es/_arrayPush.js
function arrayPush(array, values) {
  var index = -1, length = values.length, offset = array.length;
  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}
var arrayPush_default = arrayPush;

// node_modules/lodash-es/_getPrototype.js
var getPrototype = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype;

// node_modules/lodash-es/_getSymbolsIn.js
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols2 ? stubArray_default : function(object) {
  var result = [];
  while (object) {
    arrayPush_default(result, getSymbols_default(object));
    object = getPrototype_default(object);
  }
  return result;
};
var getSymbolsIn_default = getSymbolsIn;

// node_modules/lodash-es/_copySymbolsIn.js
function copySymbolsIn(source, object) {
  return copyObject_default(source, getSymbolsIn_default(source), object);
}
var copySymbolsIn_default = copySymbolsIn;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_default(object) ? result : arrayPush_default(result, symbolsFunc(object));
}
var baseGetAllKeys_default = baseGetAllKeys;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object) {
  return baseGetAllKeys_default(object, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;

// node_modules/lodash-es/_getAllKeysIn.js
function getAllKeysIn(object) {
  return baseGetAllKeys_default(object, keysIn_default, getSymbolsIn_default);
}
var getAllKeysIn_default = getAllKeysIn;

// node_modules/lodash-es/_DataView.js
var DataView = getNative_default(root_default, "DataView");
var DataView_default = DataView;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;

// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;

// node_modules/lodash-es/_getTag.js
var mapTag2 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag2 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag2 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag2 || Map_default && getTag(new Map_default()) != mapTag2 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag2 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
  getTag = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag2;
        case mapCtorString:
          return mapTag2;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag2;
        case weakMapCtorString:
          return weakMapTag2;
      }
    }
    return result;
  };
}
var getTag_default = getTag;

// node_modules/lodash-es/_initCloneArray.js
var objectProto13 = Object.prototype;
var hasOwnProperty10 = objectProto13.hasOwnProperty;
function initCloneArray(array) {
  var length = array.length, result = new array.constructor(length);
  if (length && typeof array[0] == "string" && hasOwnProperty10.call(array, "index")) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}
var initCloneArray_default = initCloneArray;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer;

// node_modules/lodash-es/_cloneDataView.js
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var cloneDataView_default = cloneDataView;

// node_modules/lodash-es/_cloneRegExp.js
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var cloneRegExp_default = cloneRegExp;

// node_modules/lodash-es/_cloneSymbol.js
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}
var cloneSymbol_default = cloneSymbol;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray;

// node_modules/lodash-es/_initCloneByTag.js
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag2:
      return cloneArrayBuffer_default(object);
    case boolTag2:
    case dateTag2:
      return new Ctor(+object);
    case dataViewTag3:
      return cloneDataView_default(object, isDeep);
    case float32Tag2:
    case float64Tag2:
    case int8Tag2:
    case int16Tag2:
    case int32Tag2:
    case uint8Tag2:
    case uint8ClampedTag2:
    case uint16Tag2:
    case uint32Tag2:
      return cloneTypedArray_default(object, isDeep);
    case mapTag3:
      return new Ctor();
    case numberTag2:
    case stringTag2:
      return new Ctor(object);
    case regexpTag2:
      return cloneRegExp_default(object);
    case setTag3:
      return new Ctor();
    case symbolTag:
      return cloneSymbol_default(object);
  }
}
var initCloneByTag_default = initCloneByTag;

// node_modules/lodash-es/_baseCreate.js
var objectCreate = Object.create;
var baseCreate = function() {
  function object() {
  }
  return function(proto) {
    if (!isObject_default(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object();
    object.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject(object) {
  return typeof object.constructor == "function" && !isPrototype_default(object) ? baseCreate_default(getPrototype_default(object)) : {};
}
var initCloneObject_default = initCloneObject;

// node_modules/lodash-es/_baseIsMap.js
var mapTag4 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_default(value) && getTag_default(value) == mapTag4;
}
var baseIsMap_default = baseIsMap;

// node_modules/lodash-es/isMap.js
var nodeIsMap = nodeUtil_default && nodeUtil_default.isMap;
var isMap = nodeIsMap ? baseUnary_default(nodeIsMap) : baseIsMap_default;
var isMap_default = isMap;

// node_modules/lodash-es/_baseIsSet.js
var setTag4 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_default(value) && getTag_default(value) == setTag4;
}
var baseIsSet_default = baseIsSet;

// node_modules/lodash-es/isSet.js
var nodeIsSet = nodeUtil_default && nodeUtil_default.isSet;
var isSet = nodeIsSet ? baseUnary_default(nodeIsSet) : baseIsSet_default;
var isSet_default = isSet;

// node_modules/lodash-es/_baseClone.js
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag5 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag3 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag2 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag3] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag3] = cloneableTags[dataViewTag4] = cloneableTags[boolTag3] = cloneableTags[dateTag3] = cloneableTags[float32Tag3] = cloneableTags[float64Tag3] = cloneableTags[int8Tag3] = cloneableTags[int16Tag3] = cloneableTags[int32Tag3] = cloneableTags[mapTag5] = cloneableTags[numberTag3] = cloneableTags[objectTag3] = cloneableTags[regexpTag3] = cloneableTags[setTag5] = cloneableTags[stringTag3] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag3] = cloneableTags[uint8ClampedTag3] = cloneableTags[uint16Tag3] = cloneableTags[uint32Tag3] = true;
cloneableTags[errorTag2] = cloneableTags[funcTag3] = cloneableTags[weakMapTag3] = false;
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_default(value)) {
    return value;
  }
  var isArr = isArray_default(value);
  if (isArr) {
    result = initCloneArray_default(value);
    if (!isDeep) {
      return copyArray_default(value, result);
    }
  } else {
    var tag = getTag_default(value), isFunc = tag == funcTag3 || tag == genTag2;
    if (isBuffer_default(value)) {
      return cloneBuffer_default(value, isDeep);
    }
    if (tag == objectTag3 || tag == argsTag3 || isFunc && !object) {
      result = isFlat || isFunc ? {} : initCloneObject_default(value);
      if (!isDeep) {
        return isFlat ? copySymbolsIn_default(value, baseAssignIn_default(result, value)) : copySymbols_default(value, baseAssign_default(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag_default(value, tag, isDeep);
    }
  }
  stack || (stack = new Stack_default());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_default(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_default(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? getAllKeysIn_default : getAllKeys_default : isFlat ? keysIn_default : keys_default;
  var props = isArr ? void 0 : keysFunc(value);
  arrayEach_default(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    assignValue_default(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var baseClone_default = baseClone;

// node_modules/lodash-es/cloneDeep.js
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG2 = 4;
function cloneDeep(value) {
  return baseClone_default(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
}
var cloneDeep_default = cloneDeep;

// node_modules/lodash-es/clone.js
var CLONE_SYMBOLS_FLAG3 = 4;
function clone(value) {
  return baseClone_default(value, CLONE_SYMBOLS_FLAG3);
}
var clone_default = clone;

// node_modules/@polygonjs/polygonjs/dist/src/core/ObjectUtils.js
function getObjectMethodNames(obj) {
  let properties = /* @__PURE__ */ new Set();
  let currentObj = obj;
  do {
    Object.getOwnPropertyNames(currentObj).map((item) => properties.add(item));
  } while (currentObj = Object.getPrototypeOf(currentObj));
  return [...properties.keys()].filter((item) => typeof obj[item] === "function");
}
function objectIsEqual(object0, object1) {
  if (CoreType.isBoolean(object0) && CoreType.isBoolean(object1)) {
    return object0 == object1;
  }
  if (CoreType.isNumber(object0) && CoreType.isNumber(object1)) {
    return object0 == object1;
  }
  if (CoreType.isString(object0) && CoreType.isString(object1)) {
    return object0 == object1;
  }
  if (CoreType.isObject(object0) && CoreType.isObject(object1)) {
    const keys0 = Object.keys(object0);
    const keys1 = Object.keys(object1);
    if (!arrayIsEqual(keys0, keys1)) {
      return false;
    }
    return JSON.stringify(object0) == JSON.stringify(object1);
  }
  return false;
}
function objectClone(value) {
  return clone_default(value);
}
function objectCloneDeep(value) {
  return cloneDeep_default(value);
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/assemblers/actor/ActorEvaluatorGenerator.js
var evaluatorGeneratorByObject = /* @__PURE__ */ new WeakMap();
function registerGeneratorForObject(object, generator) {
  let set = evaluatorGeneratorByObject.get(object);
  if (!set) {
    set = /* @__PURE__ */ new Set();
    evaluatorGeneratorByObject.set(object, set);
  }
  set.add(generator);
}
function deregisterGeneratorForObject(object, generator) {
  let set = evaluatorGeneratorByObject.get(object);
  if (!set) {
    return;
  }
  set.delete(generator);
}
var NOT_STORABLE_METHOD_NAMES = /* @__PURE__ */ new Set([
  "constructor",
  "onDispose",
  "dispose",
  "__defineGetter__",
  "__defineSetter__",
  "hasOwnProperty",
  "__lookupGetter__",
  "__lookupSetter__",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toString",
  "valueOf",
  "toLocaleString"
]);
var ActorEvaluatorGenerator = class {
  constructor(_func) {
    this._func = _func;
    this._expectedEvaluatorMethodNames = /* @__PURE__ */ new Set();
    this._evaluatorByObject = /* @__PURE__ */ new Map();
  }
  _createEvaluator(object) {
    return this._func(object);
  }
  setExpectedEvaluatorMethodNames(dummyEvaluator) {
    this._expectedEvaluatorMethodNames.clear();
    const methodNames = getObjectMethodNames(dummyEvaluator);
    for (const methodName of methodNames) {
      if (dummyEvaluator[methodName] && !NOT_STORABLE_METHOD_NAMES.has(methodName)) {
        this._expectedEvaluatorMethodNames.add(methodName);
      }
    }
  }
  hasExpectedEvaluatorMethodName(methodName) {
    return this._expectedEvaluatorMethodNames.has(methodName);
  }
  size() {
    return this._evaluatorByObject.size;
  }
  disposeEvaluator(object) {
    const evaluator = this._evaluatorByObject.get(object);
    if (!evaluator) {
      return;
    }
    evaluator.dispose();
    this._evaluatorByObject.delete(object);
  }
  findOrCreateEvaluator(object) {
    let evaluator = this._evaluatorByObject.get(object);
    if (!evaluator) {
      evaluator = this._createEvaluator(object);
      this._evaluatorByObject.set(object, evaluator);
      registerGeneratorForObject(object, this);
    }
    return evaluator;
  }
  traverseEvaluator(callback) {
    this._evaluatorByObject.forEach(callback);
  }
  clearObjects() {
    this._evaluatorByObject.forEach((evaluator, object) => {
      evaluator.dispose();
      deregisterGeneratorForObject(object, this);
    });
    this._evaluatorByObject.clear();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/PolyOnObjectsAddRemoveHooksController.js
var HandlerName = ((HandlerName2) => {
  HandlerName2["ADD"] = "onObjectAddHookHandlerNodeIds";
  HandlerName2["REMOVE"] = "onObjectRemoveHookHandlerNodeIds";
  return HandlerName2;
})(HandlerName || {});
function assignHookHandler(object, node, handlerName) {
  let ids = hookHandlers(object, handlerName);
  if (!ids) {
    ids = [];
    object.userData[handlerName] = ids;
  }
  const id = node.graphNodeId();
  if (!ids.includes(id)) {
    ids.push(id);
  }
}
function hookHandlers(object, handlerName) {
  return object.userData[handlerName];
}
function runHooks(scene, parent, handlerName) {
  const children = parent.children;
  for (let child of children) {
    child.traverse((grandChild) => {
      runHookOnObject(grandChild, scene, handlerName);
    });
  }
}
function runHookOnObject(object, scene, handlerName) {
  if (object.parent) {
    const ids = hookHandlers(object, handlerName);
    if (!ids) {
      return;
    }
    for (const id of ids) {
      const node = scene.graph.nodeFromId(id);
      if (node && !node.disposed()) {
        switch (handlerName) {
          case "onObjectAddHookHandlerNodeIds": {
            node.updateObjectOnAdd(object, object.parent);
            break;
          }
          case "onObjectRemoveHookHandlerNodeIds": {
            node.updateObjectOnRemove(object, object.parent);
            break;
          }
        }
      }
    }
  }
}
var PolyOnObjectsAddRemoveHooksController = class {
  assignOnAddHookHandler(object, node) {
    assignHookHandler(
      object,
      node,
      "onObjectAddHookHandlerNodeIds"
      /* ADD */
    );
  }
  assignOnRemoveHookHandler(object, node) {
    assignHookHandler(
      object,
      node,
      "onObjectRemoveHookHandlerNodeIds"
      /* REMOVE */
    );
  }
  runOnAddHooks(scene, parent) {
    runHooks(
      scene,
      parent,
      "onObjectAddHookHandlerNodeIds"
      /* ADD */
    );
  }
  runOnRemoveHooks(scene, parent) {
    runHooks(
      scene,
      parent,
      "onObjectRemoveHookHandlerNodeIds"
      /* REMOVE */
    );
  }
  runOnAddHookOnObject(scene, object) {
    runHookOnObject(
      object,
      scene,
      "onObjectAddHookHandlerNodeIds"
      /* ADD */
    );
  }
  runOnRemoveHookOnObject(scene, object) {
    runHookOnObject(
      object,
      scene,
      "onObjectRemoveHookHandlerNodeIds"
      /* REMOVE */
    );
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/PolyOnSceneUpdatedHooksController.js
var PolyOnSceneUpdatedHooksController = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  registerHook(node, hook) {
    this._map.set(node, hook);
    this._updateCache();
  }
  unregisterHook(node) {
    this._map.delete(node);
    this._updateCache();
  }
  runHooks() {
    const hooks = this._hooks;
    if (!hooks) {
      return;
    }
    for (let hook of hooks) {
      hook();
    }
  }
  hookedNodes() {
    return Array.from(this._map.keys());
  }
  _updateCache() {
    if (this._map.size == 0) {
      this._hooks = void 0;
    } else {
      this._hooks = this._hooks || [];
      this._hooks.length = 0;
      const hooks = this._hooks;
      this._map.forEach((hook) => hooks.push(hook));
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/PolySpecializedChildrenController.js
var PolySpecializedChildrenController = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  registerHook(hookName, hook) {
    this._map.set(hookName, hook);
    this._updateCache();
  }
  _updateCache() {
    this._hooks = [];
    const hooks = this._hooks;
    this._map.forEach((hook) => {
      hooks.push(hook);
    });
  }
  runHooks(displayNode, coreGroup, newObjects, params) {
    let newObjectsAreDifferent = false;
    if (this._hooks) {
      for (let hook of this._hooks) {
        const _newObjectsAreDifferent = hook(displayNode, coreGroup, newObjects, params);
        if (_newObjectsAreDifferent) {
          newObjectsAreDifferent = true;
        }
      }
    }
    return newObjectsAreDifferent;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/plugins/Plugin.js
var PolyPlugin = class {
  constructor(_name, _callback, _options) {
    this._name = _name;
    this._callback = _callback;
    this._options = _options;
  }
  name() {
    return this._name;
  }
  libraryName() {
    return this._options.libraryName;
  }
  init(poly) {
    this._callback(poly);
  }
  toJSON() {
    return {
      name: this._name,
      libraryName: this._options.libraryName,
      libraryImportPath: this._options.libraryImportPath
    };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/plugins/PluginsRegister.js
var PluginsRegister = class {
  constructor(poly) {
    this.poly = poly;
    this._pluginsByName = /* @__PURE__ */ new Map();
    this._pluginNameByNodeContextByType = /* @__PURE__ */ new Map();
    this._pluginNameByOperationContextByType = /* @__PURE__ */ new Map();
  }
  async wrapConfigurePolygonjs(callback) {
    this._configurePolygonjsPlugin = this._configurePolygonjsPlugin || new PolyPlugin("configurePolygonjs", () => {
    }, { libraryImportPath: "../PolyConfig", libraryName: "" });
    this._currentPlugin = this._configurePolygonjsPlugin;
    this._pluginsByName.set(this._currentPlugin.name(), this._currentPlugin);
    await callback();
    this._currentPlugin = void 0;
  }
  register(plugin) {
    const previousCurrentPlugin = this._currentPlugin;
    this._currentPlugin = plugin;
    this._pluginsByName.set(plugin.name(), plugin);
    plugin.init(this.poly);
    this._currentPlugin = previousCurrentPlugin;
  }
  pluginByName(pluginName) {
    return this._pluginsByName.get(pluginName);
  }
  registerNode(node) {
    if (!this._currentPlugin) {
      return;
    }
    const context = node.context();
    const type = node.type();
    let mapForContext = this._pluginNameByNodeContextByType.get(context);
    if (!mapForContext) {
      mapForContext = /* @__PURE__ */ new Map();
      this._pluginNameByNodeContextByType.set(context, mapForContext);
    }
    mapForContext.set(type, this._currentPlugin.name());
  }
  registerOperation(operation) {
    if (!this._currentPlugin) {
      return;
    }
    const context = operation.context();
    const type = operation.type();
    let mapForContext = this._pluginNameByOperationContextByType.get(context);
    if (!mapForContext) {
      mapForContext = /* @__PURE__ */ new Map();
      this._pluginNameByOperationContextByType.set(context, mapForContext);
    }
    mapForContext.set(type, this._currentPlugin.name());
  }
  toJson() {
    const data = {
      plugins: {},
      nodes: {},
      operations: {}
    };
    this._pluginsByName.forEach((plugin, name) => {
      data.plugins[name] = plugin.toJSON();
    });
    this._pluginNameByNodeContextByType.forEach((mapForContext, context) => {
      data.nodes[context] = {};
      mapForContext.forEach((pluginName, type) => {
        data.nodes[context][type] = pluginName;
      });
    });
    this._pluginNameByOperationContextByType.forEach((mapForContext, context) => {
      data.operations[context] = {};
      mapForContext.forEach((pluginName, type) => {
        data.operations[context][type] = pluginName;
      });
    });
    return data;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/cameras/PolyCamerasRegister.js
var PolyCamerasRegister = class {
  constructor(poly) {
    this._cameraNodeTypes = [];
    this._registeredViewerCreateCallbackByCamera = /* @__PURE__ */ new Map();
  }
  registerNodeType(nodeType) {
    if (!this._cameraNodeTypes.includes(nodeType)) {
      this._cameraNodeTypes.push(nodeType);
    }
  }
  registeredNodeTypes() {
    return this._cameraNodeTypes;
  }
  register(cameraClass, viewerCreateCallback) {
    this._registeredViewerCreateCallbackByCamera.set(cameraClass, viewerCreateCallback);
  }
  createViewer(options) {
    const callback = this._registeredViewerCreateCallbackByCamera.get(options.camera.constructor);
    if (!callback) {
      console.error("no createViewer callback available");
      console.log(
        "createViewer",
        options.camera,
        options.camera.constructor,
        this._registeredViewerCreateCallbackByCamera
      );
      return;
    }
    return callback(options);
  }
  objectRegistered(object) {
    const callback = this._registeredViewerCreateCallbackByCamera.get(object.constructor);
    return callback != null;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/modules/_BaseRegister.js
var BaseModulesRegister = class {
  constructor(poly) {
    this.poly = poly;
    this._moduleByName = /* @__PURE__ */ new Map();
  }
  register(moduleName, module2, options) {
    let printWarnings = options == null ? void 0 : options.printWarnings;
    if (printWarnings == null) {
      printWarnings = true;
    }
    if (this._moduleByName.has(moduleName) && printWarnings) {
      console.warn("module already registered", moduleName);
      return;
    }
    this._moduleByName.set(moduleName, module2);
    module2.onRegister(this.poly);
  }
  moduleNames() {
    const list = [];
    this._moduleByName.forEach((module2, moduleName) => {
      list.push(moduleName);
    });
    return list;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/modules/DynamicModulesRegister.js
var DynamicModulesRegister = class extends BaseModulesRegister {
  // module<K extends keyof ModulesMap>(moduleName: K): ModulesMap[K] {
  // 	return super.module(moduleName as any);
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/expressions/_BaseRegister.js
var BaseExpressionRegister = class {
  constructor() {
    this._methodsNames = [];
    this._methodsByName = /* @__PURE__ */ new Map();
  }
  register(expression, name) {
    this._methodsNames.push(name);
    this._methodsByName.set(name, expression);
  }
  getMethod(name) {
    return this._methodsByName.get(name);
  }
  availableMethods() {
    return this._methodsNames;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/expressions/ExpressionRegister.js
var ExpressionRegister = class extends BaseExpressionRegister {
  getMethod(name) {
    return super.getMethod(name);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/assemblers/_BaseRegister.js
var AssemblerName = ((AssemblerName2) => {
  AssemblerName2["GL_CLOTH"] = "GL_CLOTH";
  AssemblerName2["GL_LINE"] = "GL_LINE";
  AssemblerName2["GL_MESH_BASIC"] = "GL_MESH_BASIC";
  AssemblerName2["GL_MESH_DEPTH"] = "GL_MESH_DEPTH";
  AssemblerName2["GL_MESH_DISTANCE"] = "GL_MESH_DISTANCE";
  AssemblerName2["GL_MESH_LAMBERT"] = "GL_MESH_LAMBERT";
  AssemblerName2["GL_MESH_PHONG"] = "GL_MESH_PHONG";
  AssemblerName2["GL_MESH_PHYSICAL"] = "GL_MESH_PHYSICAL";
  AssemblerName2["GL_MESH_STANDARD"] = "GL_MESH_STANDARD";
  AssemblerName2["GL_MESH_TOON"] = "GL_MESH_TOON";
  AssemblerName2["GL_PARTICLES"] = "GL_PARTICLES";
  AssemblerName2["GL_POINTS"] = "GL_POINTS";
  AssemblerName2["GL_POST"] = "GL_POST";
  AssemblerName2["GL_RAYMARCHING"] = "GL_RAYMARCHING";
  AssemblerName2["GL_TEXTURE"] = "GL_TEXTURE";
  AssemblerName2["GL_TEXTURE_2D_ARRAY"] = "GL_TEXTURE_2D_ARRAY";
  AssemblerName2["GL_VOLUME"] = "GL_VOLUME";
  AssemblerName2["JS_ACTOR"] = "JS_ACTOR";
  AssemblerName2["JS_ENTITY_BUILDER"] = "JS_ENTITY_BUILDER";
  AssemblerName2["JS_INSTANCE_BUILDER"] = "JS_INSTANCE_BUILDER";
  AssemblerName2["JS_OBJECT_BUILDER"] = "JS_OBJECT_BUILDER";
  AssemblerName2["JS_POINT_BUILDER"] = "JS_POINT_BUILDER";
  AssemblerName2["JS_SDF"] = "JS_SDF";
  AssemblerName2["JS_SOFT_BODY"] = "JS_SOFT_BODY";
  return AssemblerName2;
})(AssemblerName || {});
var BaseAssemblersRegister = class {
  constructor() {
    this._controllerAssemblerByName = /* @__PURE__ */ new Map();
  }
  register(name, controller, assembler) {
    this._controllerAssemblerByName.set(name, {
      controller,
      assembler
    });
  }
  unregister(name) {
    this._controllerAssemblerByName.delete(name);
  }
  traverse(callback) {
    this._controllerAssemblerByName.forEach(callback);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/assemblers/AssemblersRegistry.js
var AssemblersRegister = class extends BaseAssemblersRegister {
  assembler(node, name) {
    const pair = this._controllerAssemblerByName.get(name);
    if (pair) {
      const { controller, assembler } = pair;
      return new controller(node, assembler);
    }
    return pair;
  }
  unregister(name) {
    const pair = this._controllerAssemblerByName.get(name);
    super.unregister(name);
    return pair;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/NodesRegister.js
var NodesRegister = class _NodesRegister {
  constructor(poly) {
    this.poly = poly;
    this._nodesRegister = /* @__PURE__ */ new Map();
    this._nodesRegisterCategories = /* @__PURE__ */ new Map();
    this._nodesRegisterOptions = /* @__PURE__ */ new Map();
  }
  static type(node) {
    return this.filterType(node.type());
  }
  static filterType(nodeType) {
    return nodeType.toLowerCase();
  }
  register(node, tabMenuCategory, options) {
    var _a, _b;
    const context = node.context();
    const nodeType = _NodesRegister.type(node);
    let printWarnings = options == null ? void 0 : options.printWarnings;
    if (printWarnings == null) {
      printWarnings = true;
    }
    let current_nodes_for_context = this._nodesRegister.get(context);
    if (!current_nodes_for_context) {
      current_nodes_for_context = /* @__PURE__ */ new Map();
      this._nodesRegister.set(context, current_nodes_for_context);
    }
    const alreadyRegisteredNode = current_nodes_for_context.get(nodeType);
    if (alreadyRegisteredNode) {
      const isAlreadyRegisteredNodePolyNode = ((_b = (_a = this._nodesRegisterOptions.get(context)) == null ? void 0 : _a.get(nodeType)) == null ? void 0 : _b.polyNode) == true;
      const isNewNodePolyNode = (options == null ? void 0 : options.polyNode) == true;
      if (isAlreadyRegisteredNodePolyNode && isNewNodePolyNode) {
      } else {
        if (printWarnings) {
          console.warn(`node ${context}/${nodeType} already registered`);
        }
        return;
      }
    }
    current_nodes_for_context.set(nodeType, node);
    if (node.onRegister) {
      node.onRegister(this.poly);
    }
    if (tabMenuCategory) {
      let current_categories = this._nodesRegisterCategories.get(context);
      if (!current_categories) {
        current_categories = /* @__PURE__ */ new Map();
        this._nodesRegisterCategories.set(context, current_categories);
      }
      const savedCategory = CoreType.isArray(tabMenuCategory) ? tabMenuCategory : [tabMenuCategory];
      current_categories.set(nodeType, savedCategory);
    }
    if (options) {
      let current_options = this._nodesRegisterOptions.get(context);
      if (!current_options) {
        current_options = /* @__PURE__ */ new Map();
        this._nodesRegisterOptions.set(context, current_options);
      }
      current_options.set(nodeType, options);
    }
    this.poly.pluginsRegister.registerNode(node);
  }
  deregister(context, nodeType) {
    var _a, _b, _c;
    nodeType = _NodesRegister.filterType(nodeType);
    (_a = this._nodesRegister.get(context)) == null ? void 0 : _a.delete(nodeType);
    (_b = this._nodesRegisterCategories.get(context)) == null ? void 0 : _b.delete(nodeType);
    (_c = this._nodesRegisterOptions.get(context)) == null ? void 0 : _c.delete(nodeType);
  }
  isRegistered(context, nodeType) {
    const nodes_for_context = this._nodesRegister.get(context);
    if (!nodes_for_context) {
      return false;
    }
    nodeType = _NodesRegister.filterType(nodeType);
    return nodes_for_context.get(nodeType) != null;
  }
  nodeOptions(context, nodeType) {
    var _a;
    nodeType = _NodesRegister.filterType(nodeType);
    return (_a = this._nodesRegisterOptions.get(context)) == null ? void 0 : _a.get(nodeType);
  }
  registeredNodesForParentNode(parentNode) {
    var _a, _b;
    const context = (_a = parentNode.childrenController) == null ? void 0 : _a.context;
    if (!context) {
      return [];
    }
    const map = this._nodesRegister.get(context);
    if (map) {
      const nodes_for_context = [];
      (_b = this._nodesRegister.get(context)) == null ? void 0 : _b.forEach((node, type) => {
        nodes_for_context.push(node);
      });
      return nodes_for_context.filter((node) => {
        const nodeType = _NodesRegister.type(node);
        const options = this.nodeOptions(context, nodeType);
        if (!options) {
          return true;
        } else {
          const parentOptions = this.nodeOptions(parentNode.context(), parentNode.type());
          if ((parentOptions == null ? void 0 : parentOptions.polyNode) == true) {
            return true;
          }
          const option_only = options["only"];
          const option_except = options["except"];
          const context_and_type = `${parentNode.context()}/${parentNode.type()}`;
          if (option_only) {
            return option_only.includes(context_and_type);
          }
          if (option_except) {
            return !option_except.includes(context_and_type);
          }
          return true;
        }
      });
    } else {
      return [];
    }
  }
  registeredNodes(parentNode) {
    const nodesByType = {};
    const nodes = this.registeredNodesForParentNode(parentNode);
    for (let node of nodes) {
      const nodeType = _NodesRegister.type(node);
      nodesByType[nodeType] = node;
    }
    return nodesByType;
  }
  registeredCategory(context, nodeType) {
    var _a;
    nodeType = _NodesRegister.filterType(nodeType);
    return (_a = this._nodesRegisterCategories.get(context)) == null ? void 0 : _a.get(nodeType);
  }
  map() {
    return this._nodesRegister;
  }
};
var OperationsRegister = class _OperationsRegister {
  constructor(poly) {
    this.poly = poly;
    this._operation_register = /* @__PURE__ */ new Map();
  }
  static type(node) {
    return this.filterType(node.type());
  }
  static filterType(nodeType) {
    return nodeType.toLowerCase();
  }
  register(operation, options) {
    let printWarnings = options == null ? void 0 : options.printWarnings;
    if (printWarnings == null) {
      printWarnings = true;
    }
    const context = operation.context();
    let current_operations_for_context = this._operation_register.get(context);
    if (!current_operations_for_context) {
      current_operations_for_context = /* @__PURE__ */ new Map();
      this._operation_register.set(context, current_operations_for_context);
    }
    const operationType = _OperationsRegister.type(operation);
    const already_registered_operation = current_operations_for_context.get(operationType);
    if (already_registered_operation) {
      if (printWarnings) {
        const message = `operation ${context}/${operationType} already registered`;
        console.warn(message);
      }
      return;
    }
    current_operations_for_context.set(operationType, operation);
    if (operation.onRegister) {
      operation.onRegister(this.poly);
    }
    this.poly.pluginsRegister.registerOperation(operation);
  }
  registeredOperationsForContextAndParentType(context, parentNodeType) {
    var _a;
    const map = this._operation_register.get(context);
    if (map) {
      const nodes_for_context = [];
      (_a = this._operation_register.get(context)) == null ? void 0 : _a.forEach((operation, type) => {
        nodes_for_context.push(operation);
      });
      return nodes_for_context;
    } else {
      return [];
    }
  }
  registeredOperation(context, operationType) {
    const current_operations_for_context = this._operation_register.get(context);
    if (current_operations_for_context) {
      operationType = _OperationsRegister.filterType(operationType);
      return current_operations_for_context.get(operationType);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/functions/_BaseRegister.js
var BaseNamedFunctionRegister = class {
  constructor() {
    this._functionByName = /* @__PURE__ */ new Map();
  }
  register(namedFunction, options) {
    let printWarnings = options == null ? void 0 : options.printWarnings;
    if (printWarnings == null) {
      printWarnings = true;
    }
    const type = namedFunction.type();
    if (this._functionByName.has(type) && printWarnings) {
      console.warn(`namedFunction already registered`, type);
    }
    this._functionByName.set(type, namedFunction);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/functions/FunctionsRegister.js
var NamedFunctionRegister = class extends BaseNamedFunctionRegister {
  getFunction(functionName, node, shadersCollectionController) {
    const funcClass = this._functionByName.get(functionName);
    if (!funcClass) {
      console.error(`function not registered:'${functionName}'`);
    }
    const func = new funcClass(node, shadersCollectionController);
    return func;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/Poly.js
var POLYGONJS_VERSION = "1.5.60";
var PolyEngine = class _PolyEngine {
  constructor() {
    this.renderersController = new RenderersController();
    this.scenesRegister = new ScenesRegister();
    this.nodesRegister = new NodesRegister(this);
    this.operationsRegister = new OperationsRegister(this);
    this.expressionsRegister = new ExpressionRegister();
    this.assemblersRegister = new AssemblersRegister();
    this.pluginsRegister = new PluginsRegister(this);
    this.camerasRegister = new PolyCamerasRegister(this);
    this.modulesRegister = new DynamicModulesRegister(this);
    this.namedFunctionsRegister = new NamedFunctionRegister();
    this.blobs = new BlobsController(this);
    this.assetUrls = new AssetUrlsController();
    this.thirdParty = new PolyThirdPartyController();
    this.onObjectsAddRemoveHooks = new PolyOnObjectsAddRemoveHooksController();
    this.onSceneUpdatedHooks = new PolyOnSceneUpdatedHooksController();
    this.specializedChildren = new PolySpecializedChildrenController();
    this.performance = new PolyPerformanceformanceController();
    this.scenesByUuid = {};
    this._playerMode = true;
    this._logger = null;
  }
  static _instance_() {
    if (window.__POLYGONJS_POLY_INSTANCE__) {
      return window.__POLYGONJS_POLY_INSTANCE__;
    } else {
      const instance = new _PolyEngine();
      window.__POLYGONJS_POLY_INSTANCE__ = instance;
      return window.__POLYGONJS_POLY_INSTANCE__;
    }
  }
  version() {
    return POLYGONJS_VERSION;
  }
  setPlayerMode(mode) {
    this._playerMode = mode;
  }
  playerMode() {
    return this._playerMode;
  }
  dispose() {
    this.scenesRegister.dispose();
    this.renderersController.dispose();
  }
  registerNode(node, tab_menu_category, options) {
    this.nodesRegister.register(node, tab_menu_category, options);
  }
  registerOperation(operation, options) {
    this.operationsRegister.register(operation, options);
  }
  registerNamedFunction(namedFunction, options) {
    this.namedFunctionsRegister.register(namedFunction, options);
  }
  registerCamera(cameraClass, viewerCreateCallback) {
    this.camerasRegister.register(cameraClass, viewerCreateCallback);
  }
  registerCameraNodeType(nodeType) {
    this.camerasRegister.registerNodeType(nodeType);
  }
  registerPlugin(plugin) {
    this.pluginsRegister.register(plugin);
  }
  wrapConfigurePolygonjs(callback) {
    this.pluginsRegister.wrapConfigurePolygonjs(callback);
  }
  registeredNodes(parentNode) {
    return this.nodesRegister.registeredNodes(parentNode);
  }
  registeredOperation(parent_context, operation_type) {
    return this.operationsRegister.registeredOperation(parent_context, operation_type);
  }
  // registeredCameraTypes() {
  // 	return this.camerasRegister.registeredTypes();
  // }
  registerModule(module2, options) {
    this.modulesRegister.register(module2.moduleName, module2, options);
  }
  inWorkerThread() {
    return false;
  }
  get libs() {
    return this._libs_controller = this._libs_controller || new PolyLibsController();
  }
  //
  //
  // ENV
  //
  //
  setEnv(env) {
    this._env = env;
  }
  env() {
    return this._env;
  }
  //
  //
  // LOGGER
  //
  //
  setLogger(logger) {
    this._logger = logger;
  }
  logger() {
    return this._logger;
  }
  log(message, ...optionalParams) {
    var _a;
    (_a = this._logger) == null ? void 0 : _a.log(...[message, ...optionalParams]);
  }
  warn(message, ...optionalParams) {
    var _a;
    (_a = this._logger) == null ? void 0 : _a.warn(...[message, ...optionalParams]);
  }
  error(message, ...optionalParams) {
    var _a;
    (_a = this._logger) == null ? void 0 : _a.error(...[message, ...optionalParams]);
  }
};
var Poly = PolyEngine._instance_();

export {
  PowerPreference,
  POWER_PREFERENCES,
  RendererPrecision,
  RENDERER_PRECISIONS,
  WEBGL_RENDERER_DEFAULT_PARAMS,
  pushOnArrayAtEntry,
  addToSetAtEntry,
  mapValuesToArray,
  MapUtils,
  setToArray,
  setUnion,
  setIntersection,
  setDifference,
  Easing,
  radToDeg2 as radToDeg,
  CoreMath,
  range,
  rangeWithEnd,
  arrayUniq,
  arrayCompact,
  arraySum,
  arrayUnion,
  arrayDifference,
  arrayToSet,
  arrayIsEqual,
  arraySortBy,
  arrayShallowClone,
  arrayMap,
  arrayPushItems,
  arrayCopy,
  objectIsEqual,
  objectClone,
  objectCloneDeep,
  ActorEvaluatorGenerator,
  AssemblerName,
  PolyEngine,
  Poly
};
//# sourceMappingURL=chunk-O564GFGZ.js.map
