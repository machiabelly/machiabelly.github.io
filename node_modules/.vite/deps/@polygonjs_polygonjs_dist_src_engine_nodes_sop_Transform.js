import {
  CoreMask
} from "./chunk-W3H7NWH6.js";
import {
  TypedSopNode
} from "./chunk-XJZFUBTR.js";
import {
  SopType
} from "./chunk-OBFUH3H6.js";
import "./chunk-VPW6KKKV.js";
import {
  BaseSopOperation,
  CoreTransform,
  InputCloneMode,
  NodeParamsConfig,
  OBJECT_TRANSFORM_MODES,
  OBJECT_TRANSFORM_SPACES,
  OBJECT_TRANSFORM_SPACE_MENU_ENTRIES,
  ObjectTransformMode,
  ObjectTransformSpace,
  ParamConfig,
  ROTATION_ORDERS,
  RotationOrder,
  TRANSFORM_TARGET_TYPES,
  TransformTargetType,
  TypeAssert,
  applyTransformWithSpaceToObject,
  coreObjectClassFactory,
  isObject3D,
  pointsFromObjectFromGroup
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import "./chunk-O564GFGZ.js";
import {
  Euler,
  MathUtils,
  Matrix4,
  Quaternion,
  Vector3
} from "./chunk-6OBTIB4K.js";
import "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/Transform.js
var _r = new Vector3();
var _euler = new Euler();
var _q = new Quaternion();
var _s = new Vector3();
var _mat4 = new Matrix4();
var _pointPos = new Vector3();
var _points = [];
var TransformSopOperation = class extends BaseSopOperation {
  constructor() {
    super(...arguments);
    this._coreTransform = new CoreTransform();
  }
  static type() {
    return SopType.TRANSFORM;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const selectedObjects = CoreMask.filterObjects(coreGroup, params);
    for (const inputObject of selectedObjects) {
      this._applyTransform(inputObject, coreGroup, params);
    }
    coreGroup.resetBoundingBox();
    return coreGroup;
  }
  _applyTransform(object, coreGroup, params) {
    if (isObject3D(object)) {
      this._applyTransformWithTransformTargetType(object, coreGroup, params);
    } else {
      this._applyTransformWithoutTransformTargetType(object, params);
    }
  }
  _applyTransformWithoutTransformTargetType(object, params) {
    this._updateObject(object, params);
  }
  _applyTransformWithTransformTargetType(object, coreGroup, params) {
    const mode = TRANSFORM_TARGET_TYPES[params.applyOn];
    switch (mode) {
      case TransformTargetType.GEOMETRY: {
        return this._updateGeometry(object, params);
      }
      case TransformTargetType.OBJECT: {
        return this._updateObject(object, params);
      }
    }
    TypeAssert.unreachable(mode);
  }
  // private _applyCadTransform(objects: CadCoreObject<CadGeometryType>[]|undefined, params: TransformSopParams) {
  // 	if(!objects){
  // 		return
  // 	}
  // 	for(let object of objects){
  // 		cadTransform(object, params.t, params.r, params.scale)
  // 	}
  // }
  _updateGeometry(object, params) {
    const matrix = this._matrix(params);
    const pointGroup = params.pointGroup;
    if (pointGroup.trim() === "") {
      const geometry = object.geometry;
      if (geometry) {
        geometry.translate(-params.pivot.x, -params.pivot.y, -params.pivot.z);
        geometry.applyMatrix4(matrix);
        geometry.translate(params.pivot.x, params.pivot.y, params.pivot.z);
      }
    } else {
      pointsFromObjectFromGroup(object, pointGroup, _points);
      for (const point of _points) {
        const position = point.position(_pointPos).sub(params.pivot);
        position.applyMatrix4(matrix);
        point.setPosition(position.add(params.pivot));
      }
    }
  }
  _updateObject(object, params) {
    const objectMode = OBJECT_TRANSFORM_MODES[params.objectMode];
    switch (objectMode) {
      case ObjectTransformMode.SET: {
        return this._setMatrix(object, params);
      }
      case ObjectTransformMode.MULT: {
        return this._multMatrix(object, params);
      }
    }
    TypeAssert.unreachable(objectMode);
  }
  _setMatrix(object, params) {
    const order = ROTATION_ORDERS[params.rotationOrder];
    _r.copy(params.r).multiplyScalar(MathUtils.DEG2RAD);
    _euler.set(_r.x, _r.y, _r.z, order);
    _q.setFromEuler(_euler);
    _s.copy(params.s).multiplyScalar(params.scale);
    _mat4.compose(params.t, _q, _s);
    coreObjectClassFactory(object).applyMatrix(
      object,
      _mat4,
      TRANSFORM_TARGET_TYPES[params.applyOn],
      ObjectTransformSpace.LOCAL,
      ObjectTransformMode.SET
    );
  }
  // private _objectPosition = new Vector3();
  _multMatrix(object, params) {
    const matrix = this._matrix(params);
    const transformSpace = OBJECT_TRANSFORM_SPACES[params.objectTransformSpace];
    applyTransformWithSpaceToObject(object, matrix, transformSpace, ObjectTransformMode.MULT);
  }
  _matrix(params) {
    return this._coreTransform.matrix(
      params.t,
      params.r,
      params.s,
      params.scale,
      ROTATION_ORDERS[params.rotationOrder]
    );
  }
};
TransformSopOperation.DEFAULT_PARAMS = {
  applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY),
  group: "",
  objectMode: OBJECT_TRANSFORM_MODES.indexOf(ObjectTransformMode.SET),
  objectTransformSpace: OBJECT_TRANSFORM_SPACES.indexOf(ObjectTransformSpace.PARENT),
  pointGroup: "",
  rotationOrder: ROTATION_ORDERS.indexOf(RotationOrder.XYZ),
  t: new Vector3(0, 0, 0),
  r: new Vector3(0, 0, 0),
  s: new Vector3(1, 1, 1),
  scale: 1,
  pivot: new Vector3(0, 0, 0)
};
TransformSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/Transform.js
var DEFAULT = TransformSopOperation.DEFAULT_PARAMS;
var TransformSopParamConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.applyOn = ParamConfig.INTEGER(DEFAULT.applyOn, {
      menu: {
        entries: TRANSFORM_TARGET_TYPES.map((name, value) => ({ name, value }))
      }
    });
    this.group = ParamConfig.STRING(DEFAULT.group, {
      objectMask: true
    });
    this.objectMode = ParamConfig.INTEGER(DEFAULT.objectMode, {
      visibleIf: { applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT) },
      menu: {
        entries: OBJECT_TRANSFORM_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    this.objectTransformSpace = ParamConfig.INTEGER(0, {
      visibleIf: {
        applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT),
        objectMode: OBJECT_TRANSFORM_MODES.indexOf(ObjectTransformMode.MULT)
      },
      menu: {
        entries: OBJECT_TRANSFORM_SPACE_MENU_ENTRIES
      }
    });
    this.pointGroup = ParamConfig.STRING(DEFAULT.pointGroup, {
      visibleIf: { applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY) }
    });
    this.rotationOrder = ParamConfig.INTEGER(DEFAULT.rotationOrder, {
      separatorBefore: true,
      menu: {
        entries: ROTATION_ORDERS.map((order, v) => {
          return { name: order, value: v };
        })
      }
    });
    this.t = ParamConfig.VECTOR3(DEFAULT.t);
    this.r = ParamConfig.VECTOR3(DEFAULT.r);
    this.s = ParamConfig.VECTOR3(DEFAULT.s);
    this.scale = ParamConfig.FLOAT(DEFAULT.scale, {
      range: [0, 2],
      step: 0.01
    });
    this.pivot = ParamConfig.VECTOR3(DEFAULT.pivot, {
      visibleIf: { applyOn: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY) }
    });
  }
};
var ParamsConfig = new TransformSopParamConfig();
var TransformSopNode = class extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.TRANSFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(TransformSopOperation.INPUT_CLONED_STATE);
  }
  setApplyOn(type) {
    this.p.applyOn.set(TRANSFORM_TARGET_TYPES.indexOf(type));
  }
  applyOn() {
    return TRANSFORM_TARGET_TYPES[this.pv.applyOn];
  }
  setObjectMode(mode) {
    this.p.objectMode.set(OBJECT_TRANSFORM_MODES.indexOf(mode));
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new TransformSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
};
export {
  TransformSopNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_sop_Transform.js.map
