import "./chunk-HNBBUMSC.js";
import {
  CoreMask
} from "./chunk-W3H7NWH6.js";
import {
  CORE_CAMERA_DEFAULT,
  CameraAttribute,
  CoreCameraPostProcessController,
  OrthographicCameraAttribute
} from "./chunk-ALDW4QX7.js";
import {
  HierarchyController,
  ObjChildrenDisplayController,
  ObjType,
  TransformController,
  TransformedParamConfig
} from "./chunk-GP5RO6D3.js";
import {
  DisplayNodeController
} from "./chunk-F6CWW4TB.js";
import "./chunk-OBFUH3H6.js";
import {
  ACCEPTED_KEYBOARD_EVENT_TYPES,
  CoreEventEmitter,
  DESIRED_FPS,
  EVENT_EMITTERS,
  createRaycaster
} from "./chunk-DSYQHAWE.js";
import {
  CorePath
} from "./chunk-VPW6KKKV.js";
import "./chunk-3T7UEVUR.js";
import "./chunk-EGRHWZRV.js";
import {
  ObjNodeRenderOrder,
  TypedObjNode
} from "./chunk-26GUALO3.js";
import {
  BaseSopOperation,
  CoreTransform,
  FlagsController,
  FlagsControllerD,
  InputCloneMode,
  NodeParamsConfig,
  ObjectType,
  ParamConfig,
  ThreejsCoreObject,
  TypedNode,
  coreObjectClassFactory,
  registerObjectType
} from "./chunk-FUAFRKQ7.js";
import {
  TypedNodePathParamValue
} from "./chunk-RVFV2LA3.js";
import {
  POWER_PREFERENCES,
  Poly,
  PowerPreference,
  RENDERER_PRECISIONS,
  RendererPrecision,
  WEBGL_RENDERER_DEFAULT_PARAMS
} from "./chunk-O564GFGZ.js";
import {
  ACESFilmicToneMapping,
  BasicShadowMap,
  BufferGeometry,
  CineonToneMapping,
  Color,
  CoreType,
  DisplayP3ColorSpace,
  EventDispatcher,
  Float32BufferAttribute,
  LineBasicMaterial,
  LineSegments,
  LinearDisplayP3ColorSpace,
  LinearSRGBColorSpace,
  LinearToneMapping,
  MathUtils,
  NoColorSpace,
  NoToneMapping,
  OrthographicCamera,
  PCFShadowMap,
  PCFSoftShadowMap,
  PerspectiveCamera,
  ReinhardToneMapping,
  SRGBColorSpace,
  VSMShadowMap,
  Vector2,
  Vector3,
  WebGLRenderer,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import {
  CameraNodeType,
  CameraSopNodeType,
  NetworkNodeType,
  NodeContext
} from "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/utils/LayersController.js
var PARAM_NAME = "layer";
function LayerParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.layer = ParamConfig.INTEGER(0, {
        range: [0, 31],
        rangeLocked: [true, true]
      });
    }
  };
}
var LayersController = class {
  constructor(node) {
    this.node = node;
  }
  update() {
    const object = this.node.object;
    object.layers.set(0);
    object.layers.enable(this.node.params.integer(PARAM_NAME));
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Rop.js
var RopType = ((RopType2) => {
  RopType2["CSS2D"] = "CSS2DRenderer";
  RopType2["CSS3D"] = "CSS3DRenderer";
  RopType2["WEBGL"] = "WebGLRenderer";
  RopType2["WEBGPU"] = "WebGPURenderer";
  RopType2["PATH_TRACING"] = "pathTracingRenderer";
  return RopType2;
})(RopType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/utils/cameras/RenderController.js
function CameraRenderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.render = ParamConfig.FOLDER();
      this.setScene = ParamConfig.BOOLEAN(0);
      this.scene = ParamConfig.NODE_PATH("", {
        visibleIf: { setScene: 1 },
        nodeSelection: {
          context: NodeContext.OBJ,
          types: [ObjType.SCENE]
        }
      });
      this.setRenderer = ParamConfig.BOOLEAN(0);
      this.renderer = ParamConfig.NODE_PATH("", {
        visibleIf: { setRenderer: 1 },
        nodeSelection: {
          context: NodeContext.ROP,
          types: [RopType.WEBGL]
        },
        dependentOnFoundNode: true
      });
      this.setCSSRenderer = ParamConfig.BOOLEAN(0);
      this.CSSRenderer = ParamConfig.NODE_PATH("", {
        visibleIf: { setCSSRenderer: 1 },
        nodeSelection: {
          context: NodeContext.ROP,
          types: [RopType.CSS2D, RopType.CSS3D]
        },
        dependentOnFoundNode: true
      });
    }
  };
}

// node_modules/@polygonjs/polygonjs/dist/src/core/helpers/CameraHelper.js
var _vector = new Vector3();
var _camera = new PerspectiveCamera();
function _createGeometry() {
  const geometry = new BufferGeometry();
  const colorFrustum = new Color(16755200);
  const colorCone = new Color(16711680);
  const colorUp = new Color(43775);
  const colorTarget = new Color(16777215);
  const colorCross = new Color(3355443);
  const vertices = [];
  const colors = [];
  const pointMap = {};
  function addLine(a, b, color) {
    addPoint(a, color);
    addPoint(b, color);
  }
  function addPoint(id, color) {
    vertices.push(0, 0, 0);
    colors.push(color.r, color.g, color.b);
    if (pointMap[id] === void 0) {
      pointMap[id] = [];
    }
    pointMap[id].push(vertices.length / 3 - 1);
  }
  addLine("n1", "n2", colorFrustum);
  addLine("n2", "n4", colorFrustum);
  addLine("n4", "n3", colorFrustum);
  addLine("n3", "n1", colorFrustum);
  addLine("f1", "f2", colorFrustum);
  addLine("f2", "f4", colorFrustum);
  addLine("f4", "f3", colorFrustum);
  addLine("f3", "f1", colorFrustum);
  addLine("n1", "f1", colorFrustum);
  addLine("n2", "f2", colorFrustum);
  addLine("n3", "f3", colorFrustum);
  addLine("n4", "f4", colorFrustum);
  addLine("p", "n1", colorCone);
  addLine("p", "n2", colorCone);
  addLine("p", "n3", colorCone);
  addLine("p", "n4", colorCone);
  addLine("u1", "u2", colorUp);
  addLine("u2", "u3", colorUp);
  addLine("u3", "u1", colorUp);
  addLine("c", "t", colorTarget);
  addLine("p", "c", colorCross);
  addLine("cn1", "cn2", colorCross);
  addLine("cn3", "cn4", colorCross);
  addLine("cf1", "cf2", colorCross);
  addLine("cf3", "cf4", colorCross);
  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
  return { geometry, pointMap };
}
function _createMaterial() {
  return new LineBasicMaterial({ color: 16777215, vertexColors: true, toneMapped: false });
}
var CameraHelper = class _CameraHelper extends LineSegments {
  constructor(camera) {
    super();
    this._pointMap = {};
    this.camera = camera;
    if (this.camera.updateProjectionMatrix) {
      this.camera.updateProjectionMatrix();
    }
    this.name = "CameraHelper";
    this.type = "CameraHelper";
    this.matrixAutoUpdate = false;
    const { geometry, pointMap } = _createGeometry();
    this.geometry = geometry;
    this._pointMap = pointMap;
    this.material = _createMaterial();
  }
  // private setCamera(camera: Camera) {
  // 	this._camera = camera;
  // 	if ((this._camera as PerspectiveCamera).updateProjectionMatrix) {
  // 		(this._camera as PerspectiveCamera).updateProjectionMatrix();
  // 	}
  // 	this.update();
  // }
  clone() {
    const helper = new _CameraHelper(this.camera);
    return helper;
  }
  update() {
    const geometry = this.geometry;
    const pointMap = this._pointMap;
    const w = 1, h = 1;
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
    setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
    setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
    setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
    setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
    setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
    setPoint("n4", pointMap, geometry, _camera, w, h, -1);
    setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
    setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
    setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
    setPoint("f4", pointMap, geometry, _camera, w, h, 1);
    setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
    setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
    setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
    setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
    setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
    setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
    setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
    setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
    setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
    setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
    setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
    geometry.getAttribute("position").needsUpdate = true;
  }
};
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera);
  const points = pointMap[point];
  if (points !== void 0) {
    const position = geometry.getAttribute("position");
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
    }
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/utils/cameras/PostProcessParamOptions.js
function CameraPostProcessParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.doPostProcess = ParamConfig.BOOLEAN(0);
      this.postProcessNode = ParamConfig.NODE_PATH("", {
        visibleIf: {
          doPostProcess: 1
        },
        nodeSelection: {
          types: [NetworkNodeType.POST]
        },
        // cook: false,
        // ...POST_PROCESS_PARAM_OPTIONS,
        dependentOnFoundNode: false
      });
    }
    // prepend_render_pass = ParamConfig.BOOLEAN(1, {
    // 	visibleIf: {
    // 		doPostProcess: 1,
    // 	},
    // });
    // use_render_target = ParamConfig.BOOLEAN(0, {
    // 	visibleIf: {
    // 		doPostProcess: 1,
    // 	},
    // 	...POST_PROCESS_PARAM_OPTIONS,
    // });
  };
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraControls.js
var _CameraControlsSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.CONTROLS;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraControlsSopOperation.updateObject({
        objects,
        params,
        node: this._node,
        active: true,
        errorIfNodeNotFound: true
      });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params, node, active, errorIfNodeNotFound } = options;
    const relativeOrAbsolutePath = params.node.path();
    const foundNode = node.node(relativeOrAbsolutePath);
    if (foundNode && active) {
      const nodeId = foundNode.graphNodeId();
      for (let object of objects) {
        ThreejsCoreObject.addAttribute(object, CameraAttribute.CONTROLS_NODE_ID, nodeId);
      }
    } else {
      for (let object of objects) {
        ThreejsCoreObject.deleteAttribute(object, CameraAttribute.CONTROLS_NODE_ID);
      }
      if (errorIfNodeNotFound) {
        node.states.error.set("controls node not found");
      }
    }
  }
};
var CameraControlsSopOperation = _CameraControlsSopOperation;
CameraControlsSopOperation.DEFAULT_PARAMS = {
  group: "",
  node: new TypedNodePathParamValue("")
};
CameraControlsSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraRenderer.js
var _CameraRendererSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.RENDERER;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraRendererSopOperation.updateObject({ objects, params, node: this._node, active: true });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params, node, active } = options;
    const relativeOrAbsolutePath = params.node.path();
    const foundNode = node.node(relativeOrAbsolutePath);
    if (foundNode && active) {
      const nodeId = foundNode.graphNodeId();
      for (let object of objects) {
        ThreejsCoreObject.addAttribute(object, CameraAttribute.RENDERER_NODE_ID, nodeId);
      }
    } else {
      for (let object of objects) {
        ThreejsCoreObject.deleteAttribute(object, CameraAttribute.RENDERER_NODE_ID);
      }
    }
  }
};
var CameraRendererSopOperation = _CameraRendererSopOperation;
CameraRendererSopOperation.DEFAULT_PARAMS = {
  group: "",
  node: new TypedNodePathParamValue("")
};
CameraRendererSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraCSSRenderer.js
var _CameraCSSRendererSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.CSS_RENDERER;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraCSSRendererSopOperation.updateObject({ objects, params, node: this._node, active: true });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params, node, active } = options;
    const relativeOrAbsolutePath = params.node.path();
    const foundNode = node.node(relativeOrAbsolutePath);
    if (foundNode && active) {
      const nodeId = foundNode.graphNodeId();
      for (let object of objects) {
        ThreejsCoreObject.addAttribute(object, CameraAttribute.CSS_RENDERER_NODE_ID, nodeId);
      }
    } else {
      for (let object of objects) {
        ThreejsCoreObject.deleteAttribute(object, CameraAttribute.CSS_RENDERER_NODE_ID);
      }
    }
  }
};
var CameraCSSRendererSopOperation = _CameraCSSRendererSopOperation;
CameraCSSRendererSopOperation.DEFAULT_PARAMS = {
  group: "",
  node: new TypedNodePathParamValue("")
};
CameraCSSRendererSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraPostProcess.js
var CameraPostProcessSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.POST_PROCESS;
  }
  cook(inputCoreGroups, params) {
    var _a;
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    const relativeOrAbsolutePath = params.node.path();
    const node = isBooleanTrue(params.useOtherNode) ? (_a = this._node) == null ? void 0 : _a.node(relativeOrAbsolutePath) : this._node;
    if (node) {
      const nodeId = node.graphNodeId();
      for (let object of objects) {
        ThreejsCoreObject.addAttribute(object, CameraAttribute.POST_PROCESS_NODE_ID, nodeId);
      }
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params, node, active } = options;
    const relativeOrAbsolutePath = params.node.path();
    const foundNode = node.node(relativeOrAbsolutePath);
    if (foundNode && active) {
      const nodeId = foundNode.graphNodeId();
      for (let object of objects) {
        ThreejsCoreObject.addAttribute(object, CameraAttribute.POST_PROCESS_NODE_ID, nodeId);
      }
    } else {
      for (let object of objects) {
        ThreejsCoreObject.deleteAttribute(object, CameraAttribute.POST_PROCESS_NODE_ID);
      }
    }
  }
};
CameraPostProcessSopOperation.DEFAULT_PARAMS = {
  group: "",
  useOtherNode: false,
  node: new TypedNodePathParamValue("")
};
CameraPostProcessSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraRenderScene.js
var _CameraRenderSceneSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.RENDER_SCENE;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraRenderSceneSopOperation.updateObject({ objects, params, node: this._node, active: true });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params, node, active } = options;
    const relativeOrAbsolutePath = params.node.path();
    const foundNode = node.node(relativeOrAbsolutePath);
    if (foundNode && active) {
      const nodeId = foundNode.graphNodeId();
      for (let object of objects) {
        ThreejsCoreObject.addAttribute(object, CameraAttribute.RENDER_SCENE_NODE_ID, nodeId);
      }
    } else {
      for (let object of objects) {
        ThreejsCoreObject.deleteAttribute(object, CameraAttribute.RENDER_SCENE_NODE_ID);
      }
    }
  }
};
var CameraRenderSceneSopOperation = _CameraRenderSceneSopOperation;
CameraRenderSceneSopOperation.DEFAULT_PARAMS = {
  group: "",
  node: new TypedNodePathParamValue("")
};
CameraRenderSceneSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraFrameMode.js
var CameraFrameMode = ((CameraFrameMode2) => {
  CameraFrameMode2["DEFAULT"] = "default";
  CameraFrameMode2["COVER"] = "cover";
  CameraFrameMode2["CONTAIN"] = "contain";
  return CameraFrameMode2;
})(CameraFrameMode || {});
var CAMERA_FRAME_MODES = [
  "default",
  "cover",
  "contain"
  /* CONTAIN */
];
function CoreCameraFrameParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.frameMode = ParamConfig.INTEGER(CAMERA_FRAME_MODES.indexOf(
        "default"
        /* DEFAULT */
      ), {
        menu: {
          entries: CAMERA_FRAME_MODES.map((name, value) => {
            return { name, value };
          })
        }
      });
      this.expectedAspectRatio = ParamConfig.FLOAT("16/9", {
        visibleIf: [
          { frameMode: CAMERA_FRAME_MODES.indexOf(
            "cover"
            /* COVER */
          ) },
          { frameMode: CAMERA_FRAME_MODES.indexOf(
            "contain"
            /* CONTAIN */
          ) }
        ],
        range: [0, 2],
        rangeLocked: [true, false]
      });
    }
    // vertical_fov_range = ParamConfig.VECTOR2([0, 100], {visibleIf: {lock_width: 1}});
    // horizontal_fov_range = ParamConfig.VECTOR2([0, 100], {visibleIf: {lock_width: 0}});
  };
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraFrameMode.js
var _CameraFrameModeSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.FRAME_MODE;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraFrameModeSopOperation.updateObject({ objects, params });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params } = options;
    for (let object of objects) {
      ThreejsCoreObject.addAttribute(object, CameraAttribute.FRAME_MODE, params.frameMode);
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.FRAME_MODE_EXPECTED_ASPECT_RATIO,
        params.expectedAspectRatio
      );
    }
  }
};
var CameraFrameModeSopOperation = _CameraFrameModeSopOperation;
CameraFrameModeSopOperation.DEFAULT_PARAMS = {
  group: "",
  frameMode: CAMERA_FRAME_MODES.indexOf(CameraFrameMode.DEFAULT),
  expectedAspectRatio: 16 / 9
};
CameraFrameModeSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/_BaseCamera.js
var EVENT_CHANGE = { type: "change" };
function CameraMainCameraParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.setMainCamera = ParamConfig.BUTTON(null, {
        callback: (node, param) => {
          BaseCameraObjNodeClass.PARAM_CALLBACK_setMainCamera(node);
        }
      });
    }
  };
}
function ThreejsCameraTransformParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.camera = ParamConfig.FOLDER();
      this.controls = ParamConfig.NODE_PATH("", {
        nodeSelection: {
          context: NodeContext.EVENT
        },
        dependentOnFoundNode: true
      });
      this.near = ParamConfig.FLOAT(CORE_CAMERA_DEFAULT.near, {
        range: [0.1, 100],
        cook: false,
        computeOnDirty: true,
        callback: (node, param) => {
          BaseThreejsCameraObjNodeClass.PARAM_CALLBACK_update_near_far_from_param(
            node,
            param
          );
        }
      });
      this.far = ParamConfig.FLOAT(CORE_CAMERA_DEFAULT.far, {
        range: [0, 100],
        cook: false,
        computeOnDirty: true,
        callback: (node, param) => {
          BaseThreejsCameraObjNodeClass.PARAM_CALLBACK_update_near_far_from_param(
            node,
            param
          );
        }
      });
      this.display = ParamConfig.BOOLEAN(1);
      this.showHelper = ParamConfig.BOOLEAN(0);
    }
  };
}
var BaseCameraObjParamsConfig = class extends CameraMainCameraParamConfig(NodeParamsConfig) {
};
var BaseThreejsCameraObjParamsConfig = class extends CameraPostProcessParamConfig(
  CameraRenderParamConfig(
    CoreCameraFrameParamConfig(
      TransformedParamConfig(
        LayerParamConfig(ThreejsCameraTransformParamConfig(CameraMainCameraParamConfig(NodeParamsConfig)))
      )
    )
  )
) {
};
var TypedCameraObjNode = class extends TypedObjNode {
  constructor() {
    super(...arguments);
    this.renderOrder = ObjNodeRenderOrder.CAMERA;
    this._aspect = -1;
  }
  get object() {
    return this._object;
  }
  async cook() {
    this.updateCamera();
    this._object.dispatchEvent(EVENT_CHANGE);
    this.cookController.endCook();
  }
  // prepareRaycaster(mouse: Vector2, raycaster: Raycaster) {}
  camera() {
    return this._object;
  }
  updateCamera() {
  }
  static PARAM_CALLBACK_setMainCamera(node) {
    node.setAsMainCamera();
  }
  setAsMainCamera() {
    const path = CorePath.objectPath(this.object);
    this.scene().camerasController.setMainCameraPath(path);
  }
  setupForAspectRatio(aspect) {
  }
  // protected _updateForAspectRatio(): void {}
  update_transform_params_from_object() {
    CoreTransform.setParamsFromObject(this._object, this);
  }
  static PARAM_CALLBACK_update_from_param(node, param) {
    node.object[param.name()] = node.pv[param.name()];
  }
};
var TypedThreejsCameraObjNode = class extends TypedCameraObjNode {
  constructor() {
    super(...arguments);
    this.flags = new FlagsControllerD(this);
    this.hierarchyController = new HierarchyController(this);
    this.transformController = new TransformController(this);
    this.childrenDisplayController = new ObjChildrenDisplayController(
      this
    );
    this.displayNodeController = new DisplayNodeController(
      this,
      this.childrenDisplayController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = NodeContext.SOP;
  }
  _layersController() {
    return this.__layersController__ = this.__layersController__ || new LayersController(this);
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.io.outputs.setHasOneOutput();
    this.hierarchyController.initializeNode();
    this.transformController.initializeNode();
    this.childrenDisplayController.initializeNode();
    this.initHelperHook();
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  // override prepareRaycaster(mouse: Vector2, raycaster: Raycaster) {
  // 	raycaster.setFromCamera(mouse, this._object);
  // }
  async cook() {
    this.transformController.update();
    this._layersController().update();
    this.updateNearFar();
    this.updateCamera();
    this._updateHelper();
    const objects = [this._object];
    const node = this;
    const hierachyParams = {
      group: ""
    };
    CameraControlsSopOperation.updateObject({
      objects,
      params: {
        node: this.pv.controls,
        ...hierachyParams
      },
      node,
      active: true,
      errorIfNodeNotFound: false
    });
    CameraRendererSopOperation.updateObject({
      objects,
      params: {
        node: this.pv.renderer,
        ...hierachyParams
      },
      node,
      active: this.pv.setRenderer
    });
    CameraCSSRendererSopOperation.updateObject({
      objects,
      params: {
        node: this.pv.CSSRenderer,
        ...hierachyParams
      },
      node,
      active: this.pv.setCSSRenderer
    });
    CameraPostProcessSopOperation.updateObject({
      objects,
      params: {
        node: this.pv.postProcessNode,
        useOtherNode: false,
        ...hierachyParams
      },
      node,
      active: this.pv.doPostProcess
    });
    CameraRenderSceneSopOperation.updateObject({
      objects,
      params: {
        node: this.pv.scene,
        ...hierachyParams
      },
      node,
      active: this.pv.setScene
    });
    CameraFrameModeSopOperation.updateObject({
      objects,
      params: {
        frameMode: this.pv.frameMode,
        expectedAspectRatio: this.pv.expectedAspectRatio,
        ...hierachyParams
      }
    });
    this._object.dispatchEvent(EVENT_CHANGE);
    this.scene().camerasController.updateFromChangeInObject(this.object);
    this.cookController.endCook();
  }
  static PARAM_CALLBACK_update_near_far_from_param(node, param) {
    node.updateNearFar();
  }
  updateNearFar() {
    if (this._object.near != this.pv.near || this._object.far != this.pv.far) {
      this._object.near = this.pv.near;
      this._object.far = this.pv.far;
      this._object.updateProjectionMatrix();
      this._updateHelper();
    }
  }
  // override setupForAspectRatio(aspect: number) {
  // 	if (CoreType.isNaN(aspect)) {
  // 		return;
  // 	}
  // 	if (aspect && this._aspect != aspect) {
  // 		this._aspect = aspect;
  // 		this._updateForAspectRatio();
  // 	}
  // }
  async createViewer(options) {
    if (this.isDirty()) {
      await this.compute();
    }
    const viewer = Poly.camerasRegister.createViewer({ camera: this.object, scene: this.scene() });
    let element;
    let updateAutoRenderOnIntersectionChange;
    if (options && options instanceof HTMLElement) {
      element = options;
    } else {
      element = options == null ? void 0 : options.element;
      updateAutoRenderOnIntersectionChange = options == null ? void 0 : options.updateAutoRenderOnIntersectionChange;
    }
    if (viewer) {
      if (element) {
        viewer.mount(element, {
          updateAutoRenderOnIntersectionChange
        });
      }
    }
    return viewer;
  }
  initHelperHook() {
    this.flags.display.onUpdate(() => {
      this._updateHelper();
    });
  }
  helperVisible() {
    return this.flags.display.active() && isBooleanTrue(this.pv.showHelper);
  }
  _createHelper() {
    const helper = new CameraHelper(this.object);
    helper.update();
    return helper;
  }
  _updateHelper() {
    if (this.helperVisible()) {
      if (!this._helper) {
        this._helper = this._createHelper();
      }
      if (this._helper) {
        this.object.add(this._helper);
        this._helper.update();
      }
    } else {
      if (this._helper) {
        this.object.remove(this._helper);
      }
    }
  }
};
var BaseCameraObjNodeClass = class extends TypedCameraObjNode {
};
var BaseThreejsCameraObjNodeClass = class extends TypedThreejsCameraObjNode {
  PARAM_CALLBACK_update_effects_composer(node) {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerCamerasController.js
var ViewerCamerasController = class {
  constructor(_viewer) {
    this._viewer = _viewer;
    this._size = new Vector2(100, 100);
    this._aspect = 1;
  }
  camera() {
    return this._viewer.camera();
  }
  get size() {
    return this._size;
  }
  get aspect() {
    return this._aspect;
  }
  computeSizeAndAspect(pixelRatio) {
    this._updateSize();
    this._viewer.scene().uniformsController.updateResolution(this._size, pixelRatio);
    this._aspect = this._getAspect();
  }
  _updateSize() {
    var _a, _b;
    this._size.x = ((_a = this._viewer.domElement()) == null ? void 0 : _a.offsetWidth) || 0;
    this._size.y = ((_b = this._viewer.domElement()) == null ? void 0 : _b.offsetHeight) || 0;
  }
  _getAspect() {
    return this._size.x / this._size.y;
  }
  updateCameraAspect() {
    this._viewer.updateCameraAspect(this._aspect, this._size);
  }
  async prepareCurrentCamera() {
    await this._updateFromCameraContainer();
  }
  async _updateFromCameraContainer() {
    this.updateCameraAspect();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerControlsController.js
var CameraControlsEvent = ((CameraControlsEvent2) => {
  CameraControlsEvent2["start"] = "start";
  CameraControlsEvent2["end"] = "end";
  return CameraControlsEvent2;
})(CameraControlsEvent || {});
var CAMERA_CONTROLS_EVENTS = [
  "start",
  "end"
  /* end */
];
var START_EVENT = {
  type: "start"
  /* start */
};
var END_EVENT = {
  type: "end"
  /* end */
};
var ViewerControlsController = class extends EventDispatcher {
  constructor(viewer) {
    super();
    this.viewer = viewer;
    this._active = false;
    this._mounted = false;
    this._boundEventHandler = {
      [
        "start"
        /* start */
      ]: () => this.dispatchEvent(START_EVENT),
      [
        "end"
        /* end */
      ]: () => this.dispatchEvent(END_EVENT)
    };
  }
  controls() {
    return this._controls;
  }
  mount() {
    if (this._mounted) {
      return;
    }
    this._mounted = true;
    const controlsNode = this.viewer.controlsNode();
    const camera = this.viewer.camera();
    if (!(controlsNode && camera)) {
      return;
    }
    controlsNode.applyControls(camera, this.viewer).then((controls) => {
      this._controls = controls;
      this._updateControlsFunc = controls ? (delta) => controls.update(delta) : void 0;
      for (const eventName of CAMERA_CONTROLS_EVENTS) {
        controls.addEventListener(eventName, this._boundEventHandler[eventName]);
      }
      if (!this._mounted) {
        this._disposeControls();
      }
    });
  }
  unmount() {
    if (!this._mounted) {
      return;
    }
    this._mounted = false;
    this._disposeControls();
  }
  _disposeControls() {
    if (this._controls) {
      for (const eventName of CAMERA_CONTROLS_EVENTS) {
        this._controls.removeEventListener(eventName, this._boundEventHandler[eventName]);
      }
      this._controls.dispose();
    }
    this._updateControlsFunc = void 0;
  }
  update(delta) {
    if (this._updateControlsFunc) {
      this._updateControlsFunc(delta);
    }
  }
  setActive(active) {
    if (active) {
      this.mount();
    } else {
      this.unmount();
    }
  }
  setTarget(target) {
    if (!this._controls) {
      return;
    }
    const orbitControls = this._controls;
    if (!orbitControls.target) {
      return;
    }
    orbitControls.target.copy(target);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/event/CanvasKeyFocus.js
function allowCanvasKeyEventsListener(canvas) {
  canvas.setAttribute("tabindex", "0");
}

// node_modules/@polygonjs/polygonjs/dist/src/core/event/WindowEventType.js
var WindowEventType = ((WindowEventType2) => {
  WindowEventType2["resize"] = "resize";
  return WindowEventType2;
})(WindowEventType || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/event/EventEmitter.js
function elementFromEmitterType(emitter, canvas) {
  return emitter == CoreEventEmitter.CANVAS ? canvas : document;
}
function getEventEmitter(eventData, canvas) {
  if (eventData.type == WindowEventType.resize) {
    return window;
  } else {
    return elementFromEmitterType(eventData.emitter, canvas);
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerEventsController.js
var DEBUG = false;
var ViewerEventsController = class {
  constructor(viewer) {
    this.viewer = viewer;
    this._boundListenerMapByEventControllerType = /* @__PURE__ */ new Map();
  }
  updateEvents(eventsController) {
    if (DEBUG) {
      console.log("------------ updateEvents START:", eventsController);
    }
    const canvas = this.canvas();
    if (!canvas) {
      console.warn("no canvas found");
      return;
    }
    const controllerType = eventsController.type();
    let map = this._boundListenerMapByEventControllerType.get(controllerType);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this._boundListenerMapByEventControllerType.set(controllerType, map);
    }
    map.forEach((listenerWithData, eventType) => {
      for (let emitter of EVENT_EMITTERS) {
        const eventEmitter = getEventEmitter({ emitter, type: eventType }, canvas);
        eventEmitter.removeEventListener(eventType, listenerWithData.listener);
      }
    });
    map.clear();
    for (let eventData of eventsController.activeEventDatas()) {
      const eventEmitter = getEventEmitter(eventData, canvas);
      const eventType = eventData.type;
      const _processEvent = (event, controller) => {
        const eventContext = {
          viewer: this.viewer,
          event,
          emitter: eventData.emitter
          // camera: this.camera(),
        };
        controller.processEvent(eventContext);
      };
      const listener = (event) => {
        _processEvent(
          event,
          eventsController
          /*, canvas*/
        );
      };
      if (DEBUG) {
        console.log("- add event:", eventType, eventEmitter);
      }
      eventEmitter.addEventListener(eventType, listener, { passive: true });
      if (eventEmitter != document) {
        if (ACCEPTED_KEYBOARD_EVENT_TYPES.includes(eventData.type)) {
          allowCanvasKeyEventsListener(eventEmitter);
        }
      }
      map.set(eventData.type, { listener, data: eventData });
    }
    if (DEBUG) {
      console.log("------------ updateEvents DONE:");
    }
  }
  camera() {
    return this.viewer.camera();
  }
  canvas() {
    return this.viewer.canvas();
  }
  init() {
    if (!this.canvas()) {
      console.warn("no canvas found for eventsController");
      return;
    }
    this.viewer.scene().eventsDispatcher.traverseControllers((controller) => {
      this.updateEvents(controller);
    });
  }
  registeredEventTypes() {
    const list = [];
    this._boundListenerMapByEventControllerType.forEach((map) => {
      map.forEach((listener, eventType) => {
        list.push(eventType);
      });
    });
    return list;
  }
  dispose() {
    const canvas = this.canvas();
    this._boundListenerMapByEventControllerType.forEach((map) => {
      if (canvas) {
        map.forEach((listenerWithData, eventType) => {
          const eventOwner = getEventEmitter(listenerWithData.data, canvas);
          eventOwner.removeEventListener(eventType, listenerWithData.listener);
        });
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerWebglController.js
var ViewerWebGLController = class {
  constructor(viewer) {
    this.viewer = viewer;
  }
  init() {
    const canvas = this.viewer.canvas();
    if (canvas) {
      canvas.onwebglcontextlost = this._on_webglcontextlost.bind(this);
      canvas.onwebglcontextrestored = this._on_webglcontextrestored.bind(this);
    }
  }
  _on_webglcontextlost() {
    console.warn("context lost at frame", this.viewer.scene().frame());
    if (this.request_animation_frame_id) {
      cancelAnimationFrame(this.request_animation_frame_id);
    } else {
      console.warn("request_animation_frame_id not initialized");
    }
    console.warn("not canceled", this.request_animation_frame_id);
  }
  _on_webglcontextrestored() {
    console.log("context restored");
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerAudioController.js
var ICON = {
  ON: `<svg xmlns="http://www.w3.org/2000/svg" class="soundOn h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
	<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
  </svg>`,
  OFF: `<svg xmlns="http://www.w3.org/2000/svg" class="soundOff h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
	<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" clip-rule="evenodd" />
	<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2" />
  </svg>`
};
var ViewerAudioController = class {
  constructor(_viewer) {
    this._viewer = _viewer;
  }
  update() {
    const root = this._viewer.scene().root();
    if (isBooleanTrue(root.pv.displayAudioIcon)) {
      this._showIcon();
      this._updateIcon(root);
    } else {
      this._hideIcon();
    }
  }
  unmount() {
    var _a;
    if (this.__iconContainer) {
      (_a = this.__iconContainer.parentElement) == null ? void 0 : _a.removeChild(this.__iconContainer);
      this.__iconContainer = void 0;
    }
    this._onIcon = void 0;
    this._offIcon = void 0;
  }
  _showIcon() {
    const element = this._iconContainer();
    if (element) {
      element.style.display = "block";
    }
  }
  _hideIcon() {
    if (this.__iconContainer) {
      this.__iconContainer.style.display = "none";
    }
  }
  _iconContainer() {
    const createIconContainer = () => {
      const element = this._createIconContainer();
      const domElement = this._viewer.domElement();
      if (!domElement) {
        return;
      }
      domElement.append(element);
      return element;
    };
    return this.__iconContainer = this.__iconContainer || createIconContainer();
  }
  _createIconContainer() {
    const element = document.createElement("div");
    element.addEventListener("pointerdown", (event) => {
      this._toggleSound();
      event.preventDefault();
      event.stopPropagation();
      return false;
    });
    return element;
  }
  _setIconContainerStyle(element, root) {
    const style = root.pv.audioIconStyle;
    element.setAttribute("style", style);
    element.style.color = root.pv.audioIconColor.getStyle();
  }
  offIcon() {
    function createIcon() {
      const icon = document.createElement("div");
      icon.innerHTML = ICON.OFF;
      return icon.children[0];
    }
    return this._offIcon = this._offIcon || createIcon();
  }
  onIcon() {
    function createIcon() {
      const icon = document.createElement("div");
      icon.innerHTML = ICON.ON;
      return icon.children[0];
    }
    return this._onIcon = this._onIcon || createIcon();
  }
  _toggleSound() {
    const root = this._viewer.scene().root();
    root.audioController.toggleSound();
    this._updateIcon(root);
  }
  _updateIcon(root) {
    var _a, _b;
    const container = this._iconContainer();
    if (!container) {
      return;
    }
    this._setIconContainerStyle(container, root);
    const onIcon = this.onIcon();
    const offIcon = this.offIcon();
    if (this._viewer.scene().root().audioController.soundOn()) {
      container.appendChild(onIcon);
      (_a = offIcon.parentElement) == null ? void 0 : _a.removeChild(offIcon);
    } else {
      container.appendChild(offIcon);
      (_b = onIcon.parentElement) == null ? void 0 : _b.removeChild(onIcon);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerRaycastersController.js
var ViewerRaycastersController = class {
  constructor(viewer) {
    this.viewer = viewer;
    const scene = this.viewer.scene();
    this.pointerEventsController = scene.eventsDispatcher.pointerEventsController;
    this.pointerEventsController.setRaycaster(viewer.createRaycaster());
  }
  setCursor0(cursor) {
    this.pointerEventsController.cursor().value.set(cursor.x, cursor.y);
  }
  raycaster0() {
    return this.pointerEventsController.raycaster().value;
  }
  updateRaycasters() {
    this.pointerEventsController.raycaster().value.setFromCamera(this.pointerEventsController.cursor().value, this.viewer.camera());
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/utils/ViewerPerformanceMonitor.js
function _round(perf) {
  return Math.round(perf * 10);
}
var ViewerPerformanceMonitor = class {
  constructor(viewer) {
    this.viewer = viewer;
    this._accumulatedDelta = 0;
    this._framesCount = 0;
    this._lastRoundedPerf = _round(1);
  }
  measurePerformance(delta) {
    this._accumulatedDelta += delta;
    if (this._accumulatedDelta >= 1) {
      const perf = this._framesCount / DESIRED_FPS;
      const roundedPerf = _round(perf);
      if (roundedPerf != this._lastRoundedPerf) {
        this._lastRoundedPerf = roundedPerf;
        this.viewer.scene().perfMonitor.onPerformanceChange(perf);
      }
      this._framesCount = 0;
      this._accumulatedDelta = 0;
    }
    this._framesCount++;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/_Base.js
var HOVERED_CLASS_NAME = "hovered";
var _TypedViewer = class {
  constructor(options) {
    this._active = false;
    this._doRender = true;
    this._mounted = false;
    this._controlsController = new ViewerControlsController(this);
    this.performanceMonitor = new ViewerPerformanceMonitor(this);
    this._size = new Vector2();
    this._onBeforeTickCallbacks = [];
    this._onAfterTickCallbacks = [];
    this._onBeforeRenderCallbacks = [];
    this._onAfterRenderCallbacks = [];
    this._id = _TypedViewer._nextId();
    this._camera = options.camera;
    this._scene = options.scene;
    this._canvas = options.canvas;
    if (options.autoRender != null) {
      this._doRender = options.autoRender;
    }
    this.updateCameraAspect = options.updateCameraAspect;
    this.scene().viewersRegister.registerViewer(this);
    this.raycastersController = new ViewerRaycastersController(this);
  }
  static _nextId() {
    return `${_TypedViewer._nextViewerId++}`;
  }
  createRaycaster() {
    return createRaycaster();
  }
  /**
   * mounts the viewer onto an element
   *
   *
   */
  mount(element, options) {
    let updateAutoRenderOnIntersectionChange = true;
    if (options && options.updateAutoRenderOnIntersectionChange != null) {
      updateAutoRenderOnIntersectionChange = options.updateAutoRenderOnIntersectionChange;
    }
    this._domElement = element;
    this._domElement.viewer = this;
    this._domElement.scene = this._scene;
    this._domElement.Poly = Poly;
    if (updateAutoRenderOnIntersectionChange) {
      this.updateAutoRenderOnIntersectionChange({ playPauseScene: true });
    }
    this.controlsController().mount();
    this._mounted = true;
  }
  /**
   * unmounts the viewer
   *
   *
   */
  unmount() {
    var _a;
    if (!this._domElement) {
      return;
    }
    (_a = this._audioController) == null ? void 0 : _a.unmount();
    this._domElement.removeChild(this.canvas());
    this.controlsController().unmount();
    this._mounted = false;
  }
  static _canvasIdPrefix() {
    return "TypedViewer";
  }
  static createCanvas(id) {
    id = id || _TypedViewer._nextId();
    const canvas = document.createElement("canvas");
    canvas.id = `${this._canvasIdPrefix()}_${id}`;
    canvas.style.display = "block";
    canvas.style.outline = "none";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.addEventListener("contextmenu", (e) => {
      e.preventDefault();
      e.stopPropagation();
    });
    return canvas;
  }
  controlsNode() {
    return this._controlsNode;
  }
  /**
   * return the canvas and create one if none yet
   *
   *
   */
  canvas() {
    return this._canvas = this._canvas || _TypedViewer.createCanvas(this._id);
  }
  _tickAndRender(delta) {
    this._tick(delta);
    this.render(delta);
    this._postRender(delta);
  }
  _tick(delta) {
    this.controlsController().update(delta);
    this.raycastersController.updateRaycasters();
    this._runOnBeforeTickCallbacks(delta);
    this.scene().update(delta);
    this._runOnAfterTickCallbacks(delta);
  }
  render(delta) {
    if (!this._doRender) {
      return;
    }
    const renderer = this._renderer;
    if (!renderer) {
      console.error("render: no renderer");
      return;
    }
    this._runOnBeforeRenderCallbacks(delta, renderer);
    if (this._renderFunc) {
      this._renderFunc(delta);
    }
    if (this._renderCSSFunc) {
      this._renderCSSFunc();
    }
    this._runOnAfterRenderCallbacks(delta, renderer);
  }
  _postRender(delta) {
    this._scene.viewersRegister.markViewerAsRendered(this);
    if (this.scene().timeController.playing()) {
      this.performanceMonitor.measurePerformance(delta);
    }
  }
  setRenderObjectOverride(object) {
    if (object) {
      this._renderObjectOverride = object;
    } else {
      this._renderObjectOverride = void 0;
    }
  }
  active() {
    return this._active;
  }
  activate() {
    this._active = true;
  }
  deactivate() {
    this._active = false;
  }
  camerasController() {
    return this._camerasController = this._camerasController || new ViewerCamerasController(this);
  }
  controlsController() {
    return this._controlsController;
  }
  eventsController() {
    return this._eventsController = this._eventsController || new ViewerEventsController(this);
  }
  webglController() {
    return this._webGLController = this._webGLController || new ViewerWebGLController(this);
  }
  audioController() {
    return this._audioController = this._audioController || new ViewerAudioController(this);
  }
  domElement() {
    return this._domElement;
  }
  scene() {
    return this._scene;
  }
  /**
   * return the camera the viewer was created with
   *
   *
   */
  camera() {
    return this._camera;
  }
  // cameraControlsController(): ThreejsCameraControlsController | undefined {
  // 	return undefined;
  // }
  id() {
    return this._id;
  }
  size(target) {
    target.copy(this._size);
  }
  updateSize() {
  }
  /**
   * disposes the viewer
   *
   *
   */
  dispose() {
    this._scene.viewersRegister.unregisterViewer(this);
    this.eventsController().dispose();
    this.controlsController().unmount();
    if (!this._domElement) {
      return;
    }
    let child;
    while (child = this._domElement.children[0]) {
      this._domElement.removeChild(child);
    }
  }
  // html container class
  resetContainerClass() {
    var _a;
    (_a = this.domElement()) == null ? void 0 : _a.classList.remove(HOVERED_CLASS_NAME);
  }
  setContainerClassHovered() {
    var _a;
    (_a = this.domElement()) == null ? void 0 : _a.classList.add(HOVERED_CLASS_NAME);
  }
  markAsReady() {
  }
  /**
   * sets auto render state. If falls, the viewer will not render.
   *
   *
   */
  setAutoRender(state = true) {
    this._doRender = state;
  }
  autoRenderState() {
    return this._doRender;
  }
  /**
   * This sets the viewer to detect if it is visible, and to pause/unpause itself when its visibility changes.
   * This can be very useful to improve performance.
   *
   */
  updateAutoRenderOnIntersectionChange(_options) {
    if (!this._domElement) {
      console.warn("cannot apply");
      return;
    }
    let { threshold, root, rootMargin, playPauseScene, onChange } = _options;
    if (threshold == null) {
      threshold = 0.01;
    }
    const observerOptions = {
      root,
      rootMargin,
      threshold
    };
    const onObserverChange = (entries, observer) => {
      if (!this._scene.loadingController.loaded()) {
        return;
      }
      entries.forEach((entry) => {
        const isVisible = entry.isIntersecting;
        this.setAutoRender(isVisible);
        if (playPauseScene) {
          if (isVisible) {
            this._scene.play();
          } else {
            this._scene.pause();
          }
        }
        if (onChange) {
          onChange(isVisible);
        }
      });
    };
    this.disableUpdateAutoRenderOnIntersectionChange();
    this._observer = new IntersectionObserver(onObserverChange, observerOptions);
    this._observer.observe(this._domElement);
  }
  /**
   * Cancels the listening of the viewer's visibility.
   *
   */
  disableUpdateAutoRenderOnIntersectionChange() {
    if (!this._domElement) {
      return;
    }
    if (!this._observer) {
      return;
    }
    this._observer.unobserve(this._domElement);
  }
  // onBeforeTick
  /**
   * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
   *
   */
  registerOnBeforeTick(callbackName, callback, options = {}) {
    this._registerCallback(callbackName, callback, this.registeredBeforeTickCallbacks(), options);
  }
  /**
   * unregisters BeforeTick callback
   *
   */
  unRegisterOnBeforeTick(callbackName) {
    this._unregisterCallback(callbackName, this._onBeforeTickCallbacksMap);
  }
  /**
   * Returns the list registered BeforeTick callback names
   *
   */
  registeredBeforeTickCallbacks() {
    return this._onBeforeTickCallbacksMap = this._onBeforeTickCallbacksMap || /* @__PURE__ */ new Map();
  }
  // onAfterTick
  /**
   * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
   *
   */
  registerOnAfterTick(callbackName, callback, options = {}) {
    this._registerCallback(callbackName, callback, this.registeredAfterTickCallbacks(), options);
  }
  /**
   * unregisters AfterTick callback
   *
   */
  unRegisterOnAfterTick(callbackName) {
    this._unregisterCallback(callbackName, this._onAfterTickCallbacksMap);
  }
  /**
   * Returns the list registered AfterTick callback names
   *
   */
  registeredAfterTickCallbacks() {
    return this._onAfterTickCallbacksMap = this._onAfterTickCallbacksMap || /* @__PURE__ */ new Map();
  }
  // onBeforeRender
  /**
   * registers a BeforeRender callback. BeforeRender callbacks are run before the frame is rendered
   *
   */
  registerOnBeforeRender(callbackName, callback, options = {}) {
    this._registerCallback(callbackName, callback, this.registeredBeforeRenderCallbacks(), options);
  }
  /**
   * unregisters BeforeRender callback
   *
   */
  unRegisterOnBeforeRender(callbackName) {
    this._unregisterCallback(callbackName, this._onBeforeRenderCallbacksMap);
  }
  /**
   * Returns the list registered BeforeRender callback names
   *
   */
  registeredBeforeRenderCallbacks() {
    return this._onBeforeRenderCallbacksMap = this._onBeforeRenderCallbacksMap || /* @__PURE__ */ new Map();
  }
  // onAfterRender
  /**
   * registers a AfterRender callback. AfterRender callbacks are run after the frame is rendered
   *
   */
  registerOnAfterRender(callbackName, callback, options = {}) {
    this._registerCallback(callbackName, callback, this.registeredAfterRenderCallbacks(), options);
  }
  /**
   * unregisters AfterRender callback
   *
   */
  unRegisterOnAfterRender(callbackName) {
    this._unregisterCallback(callbackName, this._onAfterRenderCallbacksMap);
  }
  /**
   * Returns the list AfterRender BeforeRender callback names
   *
   */
  registeredAfterRenderCallbacks() {
    return this._onAfterRenderCallbacksMap = this._onAfterRenderCallbacksMap || /* @__PURE__ */ new Map();
  }
  _registerCallback(callbackName, callback, map, options = {}) {
    if (map.has(callbackName)) {
      console.warn(`callback ${callbackName} already registered`);
      return;
    }
    map.set(callbackName, { callback, options });
    this._updateCallbacks();
  }
  _unregisterCallback(callbackName, map) {
    if (!map) {
      return;
    }
    const callbackContainer = map.get(callbackName);
    if (!callbackContainer) {
      return;
    }
    const options = callbackContainer.options;
    if (options.persistent == true) {
      return;
    }
    map.delete(callbackName);
    this._updateCallbacks();
  }
  _updateCallbacks() {
    var _a, _b, _c, _d;
    this._onBeforeTickCallbacks = [];
    (_a = this._onBeforeTickCallbacksMap) == null ? void 0 : _a.forEach((callbackContainer) => {
      this._onBeforeTickCallbacks.push(callbackContainer.callback);
    });
    this._onAfterTickCallbacks = [];
    (_b = this._onAfterTickCallbacksMap) == null ? void 0 : _b.forEach((callbackContainer) => {
      this._onAfterTickCallbacks.push(callbackContainer.callback);
    });
    this._onBeforeRenderCallbacks = [];
    (_c = this._onBeforeRenderCallbacksMap) == null ? void 0 : _c.forEach((callbackContainer) => {
      this._onBeforeRenderCallbacks.push(callbackContainer.callback);
    });
    this._onAfterRenderCallbacks = [];
    (_d = this._onAfterRenderCallbacksMap) == null ? void 0 : _d.forEach((callbackContainer) => {
      this._onAfterRenderCallbacks.push(callbackContainer.callback);
    });
  }
  _runTickCallbacks(callbacks, delta) {
    for (const callback of callbacks) {
      callback(delta);
    }
  }
  _runRenderCallbacks(callbacks, delta, renderer) {
    for (const callback of callbacks) {
      callback(delta, renderer);
    }
  }
  _runOnBeforeTickCallbacks(delta) {
    this._runTickCallbacks(this._onBeforeTickCallbacks, delta);
  }
  _runOnAfterTickCallbacks(delta) {
    this._runTickCallbacks(this._onAfterTickCallbacks, delta);
  }
  _runOnBeforeRenderCallbacks(delta, renderer) {
    this._runRenderCallbacks(this._onBeforeRenderCallbacks, delta, renderer);
  }
  _runOnAfterRenderCallbacks(delta, renderer) {
    this._runRenderCallbacks(this._onAfterRenderCallbacks, delta, renderer);
  }
};
var TypedViewer = _TypedViewer;
TypedViewer._nextViewerId = 0;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/rop/_Base.js
var TypedRopNode = class extends TypedNode {
  constructor() {
    super(...arguments);
    this.flags = new FlagsController(this);
  }
  static context() {
    return NodeContext.ROP;
  }
  initializeBaseNode() {
    this.dirtyController.addPostDirtyHook("cook_immediately", () => {
      this.cookController.cookMainWithoutInputs();
    });
  }
  cook() {
    this.cookController.endCook();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/render/defaultPixelRatio.js
function defaultPixelRatio() {
  return 2;
}

// node_modules/@polygonjs/polygonjs/dist/src/core/cop/ColorSpace.js
var COLOR_SPACES_BY_NAME = [
  { Linear: NoColorSpace },
  { sRGB: SRGBColorSpace },
  { LinearSRGB: LinearSRGBColorSpace },
  { DisplayP3: DisplayP3ColorSpace },
  { LinearDisplayP3: LinearDisplayP3ColorSpace }
];
var COLOR_SPACE_NAME_BY_COLOR_SPACE = {
  [NoColorSpace]: Object.keys(COLOR_SPACES_BY_NAME[0])[0],
  [SRGBColorSpace]: Object.keys(COLOR_SPACES_BY_NAME[1])[0],
  [LinearSRGBColorSpace]: Object.keys(COLOR_SPACES_BY_NAME[2])[0],
  [DisplayP3ColorSpace]: Object.keys(COLOR_SPACES_BY_NAME[3])[0],
  [LinearDisplayP3ColorSpace]: Object.keys(COLOR_SPACES_BY_NAME[4])[0]
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/rop/WebGLRenderer.js
var COLOR_SPACES = [NoColorSpace, SRGBColorSpace, LinearSRGBColorSpace, DisplayP3ColorSpace];
var DEFAULT_OUTPUT_COLOR_SPACE = SRGBColorSpace;
var ToneMappingName = ((ToneMappingName2) => {
  ToneMappingName2["No"] = "No";
  ToneMappingName2["Linear"] = "Linear";
  ToneMappingName2["Reinhard"] = "Reinhard";
  ToneMappingName2["Cineon"] = "Cineon";
  ToneMappingName2["ACESFilmic"] = "ACESFilmic";
  return ToneMappingName2;
})(ToneMappingName || {});
var ToneMappingValue = ((ToneMappingValue2) => {
  ToneMappingValue2[ToneMappingValue2["No"] = NoToneMapping] = "No";
  ToneMappingValue2[ToneMappingValue2["Linear"] = LinearToneMapping] = "Linear";
  ToneMappingValue2[ToneMappingValue2["Reinhard"] = ReinhardToneMapping] = "Reinhard";
  ToneMappingValue2[ToneMappingValue2["Cineon"] = CineonToneMapping] = "Cineon";
  ToneMappingValue2[ToneMappingValue2["ACESFilmic"] = ACESFilmicToneMapping] = "ACESFilmic";
  return ToneMappingValue2;
})(ToneMappingValue || {});
var TONE_MAPPING_NAMES = [
  "No",
  "Linear",
  "Reinhard",
  "Cineon",
  "ACESFilmic"
  /* ACESFilmic */
];
var TONE_MAPPING_VALUES = [
  ToneMappingValue.No,
  ToneMappingValue.Linear,
  ToneMappingValue.Reinhard,
  ToneMappingValue.Cineon,
  ToneMappingValue.ACESFilmic
];
var DEFAULT_TONE_MAPPING = ToneMappingValue.ACESFilmic;
var TONE_MAPPING_MENU_ENTRIES = TONE_MAPPING_NAMES.map((name, i) => {
  return {
    name,
    value: TONE_MAPPING_VALUES[i]
  };
});
var ShadowMapTypeName = ((ShadowMapTypeName2) => {
  ShadowMapTypeName2["Basic"] = "Basic";
  ShadowMapTypeName2["PCF"] = "PCF";
  ShadowMapTypeName2["PCFSoft"] = "PCFSoft";
  ShadowMapTypeName2["VSM"] = "VSM";
  return ShadowMapTypeName2;
})(ShadowMapTypeName || {});
var ShadowMapTypeValue = ((ShadowMapTypeValue2) => {
  ShadowMapTypeValue2[ShadowMapTypeValue2["Basic"] = BasicShadowMap] = "Basic";
  ShadowMapTypeValue2[ShadowMapTypeValue2["PCF"] = PCFShadowMap] = "PCF";
  ShadowMapTypeValue2[ShadowMapTypeValue2["PCFSoft"] = PCFSoftShadowMap] = "PCFSoft";
  ShadowMapTypeValue2[ShadowMapTypeValue2["VSM"] = VSMShadowMap] = "VSM";
  return ShadowMapTypeValue2;
})(ShadowMapTypeValue || {});
var SHADOW_MAP_TYPE_NAMES = [
  "Basic",
  "PCF",
  "PCFSoft",
  "VSM"
  /* VSM */
];
var SHADOW_MAP_TYPE_VALUES = [
  ShadowMapTypeValue.Basic,
  ShadowMapTypeValue.PCF,
  ShadowMapTypeValue.PCFSoft,
  ShadowMapTypeValue.VSM
];
var DEFAULT_SHADOW_MAP_TYPE = ShadowMapTypeValue.PCFSoft;
var WebGLRendererRopParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.common = ParamConfig.FOLDER();
    this.toneMapping = ParamConfig.INTEGER(DEFAULT_TONE_MAPPING, {
      menu: {
        entries: TONE_MAPPING_MENU_ENTRIES
      },
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateToneMapping(node);
      }
    });
    this.toneMappingExposure = ParamConfig.FLOAT(1, {
      range: [0, 2],
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateToneMappingExposure(node);
      }
    });
    this.outputColorSpace = ParamConfig.STRING(DEFAULT_OUTPUT_COLOR_SPACE, {
      menuString: {
        entries: COLOR_SPACES.map((colorSpace) => ({
          name: COLOR_SPACE_NAME_BY_COLOR_SPACE[colorSpace],
          value: colorSpace
        }))
      },
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateOutputColorSpace(node);
      }
    });
    this.sortObjects = ParamConfig.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateSortObjects(node);
      }
    });
    this.tpixelRatio = ParamConfig.BOOLEAN(0, {
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updatePixelRatio(node);
      }
    });
    this.pixelRatio = ParamConfig.FLOAT(2, {
      visibleIf: { tpixelRatio: true },
      range: [0.1, 4],
      rangeLocked: [true, false],
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updatePixelRatio(node);
      }
    });
    this.shadow = ParamConfig.FOLDER();
    this.tshadowMap = ParamConfig.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateShadow(node);
      }
    });
    this.shadowMapAutoUpdate = ParamConfig.BOOLEAN(1, {
      visibleIf: { tshadowMap: 1 },
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateShadow(node);
      }
    });
    this.shadowMapNeedsUpdate = ParamConfig.BOOLEAN(0, {
      visibleIf: { tshadowMap: 1 },
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateShadow(node);
      }
    });
    this.shadowMapType = ParamConfig.INTEGER(DEFAULT_SHADOW_MAP_TYPE, {
      visibleIf: { tshadowMap: 1 },
      menu: {
        entries: SHADOW_MAP_TYPE_NAMES.map((name, i) => {
          return {
            name,
            value: SHADOW_MAP_TYPE_VALUES[i]
          };
        })
      },
      cook: false,
      callback: (node) => {
        WebGLRendererRopNode.PARAM_CALLBACK_updateShadow(node);
      }
    });
    this.advanced = ParamConfig.FOLDER();
    this.alpha = ParamConfig.BOOLEAN(1);
    this.antialias = ParamConfig.BOOLEAN(1);
    this.premultipliedAlpha = ParamConfig.BOOLEAN(1);
    this.stencil = ParamConfig.BOOLEAN(1);
    this.depth = ParamConfig.BOOLEAN(1);
    this.localClippingEnabled = ParamConfig.BOOLEAN(0);
    this.logarithmicDepthBuffer = ParamConfig.BOOLEAN(0);
    this.preserveDrawingBuffer = ParamConfig.BOOLEAN(0);
    this.tprecision = ParamConfig.BOOLEAN(0);
    this.precision = ParamConfig.INTEGER(RENDERER_PRECISIONS.indexOf(RendererPrecision.HIGH), {
      visibleIf: { tprecision: 1 },
      menu: {
        entries: RENDERER_PRECISIONS.map((name, value) => {
          return { value, name };
        })
      }
    });
    this.tpowerPreference = ParamConfig.BOOLEAN(0);
    this.powerPreference = ParamConfig.INTEGER(POWER_PREFERENCES.indexOf(PowerPreference.HIGH), {
      visibleIf: { tpowerPreference: 1 },
      menu: {
        entries: POWER_PREFERENCES.map((name, value) => {
          return { value, name };
        })
      }
    });
  }
  // preserve_drawing_buffer = ParamConfig.BOOLEAN(0);
};
var ParamsConfig = new WebGLRendererRopParamsConfig();
var WebGLRendererRopNode = class extends TypedRopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._rendererByCanvas = /* @__PURE__ */ new Map();
  }
  static type() {
    return RopType.WEBGL;
  }
  // private _renderersbyCamera: Map<Camera, WebGLRenderer> = new Map();
  createRenderer(canvas, gl) {
    const params = {};
    const keys = Object.keys(WEBGL_RENDERER_DEFAULT_PARAMS);
    let k;
    for (k of keys) {
      params[k] = WEBGL_RENDERER_DEFAULT_PARAMS[k];
    }
    if (isBooleanTrue(this.pv.tprecision)) {
      const precision = RENDERER_PRECISIONS[this.pv.precision];
      params.precision = precision;
    }
    if (isBooleanTrue(this.pv.tpowerPreference)) {
      const powerPreference = POWER_PREFERENCES[this.pv.powerPreference];
      params.powerPreference = powerPreference;
    }
    params.antialias = isBooleanTrue(this.pv.antialias);
    params.alpha = isBooleanTrue(this.pv.alpha);
    params.premultipliedAlpha = isBooleanTrue(this.pv.premultipliedAlpha);
    params.depth = isBooleanTrue(this.pv.depth);
    params.stencil = isBooleanTrue(this.pv.stencil);
    params.logarithmicDepthBuffer = isBooleanTrue(this.pv.logarithmicDepthBuffer);
    params.canvas = canvas;
    params.context = gl;
    params.preserveDrawingBuffer = this.pv.preserveDrawingBuffer;
    const renderer = Poly.renderersController.createWebGLRenderer(params);
    renderer.localClippingEnabled = isBooleanTrue(this.pv.localClippingEnabled);
    this._rendererByCanvas.set(canvas, renderer);
    if (Poly.renderersController.printDebug()) {
      Poly.renderersController.printDebugMessage(`create renderer from node '${this.path()}'`);
      Poly.renderersController.printDebugMessage({
        params
      });
    }
    this._updateRenderer(renderer);
    return renderer;
  }
  cook() {
    this._traverseSceneAndUpdateMaterials();
    this.cookController.endCook();
  }
  _updateRenderer(renderer) {
    this._updateRendererOutputColorSpace(renderer);
    this._updateRendererToneMapping(renderer);
    this._updateRendererToneMappingExposure(renderer);
    this._updateRendererShadow(renderer);
    this._updateRendererSortObjects(renderer);
    this._updateRendererPixelRatio(renderer);
  }
  _traverseSceneAndUpdateMaterials() {
    this.scene().threejsScene().traverse((object) => {
      const material = object.material;
      if (material) {
        if (CoreType.isArray(material)) {
          for (const mat of material) {
            mat.needsUpdate = true;
          }
        } else {
          material.needsUpdate = true;
        }
      }
    });
  }
  //
  //
  static PARAM_CALLBACK_updateToneMapping(node) {
    node._rendererByCanvas.forEach((renderer, canvas) => {
      node._updateRendererToneMapping(renderer);
    });
  }
  static PARAM_CALLBACK_updateToneMappingExposure(node) {
    node._rendererByCanvas.forEach((renderer, canvas) => {
      node._updateRendererToneMappingExposure(renderer);
    });
  }
  static PARAM_CALLBACK_updateOutputColorSpace(node) {
    node._rendererByCanvas.forEach((renderer, canvas) => {
      node._updateRendererOutputColorSpace(renderer);
    });
  }
  static PARAM_CALLBACK_updateShadow(node) {
    node._rendererByCanvas.forEach((renderer, canvas) => {
      node._updateRendererShadow(renderer);
    });
  }
  static PARAM_CALLBACK_updateSortObjects(node) {
    node._rendererByCanvas.forEach((renderer, canvas) => {
      node._updateRendererSortObjects(renderer);
    });
  }
  static PARAM_CALLBACK_updatePixelRatio(node) {
    node._rendererByCanvas.forEach((renderer, canvas) => {
      node._updateRendererPixelRatio(renderer);
    });
    window.dispatchEvent(new Event("resize"));
  }
  //
  //
  _updateRendererToneMapping(renderer) {
    renderer.toneMapping = this.pv.toneMapping;
  }
  _updateRendererToneMappingExposure(renderer) {
    renderer.toneMappingExposure = this.pv.toneMappingExposure;
  }
  _updateRendererOutputColorSpace(renderer) {
    renderer.outputColorSpace = this.pv.outputColorSpace;
  }
  _updateRendererShadow(renderer) {
    renderer.shadowMap.enabled = this.pv.tshadowMap;
    renderer.shadowMap.autoUpdate = this.pv.shadowMapAutoUpdate;
    renderer.shadowMap.needsUpdate = this.pv.shadowMapNeedsUpdate;
    renderer.shadowMap.type = this.pv.shadowMapType;
  }
  _updateRendererSortObjects(renderer) {
    renderer.sortObjects = this.pv.sortObjects;
  }
  _updateRendererPixelRatio(renderer) {
    const pixelRatio = this.pv.tpixelRatio ? this.pv.pixelRatio : defaultPixelRatio();
    if (Poly.renderersController.printDebug()) {
      Poly.renderersController.printDebugMessage(`set renderer pixelRatio from '${this.path()}'`);
      Poly.renderersController.printDebugMessage({
        pixelRatio
      });
    }
    renderer.setPixelRatio(pixelRatio);
  }
  setToneMapping(toneMapping) {
    this.p.toneMapping.set(toneMapping);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraRendererController.js
var UPDATE_STYLE = false;
var SIZE_MULT = 1;
var _CoreCameraRendererController = class {
  // private static _superSamplingSize = new Vector2();
  // static canvasResolution(canvas: HTMLCanvasElement) {
  // 	return this._resolutionByCanvasId.get(canvas.id);
  // }
  static renderer(canvas) {
    return this._renderersByCanvas.get(canvas);
  }
  static rendererNode(options) {
    const { scene, camera } = options;
    const rendererROPId = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.RENDERER_NODE_ID);
    if (rendererROPId && CoreType.isNumber(rendererROPId)) {
      const rendererROP = scene.graph.nodeFromId(rendererROPId);
      return rendererROP;
    }
  }
  static rendererConfig(options) {
    const { canvas, scene } = options;
    const gl = Poly.renderersController.getRenderingContext(canvas);
    if (!gl) {
      console.error("failed to create webgl context");
      return;
    }
    let renderer;
    let rendererNode;
    const rendererROP = this.rendererNode(options);
    if (rendererROP != null && rendererROP instanceof TypedNode && rendererROP.context() == NodeContext.ROP) {
      const type = rendererROP.type();
      switch (type) {
        case RopType.WEBGL: {
          renderer = rendererROP.createRenderer(canvas, gl);
          rendererNode = rendererROP;
          break;
        }
        case RopType.PATH_TRACING: {
          renderer = rendererROP.renderer(canvas, gl);
          rendererNode = rendererROP;
          break;
        }
      }
    }
    if (!renderer) {
      renderer = this._defaultRendererByContext.get(gl);
      if (!renderer) {
        renderer = _CoreCameraRendererController.createDefaultRenderer(canvas, gl);
        this._defaultRendererByContext.set(gl, renderer);
      }
    }
    scene.renderersRegister.registerRenderer(renderer);
    this._renderersByCanvas.set(canvas, renderer);
    if (!renderer) {
      return;
    }
    const renderConfig = {
      renderer,
      rendererNode
    };
    return renderConfig;
  }
  static setRendererSize(canvas, size) {
    const renderer = this.renderer(canvas);
    if (renderer) {
      renderer.setSize(SIZE_MULT * size.x, SIZE_MULT * size.y, UPDATE_STYLE);
    }
  }
  static createDefaultRenderer(canvas, gl) {
    const renderer = Poly.renderersController.defaultWebGLRendererForCanvas(canvas);
    const pixelRatio = defaultPixelRatio();
    renderer.setPixelRatio(pixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = DEFAULT_SHADOW_MAP_TYPE;
    renderer.toneMapping = DEFAULT_TONE_MAPPING;
    renderer.toneMappingExposure = 1;
    renderer.outputColorSpace = DEFAULT_OUTPUT_COLOR_SPACE;
    if (Poly.renderersController.printDebug()) {
      Poly.renderersController.printDebugMessage("create default renderer");
    }
    return renderer;
  }
};
var CoreCameraRendererController = _CoreCameraRendererController;
CoreCameraRendererController._defaultRendererByContext = /* @__PURE__ */ new Map();
CoreCameraRendererController._renderersByCanvas = /* @__PURE__ */ new Map();

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraCSSRendererController.js
var CoreCameraCSSRendererController = class {
  static isCSSRendererNode(node) {
    return node.type() == RopType.CSS2D || node.type() == RopType.CSS3D;
  }
  static cssRendererConfig(options) {
    const { canvas, scene, camera } = options;
    const nodeId = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.CSS_RENDERER_NODE_ID);
    if (nodeId == null) {
      return;
    }
    if (!CoreType.isNumber(nodeId)) {
      return;
    }
    const foundNode = scene.graph.nodeFromId(nodeId);
    if (!foundNode) {
      return;
    }
    if (!this.isCSSRendererNode(foundNode)) {
      return;
    }
    const cssRendererNode = foundNode;
    cssRendererNode.compute();
    const cssRenderer = cssRendererNode.renderer(canvas);
    return { cssRenderer, cssRendererNode };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraViewerCodeController.js
var ViewerCodeConfig = class {
  constructor(options) {
    this.options = options;
  }
  createViewerElement(options) {
    const { viewerId, html } = this.options;
    const { domElement, canvas, CSSClass } = options;
    const _container = document.createElement("div");
    const container = _container;
    container.style.height = "100%";
    container.innerHTML = html;
    domElement == null ? void 0 : domElement.appendChild(container);
    container.classList.add(CSSClass);
    const viewerElement = container.querySelector(`#${viewerId}`);
    if (!viewerElement) {
      console.error(`failed to find element with id ${viewerId}`);
      return;
    }
    viewerElement.appendChild(canvas);
    function executeScriptElements(containerElement) {
      const scriptElements = containerElement.querySelectorAll("script");
      Array.from(scriptElements).forEach((scriptElement) => {
        var _a;
        const clonedElement = document.createElement("script");
        Array.from(scriptElement.attributes).forEach((attribute) => {
          clonedElement.setAttribute(attribute.name, attribute.value);
        });
        clonedElement.text = scriptElement.text;
        (_a = scriptElement.parentNode) == null ? void 0 : _a.replaceChild(clonedElement, scriptElement);
      });
    }
    executeScriptElements(container);
    return viewerElement;
  }
};
var CoreCameraViewerCodeController = class {
  static viewerCodeConfig(options) {
    const { camera } = options;
    const coreObjectClass = coreObjectClassFactory(camera);
    const viewerId = coreObjectClass.attribValue(camera, CameraAttribute.VIEWER_ID);
    const html = coreObjectClass.attribValue(camera, CameraAttribute.VIEWER_HTML);
    if (viewerId == null || html == null) {
      return;
    }
    return new ViewerCodeConfig({ viewerId, html });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraControlsController.js
var CoreCameraControlsController = class {
  // static isCameraControlsNode(node: BaseNodeType) {
  // 	return CAMERA_CONTROLS_NODE_TYPES.includes(node.type());
  // }
  static controlsNode(options) {
    const { scene, camera } = options;
    let controlsNode;
    const foundNodeId = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.CONTROLS_NODE_ID);
    if (foundNodeId && CoreType.isNumber(foundNodeId)) {
      const foundNode = scene.graph.nodeFromId(foundNodeId);
      if (foundNode && foundNode.applyControls) {
        controlsNode = foundNode;
      }
    }
    return controlsNode;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraRenderSceneController.js
var CoreCameraRenderSceneController = class {
  static isRenderSceneNode(node) {
    return node.type() == ObjType.SCENE;
  }
  static renderScene(options) {
    const { scene, camera } = options;
    let sceneNode;
    const foundNodeId = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.RENDER_SCENE_NODE_ID);
    if (foundNodeId && CoreType.isNumber(foundNodeId)) {
      const foundNode = scene.graph.nodeFromId(foundNodeId);
      if (foundNode && foundNode instanceof TypedNode && this.isRenderSceneNode(foundNode)) {
        sceneNode = foundNode;
        return sceneNode.object;
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/webXR/Common.js
var BaseXRSessionEventName = ((BaseXRSessionEventName2) => {
  BaseXRSessionEventName2["CONNECTED"] = "connected";
  BaseXRSessionEventName2["DISCONNECTED"] = "disconnected";
  BaseXRSessionEventName2["SELECT"] = "select";
  BaseXRSessionEventName2["SELECT_START"] = "selectstart";
  BaseXRSessionEventName2["SELECT_END"] = "selectend";
  return BaseXRSessionEventName2;
})(BaseXRSessionEventName || {});
var BASE_XR_SESSION_EVENT_NAMES = [
  "connected",
  "disconnected",
  "select",
  "selectstart",
  "selectend"
  /* SELECT_END */
];
function _buildEventIndices() {
  const map = /* @__PURE__ */ new Map();
  let i = 0;
  for (const eventName of BASE_XR_SESSION_EVENT_NAMES) {
    map.set(eventName, i);
    i++;
  }
  return map;
}
var BASE_XR_EVENT_INDICES = _buildEventIndices();
var WEBXR_REFERENCE_SPACE_TYPES = [
  "viewer",
  "local",
  "local-floor",
  "bounded-floor",
  "unbounded"
];
var WebXRFeatureStatus = ((WebXRFeatureStatus2) => {
  WebXRFeatureStatus2["NOT_USED"] = "not used";
  WebXRFeatureStatus2["OPTIONAL"] = "optional";
  WebXRFeatureStatus2["REQUIRED"] = "required";
  return WebXRFeatureStatus2;
})(WebXRFeatureStatus || {});
var WEBXR_FEATURE_STATUSES = [
  "not used",
  "optional",
  "required"
  /* REQUIRED */
];
var WEBXR_FEATURE_STATUS_OPTIONAL_INDEX = WEBXR_FEATURE_STATUSES.indexOf(
  "optional"
  /* OPTIONAL */
);
var WEBXR_FEATURE_PARAM_OPTIONS = {
  menu: {
    entries: WEBXR_FEATURE_STATUSES.map((name, value) => ({ name, value }))
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/webXR/webXRVR/CommonVR.js
var WebXRVRFeature = ((WebXRVRFeature2) => {
  WebXRVRFeature2["LOCAL_FLOOR"] = "local-floor";
  WebXRVRFeature2["BOUNDED_FLOOR"] = "bounded-floor";
  WebXRVRFeature2["HAND_TRACKING"] = "hand-tracking";
  WebXRVRFeature2["LAYERS"] = "layers";
  return WebXRVRFeature2;
})(WebXRVRFeature || {});
var WEBXR_VR_FEATURES = [
  "local-floor",
  "bounded-floor",
  "hand-tracking",
  "layers"
  /* LAYERS */
];

// node_modules/@polygonjs/polygonjs/dist/src/core/webXR/webXRAR/CommonAR.js
var WebXRARFeature = ((WebXRARFeature2) => {
  WebXRARFeature2["HIT_TEST"] = "hit-test";
  WebXRARFeature2["LIGHT_ESTIMATION"] = "light-estimation";
  return WebXRARFeature2;
})(WebXRARFeature || {});
var WEBXR_AR_FEATURES = [
  "hit-test",
  "light-estimation"
  /* LIGHT_ESTIMATION */
  // WebXRARFeature.CAMERA_ACCESS,
];

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/webXR/CoreCameraWebXR.js
function getFeatures(camera, attribName, existingFeatures) {
  const features = [];
  const featuresStr = coreObjectClassFactory(camera).attribValue(camera, attribName);
  const featuresStrings = featuresStr == null ? void 0 : featuresStr.split(" ");
  if (featuresStrings) {
    for (const featuresString of featuresStrings) {
      if (existingFeatures.includes(featuresString)) {
        features.push(featuresString);
      }
    }
  }
  return features;
}
function _getRequiredAndOptionalFeatures(camera, existingFeatures, attribNames) {
  const optionalFeatures = getFeatures(camera, attribNames.optional, existingFeatures);
  const requiredFeatures = getFeatures(camera, attribNames.required, existingFeatures);
  return { requiredFeatures, optionalFeatures };
}
function _getReferenceSpaceType(camera, options) {
  const coreObjectClass = coreObjectClassFactory(camera);
  let overrideReferenceSpaceType = coreObjectClass.attribValue(camera, options.override);
  let referenceSpaceType = coreObjectClass.attribValue(camera, options.type);
  if (!(referenceSpaceType && WEBXR_REFERENCE_SPACE_TYPES.includes(referenceSpaceType))) {
    overrideReferenceSpaceType = false;
    referenceSpaceType = void 0;
  }
  return { overrideReferenceSpaceType, referenceSpaceType };
}
var CoreCameraWebXRController = class {
  static process(options) {
    const { camera, scene, renderer, canvas } = options;
    const controllers = [];
    const subMountFunctions = [];
    const subUnmountFunctions = [];
    const mountFunction = () => {
      for (const subFunc of subMountFunctions) {
        subFunc();
      }
    };
    const unmountFunction = () => {
      for (const subFunc of subUnmountFunctions) {
        subFunc();
      }
    };
    const coreObjectClass = coreObjectClassFactory(camera);
    const isWebAR = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR);
    if (isWebAR == true) {
      const createFunction = scene.webXR.ARControllerCreateFunction();
      if (createFunction) {
        const { overrideReferenceSpaceType, referenceSpaceType } = _getReferenceSpaceType(camera, {
          type: CameraAttribute.WEBXR_AR_OVERRIDE_REFERENCE_SPACE_TYPE,
          override: CameraAttribute.WEBXR_AR_REFERENCE_SPACE_TYPE
        });
        const { requiredFeatures, optionalFeatures } = _getRequiredAndOptionalFeatures(
          camera,
          WEBXR_AR_FEATURES,
          {
            optional: CameraAttribute.WEBXR_AR_FEATURES_OPTIONAL,
            required: CameraAttribute.WEBXR_AR_FEATURES_REQUIRED
          }
        );
        const controller = createFunction(renderer, camera, canvas, {
          overrideReferenceSpaceType: overrideReferenceSpaceType || false,
          referenceSpaceType,
          requiredFeatures,
          optionalFeatures
        });
        controllers.push(controller);
      }
    }
    const isWebVR = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_VR);
    if (isWebVR == true) {
      const createFunction = scene.webXR.VRControllerCreateFunction();
      if (createFunction) {
        const { overrideReferenceSpaceType, referenceSpaceType } = _getReferenceSpaceType(camera, {
          type: CameraAttribute.WEBXR_VR_OVERRIDE_REFERENCE_SPACE_TYPE,
          override: CameraAttribute.WEBXR_VR_REFERENCE_SPACE_TYPE
        });
        const { requiredFeatures, optionalFeatures } = _getRequiredAndOptionalFeatures(
          camera,
          WEBXR_VR_FEATURES,
          {
            optional: CameraAttribute.WEBXR_VR_FEATURES_OPTIONAL,
            required: CameraAttribute.WEBXR_VR_FEATURES_REQUIRED
          }
        );
        const controller = createFunction(renderer, camera, canvas, {
          overrideReferenceSpaceType: overrideReferenceSpaceType || false,
          referenceSpaceType,
          requiredFeatures,
          optionalFeatures
        });
        controllers.push(controller);
      }
    }
    for (const controller of controllers) {
      subMountFunctions.push(() => controller.mount());
      subUnmountFunctions.push(() => controller.unmount());
    }
    return { mountFunction, unmountFunction };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/webXR/markerTracking/Common.js
var MarkerTrackingSourceMode = ((MarkerTrackingSourceMode2) => {
  MarkerTrackingSourceMode2["WEBCAM"] = "webcam";
  MarkerTrackingSourceMode2["IMAGE"] = "image";
  MarkerTrackingSourceMode2["VIDEO"] = "video";
  return MarkerTrackingSourceMode2;
})(MarkerTrackingSourceMode || {});
var MARKER_TRACKING_SOURCE_MODES = [
  "webcam",
  "image",
  "video"
  /* VIDEO */
];
var MarkerTrackingTransformMode = ((MarkerTrackingTransformMode2) => {
  MarkerTrackingTransformMode2["CAMERA"] = "camera";
  MarkerTrackingTransformMode2["MARKER"] = "marker";
  return MarkerTrackingTransformMode2;
})(MarkerTrackingTransformMode || {});
var MARKER_TRACKING_TRANSFORM_MODES = [
  "camera",
  "marker"
  /* MARKER */
];

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraWebXRARMarkerTracking.js
var _CameraWebXRARMarkerTrackingSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.WEBXR_AR_MARKER_TRACKING;
  }
  cook(inputCoreGroups, params) {
    var _a;
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (Poly.thirdParty.markerTracking().hasController()) {
      if (this._node) {
        _CameraWebXRARMarkerTrackingSopOperation.updateObject({
          scene: this._node.scene(),
          objects,
          params,
          active: true
        });
      }
    } else {
      (_a = this._node) == null ? void 0 : _a.states.error.set(
        "This node requires the plugin-marker-tracking. See [https://github.com/polygonjs/plugin-marker-tracking](https://github.com/polygonjs/plugin-marker-tracking)"
      );
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params, active } = options;
    for (let object of objects) {
      ThreejsCoreObject.addAttribute(object, CameraAttribute.WEBXR_AR_MARKER_TRACKING, active);
      const sourceMode = MARKER_TRACKING_SOURCE_MODES[params.sourceMode];
      ThreejsCoreObject.addAttribute(object, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SOURCE_MODE, sourceMode);
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.WEBXR_AR_MARKER_TRACKING_SOURCE_URL,
        params.sourceUrl
      );
      const transformMode = MARKER_TRACKING_TRANSFORM_MODES[params.transformMode];
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.WEBXR_AR_MARKER_TRACKING_TRANSFORM_MODE,
        transformMode
      );
      ThreejsCoreObject.addAttribute(object, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SMOOTH, params.smooth);
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.WEBXR_AR_MARKER_TRACKING_SMOOTH_COUNT,
        params.smoothCount
      );
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.WEBXR_AR_MARKER_TRACKING_BAR_CODE_TYPE,
        params.barCodeType
      );
      ThreejsCoreObject.addAttribute(
        object,
        CameraAttribute.WEBXR_AR_MARKER_TRACKING_BAR_CODE_VALUE,
        params.barCodeValue
      );
    }
  }
};
var CameraWebXRARMarkerTrackingSopOperation = _CameraWebXRARMarkerTrackingSopOperation;
CameraWebXRARMarkerTrackingSopOperation.DEFAULT_PARAMS = {
  group: "",
  sourceMode: MARKER_TRACKING_SOURCE_MODES.indexOf(MarkerTrackingSourceMode.WEBCAM),
  sourceUrl: "",
  transformMode: MARKER_TRACKING_TRANSFORM_MODES.indexOf(MarkerTrackingTransformMode.CAMERA),
  smooth: true,
  smoothCount: 5,
  barCodeType: Poly.thirdParty.markerTracking().barCodeTypes()[0] || "",
  barCodeValue: 0
};
CameraWebXRARMarkerTrackingSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/webXR/CoreCameraMarkerTracking.js
var DEFAULT = CameraWebXRARMarkerTrackingSopOperation.DEFAULT_PARAMS;
var CoreCameraMarkerTrackingController = class {
  static process(options) {
    const { canvas, scene, camera, onError } = options;
    const coreObjectClass = coreObjectClassFactory(camera);
    const isARjsTrackMarker = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING);
    if (!isARjsTrackMarker) {
      return;
    }
    const sourceMode = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_SOURCE_MODE
    );
    const sourceUrl = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SOURCE_URL);
    const barCodeType = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_BAR_CODE_TYPE
    );
    const barCodeValue = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_BAR_CODE_VALUE
    );
    const transformMode = coreObjectClass.attribValue(
      camera,
      CameraAttribute.WEBXR_AR_MARKER_TRACKING_TRANSFORM_MODE
    );
    if (sourceMode == null || barCodeType == null || barCodeValue == null || transformMode == null) {
      return;
    }
    if (!MARKER_TRACKING_SOURCE_MODES.includes(sourceMode)) {
      return;
    }
    if ([MarkerTrackingSourceMode.IMAGE, MarkerTrackingSourceMode.VIDEO].includes(sourceMode) && sourceUrl == null) {
      return;
    }
    if (!CoreType.isString(barCodeType)) {
      return;
    }
    if (!CoreType.isString(transformMode)) {
      return;
    }
    if (!Poly.thirdParty.markerTracking().barCodeTypes().includes(barCodeType)) {
      return;
    }
    if (!MARKER_TRACKING_TRANSFORM_MODES.includes(transformMode)) {
      return;
    }
    if (!CoreType.isNumber(barCodeValue)) {
      return;
    }
    const smooth = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SMOOTH) || false;
    const smoothCount = coreObjectClass.attribValue(camera, CameraAttribute.WEBXR_AR_MARKER_TRACKING_SMOOTH_COUNT) || 0;
    try {
      const controller = Poly.thirdParty.markerTracking().createController({
        sourceMode,
        sourceUrl,
        canvas,
        camera,
        scene: scene.threejsScene(),
        transformMode,
        barCode: {
          type: barCodeType,
          value: barCodeValue
        },
        smooth: {
          active: smooth,
          count: smoothCount
        }
      });
      const errorMessage = controller == null ? void 0 : controller.errorMessage();
      if (errorMessage) {
        onError(errorMessage);
      } else {
        if (!controller) {
          onError(
            "failed to create the MarkerTracking controller. Make sure you have loaded the plugin. See: `https://polygonjs.com/markerTracking`"
          );
        }
      }
      return controller == null ? void 0 : controller.config();
    } catch (err) {
      onError("There was an unknown error while using the MarkerTracking plugin");
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/CameraFPS.js
var _CameraFPSSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraSopNodeType.FPS;
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = CoreMask.filterObjects(coreGroup, {
      group: params.group
    });
    if (this._node) {
      _CameraFPSSopOperation.updateObject({ objects, params });
    }
    return coreGroup;
  }
  static updateObject(options) {
    const { objects, params } = options;
    for (let object of objects) {
      ThreejsCoreObject.addAttribute(object, CameraAttribute.MAX_FPS, params.maxFPS);
      ThreejsCoreObject.addAttribute(object, CameraAttribute.MAX_FPS_DYNAMIC_CHANGE, params.allowDynamicChange);
    }
  }
};
var CameraFPSSopOperation = _CameraFPSSopOperation;
CameraFPSSopOperation.DEFAULT_PARAMS = {
  group: "",
  maxFPS: 60,
  allowDynamicChange: false
};
CameraFPSSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraFPS.js
var DEFAULT2 = CameraFPSSopOperation.DEFAULT_PARAMS;
var _getMinDelta = (fps) => {
  return 1 / fps;
};
var SAFETY_THRESHOLD = 0.1;
function isDeltaValid(accumulatedDelta, condig) {
  const minDelta = condig.minDelta();
  if (accumulatedDelta > minDelta) {
    return true;
  }
  const deltaDeltas = minDelta - accumulatedDelta;
  if (deltaDeltas > 0 && deltaDeltas / minDelta > SAFETY_THRESHOLD) {
    return false;
  }
  return true;
}
var CoreCameraViewerFPSController = class {
  static viewerFPSConfig(options) {
    const { camera } = options;
    const _getMaxFPSIfPreset = () => {
      return coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.MAX_FPS);
    };
    const maxFPS = _getMaxFPSIfPreset();
    if (maxFPS == null) {
      return;
    }
    const _minDelta = _getMinDelta(maxFPS);
    const allowDynamicChange = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.MAX_FPS_DYNAMIC_CHANGE) || false;
    if (allowDynamicChange) {
      const defaultMinDelta = _getMinDelta(60);
      const config = {
        minDelta: () => {
          const maxFPS2 = _getMaxFPSIfPreset();
          if (maxFPS2 == null) {
            return defaultMinDelta;
          }
          return _getMinDelta(maxFPS2);
        }
      };
      return config;
    } else {
      const config = {
        minDelta: () => _minDelta
      };
      return config;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/viewers/Threejs.js
var CSS_CLASS = "CoreThreejsViewer";
var ThreejsViewer = class extends TypedViewer {
  constructor(options) {
    super(options);
    this._animateWebBound = this._animateWeb.bind(this);
    this._accumulatedDelta = 0;
    this._onResizeBound = this.onResize.bind(this);
    this._setupFunctions(options);
  }
  static _canvasIdPrefix() {
    return "ThreejsViewer";
  }
  rendererConfig() {
    return this._rendererConfig;
  }
  _setupFunctions(options) {
    var _a;
    const camera = this.camera();
    const scene = this.scene();
    const canvas = this.canvas();
    const threejsScene = scene.threejsScene();
    this._errorMessage = void 0;
    this._renderer = options.renderer;
    if (!this._renderer) {
      this._rendererConfig = CoreCameraRendererController.rendererConfig({
        camera,
        scene,
        canvas
      });
      if (this._rendererConfig) {
        this._renderer = this._rendererConfig.renderer;
      }
    }
    const renderer = this._renderer;
    if (!renderer) {
      console.error("no renderer");
    }
    if (renderer) {
      const rendererScene = CoreCameraRenderSceneController.renderScene({ camera, scene });
      const renderScene = rendererScene || threejsScene;
      this._effectComposer = CoreCameraPostProcessController.createComposer({
        camera,
        scene,
        renderScene,
        renderer,
        viewer: this
      });
      const effectComposer = this._effectComposer;
      if (renderer instanceof WebGLRenderer) {
        this._webXRConfig = CoreCameraWebXRController.process({
          camera,
          scene,
          renderer,
          canvas: this.canvas()
        });
        this._markerTrackingConfig = CoreCameraMarkerTrackingController.process({
          canvas,
          camera,
          scene,
          onError: (errorMessage) => {
            this._errorMessage = errorMessage;
          }
        });
      }
      this._codeConfig = CoreCameraViewerCodeController.viewerCodeConfig({ camera });
      this._cssRendererConfig = CoreCameraCSSRendererController.cssRendererConfig({ scene, camera, canvas });
      const cssRenderer = (_a = this._cssRendererConfig) == null ? void 0 : _a.cssRenderer;
      this._renderCSSFunc = cssRenderer ? () => cssRenderer.render(renderScene, camera) : void 0;
      this._controlsNode = CoreCameraControlsController.controlsNode({ camera, scene });
      this._FPSConfig = CoreCameraViewerFPSController.viewerFPSConfig({ camera });
      if (effectComposer) {
        this._renderFunc = (delta) => effectComposer.render(delta);
      } else {
        this._renderFunc = () => renderer.render(renderScene, camera);
      }
      return { renderer, renderScene, camera };
    }
  }
  /**
   * mounts the viewer onto an element
   *
   *
   */
  mount(element, options) {
    var _a, _b, _c;
    super.mount(element, options);
    const canvas = this.canvas();
    const _appendCanvasWithViewerCodeConfig = (config) => {
      if (!this._domElement) {
        return;
      }
      return config.createViewerElement({ domElement: this._domElement, canvas, CSSClass: CSS_CLASS });
    };
    const _appendCanvasWithoutViewerCodeConfig = () => {
      var _a2, _b2;
      (_a2 = this._domElement) == null ? void 0 : _a2.appendChild(canvas);
      (_b2 = this._domElement) == null ? void 0 : _b2.classList.add(CSS_CLASS);
      return this._domElement;
    };
    const viewerContainerElement = this._codeConfig ? _appendCanvasWithViewerCodeConfig(this._codeConfig) : _appendCanvasWithoutViewerCodeConfig();
    const cssRendererNode = (_a = this._cssRendererConfig) == null ? void 0 : _a.cssRendererNode;
    if (cssRendererNode) {
      cssRendererNode.mountRenderer(canvas);
    }
    (_b = this._webXRConfig) == null ? void 0 : _b.mountFunction();
    (_c = this._markerTrackingConfig) == null ? void 0 : _c.mountFunction();
    this._build();
    this._setEvents();
    const canvasParent = canvas.parentElement;
    if (canvasParent) {
      this._createResizeObserver(canvasParent);
    }
    this.onResize();
    if (this._errorMessage) {
      const errorElement = document.createElement("div");
      errorElement.style.position = "absolute";
      errorElement.style.top = "0px";
      errorElement.style.width = "100%";
      errorElement.style.color = "red";
      errorElement.style.backgroundColor = "white";
      errorElement.style.padding = "20px";
      errorElement.style.textAlign = "center";
      errorElement.style.opacity = "90%";
      errorElement.innerText = this._errorMessage;
      viewerContainerElement == null ? void 0 : viewerContainerElement.append(errorElement);
    }
  }
  _build() {
    this._initDisplay();
    this.activate();
  }
  /**
   * disposes the viewer
   *
   *
   */
  dispose() {
    var _a, _b, _c;
    const canvas = this.canvas();
    const cssRendererNode = (_a = this._cssRendererConfig) == null ? void 0 : _a.cssRendererNode;
    if (cssRendererNode) {
      cssRendererNode.unmountRenderer(canvas);
    }
    this._cssRendererConfig = void 0;
    (_b = this._webXRConfig) == null ? void 0 : _b.unmountFunction();
    (_c = this._markerTrackingConfig) == null ? void 0 : _c.unmountFunction();
    this._effectComposer = void 0;
    this.setAutoRender(false);
    this._cancelAnimate();
    this._unlistenToWindowResize();
    this._disposeResizeObserver();
    super.dispose();
  }
  _setEvents() {
    this.eventsController().init();
    this.webglController().init();
    this._unlistenToWindowResize();
    this._listenToWindowResize();
  }
  _initDisplay() {
    if (!this._canvas) {
      console.warn("no canvas found for viewer");
      return;
    }
    if (!this._renderer) {
      return;
    }
    const pixelRatio = this._renderer.getPixelRatio();
    this.camerasController().computeSizeAndAspect(pixelRatio);
    this.audioController().update();
    this._startAnimate();
  }
  /**
   * setAutoRender to false will stop the rendering. This can be useful if you know that nothing has changed in the scene, or if the renderer is currently not visible.
   *
   *
   */
  setAutoRender(state = true, options) {
    super.setAutoRender(state);
    if (this._doRender && this._requestAnimationFrameId == null) {
      this._startAnimate();
    }
    if (!this._doRender) {
      if (options && options.cancelAnimate == true) {
        this._cancelAnimate();
      }
    }
  }
  isXR() {
    if (!this._renderer) {
      return false;
    }
    return this._renderer instanceof WebGLRenderer && this._renderer.xr.enabled;
  }
  _startAnimate() {
    if (this.isXR()) {
      const renderer = this._renderer;
      if (!renderer) {
        return;
      }
      const webXRController = this.scene().webXR;
      const xrCallback = (timestamp, frame) => {
        var _a;
        (_a = webXRController.activeXRController()) == null ? void 0 : _a.process(frame);
        this._animateWebXR();
      };
      renderer.setAnimationLoop(xrCallback);
    } else {
      this._animateWeb();
    }
  }
  _cancelAnimate() {
    var _a;
    if (this.isXR()) {
      (_a = this._renderer) == null ? void 0 : _a.setAnimationLoop(null);
    } else {
      this._cancelAnimateCommon();
    }
  }
  _animateWeb() {
    this._requestAnimationFrameId = requestAnimationFrame(this._animateWebBound);
    this.__animateCommon__();
  }
  _animateWebXR() {
    this.__animateCommon__();
  }
  __animateCommon__() {
    const delta = this._scene.timeController.updateClockDelta();
    if (this._FPSConfig) {
      this._accumulatedDelta += delta;
      if (!isDeltaValid(this._accumulatedDelta, this._FPSConfig)) {
        return;
      }
      this._accumulatedDelta = 0;
    }
    this._tickAndRender(delta);
  }
  _cancelAnimateCommon() {
    this._doRender = false;
    if (this._requestAnimationFrameId != null) {
      cancelAnimationFrame(this._requestAnimationFrameId);
      this._requestAnimationFrameId = void 0;
    }
    if (this._canvas) {
    }
  }
  _tick(delta) {
    var _a;
    super._tick(delta);
    (_a = this._markerTrackingConfig) == null ? void 0 : _a.renderFunction();
  }
  /**
   * returns the current renderer
   *
   *
   */
  renderer() {
    return this._renderer;
  }
  effectComposer() {
    return this._effectComposer;
  }
  preCompile() {
    if (!this._renderer) {
      return;
    }
    this._renderer.compile(this._scene.threejsScene(), this._camera);
  }
  markAsReady() {
    this.preCompile();
    this.setAutoRender(true);
  }
  // private _resizeRequired = false;
  onResize() {
    const renderUpdateRequired = this.updateSize();
    if (!renderUpdateRequired) {
      return;
    }
    if (this._renderFunc) {
      this._updateRendererSize();
      this._renderFunc(this.scene().timeController.delta());
    }
    return;
  }
  updateSize() {
    const renderer = this._renderer;
    if (!renderer) {
      return false;
    }
    const pixelRatio = renderer.getPixelRatio();
    this.camerasController().computeSizeAndAspect(pixelRatio);
    const size = this.camerasController().size;
    if (this._size.equals(size)) {
      return false;
    }
    this._size.copy(size);
    this._scene.viewersRegister.markViewerAsSizeUpdated(this);
    return true;
  }
  // private _rendererSizeUpdateRequired = false;
  _updateRendererSize() {
    var _a, _b;
    const canvas = this._canvas;
    if (!canvas) {
      return;
    }
    CoreCameraRendererController.setRendererSize(canvas, this._size);
    (_a = this._cssRendererConfig) == null ? void 0 : _a.cssRenderer.setSize(this._size.x, this._size.y);
    (_b = this._effectComposer) == null ? void 0 : _b.setSize(this._size.x, this._size.y);
    this.camerasController().updateCameraAspect();
  }
  _listenToWindowResize() {
  }
  _unlistenToWindowResize() {
  }
  _createResizeObserver(canvasElementParent) {
    this._disposeResizeObserver();
    this._resizeObserver = new ResizeObserver(this._onResizeBound);
    this._resizeObserver.observe(canvasElementParent, { box: "border-box" });
  }
  _disposeResizeObserver() {
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = void 0;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/frameMode/_BaseCoreCameraFrameMode.js
var BaseCoreCameraFrameMode = class {
  static frameMode(camera) {
    return this._getFrameMode(camera) || CameraFrameMode.DEFAULT;
  }
  static expectedAspectRatio(camera) {
    return coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.FRAME_MODE_EXPECTED_ASPECT_RATIO);
  }
  static _getFrameMode(camera) {
    const frameModeAttribVal = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.FRAME_MODE);
    if (!frameModeAttribVal) {
      return;
    }
    if (!CoreType.isNumber(frameModeAttribVal)) {
      return;
    }
    return CAMERA_FRAME_MODES[frameModeAttribVal];
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreCameraViewOffset.js
function cameraViewOffsetMin(coreObjectClass, camera, target) {
  target.set(0, 0);
  coreObjectClass.attribValue(camera, CameraAttribute.VIEW_OFFSET_MIN, 0, target);
}
function cameraViewOffsetMax(coreObjectClass, camera, target) {
  target.set(1, 1);
  coreObjectClass.attribValue(camera, CameraAttribute.VIEW_OFFSET_MAX, 0, target);
}
var _min = new Vector2();
var _max = new Vector2();
function cameraSetViewOffset(camera, resolution) {
  const coreObjectClass = coreObjectClassFactory(camera);
  const hasMin = coreObjectClass.hasAttribute(camera, CameraAttribute.VIEW_OFFSET_MIN);
  const hasMax = coreObjectClass.hasAttribute(camera, CameraAttribute.VIEW_OFFSET_MAX);
  if (!(hasMin && hasMax)) {
    return;
  }
  cameraViewOffsetMin(coreObjectClass, camera, _min);
  cameraViewOffsetMax(coreObjectClass, camera, _max);
  camera.setViewOffset(
    resolution.x,
    resolution.y,
    _min.x * resolution.x,
    _min.y * resolution.y,
    _max.x * resolution.x,
    _max.y * resolution.y
  );
}

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/frameMode/CoreCameraOrthographicFrameMode.js
var CoreCameraOrthographicFrameMode = class {
  static updateCameraAspect(camera, aspect, options) {
    const cameraWithAttributes = (options == null ? void 0 : options.cameraWithAttributes) || camera;
    const frameMode = BaseCoreCameraFrameMode.frameMode(cameraWithAttributes);
    const expectedAspectRatio = BaseCoreCameraFrameMode.expectedAspectRatio(cameraWithAttributes);
    const size = coreObjectClassFactory(cameraWithAttributes).attribValue(
      cameraWithAttributes,
      OrthographicCameraAttribute.SIZE
    );
    if (size != null) {
      this._update({
        mode: frameMode,
        camera,
        size,
        aspect,
        expectedAspectRatio
      });
    }
    if (options && options.resolution) {
      cameraSetViewOffset(camera, options.resolution);
    }
    camera.updateProjectionMatrix();
  }
  static _update(options) {
    const mode = options.mode;
    if (mode == CameraFrameMode.DEFAULT || options.expectedAspectRatio == null) {
      this._adjustFOVFromModeDefault(options);
    } else {
      const { expectedAspectRatio } = options;
      if (mode == CameraFrameMode.COVER) {
        this._adjustFOVFromModeCover({ ...options, expectedAspectRatio });
      } else {
        this._adjustFOVFromModeContain({ ...options, expectedAspectRatio });
      }
    }
  }
  static _adjustFOVFromModeDefault(options) {
    this._adjustFOVFromSize(options.size || 1, options);
  }
  static _adjustFOVFromModeCover(options) {
    const size = options.size || 1;
    if (options.aspect > options.expectedAspectRatio) {
      this._adjustFOVFromSize(options.expectedAspectRatio * size / options.aspect, options);
    } else {
      this._adjustFOVFromSize(size, options);
    }
  }
  static _adjustFOVFromModeContain(options) {
    const size = options.size || 1;
    if (options.aspect > options.expectedAspectRatio) {
      this._adjustFOVFromSize(size, options);
    } else {
      this._adjustFOVFromSize(options.expectedAspectRatio * size / options.aspect, options);
    }
  }
  static _adjustFOVFromSize(size, options) {
    const horizontalSize = size * options.aspect;
    const zoom = 1;
    options.camera.left = ORTHOGRAPHIC_CAMERA_DEFAULT.left * horizontalSize * zoom;
    options.camera.right = ORTHOGRAPHIC_CAMERA_DEFAULT.right * horizontalSize * zoom;
    options.camera.top = ORTHOGRAPHIC_CAMERA_DEFAULT.top * size * zoom;
    options.camera.bottom = ORTHOGRAPHIC_CAMERA_DEFAULT.bottom * size * zoom;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/camera/CoreOrthographicCamera.js
var ORTHOGRAPHIC_CAMERA_DEFAULT = {
  left: -0.5,
  right: 0.5,
  top: 0.5,
  bottom: -0.5
};
function OrthographicCameraParamConfigMixin(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.size = ParamConfig.FLOAT(1);
    }
  };
}
var registerOrthographicCamera = (poly) => {
  poly.registerCameraNodeType(CameraNodeType.ORTHOGRAPHIC);
  poly.registerCamera(
    OrthographicCamera,
    (options) => {
      const viewer = new ThreejsViewer({
        ...options,
        updateCameraAspect: (aspect, resolution) => {
          CoreCameraOrthographicFrameMode.updateCameraAspect(options.camera, aspect, { resolution });
        }
      });
      return viewer;
    }
  );
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/operations/sop/OrthographicCamera.js
var _OrthographicCameraSopOperation = class extends BaseSopOperation {
  static type() {
    return CameraNodeType.ORTHOGRAPHIC;
  }
  cook(inputCoreGroups, params) {
    const camera = _OrthographicCameraSopOperation.createCamera(params, this._node);
    camera.left = ORTHOGRAPHIC_CAMERA_DEFAULT.left * params.size;
    camera.right = ORTHOGRAPHIC_CAMERA_DEFAULT.right * params.size;
    camera.top = ORTHOGRAPHIC_CAMERA_DEFAULT.top * params.size;
    camera.bottom = ORTHOGRAPHIC_CAMERA_DEFAULT.bottom * params.size;
    camera.name = params.name || CameraNodeType.ORTHOGRAPHIC;
    camera.position.copy(params.position);
    camera.rotation.set(
      MathUtils.degToRad(params.rotation.x),
      MathUtils.degToRad(params.rotation.y),
      MathUtils.degToRad(params.rotation.z)
    );
    _OrthographicCameraSopOperation.setCameraAttributes(camera, params);
    camera.updateWorldMatrix(false, false);
    camera.updateProjectionMatrix();
    camera.matrixAutoUpdate = params.matrixAutoUpdate;
    const objects = [camera];
    if (isBooleanTrue(params.showHelper)) {
      const helper = new CameraHelper(camera);
      helper.update();
      camera.add(helper);
    }
    return this.createCoreGroupFromObjects(objects);
  }
  static createCamera(params, nodeGenerator) {
    registerObjectType({
      type: ObjectType.ORTHOGRAPHIC_CAMERA,
      checkFunc: (o) => {
        if (o.isOrthographicCamera) {
          return ObjectType.ORTHOGRAPHIC_CAMERA;
        }
      },
      ctor: OrthographicCamera,
      humanName: "OrthographicCamera"
    });
    const camera = new OrthographicCamera(
      params.size * 2,
      params.size * 2,
      params.size * 2,
      params.size * 2,
      params.near,
      params.far
    );
    if (nodeGenerator) {
      ThreejsCoreObject.addAttribute(camera, CameraAttribute.NODE_ID, nodeGenerator.graphNodeId());
    }
    return camera;
  }
  static setCameraAttributes(camera, options) {
    ThreejsCoreObject.addAttribute(camera, OrthographicCameraAttribute.SIZE, options.size);
  }
};
var OrthographicCameraSopOperation = _OrthographicCameraSopOperation;
OrthographicCameraSopOperation.DEFAULT_PARAMS = {
  size: 1,
  near: CORE_CAMERA_DEFAULT.near,
  far: CORE_CAMERA_DEFAULT.far,
  position: new Vector3(0, 0, 0),
  rotation: new Vector3(0, 0, 0),
  showHelper: false,
  matrixAutoUpdate: true,
  name: CameraNodeType.ORTHOGRAPHIC
};
OrthographicCameraSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
OrthographicCameraSopOperation.onRegister = registerOrthographicCamera;

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/OrthographicCamera.js
var OrthographicCameraObjParamConfig = class extends CameraPostProcessParamConfig(
  CameraRenderParamConfig(
    LayerParamConfig(
      CameraMainCameraParamConfig(
        CoreCameraFrameParamConfig(
          OrthographicCameraParamConfigMixin(
            ThreejsCameraTransformParamConfig(
              TransformedParamConfig(NodeParamsConfig, { matrixAutoUpdate: true })
            )
          )
        )
      )
    )
  )
) {
};
var ParamsConfig2 = new OrthographicCameraObjParamConfig();
var OrthographicCameraObjNode = class extends TypedThreejsCameraObjNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig2;
  }
  static type() {
    return CameraNodeType.ORTHOGRAPHIC;
  }
  createObject() {
    const camera = OrthographicCameraSopOperation.createCamera(
      {
        size: this.pv.size,
        ...CORE_CAMERA_DEFAULT
      },
      this
    );
    OrthographicCameraSopOperation.setCameraAttributes(camera, { size: this.pv.size });
    return camera;
  }
  updateCamera() {
    const { size } = this.pv;
    this._object.left = ORTHOGRAPHIC_CAMERA_DEFAULT.left * size;
    this._object.right = ORTHOGRAPHIC_CAMERA_DEFAULT.right * size;
    this._object.top = ORTHOGRAPHIC_CAMERA_DEFAULT.top * size;
    this._object.bottom = ORTHOGRAPHIC_CAMERA_DEFAULT.bottom * size;
    OrthographicCameraSopOperation.setCameraAttributes(this._object, this.pv);
    this._object.updateProjectionMatrix();
  }
  // protected override _updateForAspectRatio() {
  // 	CoreCameraOrthographicFrameMode.updateCameraAspect(this._object, this._aspect);
  // }
};
OrthographicCameraObjNode.onRegister = registerOrthographicCamera;
export {
  OrthographicCameraObjNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_obj_OrthographicCamera.js.map
