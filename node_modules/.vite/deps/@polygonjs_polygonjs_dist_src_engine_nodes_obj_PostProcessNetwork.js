import {
  EffectComposer,
  RenderPass
} from "./chunk-XZSUAFIT.js";
import {
  DisplayNodeController
} from "./chunk-F6CWW4TB.js";
import "./chunk-EGRHWZRV.js";
import {
  BaseManagerObjNode
} from "./chunk-JHQNECXP.js";
import "./chunk-26GUALO3.js";
import {
  NodeParamsConfig,
  ParamConfig
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import "./chunk-O564GFGZ.js";
import {
  FloatType,
  HalfFloatType,
  UnsignedByteType,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import {
  NetworkNodeType,
  NodeContext
} from "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/post/utils/EffectComposerController.js
var RENDER_TARGET_TEXTURE_TYPE_OPTIONS = {
  UnsignedByteType,
  HalfFloatType,
  FloatType
};
var RENDER_TARGET_TEXTURE_TYPE_MENU_ENTRIES = Object.keys(RENDER_TARGET_TEXTURE_TYPE_OPTIONS).map((name) => {
  return {
    name,
    value: RENDER_TARGET_TEXTURE_TYPE_OPTIONS[name]
  };
});
function PostProcessNetworkParamsConfigMixin(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.prependRenderPass = ParamConfig.BOOLEAN(1, {
        separatorAfter: true
      });
      this.depthBuffer = ParamConfig.BOOLEAN(1);
      this.stencilBuffer = ParamConfig.BOOLEAN(0);
      this.sampling = ParamConfig.INTEGER(0, {
        range: [0, 4],
        rangeLocked: [true, false]
      });
      this.tTextureType = ParamConfig.BOOLEAN(0);
      this.textureType = ParamConfig.INTEGER(UnsignedByteType, {
        visibleIf: { tTextureType: 1 },
        menu: {
          entries: RENDER_TARGET_TEXTURE_TYPE_MENU_ENTRIES
        }
      });
    }
  };
}
var PostProcessNetworkParamsConfig = class extends PostProcessNetworkParamsConfigMixin(NodeParamsConfig) {
};
var EffectComposerController = class {
  constructor(node) {
    this.node = node;
    this._composerAndOptionsByCamera = /* @__PURE__ */ new Map();
    this._nextId = 0;
    this._passByNodeInBuildPassesProcess = /* @__PURE__ */ new Map();
    this.node.dirtyController.addPostDirtyHook("EffectComposerController", () => {
      this._updateComposers();
    });
  }
  displayNodeControllerCallbacks() {
    return {
      onDisplayNodeRemove: () => {
      },
      onDisplayNodeSet: () => {
        this.node.setDirty();
      },
      onDisplayNodeUpdate: () => {
        this.node.setDirty();
      }
    };
  }
  createEffectsComposer(options) {
    const renderer = options.renderer;
    const pv = this.node.pv;
    const composer = new EffectComposer(renderer, {
      depthBuffer: isBooleanTrue(pv.depthBuffer),
      stencilBuffer: isBooleanTrue(pv.stencilBuffer),
      multisampling: pv.sampling,
      frameBufferType: isBooleanTrue(pv.tTextureType) ? pv.textureType : void 0
    });
    composer._polygonId = this._nextId++;
    return composer;
  }
  createEffectsComposerAndBuildPasses(options) {
    const composer = this.createEffectsComposer(options);
    this._composerAndOptionsByCamera.set(options.camera, { composer, options });
    this._buildPasses(composer, options);
    return composer;
  }
  _updateComposers() {
    this._composerAndOptionsByCamera.forEach(({ composer, options }) => {
      this._buildPasses(composer, options);
    });
  }
  addPassByNodeInBuildPassesProcess(node, pass, composer) {
    this._passByNodeInBuildPassesProcess.set(node, pass);
    composer.addPass(pass);
  }
  // passByNodeInBuildPassesProcess(node: BaseNodeType) {
  // 	return this._passByNodeInBuildPassesProcess.get(node);
  // }
  _buildPasses(composer, options) {
    this._passByNodeInBuildPassesProcess.clear();
    composer.removeAllPasses();
    if (isBooleanTrue(this.node.pv.prependRenderPass)) {
      const renderPass = new RenderPass(options.scene, options.camera);
      composer.addPass(renderPass);
    }
    const postNode = this.node.displayNodeController.displayNode();
    if (postNode) {
      postNode.setupComposer({
        composerController: this,
        composer,
        camera: options.camera,
        renderer: options.renderer,
        // resolution: options.resolution,
        scene: options.scene,
        // requester: options.requester,
        viewer: options.viewer
      });
    } else {
      console.warn(`no displayNode found inside '${this.node.path()}'`);
    }
    this._passByNodeInBuildPassesProcess.clear();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/obj/PostProcessNetwork.js
var PostProcessNetworkObjNode = class extends BaseManagerObjNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = new PostProcessNetworkParamsConfig();
    this.effectsComposerController = new EffectComposerController(this);
    this.displayNodeController = new DisplayNodeController(
      this,
      this.effectsComposerController.displayNodeControllerCallbacks()
    );
    this._childrenControllerContext = NodeContext.POST;
  }
  static type() {
    return NetworkNodeType.POST;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
};
export {
  PostProcessNetworkObjNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_obj_PostProcessNetwork.js.map
