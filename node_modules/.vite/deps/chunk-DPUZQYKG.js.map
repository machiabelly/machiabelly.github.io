{
  "version": 3,
  "sources": ["../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/_Base.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/_BaseController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/helpers/MaterialSideHelper.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/AdvancedCommonController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/_BaseTextureController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureAlphaMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureEnvMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureBumpMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureNormalMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureEmissiveMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureMetalnessRoughnessMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureLightMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureDisplacementMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TextureAOMapController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/DefaultFolder.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/TexturesFolder.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/AdvancedFolder.js", "../../@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Mat.js"],
  "sourcesContent": ["\"use strict\";\nimport { TypedNode } from \"../_Base\";\nimport { NodeContext } from \"../../poly/NodeContext\";\nimport { InputCloneMode } from \"../../poly/InputCloneMode\";\nimport { FlagsControllerB } from \"../utils/FlagsController\";\nimport { arrayCompact } from \"../../../core/ArrayUtils\";\nimport { Poly } from \"../../Poly\";\nexport class TypedMatNode extends TypedNode {\n  constructor() {\n    super(...arguments);\n    this._cookWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);\n  }\n  static context() {\n    return NodeContext.MAT;\n  }\n  initializeBaseNode() {\n    super.initializeBaseNode();\n    this.io.outputs.setHasOneOutput();\n    this.addPostDirtyHook(\"_cookWhenDirty\", () => {\n      setTimeout(this._cookWhenDirtyBound, 0);\n    });\n  }\n  async _cookMainWithoutInputsWhenDirty() {\n    await this.cookController.cookMainWithoutInputs();\n  }\n  setMaterial(material) {\n    Poly.onSceneUpdatedHooks.runHooks();\n    this._setContainer(material);\n  }\n}\nexport class PrimitiveMatNode extends TypedMatNode {\n  constructor() {\n    super(...arguments);\n    this.controllersList = [];\n  }\n  __materialSync__() {\n    return this._material = this._material || this.createMaterial();\n  }\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n  initializeBaseNode() {\n    super.initializeBaseNode();\n    this.nameController.add_post_set_fullPath_hook(this.set_material_name.bind(this));\n  }\n  set_material_name() {\n    if (this._material) {\n      this._material.name = this.path();\n    }\n  }\n  setMaterial(material) {\n    this._material = material;\n    super.setMaterial(material);\n  }\n  getTextures(material, record) {\n    for (const controller of this.controllersList) {\n      controller.getTextures(material, record);\n    }\n  }\n  setParamsFromMaterial(material, record) {\n    for (const controller of this.controllersList) {\n      controller.setParamsFromMaterial(material, record);\n    }\n  }\n  controllersPromises(material) {\n    const promises = this.controllersList.map((controller) => controller.updateMaterial(material));\n    const compactPromises = [];\n    arrayCompact(promises, compactPromises);\n    return compactPromises;\n  }\n  initializeNode() {\n    this.params.onParamsCreated(\"init controllers\", () => {\n      for (const controller of this.controllersList) {\n        controller.initializeNode();\n      }\n    });\n  }\n}\nexport class UpdateMatNode extends TypedMatNode {\n  constructor() {\n    super(...arguments);\n    this.flags = new FlagsControllerB(this);\n    this._cookWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);\n  }\n  async _cookMainWithoutInputsWhenDirty() {\n    await this.cookController.cookMain();\n  }\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n  initializeBaseNode() {\n    super.initializeBaseNode();\n    this.io.inputs.setCount(1);\n    this.io.inputs.initInputsClonedState(InputCloneMode.ALWAYS);\n  }\n}\nexport class BaseMatNodeClass extends TypedMatNode {\n  // createMaterial() {\n  // \treturn new Material();\n  // }\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\n", "\"use strict\";\nexport class BaseController {\n  constructor(node) {\n    this.node = node;\n  }\n  // add_params() {}\n  initializeNode() {\n  }\n  setParamsFromMaterial(material, record) {\n  }\n  getTextures(material, record) {\n  }\n  // get material() {\n  // \treturn this.node.material;\n  // }\n}\n", "\"use strict\";\nimport { isBooleanTrue } from \"../../../../../core/Type\";\nimport { FrontSide, BackSide, DoubleSide } from \"three\";\nexport function updateMaterialSide(mat, params) {\n  const singleSide = isBooleanTrue(params.front) ? FrontSide : BackSide;\n  const newSide = isBooleanTrue(params.doubleSided) ? DoubleSide : singleSide;\n  if (newSide != mat.side) {\n    mat.side = newSide;\n    mat.forceSinglePass = !isBooleanTrue(params.doubleSided);\n    mat.needsUpdate = true;\n  }\n}\nfunction updateNodeSide(mat, params) {\n  switch (mat.side) {\n    case FrontSide: {\n      params.doubleSided.set(false);\n      params.front.set(true);\n      return;\n    }\n    case BackSide: {\n      params.doubleSided.set(false);\n      params.front.set(false);\n      return;\n    }\n    case DoubleSide: {\n      params.doubleSided.set(true);\n      params.front.set(true);\n      return;\n    }\n  }\n}\nexport function updateMaterialSideWithShadow(mat, params) {\n  updateMaterialSide(mat, params);\n  if (isBooleanTrue(params.overrideShadowSide)) {\n    const singleSide = isBooleanTrue(params.shadowFront) ? FrontSide : BackSide;\n    const newSide = isBooleanTrue(params.shadowDoubleSided) ? DoubleSide : singleSide;\n    if (newSide != mat.shadowSide) {\n      mat.shadowSide = newSide;\n      mat.needsUpdate = true;\n    }\n  } else {\n    mat.shadowSide = null;\n  }\n  const customMaterials = mat.customMaterials;\n  if (customMaterials) {\n    const customNames = Object.keys(customMaterials);\n    for (const customName of customNames) {\n      const customMaterial = customMaterials[customName];\n      if (customMaterial) {\n        updateMaterialSideWithShadow(customMaterial, params);\n      }\n    }\n  }\n}\nexport function updateNodeSideWithShadow(mat, params) {\n  updateNodeSide(mat, params);\n  if (mat.shadowSide != null) {\n    params.overrideShadowSide.set(true);\n    switch (mat.shadowSide) {\n      case FrontSide: {\n        params.shadowDoubleSided.set(false);\n        params.shadowFront.set(true);\n        return;\n      }\n      case BackSide: {\n        params.shadowDoubleSided.set(false);\n        params.shadowFront.set(false);\n        return;\n      }\n      case DoubleSide: {\n        params.shadowDoubleSided.set(true);\n        params.shadowFront.set(true);\n        return;\n      }\n    }\n  }\n  const customMaterials = mat.customMaterials;\n  if (customMaterials) {\n    const customNames = Object.keys(customMaterials);\n    for (const customName of customNames) {\n      const customMaterial = customMaterials[customName];\n      if (customMaterial) {\n        updateNodeSideWithShadow(customMaterial, params);\n      }\n    }\n  }\n}\n", "\"use strict\";\nimport {\n  NoBlending,\n  NormalBlending,\n  AdditiveBlending,\n  SubtractiveBlending,\n  MultiplyBlending\n} from \"three\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseController } from \"./_BaseController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { updateMaterialSideWithShadow, updateNodeSideWithShadow } from \"./helpers/MaterialSideHelper\";\nconst BLENDING_VALUES = {\n  NoBlending,\n  NormalBlending,\n  AdditiveBlending,\n  SubtractiveBlending,\n  MultiplyBlending\n};\nconst BLENDING_VALUE_NAMES = Object.keys(BLENDING_VALUES);\nexport function AdvancedCommonParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param defines if the material is double sided or not */\n      this.doubleSided = ParamConfig.BOOLEAN(0);\n      /** @param if the material is not double sided, it can be front sided, or back sided */\n      this.front = ParamConfig.BOOLEAN(1, { visibleIf: { doubleSided: false } });\n      /** @param override the default shadowSide behavior */\n      this.overrideShadowSide = ParamConfig.BOOLEAN(0);\n      /** @param defines which side(s) are used when rendering shadows */\n      this.shadowDoubleSided = ParamConfig.BOOLEAN(0, { visibleIf: { overrideShadowSide: true } });\n      /** @param if the material is not double sided, it can be front sided, or back sided, when computing shadows */\n      this.shadowFront = ParamConfig.BOOLEAN(1, { visibleIf: { overrideShadowSide: true, shadowDoubleSided: false } });\n      /** @param defines if the objects using this material will be rendered in the color buffer. Setting it to false can have those objects occlude the ones behind */\n      this.colorWrite = ParamConfig.BOOLEAN(1, {\n        separatorBefore: true,\n        cook: false,\n        callback: (node, param) => {\n          AdvancedCommonController.update(node);\n        }\n      });\n      /** @param defines if the objects using this material will be rendered in the depth buffer. This can often help transparent objects */\n      this.depthWrite = ParamConfig.BOOLEAN(1, {\n        cook: false,\n        callback: (node, param) => {\n          AdvancedCommonController.update(node);\n        }\n      });\n      /** @param toggle depth test */\n      this.depthTest = ParamConfig.BOOLEAN(1, {\n        cook: false,\n        callback: (node, param) => {\n          AdvancedCommonController.update(node);\n        }\n      });\n      /** @param premultipliedAlpha */\n      this.premultipliedAlpha = ParamConfig.BOOLEAN(false, {\n        separatorAfter: true\n      });\n      /** @param blending */\n      this.blending = ParamConfig.INTEGER(NormalBlending, {\n        menu: {\n          entries: BLENDING_VALUE_NAMES.map((name) => {\n            return { name, value: BLENDING_VALUES[name] };\n          })\n        }\n      });\n      /** @param dithering, which can be useful when using postprocessing and banding appears on some objects */\n      this.dithering = ParamConfig.BOOLEAN(0);\n      /** @param activate polygon offset */\n      this.polygonOffset = ParamConfig.BOOLEAN(false, { separatorBefore: true });\n      this.polygonOffsetFactor = ParamConfig.INTEGER(0, { range: [0, 1e3], visibleIf: { polygonOffset: 1 } });\n      this.polygonOffsetUnits = ParamConfig.INTEGER(0, { range: [0, 1e3], visibleIf: { polygonOffset: 1 } });\n    }\n  };\n}\nclass AdvancedCommonParamsConfig extends AdvancedCommonParamConfig(NodeParamsConfig) {\n}\nclass AdvancedCommonMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class AdvancedCommonController extends BaseController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  static async update(node) {\n    const material = await node.material();\n    if (!material) {\n      return;\n    }\n    node.controllers.advancedCommon.updateMaterial(material);\n  }\n  updateMaterial(material) {\n    const pv = this.node.pv;\n    updateMaterialSideWithShadow(material, pv);\n    material.colorWrite = pv.colorWrite;\n    material.depthWrite = pv.depthWrite;\n    material.depthTest = pv.depthTest;\n    material.blending = pv.blending;\n    material.premultipliedAlpha = pv.premultipliedAlpha;\n    material.dithering = pv.dithering;\n    material.polygonOffset = pv.polygonOffset;\n    if (material.polygonOffset) {\n      material.polygonOffsetFactor = pv.polygonOffsetFactor;\n      material.polygonOffsetUnits = pv.polygonOffsetUnits;\n      material.needsUpdate = true;\n    }\n  }\n  setParamsFromMaterial(material, record) {\n    const p = this.node.p;\n    updateNodeSideWithShadow(material, p);\n    p.colorWrite.set(material.colorWrite);\n    p.depthWrite.set(material.depthWrite);\n    p.depthTest.set(material.depthTest);\n    p.blending.set(material.blending);\n    p.premultipliedAlpha.set(material.premultipliedAlpha);\n    p.dithering.set(material.dithering);\n    p.polygonOffset.set(material.polygonOffset);\n    if (material.polygonOffset) {\n      p.polygonOffsetFactor.set(material.polygonOffsetFactor);\n      p.polygonOffsetUnits.set(material.polygonOffsetUnits);\n    }\n  }\n}\n", "\"use strict\";\nimport { BaseController } from \"./_BaseController\";\nimport { ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { NodeContext } from \"../../../poly/NodeContext\";\nimport { Poly } from \"../../../Poly\";\nexport function TextureMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      this.useMap = ParamConfig.BOOLEAN(0);\n      this.map = ParamConfig.NODE_PATH(\"\", { visibleIf: { useMap: 1 } });\n    }\n  };\n}\nexport function BooleanParamOptions(controller_class) {\n  return {\n    cook: false,\n    callback: (node, param) => {\n      controller_class.update(node);\n    }\n  };\n}\nexport function NodePathOptions(controller, use_map_name, options) {\n  return {\n    visibleIf: { [use_map_name]: 1 },\n    nodeSelection: { context: NodeContext.COP, types: options == null ? void 0 : options.types },\n    cook: false,\n    callback: (node, param) => {\n      controller.update(node);\n    }\n  };\n}\nconst CALLBACK_NAME = \"TextureController\";\nexport class BaseTextureMapController extends BaseController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n    this.updateBound = this.update.bind(this);\n  }\n  add_hooks(use_map_param, path_param) {\n    use_map_param.addPostDirtyHook(CALLBACK_NAME, this.updateBound);\n    path_param.addPostDirtyHook(CALLBACK_NAME, this.updateBound);\n  }\n  static async update(node) {\n  }\n  async update() {\n  }\n  async _update(material, mat_attrib_name, use_map_param, path_param) {\n    const mat = material;\n    const attr_name = mat_attrib_name;\n    await this._update_texture_on_material(mat, attr_name, use_map_param, path_param);\n  }\n  //\n  //\n  // FOR CASES WHERE THE TEXTURE IS ON THE MATERIAL\n  //\n  //\n  async _update_texture_on_material(material, mat_attrib_name, use_map_param, path_param) {\n    await this._update_required_attribute(\n      material,\n      material,\n      mat_attrib_name,\n      use_map_param,\n      path_param,\n      this._apply_texture_on_material.bind(this),\n      this._remove_texture_from_material.bind(this)\n    );\n  }\n  _apply_texture_on_material(material, texture_owner, mat_attrib_name, newTexture) {\n    const currentTexture = texture_owner[mat_attrib_name];\n    let textureChangeRequired = false;\n    if (currentTexture) {\n      if (currentTexture.uuid != newTexture.uuid) {\n        textureChangeRequired = true;\n      }\n    }\n    if (currentTexture == null || textureChangeRequired) {\n      texture_owner[mat_attrib_name] = newTexture;\n      material.needsUpdate = true;\n    }\n    Poly.onSceneUpdatedHooks.runHooks();\n  }\n  _remove_texture_from_material(material, texture_owner, mat_attrib_name) {\n    if (texture_owner[mat_attrib_name]) {\n      texture_owner[mat_attrib_name] = null;\n      material.needsUpdate = true;\n    }\n    Poly.onSceneUpdatedHooks.runHooks();\n  }\n  //\n  //\n  // MAIN ALGO to decide if texture should be updated\n  //\n  //\n  async _update_required_attribute(material, texture_owner, mat_attrib_name, use_map_param, path_param, update_callback, remove_callback) {\n    if (use_map_param.isDirty()) {\n      await use_map_param.compute();\n    }\n    const use_map = use_map_param.value;\n    if (use_map) {\n      if (path_param.isDirty()) {\n        await path_param.compute();\n      }\n      const texture_node = path_param.value.nodeWithContext(NodeContext.COP);\n      if (texture_node) {\n        const container = await texture_node.compute();\n        const texture = container.texture();\n        if (texture) {\n          await update_callback(material, texture_owner, mat_attrib_name, texture);\n          return;\n        }\n      }\n    }\n    remove_callback(material, texture_owner, mat_attrib_name);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function MapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle on to use a map affecting color */\n      this.useMap = ParamConfig.BOOLEAN(0, {\n        ...BooleanParamOptions(TextureMapController),\n        separatorBefore: true\n      });\n      /** @param texture map affecting color */\n      this.map = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureMapController, \"useMap\"));\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return true;\n}\nclass TextureMapParamsConfig extends MapParamConfig(NodeParamsConfig) {\n}\nclass TextureMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useMap, this.node.p.map);\n  }\n  static async update(node) {\n    node.controllers.map.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      console.warn(\"invalid mat for TextureMapController\", material);\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"map\", this.node.p.useMap, this.node.p.map);\n  }\n  getTextures(material, record) {\n    record.set(\"map\", material.map);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"map\");\n    this.node.p.useMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.map.setNode(mapNode, { relative: true });\n    }\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function AlphaMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use an alpha map */\n      this.useAlphaMap = ParamConfig.BOOLEAN(0, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureAlphaMapController)\n      });\n      /** @param specify the alpha map COP node */\n      this.alphaMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureAlphaMapController, \"useAlphaMap\"));\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return true;\n}\nclass TextureAlphaMapParamsConfig extends AlphaMapParamConfig(NodeParamsConfig) {\n}\nclass TextureAlphaMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureAlphaMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useAlphaMap, this.node.p.alphaMap);\n  }\n  static async update(node) {\n    node.controllers.alphaMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"alphaMap\", this.node.p.useAlphaMap, this.node.p.alphaMap);\n  }\n  getTextures(material, record) {\n    record.set(\"alphaMap\", material.alphaMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"aoMap\");\n    this.node.p.useAlphaMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.alphaMap.setNode(mapNode, { relative: true });\n    }\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { TypedNodePathParamValue } from \"../../../../core/Walker\";\nexport const ENV_MAP_OPERATION_DEFAULT_PARAMS = {\n  useEnvMap: false,\n  envMap: new TypedNodePathParamValue(\"\"),\n  envMapIntensity: 1\n};\nconst DEFAULT_PARAMS = ENV_MAP_OPERATION_DEFAULT_PARAMS;\nexport function EnvMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use an environment map */\n      this.useEnvMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS.useEnvMap, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureEnvMapController)\n      });\n      /** @param specify the environment map COP node */\n      this.envMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureEnvMapController, \"useEnvMap\"));\n      /** @param environment intensity */\n      this.envMapIntensity = ParamConfig.FLOAT(DEFAULT_PARAMS.envMapIntensity, { visibleIf: { useEnvMap: 1 } });\n    }\n  };\n}\nexport function isValidEnvMapMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.isMeshStandardMaterial || material.isMeshPhysicalMaterial;\n}\nclass TextureEnvMapParamsConfig extends EnvMapParamConfig(NodeParamsConfig) {\n}\nclass TextureEnvMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureEnvMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useEnvMap, this.node.p.envMap);\n  }\n  static async update(node) {\n    node.controllers.envMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!isValidEnvMapMaterial(material)) {\n      return;\n    }\n    this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"envMap\", this.node.p.useEnvMap, this.node.p.envMap);\n    material.envMapIntensity = this.node.pv.envMapIntensity;\n  }\n  getTextures(material, record) {\n    record.set(\"envMap\", material.envMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"envMap\");\n    this.node.p.useEnvMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.envMap.setNode(mapNode, { relative: true });\n    }\n    this.node.p.envMapIntensity.set(material.envMapIntensity);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function BumpMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use a bump map */\n      this.useBumpMap = ParamConfig.BOOLEAN(0, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureBumpMapController)\n      });\n      /** @param specify the bump map COP node */\n      this.bumpMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureBumpMapController, \"useBumpMap\"));\n      /** @param bump scale */\n      this.bumpScale = ParamConfig.FLOAT(1, {\n        range: [0, 1],\n        rangeLocked: [false, false],\n        ...NodePathOptions(TextureBumpMapController, \"useBumpMap\")\n      });\n      /** @param bump bias */\n      this.bumpBias = ParamConfig.FLOAT(0, {\n        range: [0, 1],\n        rangeLocked: [false, false],\n        ...NodePathOptions(TextureBumpMapController, \"useBumpMap\")\n      });\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.bumpScale != null;\n}\nclass TextureBumpMapParamsConfig extends BumpMapParamConfig(NodeParamsConfig) {\n}\nclass TextureBumpMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureBumpMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useBumpMap, this.node.p.bumpMap);\n  }\n  static async update(node) {\n    node.controllers.bumpMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"bumpMap\", this.node.p.useBumpMap, this.node.p.bumpMap);\n    material.bumpScale = this.node.pv.bumpScale;\n  }\n  getTextures(material, record) {\n    record.set(\"bumpMap\", material.bumpMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"emissiveMap\");\n    this.node.p.useBumpMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.bumpMap.setNode(mapNode, { relative: true });\n    }\n    this.node.p.bumpScale.set(material.bumpScale);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { TangentSpaceNormalMap, ObjectSpaceNormalMap } from \"three\";\nvar NormalMapMode = /* @__PURE__ */ ((NormalMapMode2) => {\n  NormalMapMode2[\"TANGENT\"] = \"tangent\";\n  NormalMapMode2[\"OBJECT\"] = \"object\";\n  return NormalMapMode2;\n})(NormalMapMode || {});\nconst NORMAL_MAP_MODES = [\"tangent\" /* TANGENT */, \"object\" /* OBJECT */];\nconst NormalMapModeByName = {\n  [\"tangent\" /* TANGENT */]: TangentSpaceNormalMap,\n  [\"object\" /* OBJECT */]: ObjectSpaceNormalMap\n};\nconst NormalNameByMode = {\n  [TangentSpaceNormalMap]: \"tangent\" /* TANGENT */,\n  [ObjectSpaceNormalMap]: \"object\" /* OBJECT */\n};\nexport function NormalMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use a normal map */\n      this.useNormalMap = ParamConfig.BOOLEAN(0, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureNormalMapController)\n      });\n      /** @param specify the normal map COP node */\n      this.normalMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureNormalMapController, \"useNormalMap\"));\n      /** @param type of normal map being used */\n      this.normalMapType = ParamConfig.INTEGER(0, {\n        visibleIf: { useNormalMap: 1 },\n        menu: {\n          entries: NORMAL_MAP_MODES.map((name, value) => {\n            return { name, value };\n          })\n        }\n      });\n      /** @param How much the normal map affects the material. Typical ranges are 0-1 */\n      this.normalScale = ParamConfig.VECTOR2([1, 1], { visibleIf: { useNormalMap: 1 } });\n      /** @param Normal Map Scale Multiplier, which multiples normalScale */\n      this.normalScaleMult = ParamConfig.FLOAT(1, {\n        range: [0, 1],\n        rangeLocked: [false, false],\n        visibleIf: { useNormalMap: 1 }\n      });\n    }\n  };\n}\nfunction isTextureNormalMapMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.normalScale != null;\n}\nclass TextureNormalMapParamsConfig extends NormalMapParamConfig(NodeParamsConfig) {\n}\nclass TextureNormalMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nconst tmpN2 = [0, 0];\nexport class TextureNormalMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useNormalMap, this.node.p.normalMap);\n  }\n  static async update(node) {\n    node.controllers.normalMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!isTextureNormalMapMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    const { p, pv } = this.node;\n    await this._update(material, \"normalMap\", p.useNormalMap, p.normalMap);\n    const normalMapType = NormalMapModeByName[NORMAL_MAP_MODES[pv.normalMapType]];\n    const mat = material;\n    mat.normalMapType = normalMapType;\n    mat.normalScale.copy(pv.normalScale).multiplyScalar(pv.normalScaleMult);\n  }\n  getTextures(material, record) {\n    record.set(\"normalMap\", material.normalMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"normalMap\");\n    const p = this.node.p;\n    p.useNormalMap.set(mapNode != null);\n    if (mapNode) {\n      p.normalMap.setNode(mapNode, { relative: true });\n    }\n    material.normalScale.toArray(tmpN2);\n    p.normalScale.set(tmpN2);\n    p.normalMapType.set(NORMAL_MAP_MODES.indexOf(NormalNameByMode[material.normalMapType]));\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { ColorConversion } from \"../../../../core/Color\";\nexport function EmissiveMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param emissive color */\n      this.emissive = ParamConfig.COLOR([0, 0, 0], { separatorBefore: true });\n      /** @param toggle if you want to use a emissive map */\n      this.useEmissiveMap = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureEmissiveMapController));\n      /** @param specify the emissive map COP node */\n      this.emissiveMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureEmissiveMapController, \"useEmissiveMap\"));\n      /** @param emissive intensity */\n      this.emissiveIntensity = ParamConfig.FLOAT(1);\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.emissive != null;\n}\nclass TextureEmissiveMapParamsConfig extends EmissiveMapParamConfig(NodeParamsConfig) {\n}\nclass TextureEmissiveMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nconst tmpN3 = [0, 0, 0];\nexport class TextureEmissiveMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useEmissiveMap, this.node.p.emissiveMap);\n  }\n  static async update(node) {\n    node.controllers.emissiveMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"emissiveMap\", this.node.p.useEmissiveMap, this.node.p.emissiveMap);\n    material.emissive.copy(this.node.pv.emissive);\n    material.emissiveIntensity = this.node.pv.emissiveIntensity;\n  }\n  getTextures(material, record) {\n    record.set(\"emissiveMap\", material.emissiveMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"emissiveMap\");\n    this.node.p.useEmissiveMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.emissiveMap.setNode(mapNode, { relative: true });\n    }\n    material.emissive.toArray(tmpN3);\n    this.node.p.emissive.set(tmpN3);\n    this.node.p.emissive.setConversion(ColorConversion.NONE);\n    this.node.p.emissiveIntensity.set(material.emissiveIntensity);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nimport { TypedNodePathParamValue } from \"../../../../core/Walker\";\nexport const METALNESS_ROUGHNESS_OPERATION_DEFAULT_PARAMS = {\n  useMetalnessMap: false,\n  metalnessMap: new TypedNodePathParamValue(\"\"),\n  metalness: 0,\n  useRoughnessMap: false,\n  roughnessMap: new TypedNodePathParamValue(\"\"),\n  roughness: 1\n};\nconst DEFAULT_PARAMS = METALNESS_ROUGHNESS_OPERATION_DEFAULT_PARAMS;\nexport function MetalnessRoughnessMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use a metalness map */\n      this.useMetalnessMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS.useMetalnessMap, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureMetalnessRoughnessMapController)\n      });\n      /** @param specify the metalness map COP node */\n      this.metalnessMap = ParamConfig.NODE_PATH(\n        \"\",\n        NodePathOptions(TextureMetalnessRoughnessMapController, \"useMetalnessMap\")\n      );\n      /** @param metalness. It's recommended to either set this value to 0 or to 1, as objects are either metallic or not. Any value in between tends to look like an alien plastic */\n      this.metalness = ParamConfig.FLOAT(DEFAULT_PARAMS.metalness);\n      // a default of 0 is good to non builder materials, but 1 should be better for builders, in case metalness is multiplied with this param from its child output node\n      /** @param toggle if you want to use a roughness map */\n      this.useRoughnessMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS.useRoughnessMap, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureMetalnessRoughnessMapController)\n      });\n      /** @param specify the roughness map COP node */\n      this.roughnessMap = ParamConfig.NODE_PATH(\n        \"\",\n        NodePathOptions(TextureMetalnessRoughnessMapController, \"useRoughnessMap\")\n      );\n      /** @param roughness. When set to 0, reflections from environment maps will be very sharp, or blurred when 1. Any value between 0 and 1 can help modulate this. */\n      this.roughness = ParamConfig.FLOAT(DEFAULT_PARAMS.roughness);\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.metalness != null;\n}\nclass TextureMetalnessMapParamsConfig extends MetalnessRoughnessMapParamConfig(NodeParamsConfig) {\n}\nclass TextureMetalnessMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureMetalnessRoughnessMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useMetalnessMap, this.node.p.metalnessMap);\n  }\n  static async update(node) {\n    node.controllers.metalnessRoughnessMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    material.metalness = this.node.pv.metalness;\n    material.roughness = this.node.pv.roughness;\n    await Promise.all([\n      this._update(material, \"metalnessMap\", this.node.p.useMetalnessMap, this.node.p.metalnessMap),\n      this._update(material, \"roughnessMap\", this.node.p.useRoughnessMap, this.node.p.roughnessMap)\n    ]);\n  }\n  getTextures(material, record) {\n    record.set(\"metalnessMap\", material.metalnessMap);\n    record.set(\"roughnessMap\", material.roughnessMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const metalnessMapNode = record.get(\"metalnessMap\");\n    const roughnessMapNode = record.get(\"roughnessMap\");\n    this.node.p.useMetalnessMap.set(metalnessMapNode != null);\n    this.node.p.useRoughnessMap.set(roughnessMapNode != null);\n    if (metalnessMapNode) {\n      this.node.p.metalnessMap.setNode(metalnessMapNode, { relative: true });\n    }\n    if (roughnessMapNode) {\n      this.node.p.roughnessMap.setNode(roughnessMapNode, { relative: true });\n    }\n    this.node.p.metalness.set(material.metalness);\n    this.node.p.roughness.set(material.roughness);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function LightMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use a light map */\n      this.useLightMap = ParamConfig.BOOLEAN(0, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureLightMapController)\n      });\n      /** @param specify the light map COP node */\n      this.lightMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureLightMapController, \"useLightMap\"));\n      /** @param light. When set to 0, reflections from environment maps will be very sharp, or blurred when 1. Any value between 0 and 1 can help modulate this. */\n      this.lightMapIntensity = ParamConfig.FLOAT(1, {\n        visibleIf: { useLightMap: 1 }\n      });\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.lightMapIntensity != null;\n}\nclass TextureLightMapParamsConfig extends LightMapParamConfig(NodeParamsConfig) {\n}\nclass TextureLightMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureLightMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useLightMap, this.node.p.lightMap);\n  }\n  static async update(node) {\n    node.controllers.lightMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"lightMap\", this.node.p.useLightMap, this.node.p.lightMap);\n    material.lightMapIntensity = this.node.pv.lightMapIntensity;\n  }\n  getTextures(material, record) {\n    record.set(\"lightMap\", material.lightMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"lightMap\");\n    this.node.p.useLightMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.lightMap.setNode(mapNode, { relative: true });\n    }\n    this.node.p.lightMapIntensity.set(material.lightMapIntensity);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function DisplacementMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use a displacement map */\n      this.useDisplacementMap = ParamConfig.BOOLEAN(0, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureDisplacementMapController)\n      });\n      /** @param specify the displacement map COP node */\n      this.displacementMap = ParamConfig.NODE_PATH(\n        \"\",\n        NodePathOptions(TextureDisplacementMapController, \"useDisplacementMap\")\n      );\n      /** @param displacement scale */\n      this.displacementScale = ParamConfig.FLOAT(1, {\n        range: [0, 1],\n        rangeLocked: [false, false],\n        ...NodePathOptions(TextureDisplacementMapController, \"useDisplacementMap\")\n      });\n      /** @param displacement bias */\n      this.displacementBias = ParamConfig.FLOAT(0, {\n        range: [0, 1],\n        rangeLocked: [false, false],\n        ...NodePathOptions(TextureDisplacementMapController, \"useDisplacementMap\")\n      });\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.displacementScale != null;\n}\nclass TextureDisplacementMapParamsConfig extends DisplacementMapParamConfig(NodeParamsConfig) {\n}\nclass TextureDisplacementMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureDisplacementMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useDisplacementMap, this.node.p.displacementMap);\n  }\n  static async update(node) {\n    node.controllers.displacementMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"displacementMap\", this.node.p.useDisplacementMap, this.node.p.displacementMap);\n    material.displacementScale = this.node.pv.displacementScale;\n    material.displacementBias = this.node.pv.displacementBias;\n  }\n  getTextures(material, record) {\n    record.set(\"displacementMap\", material.displacementMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"emissiveMap\");\n    this.node.p.useDisplacementMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.displacementMap.setNode(mapNode, { relative: true });\n    }\n    this.node.p.displacementScale.set(material.displacementScale);\n    this.node.p.displacementBias.set(material.displacementBias);\n  }\n}\n", "\"use strict\";\nimport { TypedMatNode } from \"../_Base\";\nimport { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from \"./_BaseTextureController\";\nimport { NodeParamsConfig, ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function AOMapParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      /** @param toggle if you want to use an ambient occlusion map */\n      this.useAOMap = ParamConfig.BOOLEAN(0, {\n        separatorBefore: true,\n        ...BooleanParamOptions(TextureAOMapController)\n      });\n      /** @param specify the AO map COP node */\n      this.aoMap = ParamConfig.NODE_PATH(\"\", NodePathOptions(TextureAOMapController, \"useAOMap\"));\n      /** @param ambient occlusion intensity */\n      this.aoMapIntensity = ParamConfig.FLOAT(1, { range: [0, 1], rangeLocked: [false, false], visibleIf: { useAOMap: 1 } });\n    }\n  };\n}\nfunction _isValidMaterial(material) {\n  if (!material) {\n    return false;\n  }\n  return material.aoMapIntensity != null;\n}\nclass TextureAOMapParamsConfig extends AOMapParamConfig(NodeParamsConfig) {\n}\nclass TextureAOMapMatNode extends TypedMatNode {\n  async material() {\n    const container = await this.compute();\n    return container.material();\n  }\n}\nexport class TextureAOMapController extends BaseTextureMapController {\n  constructor(node) {\n    super(node);\n    this.node = node;\n  }\n  initializeNode() {\n    this.add_hooks(this.node.p.useAOMap, this.node.p.aoMap);\n  }\n  static async update(node) {\n    node.controllers.aoMap.update();\n  }\n  async update() {\n    const material = await this.node.material();\n    if (!_isValidMaterial(material)) {\n      return;\n    }\n    await this.updateMaterial(material);\n  }\n  async updateMaterial(material) {\n    await this._update(material, \"aoMap\", this.node.p.useAOMap, this.node.p.aoMap);\n    material.aoMapIntensity = this.node.pv.aoMapIntensity;\n  }\n  getTextures(material, record) {\n    record.set(\"aoMap\", material.aoMap);\n  }\n  setParamsFromMaterial(material, record) {\n    const mapNode = record.get(\"aoMap\");\n    this.node.p.useAOMap.set(mapNode != null);\n    if (mapNode) {\n      this.node.p.aoMap.setNode(mapNode, { relative: true });\n    }\n    this.node.p.aoMapIntensity.set(material.aoMapIntensity);\n  }\n}\n", "\"use strict\";\nimport { ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function DefaultFolderParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      this.default = ParamConfig.FOLDER(null);\n    }\n  };\n}\n", "\"use strict\";\nimport { ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function TexturesFolderParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      this.textures = ParamConfig.FOLDER(null);\n    }\n  };\n}\n", "\"use strict\";\nimport { ParamConfig } from \"../../utils/params/ParamsConfig\";\nexport function AdvancedFolderParamConfig(Base) {\n  return class Mixin extends Base {\n    constructor() {\n      super(...arguments);\n      this.advanced = ParamConfig.FOLDER(null);\n    }\n  };\n}\n", "\"use strict\";\nexport var MatType = /* @__PURE__ */ ((MatType2) => {\n  MatType2[\"LINE_BASIC\"] = \"lineBasic\";\n  MatType2[\"LINE_BASIC_BUILDER\"] = \"lineBasicBuilder\";\n  MatType2[\"MESH_BASIC\"] = \"meshBasic\";\n  MatType2[\"MESH_BASIC_BUILDER\"] = \"meshBasicBuilder\";\n  MatType2[\"MESH_DEPTH_BUILDER\"] = \"meshDepthBuilder\";\n  MatType2[\"MESH_DISTANCE_BUILDER\"] = \"meshDistanceBuilder\";\n  MatType2[\"MESH_LAMBERT\"] = \"meshLambert\";\n  MatType2[\"MESH_LAMBERT_BUILDER\"] = \"meshLambertBuilder\";\n  MatType2[\"MESH_MATCAP\"] = \"meshMatcap\";\n  MatType2[\"MESH_NORMAL\"] = \"meshNormal\";\n  MatType2[\"MESH_PHONG\"] = \"meshPhong\";\n  MatType2[\"MESH_PHONG_BUILDER\"] = \"meshPhongBuilder\";\n  MatType2[\"MESH_PHYSICAL\"] = \"meshPhysical\";\n  MatType2[\"MESH_PHYSICAL_BUILDER\"] = \"meshPhysicalBuilder\";\n  MatType2[\"MESH_STANDARD\"] = \"meshStandard\";\n  MatType2[\"MESH_STANDARD_BUILDER\"] = \"meshStandardBuilder\";\n  MatType2[\"MESH_TOON\"] = \"meshToon\";\n  MatType2[\"MESH_TOON_BUILDER\"] = \"meshToonBuilder\";\n  MatType2[\"POINTS\"] = \"points\";\n  MatType2[\"POINTS_BUILDER\"] = \"pointsBuilder\";\n  MatType2[\"RAY_MARCHING_BUILDER\"] = \"rayMarchingBuilder\";\n  MatType2[\"SHADOW\"] = \"shadow\";\n  MatType2[\"SKY\"] = \"sky\";\n  MatType2[\"VOLUME\"] = \"volume\";\n  MatType2[\"VOLUME_BUILDER\"] = \"volumeBuilder\";\n  return MatType2;\n})(MatType || {});\n"],
  "mappings": "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",
  "names": ["_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "DEFAULT_PARAMS", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial", "_isValidMaterial"]
}
