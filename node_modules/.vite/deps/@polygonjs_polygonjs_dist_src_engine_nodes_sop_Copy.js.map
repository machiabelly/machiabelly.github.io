{
  "version": 3,
  "sources": ["../../@polygonjs/polygonjs/dist/src/engine/nodes/utils/BaseCopyStamp.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/sop/utils/CopyStamp.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/sop/Copy.js"],
  "sourcesContent": ["\"use strict\";\nimport { CoreGraphNode } from \"../../../core/graph/CoreGraphNode\";\nexport class BaseCopyStamp extends CoreGraphNode {\n  constructor(scene) {\n    super(scene, \"CopyStamp\");\n  }\n  reset() {\n    this.setGlobalIndex(0);\n  }\n  setGlobalIndex(index) {\n    const oldIndex = this._globalIndex;\n    this._globalIndex = index;\n    if (oldIndex != this._globalIndex) {\n      this.setDirty();\n      this.removeDirtyState();\n    }\n  }\n  value(attribName) {\n    return this._globalIndex;\n  }\n}\n", "\"use strict\";\nimport { BaseCopyStamp } from \"../../utils/BaseCopyStamp\";\nexport class SopCopyStamp extends BaseCopyStamp {\n  reset() {\n    super.reset();\n    this.setPoint(void 0);\n  }\n  setPoint(point) {\n    const oldPoint = this._point;\n    this._point = point;\n    if (oldPoint != this._point) {\n      this.setDirty();\n      this.removeDirtyState();\n    }\n  }\n  value(attribName) {\n    if (this._point) {\n      if (attribName) {\n        return this._point.attribValue(attribName);\n      } else {\n        return this._point.index();\n      }\n    } else {\n      if (attribName == null || attribName == \"i\") {\n        return this._globalIndex;\n      }\n    }\n  }\n}\n", "\"use strict\";\nimport { ObjectTransformMode } from \"./../../../core/TransformSpace\";\nimport { SopType } from \"./../../poly/registers/nodes/types/Sop\";\nimport { TypedSopNode } from \"./_Base\";\nimport { BaseCoreObject } from \"../../../core/geometry/entities/object/BaseCoreObject\";\nimport { CoreInstancer } from \"../../../core/geometry/Instancer\";\nimport { SopCopyStamp } from \"./utils/CopyStamp\";\nimport { Matrix4 } from \"three\";\nimport { NodeParamsConfig, ParamConfig } from \"../utils/params/ParamsConfig\";\nimport { InputCloneMode } from \"../../poly/InputCloneMode\";\nimport { isBooleanTrue } from \"../../../core/BooleanValue\";\nimport {\n  filterCoreObjectsFromCoreGroup,\n  filterObjectsWithGroup,\n  filterThreejsCoreObjectsFromCoreGroup\n} from \"../../../core/geometry/Mask\";\nimport { CoreTransform, RotationOrder, TRANSFORM_TARGET_TYPES, TransformTargetType } from \"../../../core/Transform\";\nimport { OBJECT_TRANSFORM_SPACE_MENU_ENTRIES, OBJECT_TRANSFORM_SPACES } from \"../../../core/TransformSpace\";\nimport { coreObjectClassFactory } from \"../../../core/geometry/CoreObjectFactory\";\nimport { pointsFromCoreObjects } from \"../../../core/geometry/entities/point/CorePointUtils\";\nclass CopySopParamsConfig extends NodeParamsConfig {\n  constructor() {\n    super(...arguments);\n    /** @param select which objects are copied */\n    this.srcGroup = ParamConfig.STRING(\"\", {\n      objectMask: true\n    });\n    /** @param select which objects the src objects are copied onto */\n    this.templateGroup = ParamConfig.STRING(\"\", {\n      objectMask: {\n        inputIndex: 1\n      }\n    });\n    /** @param copies count, used when the second input is not given */\n    this.count = ParamConfig.INTEGER(1, {\n      range: [1, 20],\n      rangeLocked: [true, false]\n    });\n    /** @param translate each copy */\n    this.t = ParamConfig.VECTOR3([0, 0, 0]);\n    /** @param rotate each copy */\n    this.r = ParamConfig.VECTOR3([0, 0, 0]);\n    /** @param scale each copy */\n    this.s = ParamConfig.VECTOR3([1, 1, 1]);\n    /** @param scale multiplier for each copy */\n    this.scale = ParamConfig.FLOAT(1);\n    /** @param transforms every input object each on a single input point */\n    this.transformOnly = ParamConfig.BOOLEAN(0);\n    /** @param defines if the objects or the geometries are transformed */\n    this.transformMode = ParamConfig.INTEGER(TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT), {\n      menu: {\n        entries: TRANSFORM_TARGET_TYPES.map((name, value) => ({ name, value }))\n      }\n    });\n    /** @param defines how the objects are transformed */\n    this.objectTransformSpace = ParamConfig.INTEGER(0, {\n      visibleIf: { transformMode: TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.OBJECT) },\n      menu: {\n        entries: OBJECT_TRANSFORM_SPACE_MENU_ENTRIES\n      }\n    });\n    /** @param toggles on to copy attributes from the input points to the created objects. Note that the vertex attributes from the points become object attributes */\n    this.copyAttributes = ParamConfig.BOOLEAN(0);\n    /** @param names of attributes to copy */\n    this.attributesToCopy = ParamConfig.STRING(\"\", {\n      visibleIf: { copyAttributes: true }\n    });\n    /** @param toggle on to use the `copy` expression, which allows to change how the left input is evaluated for each point */\n    this.useCopyExpr = ParamConfig.BOOLEAN(1);\n  }\n}\nconst ParamsConfig = new CopySopParamsConfig();\nexport class CopySopNode extends TypedSopNode {\n  constructor() {\n    super(...arguments);\n    this.paramsConfig = ParamsConfig;\n    this._attribNamesToCopy = [];\n    this._objects = [];\n    this._instancer = new CoreInstancer();\n    this._instanceMatrix = new Matrix4();\n    //\n    //\n    // ACCUMULATE TRANSFORM\n    //\n    //\n    this._coreTransform = new CoreTransform();\n    this._transformAccumulatedMatrix = new Matrix4();\n    this._transformMatrix = new Matrix4();\n  }\n  static type() {\n    return SopType.COPY;\n  }\n  initializeNode() {\n    this.io.inputs.setCount(1, 2);\n    this.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);\n  }\n  setTransformMode(transformMode) {\n    this.p.transformMode.set(TRANSFORM_TARGET_TYPES.indexOf(transformMode));\n  }\n  setObjectTransformSpace(transformSpace) {\n    this.p.objectTransformSpace.set(OBJECT_TRANSFORM_SPACES.indexOf(transformSpace));\n  }\n  async cook(inputCoreGroups) {\n    if (!isBooleanTrue(this.pv.useCopyExpr)) {\n      this.stampNode().reset();\n    }\n    const coreGroup0 = inputCoreGroups[0];\n    if (!this.io.inputs.hasInput(1)) {\n      await this.cookWithoutTemplate(coreGroup0);\n      return;\n    }\n    const coreGroup1 = inputCoreGroups[1];\n    if (!coreGroup1) {\n      this.states.error.set(\"second input invalid\");\n      return;\n    }\n    await this.cookWithTemplate(coreGroup0, coreGroup1);\n    this.stampNode().reset();\n  }\n  async cookWithTemplate(instanceCoreGroup, templateCoreGroup) {\n    this._objects = [];\n    const templateCoreObjects = filterThreejsCoreObjectsFromCoreGroup(templateCoreGroup, {\n      group: this.pv.templateGroup\n    });\n    const templatePoints = [];\n    pointsFromCoreObjects(templateCoreObjects, templatePoints);\n    this._instancer.setCoreGroup(templateCoreGroup);\n    this._attribNamesToCopy = templateCoreGroup.pointAttribNamesMatchingMask(this.pv.attributesToCopy);\n    await this._copyMovedObjectsOnTemplatePoints(instanceCoreGroup, templatePoints);\n    this.setObjects(this._objects);\n  }\n  // https://stackoverflow.com/questions/24586110/resolve-promises-one-after-another-i-e-in-sequence\n  async _copyMovedObjectsOnTemplatePoints(instanceCoreGroup, templatePoints) {\n    this._initAccumulatedTransform();\n    for (let pointIndex = 0; pointIndex < templatePoints.length; pointIndex++) {\n      await this._copyMovedObjectOnTemplatePoint(instanceCoreGroup, templatePoints, pointIndex);\n      this._accumulateTransform();\n    }\n  }\n  async _copyMovedObjectOnTemplatePoint(instanceCoreGroup, templatePoints, point_index) {\n    this._instancer.matrixFromPoint(templatePoints[point_index], this._instanceMatrix);\n    const templatePoint = templatePoints[point_index];\n    if (isBooleanTrue(this.pv.useCopyExpr)) {\n      this.stampNode().setPoint(templatePoint);\n    }\n    const movedObjects = await this._getMovedObjectsForTemplatePoint(instanceCoreGroup, point_index);\n    for (const movedObject of movedObjects) {\n      if (isBooleanTrue(this.pv.copyAttributes)) {\n        this._copyAttributesGromTemplate(movedObject, templatePoint);\n      }\n      if (isBooleanTrue(this.pv.transformOnly)) {\n        movedObject.applyMatrix4(this._instanceMatrix);\n      } else {\n        this._applyMatrixToObject(movedObject, this._instanceMatrix);\n      }\n      this._applyAccumulatedTransform(movedObject);\n      this._objects.push(movedObject);\n    }\n  }\n  async _getMovedObjectsForTemplatePoint(instanceCoreGroup, pointIndex) {\n    const stampedInstanceCoreGroup = await this._stampInstanceGroupIfRequired(instanceCoreGroup);\n    if (stampedInstanceCoreGroup) {\n      const getObjectsForTransformOnly = () => {\n        const objects = filterObjectsWithGroup(stampedInstanceCoreGroup, { group: this.pv.srcGroup });\n        const object = objects[pointIndex];\n        if (object) {\n          return [coreObjectClassFactory(object).clone(object)];\n        } else {\n          return [];\n        }\n      };\n      const movedObjects = isBooleanTrue(this.pv.transformOnly) ? (\n        // TODO: why is doing a transform slower than cloning the input??\n        getObjectsForTransformOnly()\n      ) : filterObjectsWithGroup(stampedInstanceCoreGroup.clone(), { group: this.pv.srcGroup });\n      return movedObjects;\n    } else {\n      return [];\n    }\n  }\n  async _stampInstanceGroupIfRequired(instanceCoreGroup) {\n    const container0 = await this.containerController.requestInputContainer(0);\n    if (container0) {\n      const coreGroup0 = container0.coreContent();\n      if (coreGroup0) {\n        return coreGroup0;\n      } else {\n        return;\n      }\n    } else {\n      this.states.error.set(`input failed for index ${this.stampValue()}`);\n      return;\n    }\n  }\n  async _copyMovedObjectsForEachInstance(instanceCoreGroup) {\n    this._initAccumulatedTransform();\n    for (let i = 0; i < this.pv.count; i++) {\n      await this._copyMovedObjectsForInstance(instanceCoreGroup, i);\n      this._accumulateTransform();\n    }\n  }\n  async _copyMovedObjectsForInstance(instanceCoreGroup, i) {\n    if (isBooleanTrue(this.pv.useCopyExpr)) {\n      this.stampNode().setGlobalIndex(i);\n    }\n    const stamptedInstanceCoreGroup = await this._stampInstanceGroupIfRequired(instanceCoreGroup);\n    if (stamptedInstanceCoreGroup) {\n      const srcCoreObjects = filterCoreObjectsFromCoreGroup(stamptedInstanceCoreGroup, {\n        group: this.pv.srcGroup\n      });\n      for (const coreObject of srcCoreObjects) {\n        const clonedObject = coreObject.clone().object();\n        if (clonedObject) {\n          this._applyAccumulatedTransform(clonedObject);\n          this._objects.push(clonedObject);\n        }\n      }\n    }\n  }\n  // TODO: what if I combine both param_count and stamping?!\n  async cookWithoutTemplate(instanceCoreGroup) {\n    this._objects = [];\n    await this._copyMovedObjectsForEachInstance(instanceCoreGroup);\n    this.setObjects(this._objects);\n  }\n  _copyAttributesGromTemplate(object, templatePoint) {\n    this._attribNamesToCopy.forEach((attribName, i) => {\n      const attribValue = templatePoint.attribValue(attribName);\n      BaseCoreObject.addAttribute(object, attribName, attribValue);\n    });\n  }\n  //\n  //\n  // STAMP\n  //\n  //\n  stampValue(attribName) {\n    return this.stampNode().value(attribName);\n  }\n  stampNode() {\n    return this._stampNode = this._stampNode || this._createStampNode();\n  }\n  _createStampNode() {\n    const stampNode = new SopCopyStamp(this.scene());\n    stampNode.setForbiddenTriggerNodes(this);\n    return stampNode;\n  }\n  dispose() {\n    super.dispose();\n    if (this._stampNode) {\n      this._stampNode.dispose();\n    }\n  }\n  _initAccumulatedTransform() {\n    const pv = this.pv;\n    this._transformMatrix = this._coreTransform.matrix(pv.t, pv.r, pv.s, pv.scale, RotationOrder.XYZ);\n    this._transformAccumulatedMatrix.identity();\n  }\n  _accumulateTransform() {\n    this._transformAccumulatedMatrix.multiply(this._transformMatrix);\n  }\n  _applyMatrixToObject(object, matrix) {\n    coreObjectClassFactory(object).applyMatrix(\n      object,\n      matrix,\n      TRANSFORM_TARGET_TYPES[this.pv.transformMode],\n      OBJECT_TRANSFORM_SPACES[this.pv.objectTransformSpace],\n      ObjectTransformMode.MULT\n    );\n  }\n  _applyAccumulatedTransform(object) {\n    this._applyMatrixToObject(object, this._transformAccumulatedMatrix);\n  }\n  //\n  //\n  // MATRIX OPERATIONS\n  //\n  //\n  // private _applyMatrixToObjectOrGeometry(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {\n  // \tconst transformMode = TRANSFORM_MODES[this.pv.transformMode];\n  // \tswitch (transformMode) {\n  // \t\tcase TransformMode.OBJECT: {\n  // \t\t\tthis._applyMatrixToObject(object, matrix);\n  // \t\t\treturn;\n  // \t\t}\n  // \t\tcase TransformMode.GEOMETRY: {\n  // \t\t\tconst geometry = (object as Object3DWithGeometry).geometry;\n  // \t\t\tif (geometry) {\n  // \t\t\t\tgeometry.applyMatrix4(matrix);\n  // \t\t\t}\n  // \t\t\treturn;\n  // \t\t}\n  // \t}\n  // \tTypeAssert.unreachable(transformMode);\n  // }\n  // private _object_position = new Vector3();\n  // private _applyMatrixToObject(object: ObjectContent<CoreObjectType>, matrix: Matrix4) {\n  // \tapplyTransformWithSpaceToObject(object, matrix, OBJECT_TRANSFORM_SPACES[this.pv.objectTransformSpace]);\n  // }\n}\n"],
  "mappings": "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",
  "names": []
}
