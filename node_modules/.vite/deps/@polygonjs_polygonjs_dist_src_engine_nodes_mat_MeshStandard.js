import {
  AOMapParamConfig,
  AdvancedCommonController,
  AdvancedCommonParamConfig,
  AdvancedFolderParamConfig,
  AlphaMapParamConfig,
  BaseController,
  BumpMapParamConfig,
  DefaultFolderParamConfig,
  DisplacementMapParamConfig,
  EmissiveMapParamConfig,
  EnvMapParamConfig,
  LightMapParamConfig,
  MapParamConfig,
  MatType,
  MetalnessRoughnessMapParamConfig,
  NormalMapParamConfig,
  PrimitiveMatNode,
  TextureAOMapController,
  TextureAlphaMapController,
  TextureBumpMapController,
  TextureDisplacementMapController,
  TextureEmissiveMapController,
  TextureEnvMapController,
  TextureLightMapController,
  TextureMapController,
  TextureMetalnessRoughnessMapController,
  TextureNormalMapController,
  TexturesFolderParamConfig
} from "./chunk-DPUZQYKG.js";
import "./chunk-EGRHWZRV.js";
import {
  ColorConversion,
  NodeParamsConfig,
  ParamConfig
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import "./chunk-O564GFGZ.js";
import {
  Color,
  FrontSide,
  MeshStandardMaterial,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/ColorsController.js
function ColorParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.color = ParamConfig.COLOR([1, 1, 1], {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      this.useVertexColors = ParamConfig.BOOLEAN(0, { separatorAfter: true });
      this.transparent = ParamConfig.BOOLEAN(0);
      this.opacity = ParamConfig.FLOAT(1);
      this.alphaTest = ParamConfig.FLOAT(0);
    }
  };
}
function isValidColoredMaterial(material) {
  if (!material) {
    return false;
  }
  return material.color != null;
}
var ColorParamsConfig = class extends ColorParamConfig(NodeParamsConfig) {
};
var _tmpColor = new Color();
var _tmpColorArray = [0, 0, 0];
var ColorsController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const container = await node.compute();
    const material = container.material();
    if (!isValidColoredMaterial(material)) {
      return;
    }
    node.controllers.colors.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.color.copy(pv.color);
    const newVertexColor = isBooleanTrue(pv.useVertexColors);
    if (newVertexColor != material.vertexColors) {
      material.vertexColors = newVertexColor;
      material.needsUpdate = true;
    }
    material.opacity = pv.opacity;
    material.transparent = pv.transparent;
    material.alphaTest = pv.alphaTest;
  }
  setParamsFromMaterial(material, record) {
    const p = this.node.p;
    _tmpColor.copy(material.color).toArray(_tmpColorArray);
    p.color.set(_tmpColorArray);
    p.color.setConversion(ColorConversion.NONE);
    p.useVertexColors.set(material.vertexColors);
    p.opacity.set(material.opacity);
    p.transparent.set(material.transparent);
    p.alphaTest.set(material.alphaTest);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/FlatShadingController.js
function FlatShadingParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.flatShading = ParamConfig.BOOLEAN(0, {
        separatorAfter: true
      });
    }
  };
}
var FlatShadingParamsConfig = class extends FlatShadingParamConfig(NodeParamsConfig) {
};
function _isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return material.flatShading != null;
}
var FlatShadingController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!_isValidMaterial(material)) {
      return;
    }
    node.controllers.flatShading.updateMaterial(material);
  }
  updateMaterial(material) {
    material.flatShading = this.node.pv.flatShading;
  }
  setParamsFromMaterial(material, record) {
    this.node.p.flatShading.set(material.flatShading);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/WireframeController.js
var LineCapType = ((LineCapType2) => {
  LineCapType2["ROUND"] = "round";
  LineCapType2["BUTT"] = "butt";
  LineCapType2["SQUARE"] = "square";
  return LineCapType2;
})(LineCapType || {});
var LINE_CAP_TYPES = [
  "round",
  "butt",
  "square"
  /* SQUARE */
];
var LineJoinType = ((LineJoinType2) => {
  LineJoinType2["ROUND"] = "round";
  LineJoinType2["BEVEL"] = "bevel";
  LineJoinType2["MITER"] = "miter";
  return LineJoinType2;
})(LineJoinType || {});
var LINE_JOIN_TYPES = [
  "round",
  "bevel",
  "miter"
  /* MITER */
];
function WireframeParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.wireframe = ParamConfig.BOOLEAN(0, { separatorBefore: true });
      this.wireframeLinewidth = ParamConfig.FLOAT(1, {
        range: [0, 5],
        rangeLocked: [true, false],
        visibleIf: { wireframe: 1 }
      });
      this.wireframeLinecap = ParamConfig.INTEGER(0, {
        menu: {
          entries: LINE_CAP_TYPES.map((name, value) => {
            return { name, value };
          })
        },
        visibleIf: { wireframe: 1 }
      });
      this.wireframeLinejoin = ParamConfig.INTEGER(0, {
        menu: {
          entries: LINE_JOIN_TYPES.map((name, value) => {
            return { name, value };
          })
        },
        visibleIf: { wireframe: 1 },
        separatorAfter: true
      });
    }
  };
}
function isValidWireframeMaterial(material) {
  if (!material) {
    return false;
  }
  return material.wireframe != null;
}
var WireframeParamsConfig = class extends WireframeParamConfig(NodeParamsConfig) {
};
var WireframeController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!isValidWireframeMaterial(material)) {
      return;
    }
    node.controllers.wireframe.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.wireframe = isBooleanTrue(pv.wireframe);
    material.wireframeLinewidth = pv.wireframeLinewidth;
    material.wireframeLinecap = LINE_CAP_TYPES[pv.wireframeLinecap];
    material.wireframeLinejoin = LINE_JOIN_TYPES[pv.wireframeLinejoin];
    material.needsUpdate = true;
  }
  getTextures(material, record) {
  }
  setParamsFromMaterial(material, record) {
    this.node.p.wireframe.set(material.wireframe);
    this.node.p.wireframeLinewidth.set(material.wireframeLinewidth);
    this.node.p.wireframeLinecap.set(LINE_CAP_TYPES.indexOf(material.wireframeLinecap));
    this.node.p.wireframeLinejoin.set(LINE_JOIN_TYPES.indexOf(material.wireframeLinejoin));
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/FogController.js
function FogParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useFog = ParamConfig.BOOLEAN(0);
    }
  };
}
function isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return material.fog != null;
}
var FogParamsConfig = class extends FogParamConfig(NodeParamsConfig) {
};
var FogController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const container = await node.compute();
    const material = container.material();
    if (!isValidMaterial(material)) {
      return;
    }
    node.controllers.fog.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.fog = isBooleanTrue(pv.useFog);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/MeshStandard.js
var MeshStandardMatParamsConfig = class extends FogParamConfig(
  WireframeParamConfig(
    AdvancedCommonParamConfig(
      FlatShadingParamConfig(
        /* advanced */
        AdvancedFolderParamConfig(
          MetalnessRoughnessMapParamConfig(
            NormalMapParamConfig(
              LightMapParamConfig(
                EnvMapParamConfig(
                  EmissiveMapParamConfig(
                    DisplacementMapParamConfig(
                      BumpMapParamConfig(
                        AOMapParamConfig(
                          AlphaMapParamConfig(
                            MapParamConfig(
                              /* textures */
                              TexturesFolderParamConfig(
                                ColorParamConfig(
                                  DefaultFolderParamConfig(NodeParamsConfig)
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
};
var ParamsConfig = new MeshStandardMatParamsConfig();
var MeshStandardMatNode = class extends PrimitiveMatNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.controllers = {
      colors: new ColorsController(this),
      advancedCommon: new AdvancedCommonController(this),
      alphaMap: new TextureAlphaMapController(this),
      aoMap: new TextureAOMapController(this),
      bumpMap: new TextureBumpMapController(this),
      displacementMap: new TextureDisplacementMapController(this),
      emissiveMap: new TextureEmissiveMapController(this),
      envMap: new TextureEnvMapController(this),
      fog: new FogController(this),
      flatShading: new FlatShadingController(this),
      lightMap: new TextureLightMapController(this),
      map: new TextureMapController(this),
      metalnessRoughnessMap: new TextureMetalnessRoughnessMapController(this),
      normalMap: new TextureNormalMapController(this),
      wireframe: new WireframeController(this)
    };
    this.controllersList = Object.values(this.controllers);
  }
  static type() {
    return MatType.MESH_STANDARD;
  }
  createMaterial() {
    return new MeshStandardMaterial({
      vertexColors: false,
      side: FrontSide,
      color: 16777215,
      opacity: 1,
      metalness: 1,
      roughness: 0
    });
  }
  async cook() {
    this._material = this._material || this.createMaterial();
    await Promise.all(this.controllersPromises(this._material));
    this.setMaterial(this._material);
  }
};
export {
  MeshStandardMatNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_mat_MeshStandard.js.map
