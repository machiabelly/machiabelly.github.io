{
  "version": 3,
  "sources": ["../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/globals/_Base.js", "../../@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Gl.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/utils/io/ParamsEditableStateController.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/_Base.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/Attribute.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/utils/GLDefinitionCollection.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/utils/GLDefinition.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/utils/shaders/ShaderName.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/assemblers/materials/common/GlobalOutput.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/globals/Common.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/globals/Geometry.js", "../../@polygonjs/polygonjs/dist/src/engine/operations/sop/Material.js", "../../@polygonjs/polygonjs/dist/src/engine/nodes/sop/Material.js"],
  "sourcesContent": ["\"use strict\";\nexport class GlobalsBaseController {\n  handleGlobalsNode(globalsNode, outputName, shadersCollectionController) {\n  }\n  handleGlobalVar(globalsNode, outputName, glType, shadersCollectionController) {\n  }\n}\n", "\"use strict\";\nexport var GlType = /* @__PURE__ */ ((GlType2) => {\n  GlType2[\"ADJACENT_POINTS_ATTRIB_SMOOTH\"] = \"adjacentPointsAttribSmooth\";\n  GlType2[\"ADJACENT_UV_ATTRIB_SMOOTH\"] = \"adjacentUvAttribSmooth\";\n  GlType2[\"ATTRIBUTE\"] = \"attribute\";\n  GlType2[\"COMPUTE_NORMALS\"] = \"computeNormals\";\n  GlType2[\"CONSTANT\"] = \"constant\";\n  GlType2[\"FOR_LOOP\"] = \"forLoop\";\n  GlType2[\"IF_THEN\"] = \"ifThen\";\n  GlType2[\"GLOBALS\"] = \"globals\";\n  GlType2[\"NOISE\"] = \"noise\";\n  GlType2[\"OUTPUT\"] = \"output\";\n  GlType2[\"PARAM\"] = \"param\";\n  GlType2[\"RAMP\"] = \"ramp\";\n  GlType2[\"SDF_2D_BOX\"] = \"SDF2DBox\";\n  GlType2[\"SDF_2D_CIRCLE\"] = \"SDF2DCircle\";\n  GlType2[\"SDF_2D_CROSS\"] = \"SDF2DCross\";\n  GlType2[\"SDF_2D_HEART\"] = \"SDF2DHeart\";\n  GlType2[\"SDF_2D_ROUNDED_X\"] = \"SDF2DRoundedX\";\n  GlType2[\"SDF_2D_STAIRS\"] = \"SDF2DStairs\";\n  GlType2[\"SDF_BOX\"] = \"SDFBox\";\n  GlType2[\"SDF_BOX_FRAME\"] = \"SDFBoxFrame\";\n  GlType2[\"SDF_BOX_ROUND\"] = \"SDFBoxRound\";\n  GlType2[\"SDF_CAPSULE\"] = \"SDFCapsule\";\n  GlType2[\"SDF_CAPSULE_VERTICAL\"] = \"SDFCapsuleVertical\";\n  GlType2[\"SDF_CONE\"] = \"SDFCone\";\n  GlType2[\"SDF_CONE_ROUND\"] = \"SDFConeRound\";\n  GlType2[\"SDF_ELONGATE\"] = \"SDFElongate\";\n  GlType2[\"SDF_FRACTAL_MANDELBROT\"] = \"SDFFractalMandelbrot\";\n  GlType2[\"SDF_GRADIENT\"] = \"SDFGradient\";\n  GlType2[\"SDF_HEXAGONAL_PRISM\"] = \"SDFHexagonalPrism\";\n  GlType2[\"SDF_HORSE_SHOE\"] = \"SDFHorseShoe\";\n  GlType2[\"SDF_LINK\"] = \"SDFLink\";\n  GlType2[\"SDF_OCTAHEDRON\"] = \"SDFOctahedron\";\n  GlType2[\"SDF_OCTOGONAL_PRISM\"] = \"SDFOctogonalPrism\";\n  GlType2[\"SDF_ONION\"] = \"SDFOnion\";\n  GlType2[\"SDF_PLANE\"] = \"SDFPlane\";\n  GlType2[\"SDF_PYRAMID\"] = \"SDFPyramid\";\n  GlType2[\"SDF_QUAD\"] = \"SDFQuad\";\n  GlType2[\"SDF_REPEAT_POLAR\"] = \"SDFRepeatPolar\";\n  GlType2[\"SDF_REVOLUTION\"] = \"SDFRevolution\";\n  GlType2[\"SDF_RHOMBUS\"] = \"SDFRhombus\";\n  GlType2[\"SDF_RHOMBUS_TRIACONTAHEDRON\"] = \"SDFRhombusTriacontahedron\";\n  GlType2[\"SDF_SOLID_ANGLE\"] = \"SDFSolidAngle\";\n  GlType2[\"SDF_SPHERE\"] = \"SDFSphere\";\n  GlType2[\"SDF_SPHERE_CUT\"] = \"SDFSphereCut\";\n  GlType2[\"SDF_SPHERE_HOLLOW\"] = \"SDFSphereHollow\";\n  GlType2[\"SDF_TORUS\"] = \"SDFTorus\";\n  GlType2[\"SDF_TRANSFORM\"] = \"SDFTransform\";\n  GlType2[\"SDF_TRIANGULAR_PRISM\"] = \"SDFTriangularPrism\";\n  GlType2[\"SDF_TRIANGLE\"] = \"SDFTriangle\";\n  GlType2[\"SDF_TUBE\"] = \"SDFTube\";\n  GlType2[\"SDF_TWIST\"] = \"SDFTwist\";\n  GlType2[\"SDF_CONTEXT\"] = \"SDFContext\";\n  GlType2[\"SDF_MATERIAL\"] = \"SDFMaterial\";\n  GlType2[\"TEXTURE\"] = \"texture\";\n  GlType2[\"TEXTURE_DISPLACEMENT\"] = \"textureDisplacement\";\n  GlType2[\"TEXTURE_SDF\"] = \"textureSDF\";\n  GlType2[\"VARYING_READ\"] = \"varyingRead\";\n  GlType2[\"VARYING_WRITE\"] = \"varyingWrite\";\n  GlType2[\"VERTEX_ANIMATION_TEXTURE\"] = \"vertexAnimationTexture\";\n  GlType2[\"VERTEX_ANIMATION_TEXTURE_INTERPOLATED\"] = \"vertexAnimationTextureInterpolated\";\n  return GlType2;\n})(GlType || {});\n", "\"use strict\";\nexport class ParamsEditableStateController {\n  constructor(node) {\n    this.node = node;\n    this._initialized = false;\n    this._checkParamsEditableStateBound = this._checkParamsEditableState.bind(this);\n  }\n  initializeNode() {\n    if (this._initialized) {\n      console.warn(\"already initialized\", this.node);\n      return;\n    }\n    this._initialized = true;\n    this.node.io.inputs.add_on_set_input_hook(\n      \"_checkParamsEditableStateBound\",\n      this._checkParamsEditableStateBound\n    );\n  }\n  initialized() {\n    return this._initialized;\n  }\n  _checkParamsEditableState() {\n    if (!this._paramsMatchEditableState()) {\n      this.updateParamsEditableStateIfNeeded();\n    }\n  }\n  _paramsMatchEditableState() {\n    let i = 0;\n    const params = this.node.params;\n    const connectionPoints = this.node.io.inputs.namedInputConnectionPoints();\n    if (!connectionPoints) {\n      return false;\n    }\n    for (const connectionPoint of connectionPoints) {\n      if (connectionPoint) {\n        const isConnected = this.node.io.inputs.input(i) != null;\n        const paramName = connectionPoint == null ? void 0 : connectionPoint.name();\n        const hasParam = params.has(paramName);\n        if (hasParam) {\n          const param = params.get(paramName);\n          if (param) {\n            const expectedEditableState = !isConnected;\n            const currentEditableState = param.options.editable();\n            if (expectedEditableState != currentEditableState) {\n              return false;\n            }\n          }\n        }\n      }\n      i++;\n    }\n    return true;\n  }\n  updateParamsEditableStateIfNeeded() {\n    let i = 0;\n    const params = this.node.params;\n    const connectionPoints = this.node.io.inputs.namedInputConnectionPoints();\n    if (!connectionPoints) {\n      return;\n    }\n    for (const connectionPoint of connectionPoints) {\n      if (connectionPoint) {\n        const isConnected = this.node.io.inputs.input(i) != null;\n        const paramName = connectionPoint == null ? void 0 : connectionPoint.name();\n        if (params.has(paramName)) {\n          const param = params.get(paramName);\n          if (param) {\n            const requiredState = !isConnected;\n            param.options.setEditableState(requiredState);\n          }\n        }\n      }\n      i++;\n    }\n  }\n}\n", "\"use strict\";\nimport { TypedNode } from \"../_Base\";\nimport { ThreeToGl } from \"../../../core/ThreeToGl\";\nimport { NodeContext } from \"../../poly/NodeContext\";\nimport { NodeParamsConfig } from \"../utils/params/ParamsConfig\";\nimport { ParamsEditableStateController } from \"../utils/io/ParamsEditableStateController\";\nconst GL_VAR_NAME_PREFIX = \"v_POLY\";\nexport class TypedGlNode extends TypedNode {\n  constructor() {\n    super(...arguments);\n    this._paramsEditableStatesController = new ParamsEditableStateController(this);\n  }\n  static context() {\n    return NodeContext.GL;\n  }\n  initializeBaseNode() {\n    this.uiData.setLayoutHorizontal();\n    this.io.connections.initInputs();\n    this.io.connection_points.spare_params.initializeNode();\n    this._paramsEditableStatesController.initializeNode();\n  }\n  cook() {\n    console.warn(\"gl node cooking\");\n  }\n  _setMatToRecompile() {\n    var _a, _b;\n    (_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.setCompilationRequiredAndDirty(this);\n  }\n  materialNode() {\n    const parent = this.parent();\n    if (parent) {\n      if (parent.context() == NodeContext.GL) {\n        return parent == null ? void 0 : parent.materialNode();\n      } else {\n        return parent;\n      }\n    }\n  }\n  //\n  //\n  // VARIABLES\n  //\n  //\n  glVarName(varName) {\n    const nodes = [this];\n    let currentNode = this;\n    while (currentNode.parent() && currentNode.parent() != this.materialNode()) {\n      const parent = currentNode.parent();\n      if (parent) {\n        nodes.unshift(parent);\n        currentNode = parent;\n      }\n    }\n    const baseGlVarNames = nodes.map((node) => node._glVarNameBase());\n    return `${GL_VAR_NAME_PREFIX}_${baseGlVarNames.join(\"_\")}_${varName}`;\n  }\n  _glVarNameBase() {\n    return this.name();\n  }\n  variableForInputParam(param) {\n    return this.variableForInput(param.name());\n  }\n  variableForInput(inputName) {\n    var _a;\n    const input_index = this.io.inputs.getInputIndex(inputName);\n    const connection = this.io.connections.inputConnection(input_index);\n    if (connection) {\n      const input_node = connection.nodeSrc();\n      const outputConnectionPoints = input_node.io.outputs.namedOutputConnectionPoints();\n      if (outputConnectionPoints) {\n        const output_connection_point = outputConnectionPoints[connection.outputIndex()];\n        if (output_connection_point) {\n          const output_name = output_connection_point.name();\n          return input_node.glVarName(output_name);\n        } else {\n          console.warn(`no output called '${inputName}' for gl node ${input_node.path()}`);\n          throw \"variable_for_input ERROR\";\n        }\n      }\n    } else {\n      if (this.params.has(inputName)) {\n        return ThreeToGl.any((_a = this.params.get(inputName)) == null ? void 0 : _a.value);\n      } else {\n        const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();\n        if (inputConnectionPoints) {\n          const connection_point = inputConnectionPoints[input_index];\n          return ThreeToGl.any(connection_point.init_value);\n        }\n      }\n    }\n    throw \"variable_for_input ERROR\";\n  }\n  //\n  //\n  // ADDED LINES\n  //\n  //\n  setLines(shaders_collection_controller) {\n  }\n  reset_code() {\n    var _a;\n    (_a = this._param_configs_controller) == null ? void 0 : _a.reset();\n  }\n  //\n  //\n  // PARAM CONFIGS\n  //\n  //\n  setParamConfigs() {\n  }\n  param_configs() {\n    var _a;\n    return (_a = this._param_configs_controller) == null ? void 0 : _a.list();\n  }\n  paramsGenerating() {\n    return false;\n  }\n  //\n  //\n  // INPUT\n  //\n  //\n  paramDefaultValue(name) {\n    return null;\n  }\n}\nexport class BaseGlNodeClass extends TypedGlNode {\n}\nclass ParamlessGlParamsConfig extends NodeParamsConfig {\n}\nconst ParamsConfig = new ParamlessGlParamsConfig();\nexport class ParamlessTypedGlNode extends TypedGlNode {\n  constructor() {\n    super(...arguments);\n    this.paramsConfig = ParamsConfig;\n  }\n}\n", "\"use strict\";\nimport { GlType } from \"./../../poly/registers/nodes/types/Gl\";\nimport { TypedGlNode } from \"./_Base\";\nimport { GlConnectionPointType } from \"../utils/io/connections/Gl\";\nexport const ATTRIBUTE_NODE_AVAILABLE_GL_TYPES = [\n  GlConnectionPointType.FLOAT,\n  GlConnectionPointType.VEC2,\n  GlConnectionPointType.VEC3,\n  GlConnectionPointType.VEC4\n];\nimport { NodeParamsConfig, ParamConfig } from \"../utils/params/ParamsConfig\";\nimport { isBooleanTrue } from \"../../../core/BooleanValue\";\nclass AttributeGlParamsConfig extends NodeParamsConfig {\n  constructor() {\n    super(...arguments);\n    /** @param attribute name */\n    this.name = ParamConfig.STRING(\"attribute1\");\n    /** @param attribute type (float, vec2, vec3, vec4) */\n    this.type = ParamConfig.INTEGER(0, {\n      menu: {\n        entries: ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.map((name, i) => {\n          return { name, value: i };\n        })\n      }\n    });\n    /** @param allows to export the attribute to a material (when used inside a particles system) */\n    this.texportWhenConnected = ParamConfig.BOOLEAN(0, { hidden: true });\n    /** @param allows to export the attribute to a material (when used inside a particles system) */\n    this.exportWhenConnected = ParamConfig.BOOLEAN(0, { visibleIf: { texportWhenConnected: 1 } });\n  }\n}\nconst ParamsConfig = new AttributeGlParamsConfig();\nconst _AttributeGlNode = class extends TypedGlNode {\n  constructor() {\n    super(...arguments);\n    this.paramsConfig = ParamsConfig;\n    this._bound_setExportWhenConnectedStatus = this._setExportWhenConnectedStatus.bind(this);\n  }\n  static type() {\n    return GlType.ATTRIBUTE;\n  }\n  // private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n  initializeNode() {\n    this.addPostDirtyHook(\"_setMatToRecompile\", this._setMatToRecompileIfIsExporting.bind(this));\n    this.io.connection_points.initializeNode();\n    this.io.connection_points.set_expected_input_types_function(() => {\n      var _a, _b;\n      if ((_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.allow_attribute_exports()) {\n        return [ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]];\n      } else {\n        return [];\n      }\n    });\n    this.io.connection_points.set_input_name_function((index) => {\n      return _AttributeGlNode.INPUT_NAME;\n    });\n    this.io.connection_points.set_expected_output_types_function(() => [\n      ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]\n    ]);\n    this.lifecycle.onAfterAdded(this._bound_setExportWhenConnectedStatus);\n    this.params.addOnSceneLoadHook(\"prepare params\", this._bound_setExportWhenConnectedStatus);\n  }\n  _setExportWhenConnectedStatus() {\n    var _a, _b;\n    if ((_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.allow_attribute_exports()) {\n      this.p.texportWhenConnected.set(1);\n    }\n  }\n  setAttribSize(size) {\n    this.p.type.set(size - 1);\n  }\n  // createParams() {}\n  // inputless_params_names(): string[] {\n  // \treturn ['type'];\n  // }\n  inputName() {\n    return _AttributeGlNode.INPUT_NAME;\n  }\n  outputName() {\n    return _AttributeGlNode.OUTPUT_NAME;\n  }\n  // TODO:\n  // ideally glVarName should know which shader it is being called in.\n  // so that if it is in a vertex shader, it can return the name of the attribute directly.\n  // and if it is in a fragment, it would behave as usual.\n  // override glVarName() {\n  // \t// if (name) {\n  // \t// \treturn super.glVarName(name);\n  // \t// }\n  // \t// return this.varyingName();\n  // }\n  varyingName() {\n    return `v_POLY_attribute_${this.pv.name}`;\n  }\n  // private create_inputs_from_params() {\n  // \tif (this.materialNode().allow_attribute_exports) {\n  // \t\t// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);\n  // \t\tthis.io.inputs.setNamedInputConnectionPoints([\n  // \t\t\tnew TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),\n  // \t\t]);\n  // \t\t// this._init_graph_node_inputs();\n  // \t}\n  // }\n  setLines(shadersCollectionController) {\n    const assembler = shadersCollectionController.assembler();\n    assembler.setNodeLinesAttribute(this, shadersCollectionController);\n  }\n  // update_output_type(constructor) {\n  // \tconst named_output = new constructor(Attribute.output_name());\n  // \tthis.set_named_outputs([named_output]);\n  // }\n  // update_input_type(constructor) {\n  // \tconst named_input = new constructor(Attribute.input_name());\n  // \tthis.set_named_inputs([named_input]);\n  // \tthis._init_graph_node_inputs();\n  // }\n  attributeName() {\n    return this.pv.name.trim();\n  }\n  glType() {\n    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();\n    if (!outputConnectionPoints) {\n      return GlConnectionPointType.FLOAT;\n    }\n    return outputConnectionPoints[0].type();\n  }\n  setGlType(type) {\n    this.p.type.set(ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.indexOf(type));\n  }\n  //\n  //\n  // Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles\n  //\n  //\n  connected_input_node() {\n    return this.io.inputs.named_input(_AttributeGlNode.INPUT_NAME);\n  }\n  connected_input_connection_point() {\n    return this.io.inputs.named_input_connection_point(_AttributeGlNode.INPUT_NAME);\n  }\n  // connected_input(): NamedConnection {\n  // \tconst connection_point = this.connected_input_connection_point();\n  // \tif (connection_point) {\n  // \t\treturn this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];\n  // \t}\n  // }\n  output_connection_point() {\n    return this.io.outputs.namedOutputConnectionPointsByName(this.outputName());\n  }\n  // connected_output(): NamedConnection {\n  // \tconst output = this.named_output(0);\n  // \tif (output) {\n  // \t\treturn output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]\n  // \t}\n  // }\n  isImporting() {\n    return this.io.outputs.used_output_names().length > 0;\n  }\n  isExporting() {\n    if (isBooleanTrue(this.pv.exportWhenConnected)) {\n      const input_node = this.io.inputs.named_input(_AttributeGlNode.INPUT_NAME);\n      return input_node != null;\n    } else {\n      return false;\n    }\n  }\n  _setMatToRecompileIfIsExporting() {\n    if (isBooleanTrue(this.pv.exportWhenConnected)) {\n      this._setMatToRecompile();\n    }\n  }\n  //\n  //\n  // SIGNATURE\n  //\n  //\n  // private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n  // \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n  // \t\tthis.update_input_and_output_types();\n  // \t\tthis.removeDirtyState();\n  // \t\tthis.make_output_nodes_dirty();\n  // \t}\n  // \tthis.materialNode()?.assembler_controller.set_compilation_required_and_dirty(this);\n  // }\n  // private update_input_and_output_types() {\n  // \tconst set_dirty = false;\n  // \tthis.io.outputs.setNamedOutputConnectionPoints(\n  // \t\t[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],\n  // \t\tset_dirty\n  // \t);\n  // \tif (this.materialNode()?.assembler_controller.allow_attribute_exports()) {\n  // \t\tthis.io.inputs.setNamedInputConnectionPoints([\n  // \t\t\tnew TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),\n  // \t\t]);\n  // \t}\n  // }\n};\nexport let AttributeGlNode = _AttributeGlNode;\nAttributeGlNode.INPUT_NAME = \"in\";\nAttributeGlNode.OUTPUT_NAME = \"val\";\n", "\"use strict\";\nexport class TypedGLDefinitionCollection {\n  constructor(_definitions = []) {\n    this._definitions = _definitions;\n    this._errored = false;\n  }\n  get errored() {\n    return this._errored;\n  }\n  get error_message() {\n    return this._error_message;\n  }\n  uniq() {\n    const definitions_by_name = /* @__PURE__ */ new Map();\n    const names = [];\n    for (const definition of this._definitions) {\n      if (!this._errored) {\n        const name = definition.name();\n        const existing = definitions_by_name.get(name);\n        if (existing) {\n          if (existing.data_type != definition.data_type) {\n            this._errored = true;\n            this._error_message = `attempt to create '${definition.name()}' with types '${definition.data_type}' by node '${definition.node.path()}', when there is already an existing with type ${existing.data_type} from node '${existing.node.path()}'`;\n            console.warn(\"emitting error message:\", this._error_message);\n          }\n        } else {\n          definitions_by_name.set(name, definition);\n          names.push(name);\n        }\n      }\n    }\n    const uniq_definitions = [];\n    for (const name of names) {\n      const definition = definitions_by_name.get(name);\n      if (definition) {\n        uniq_definitions.push(definition);\n      }\n    }\n    return uniq_definitions;\n  }\n}\n", "\"use strict\";\nimport { TypedGLDefinitionCollection } from \"./GLDefinitionCollection\";\nimport { GlConnectionPointType } from \"../../utils/io/connections/Gl\";\nexport var GLDefinitionType = /* @__PURE__ */ ((GLDefinitionType2) => {\n  GLDefinitionType2[\"ATTRIBUTE\"] = \"attribute\";\n  GLDefinitionType2[\"FUNCTION\"] = \"function\";\n  GLDefinitionType2[\"PRECISION\"] = \"precision\";\n  GLDefinitionType2[\"UNIFORM\"] = \"uniform\";\n  GLDefinitionType2[\"VARYING\"] = \"varying\";\n  return GLDefinitionType2;\n})(GLDefinitionType || {});\nexport class TypedGLDefinition {\n  // constructor(protected _node: BaseGlNodeType, protected _name: string) {}\n  constructor(_definition_type, _data_type, _node, _name) {\n    this._definition_type = _definition_type;\n    this._data_type = _data_type;\n    this._node = _node;\n    this._name = _name;\n  }\n  get definition_type() {\n    return this._definition_type;\n  }\n  get data_type() {\n    return this._data_type;\n  }\n  get node() {\n    return this._node;\n  }\n  name() {\n    return this._name;\n  }\n  collection_instance() {\n    return new TypedGLDefinitionCollection();\n  }\n}\nexport class AttributeGLDefinition extends TypedGLDefinition {\n  constructor(_node, _data_type, _name) {\n    super(\"attribute\" /* ATTRIBUTE */, _data_type, _node, _name);\n    this._node = _node;\n    this._data_type = _data_type;\n    this._name = _name;\n  }\n  get line() {\n    return `attribute ${this.data_type} ${this.name()}`;\n  }\n}\nexport class FunctionGLDefinition extends TypedGLDefinition {\n  constructor(_node, _name) {\n    super(\"function\" /* FUNCTION */, GlConnectionPointType.FLOAT, _node, _name);\n    this._node = _node;\n    this._name = _name;\n  }\n  get line() {\n    return this.name();\n  }\n}\nexport class UniformGLDefinition extends TypedGLDefinition {\n  constructor(_node, _data_type, _name) {\n    super(\"uniform\" /* UNIFORM */, _data_type, _node, _name);\n    this._node = _node;\n    this._data_type = _data_type;\n    this._name = _name;\n  }\n  get line() {\n    return `uniform ${this.data_type} ${this.name()}`;\n  }\n}\nexport class PrecisionGLDefinition extends TypedGLDefinition {\n  constructor(_node, _data_type, _name = \"highp\") {\n    super(\"precision\" /* PRECISION */, _data_type, _node, _name);\n    this._node = _node;\n    this._data_type = _data_type;\n    this._name = _name;\n  }\n  get line() {\n    return `precision ${this.name()} ${this.data_type}`;\n  }\n}\nexport class VaryingGLDefinition extends TypedGLDefinition {\n  constructor(_node, _data_type, _name) {\n    super(\"varying\" /* VARYING */, _data_type, _node, _name);\n    this._node = _node;\n    this._data_type = _data_type;\n    this._name = _name;\n  }\n  get line() {\n    return `varying ${this.data_type} ${this.name()}`;\n  }\n}\n", "\"use strict\";\nexport var ShaderName = /* @__PURE__ */ ((ShaderName2) => {\n  ShaderName2[\"VERTEX\"] = \"vertex\";\n  ShaderName2[\"FRAGMENT\"] = \"fragment\";\n  ShaderName2[\"LEAVES_FROM_NODES_SHADER\"] = \"leaves_from_nodes_shader\";\n  return ShaderName2;\n})(ShaderName || {});\nexport var JsFunctionName = /* @__PURE__ */ ((JsFunctionName2) => {\n  JsFunctionName2[\"MAIN\"] = \"main\";\n  JsFunctionName2[\"VELOCITY\"] = \"velocity\";\n  JsFunctionName2[\"COLLIDER\"] = \"collider\";\n  return JsFunctionName2;\n})(JsFunctionName || {});\n", "\"use strict\";\nexport var GlobalsOutput = /* @__PURE__ */ ((GlobalsOutput2) => {\n  GlobalsOutput2[\"TIME\"] = \"time\";\n  GlobalsOutput2[\"RESOLUTION\"] = \"resolution\";\n  GlobalsOutput2[\"MV_POSITION\"] = \"mvPosition\";\n  GlobalsOutput2[\"GL_POSITION\"] = \"gl_Position\";\n  GlobalsOutput2[\"GL_FRAGCOORD\"] = \"gl_FragCoord\";\n  GlobalsOutput2[\"GL_POINTCOORD\"] = \"gl_PointCoord\";\n  GlobalsOutput2[\"GL_POINTSIZE\"] = \"gl_PointSize\";\n  GlobalsOutput2[\"WORLD_POSITION\"] = \"worldPosition\";\n  GlobalsOutput2[\"WORLD_NORMAL\"] = \"worldNormal\";\n  GlobalsOutput2[\"MODEL_MATRIX\"] = \"modelMatrix\";\n  GlobalsOutput2[\"MODEL_VIEW_MATRIX\"] = \"modelViewMatrix\";\n  GlobalsOutput2[\"NORMAL_MATRIX\"] = \"normalMatrix\";\n  return GlobalsOutput2;\n})(GlobalsOutput || {});\n", "\"use strict\";\nexport var GlobalsBaseControllerType = /* @__PURE__ */ ((GlobalsBaseControllerType2) => {\n  GlobalsBaseControllerType2[\"GEOMETRY\"] = \"geometry\";\n  GlobalsBaseControllerType2[\"TEXTURE\"] = \"texture\";\n  return GlobalsBaseControllerType2;\n})(GlobalsBaseControllerType || {});\n", "\"use strict\";\nimport { GlobalsBaseController } from \"./_Base\";\nimport { AttributeGlNode } from \"../../Attribute\";\nimport { VaryingGLDefinition, AttributeGLDefinition } from \"../../utils/GLDefinition\";\nimport { MapUtils } from \"../../../../../core/MapUtils\";\nimport { ShaderName } from \"../../../utils/shaders/ShaderName\";\nimport { GlobalsOutput } from \"../assemblers/materials/common/GlobalOutput\";\nimport { GlobalsBaseControllerType } from \"./Common\";\nconst VARIABLE_CONFIG_DEFAULT_BY_NAME = {\n  position: \"vec3( position )\"\n};\nconst _GlobalsGeometryHandler = class extends GlobalsBaseController {\n  type() {\n    return GlobalsBaseControllerType.GEOMETRY;\n  }\n  handleGlobalsNode(globals_node, output_name, shaders_collection_controller) {\n    const connection_point = globals_node.io.outputs.namedOutputConnectionPointsByName(output_name);\n    if (!connection_point) {\n      return;\n    }\n    const glType = connection_point.type();\n    this.handleGlobalVar(globals_node, output_name, glType, shaders_collection_controller);\n  }\n  handleGlobalVar(globals_node, output_name, glType, shaders_collection_controller) {\n    var _a, _b;\n    const var_name = globals_node.glVarName(output_name);\n    const definition = new VaryingGLDefinition(globals_node, glType, var_name);\n    shaders_collection_controller.addDefinitions(globals_node, [definition]);\n    const assembler = (_b = (_a = globals_node.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler;\n    if (!assembler) {\n      return;\n    }\n    const shader_config = assembler.shader_config(shaders_collection_controller.currentShaderName());\n    if (!shader_config) {\n      return;\n    }\n    const dependencies = shader_config.dependencies();\n    const body_lines = [];\n    const worldPositionLine = `${var_name} = modelMatrix * vec4( position, 1.0 )`;\n    const worldNormalLine = `${var_name} = normalize( mat3( modelMatrix[0].xyz, modelMatrix[1].xyz, modelMatrix[2].xyz ) * normal )`;\n    switch (output_name) {\n      case GlobalsOutput.WORLD_POSITION: {\n        body_lines.push(worldPositionLine);\n        break;\n      }\n      case GlobalsOutput.WORLD_NORMAL: {\n        body_lines.push(worldNormalLine);\n        break;\n      }\n      default: {\n        body_lines.push(`${var_name} = ${glType}(${output_name})`);\n      }\n    }\n    for (const dependency of dependencies) {\n      shaders_collection_controller.addDefinitions(globals_node, [definition], dependency);\n      shaders_collection_controller.addBodyLines(globals_node, body_lines, dependency);\n    }\n    if (dependencies.length == 0) {\n      shaders_collection_controller.addBodyLines(globals_node, body_lines);\n    }\n  }\n  static variable_config_default(variable_name) {\n    return VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];\n  }\n  variable_config_default(variable_name) {\n    return _GlobalsGeometryHandler.variable_config_default(variable_name);\n  }\n  // variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{\n  // \treturn null\n  // }\n  readAttribute(node, gl_type, attrib_name, shaders_collection_controller) {\n    return _GlobalsGeometryHandler.readAttribute(node, gl_type, attrib_name, shaders_collection_controller);\n  }\n  static readAttribute(node, gl_type, attrib_name, shaders_collection_controller) {\n    var _a, _b;\n    if (_GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {\n      shaders_collection_controller.addDefinitions(\n        node,\n        [new AttributeGLDefinition(node, gl_type, attrib_name)],\n        ShaderName.VERTEX\n      );\n    } else {\n    }\n    const shader_name = shaders_collection_controller.currentShaderName();\n    switch (shader_name) {\n      case ShaderName.VERTEX: {\n        return attrib_name;\n      }\n      case ShaderName.FRAGMENT: {\n        if (!(node instanceof AttributeGlNode)) {\n          return;\n        }\n        const attribNode = node;\n        const var_name = attribNode.varyingName();\n        const varying_definition = new VaryingGLDefinition(node, gl_type, var_name);\n        const definitions_by_shader_name = /* @__PURE__ */ new Map();\n        definitions_by_shader_name.set(ShaderName.FRAGMENT, []);\n        const body_lines_by_shader_name = /* @__PURE__ */ new Map();\n        body_lines_by_shader_name.set(ShaderName.FRAGMENT, []);\n        MapUtils.pushOnArrayAtEntry(definitions_by_shader_name, shader_name, varying_definition);\n        const set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;\n        const shader_config = (_b = (_a = node.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.assembler.shader_config(shader_name);\n        if (shader_config) {\n          const dependencies = shader_config.dependencies();\n          for (const dependency of dependencies) {\n            MapUtils.pushOnArrayAtEntry(definitions_by_shader_name, dependency, varying_definition);\n            MapUtils.pushOnArrayAtEntry(body_lines_by_shader_name, dependency, set_varying_body_line);\n          }\n          definitions_by_shader_name.forEach((definitions, shader_name2) => {\n            shaders_collection_controller.addDefinitions(node, definitions, shader_name2);\n          });\n          body_lines_by_shader_name.forEach((body_lines, shader_name2) => {\n            shaders_collection_controller.addBodyLines(node, body_lines, shader_name2);\n          });\n        }\n        return var_name;\n      }\n    }\n  }\n  handle_attribute_node(node, gl_type, attrib_name, shaders_collection_controller) {\n    return _GlobalsGeometryHandler.readAttribute(node, gl_type, attrib_name, shaders_collection_controller);\n  }\n};\nexport let GlobalsGeometryHandler = _GlobalsGeometryHandler;\nGlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES = [\n  \"position\",\n  \"color\",\n  \"normal\",\n  \"uv\",\n  \"uv2\",\n  \"morphTarget0\",\n  \"morphTarget1\",\n  \"morphTarget2\",\n  \"morphTarget3\",\n  \"skinIndex\",\n  \"skinWeight\"\n];\nGlobalsGeometryHandler.IF_RULE = {\n  uv: \"defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\"\n};\n", "\"use strict\";\nimport { BaseSopOperation } from \"./_Base\";\nimport { TypedNodePathParamValue } from \"../../../core/Walker\";\nimport { NodeContext } from \"../../../engine/poly/NodeContext\";\nimport { applyRenderHook, applyCustomMaterials, cloneMaterial } from \"../../../core/geometry/Material\";\nimport { ShaderMaterial } from \"three\";\nimport { GlobalsGeometryHandler } from \"../../../engine/nodes/gl/code/globals/Geometry\";\nimport { InputCloneMode } from \"../../../engine/poly/InputCloneMode\";\nimport { isBooleanTrue } from \"../../../core/BooleanValue\";\nimport { CoreMask } from \"../../../core/geometry/Mask\";\nlet _nextId = 0;\nexport class MaterialSopOperation extends BaseSopOperation {\n  constructor() {\n    super(...arguments);\n    this._materialSopOperationId = _nextId++;\n    this._globalsHandler = new GlobalsGeometryHandler();\n    this._onMaterialUpdateBound = this._onMaterialUpdate.bind(this);\n    this._oldMatByOldNewId = /* @__PURE__ */ new Map();\n    this._materialByUuid = /* @__PURE__ */ new Map();\n  }\n  static type() {\n    return \"material\";\n  }\n  async cook(inputCoreGroups, params) {\n    const coreGroup = inputCoreGroups[0];\n    this._oldMatByOldNewId.clear();\n    await this._applyMaterials(coreGroup, params);\n    this._swapTextures(coreGroup, params);\n    return coreGroup;\n  }\n  async _getMaterial(params) {\n    var _a, _b, _c, _d;\n    const materialNode = params.material.nodeWithContext(NodeContext.MAT, (_a = this.states) == null ? void 0 : _a.error);\n    if (materialNode) {\n      this._watchMaterialNode(materialNode);\n      const material = await materialNode.material();\n      const baseBuilderMatNode = materialNode;\n      if (baseBuilderMatNode.assemblerController) {\n        (_b = baseBuilderMatNode.assemblerController()) == null ? void 0 : _b.setAssemblerGlobalsHandler(this._globalsHandler);\n      }\n      if (!material) {\n        (_c = this.states) == null ? void 0 : _c.error.set(`material invalid. (error: '${materialNode.states.error.message()}')`);\n      }\n      return material;\n    } else {\n      (_d = this.states) == null ? void 0 : _d.error.set(`no material node found`);\n    }\n  }\n  _watchMaterialNode(materialNode) {\n    if (this._watchedMaterialNode == materialNode) {\n      return;\n    }\n    const hookName = this._watchHookName();\n    materialNode.addPostDirtyHook(hookName, this._onMaterialUpdateBound);\n    materialNode.cookController.registerOnCookEnd(hookName, this._onMaterialUpdateBound);\n    if (this._watchedMaterialNode) {\n      this._watchedMaterialNode.removePostDirtyHook(hookName);\n      this._watchedMaterialNode.cookController.deregisterOnCookEnd(hookName);\n    }\n    this._watchedMaterialNode = materialNode;\n  }\n  async _onMaterialUpdate() {\n    if (!this._watchedMaterialNode) {\n      return;\n    }\n    const container = await this._watchedMaterialNode.compute();\n    const material = container.material();\n    if (material != this._watchedMaterialNodeMaterial) {\n      this._watchedMaterialNodeMaterial = material;\n      if (this._node) {\n        this._node.p.material.setDirty();\n      }\n    }\n  }\n  _watchHookName() {\n    return `MaterialSopOperationId-${this._materialSopOperationId}`;\n  }\n  async _applyMaterials(coreGroup, params) {\n    if (!isBooleanTrue(params.assignMat)) {\n      return;\n    }\n    const material = await this._getMaterial(params);\n    if (!material) {\n      return;\n    }\n    const selectedObjects = CoreMask.filterThreejsObjects(coreGroup, params);\n    for (let selectedObject of selectedObjects) {\n      this._applyMaterial(selectedObject, material, params);\n    }\n    return coreGroup;\n  }\n  _swapTextures(coreGroup, params) {\n    if (!isBooleanTrue(params.swapCurrentTex)) {\n      return;\n    }\n    this._materialByUuid.clear();\n    const objects = CoreMask.filterObjects(coreGroup, params, coreGroup.allCoreObjects());\n    for (let object of objects) {\n      const mat = object.material;\n      this._materialByUuid.set(mat.uuid, mat);\n    }\n    this._materialByUuid.forEach((mat, mat_uuid) => {\n      this._swapTexture(mat, params);\n    });\n  }\n  _applyMaterial(object, srcMaterial, params) {\n    const usedMaterial = isBooleanTrue(params.cloneMat) ? cloneMaterial(this.scene(), srcMaterial, {\n      shareCustomUniforms: params.shareCustomUniforms,\n      addCustomMaterials: true\n    }) : srcMaterial;\n    if (srcMaterial instanceof ShaderMaterial && usedMaterial instanceof ShaderMaterial) {\n      for (let uniform_name in srcMaterial.uniforms) {\n        usedMaterial.uniforms[uniform_name] = srcMaterial.uniforms[uniform_name];\n      }\n    }\n    if (object.isGroup) {\n      return;\n    }\n    const object_with_material = object;\n    this._oldMatByOldNewId.set(usedMaterial.uuid, object_with_material.material);\n    object_with_material.material = usedMaterial;\n    applyRenderHook(object, usedMaterial);\n    applyCustomMaterials(object, usedMaterial);\n  }\n  _swapTexture(target_mat, params) {\n    if (params.texSrc0 == \"\" || params.texDest0 == \"\") {\n      return;\n    }\n    let src_mat = this._oldMatByOldNewId.get(target_mat.uuid);\n    src_mat = src_mat || target_mat;\n    const src_tex = src_mat[params.texSrc0];\n    if (src_tex) {\n      target_mat[params.texDest0] = src_tex;\n      const uniforms = target_mat.uniforms;\n      if (uniforms) {\n        const uniforms_map = uniforms[params.texDest0];\n        if (uniforms_map) {\n          uniforms[params.texDest0] = { value: src_tex };\n        }\n      }\n    }\n  }\n}\nMaterialSopOperation.DEFAULT_PARAMS = {\n  group: \"\",\n  assignMat: true,\n  material: new TypedNodePathParamValue(\"\"),\n  cloneMat: false,\n  shareCustomUniforms: true,\n  swapCurrentTex: false,\n  texSrc0: \"emissiveMap\",\n  texDest0: \"map\"\n};\nMaterialSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;\n", "\"use strict\";\nimport { TypedSopNode } from \"./_Base\";\nimport { NodeContext } from \"../../poly/NodeContext\";\nimport { MaterialSopOperation } from \"../../operations/sop/Material\";\nimport { NodeParamsConfig, ParamConfig } from \"../utils/params/ParamsConfig\";\nimport { SopType } from \"../../poly/registers/nodes/types/Sop\";\nconst DEFAULT = MaterialSopOperation.DEFAULT_PARAMS;\nclass MaterialSopParamsConfig extends NodeParamsConfig {\n  constructor() {\n    super(...arguments);\n    /** @param group to assign the material to */\n    this.group = ParamConfig.STRING(DEFAULT.group, {\n      objectMask: true\n    });\n    /** @param toggle on to assign the new material */\n    this.assignMat = ParamConfig.BOOLEAN(DEFAULT.assignMat);\n    /** @param the material node */\n    this.material = ParamConfig.NODE_PATH(\"\", {\n      nodeSelection: {\n        context: NodeContext.MAT\n      },\n      dependentOnFoundNode: false,\n      visibleIf: { assignMat: 1 }\n    });\n    // cloneMat is mostly useful when swapping tex for multiple objects which have different textures\n    // but can also be used when requiring a unique material per object, when using a copy SOP\n    /** @param Cloning the material would prevent the material node to have any effect on the processed geometries. But it would allow to have multiple materials, if this was used with a Copy SOP for instance */\n    this.cloneMat = ParamConfig.BOOLEAN(DEFAULT.cloneMat, {\n      visibleIf: { assignMat: 1 },\n      separatorBefore: true\n    });\n    /** @param while cloning the material, you may only want to change basic properties (such as depthWrite or transparent), but you would want to still use the same custom uniforms created by GL/param nodes */\n    this.shareCustomUniforms = ParamConfig.BOOLEAN(DEFAULT.shareCustomUniforms, { visibleIf: { assignMat: 1, cloneMat: 1 } });\n    /** @param swap one texture with another */\n    this.swapCurrentTex = ParamConfig.BOOLEAN(DEFAULT.swapCurrentTex);\n    /** @param texture to swap */\n    this.texSrc0 = ParamConfig.STRING(DEFAULT.texSrc0, { visibleIf: { swapCurrentTex: 1 } });\n    /** @param texture to swap */\n    this.texDest0 = ParamConfig.STRING(DEFAULT.texDest0, { visibleIf: { swapCurrentTex: 1 } });\n  }\n}\nconst ParamsConfig = new MaterialSopParamsConfig();\nexport class MaterialSopNode extends TypedSopNode {\n  constructor() {\n    super(...arguments);\n    this.paramsConfig = ParamsConfig;\n  }\n  static type() {\n    return SopType.MATERIAL;\n  }\n  initializeNode() {\n    this.io.inputs.setCount(1);\n    this.io.inputs.initInputsClonedState(MaterialSopOperation.INPUT_CLONED_STATE);\n  }\n  async cook(inputCoreGroups) {\n    this._operation = this._operation || new MaterialSopOperation(this._scene, this.states, this);\n    const coreGroup = await this._operation.cook(inputCoreGroups, this.pv);\n    this.setCoreGroup(coreGroup);\n  }\n}\n"],
  "mappings": "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",
  "names": ["ParamsConfig", "ParamsConfig"]
}
