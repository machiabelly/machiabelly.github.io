import {
  isTouchDevice
} from "./chunk-CHIZUGOH.js";
import {
  ACCEPTED_KEYBOARD_EVENT_TYPES,
  CoreEventEmitter,
  KeyboardEventType,
  SCENE_EVENT_CREATED_EVENT_CONTEXT,
  SCENE_EVENT_READY_EVENT_CONTEXT,
  SceneEventsController,
  TIME_CONTROLLER_UPDATE_TIME_OPTIONS_DEFAULT,
  TimeController,
  createRaycaster
} from "./chunk-DSYQHAWE.js";
import {
  ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT,
  EVALUATOR_METHOD_NAMES,
  JsType
} from "./chunk-SY7VELMA.js";
import {
  CorePath,
  objectsByMask
} from "./chunk-VPW6KKKV.js";
import {
  NODE_CONNECTION_TRIGGERED_EVENT,
  NodeEvent,
  NodeParamsConfig,
  NodePathParam,
  OPERATIONS_COMPOSER_NODE_TYPE,
  ParamConfig,
  ParamPathParam,
  ParamTemplate,
  ParamType,
  RampParam,
  StringParam,
  TypeAssert,
  TypedMultipleParam,
  TypedNode,
  TypedNumericParam
} from "./chunk-FUAFRKQ7.js";
import {
  CoreGraphNode,
  CoreString,
  CoreWalker,
  stringMatchMask
} from "./chunk-RVFV2LA3.js";
import {
  MapUtils,
  Poly,
  addToSetAtEntry,
  arrayCompact,
  arrayCopy,
  arrayShallowClone,
  arraySortBy,
  arrayToSet,
  arrayUniq,
  mapValuesToArray,
  objectClone,
  pushOnArrayAtEntry,
  radToDeg,
  setToArray
} from "./chunk-O564GFGZ.js";
import {
  coreGetDefaultCamera
} from "./chunk-RG42JQG3.js";
import {
  Color,
  CoreType,
  DepthTexture,
  FloatType,
  Fog,
  FogExp2,
  Mesh,
  NearestFilter,
  NoColorSpace,
  NoToneMapping,
  OrthographicCamera,
  PerspectiveCamera,
  PlaneGeometry,
  RGBAFormat,
  Scene,
  ShaderMaterial,
  UnsignedInt248Type,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer,
  isArray,
  isBooleanTrue,
  isString,
  ref
} from "./chunk-6OBTIB4K.js";
import {
  NodeContext
} from "./chunk-PQDBXNT6.js";

// node_modules/@polygonjs/polygonjs/dist/src/core/FeaturesController.js
var CoreFeaturesController = class {
  static urlParams() {
    return new URLSearchParams(window.location.search);
  }
  static urlParam(paramName) {
    return this.urlParams().get(paramName);
  }
  static noAssemblers() {
    return this.urlParam("noassemblers") == "1";
  }
  static debugLoadProgress() {
    return this.urlParam("debugLoadProgress") == "1";
  }
  static testBatchId() {
    const testBatchIdStr = this.urlParam("testBatchId");
    if (testBatchIdStr) {
      return parseInt(testBatchIdStr);
    }
    return -1;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/ManualTriggersController.js
var ActorManualTriggersController = class {
  constructor(actorsManager) {
    this.actorsManager = actorsManager;
    this._scene = actorsManager.scene;
  }
  runTriggerFromFunctionNode(node, methodName) {
    this._scene.threejsScene().traverse((object) => {
      const nodeIds = this.actorsManager.objectActorNodeIds(object);
      if (nodeIds && nodeIds.includes(node.graphNodeId())) {
        this.actorsManager.triggerEventNode(node, object, methodName);
      }
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/ActorsKeyboardEventsController.js
var ActorKeyboardEventsController = class {
  constructor(actorsManager) {
    this.actorsManager = actorsManager;
    this._triggeredEvaluatorGeneratorsByMethodName = /* @__PURE__ */ new Map();
    this._scene = actorsManager.scene;
  }
  addTriggeredEvaluators(evaluatorGenerators, methodName) {
    evaluatorGenerators.forEach((evaluatorGenerator) => {
      MapUtils.addToSetAtEntry(this._triggeredEvaluatorGeneratorsByMethodName, methodName, evaluatorGenerator);
    });
  }
  runTriggers() {
    this._triggeredEvaluatorGeneratorsByMethodName.forEach((evaluatorGenerators, methodName) => {
      evaluatorGenerators.forEach((evaluatorGenerator) => {
        evaluatorGenerator.traverseEvaluator((evaluator) => {
          if (evaluator[methodName]) {
            evaluator[methodName]();
          }
        });
      });
    });
    this._triggeredEvaluatorGeneratorsByMethodName.clear();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/globals/Common.js
var GlobalsJsBaseControllerType = ((GlobalsJsBaseControllerType2) => {
  GlobalsJsBaseControllerType2["GEOMETRY"] = "geometry";
  return GlobalsJsBaseControllerType2;
})(GlobalsJsBaseControllerType || {});

// node_modules/@polygonjs/polygonjs/dist/src/core/geometry/util/HierarchyTraverse.js
function hierarchyTraverse(object, callback) {
  callback(object);
  const childrenCount = object.children.length;
  for (let i = 0; i < childrenCount; i++) {
    const child = object.children[i];
    if (child) {
      hierarchyTraverse(child, callback);
    }
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/render/renderPixel/depthRead/DepthRead.vert.glsl.js
var DepthRead_vert_glsl_default = "varying vec2 vUv;\n\nvoid main() {\n	vUv = uv;\n	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}";

// node_modules/@polygonjs/polygonjs/dist/src/core/render/renderPixel/depthRead/DepthRead.frag.glsl.js
var DepthRead_frag_glsl_default = "#include <packing>\n\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\nuniform float cameraNear;\nuniform float cameraFar;\n\n\nfloat readDepth( sampler2D depthSampler, vec2 coord ) {\n	float fragCoordZ = texture2D( depthSampler, coord ).x;\n	float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n	return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n}\n\nvoid main() {\n	float alpha = texture2D( tDiffuse, vUv ).a;\n	float depth = readDepth( tDepth, vUv );\n\n	gl_FragColor.rgb = vec3( depth );\n	gl_FragColor.a = alpha;\n}";

// node_modules/@polygonjs/polygonjs/dist/src/core/render/renderPixel/DepthRead.js
function setupDepthReadScene() {
  const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  const material = new ShaderMaterial({
    vertexShader: DepthRead_vert_glsl_default,
    fragmentShader: DepthRead_frag_glsl_default,
    uniforms: {
      cameraNear: { value: camera.near },
      cameraFar: { value: camera.far },
      tDiffuse: { value: null },
      tDepth: { value: null }
    }
  });
  const postPlane = new PlaneGeometry(2, 2);
  const postQuad = new Mesh(postPlane, material);
  const scene = new Scene();
  scene.add(postQuad);
  return { scene, camera, material };
}
function updateDepthSetup(setup, camera, renderTarget) {
  if (camera.isPerspectiveCamera || camera.isOrthographicCamera) {
    setup.material.uniforms.cameraNear.value = camera.near;
    setup.material.uniforms.cameraFar.value = camera.far;
    setup.material.uniforms.tDiffuse.value = renderTarget.texture;
    setup.material.uniforms.tDepth.value = renderTarget.depthTexture;
  } else {
    console.warn("camera is not a PerspectiveCamera or OrthographicCamera");
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/core/render/renderPixel/RenderPixelController.js
function coreCursorToUv(cursor, target) {
  target.x = 0.5 * (cursor.x + 1);
  target.y = 0.5 * (1 - cursor.y);
}
function _createDepthTexture() {
  const texture = new DepthTexture(1, 1);
  texture.type = UnsignedInt248Type;
  return texture;
}
var RenderPixelController = class {
  constructor() {
    this._colorWriteRenderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: FloatType,
      colorSpace: NoColorSpace,
      depthTexture: _createDepthTexture()
    });
    this._depthReadRenderTarget = new WebGLRenderTarget(1, 1, {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      format: RGBAFormat,
      type: FloatType,
      colorSpace: NoColorSpace
    });
    this._renderScene = new Scene();
    this._depthReadSetup = setupDepthReadScene();
    this._restoreContext = {
      object: {
        parent: null
      },
      // scene: {
      // 	overrideMaterial: null,
      // },
      renderer: {
        toneMapping: NoToneMapping,
        outputColorSpace: NoColorSpace
      }
    };
    this._read = new Float32Array(4);
  }
  renderColor(scene, object3D, material, camera, backgroundColor, uv, target) {
    this._doRender(scene, object3D, camera, material, backgroundColor, uv, target, false);
    return target;
  }
  renderDepth(scene, object3D, camera, backgroundColor, uv, target) {
    this._doRender(scene, object3D, camera, null, backgroundColor, uv, target, true);
    return target;
  }
  _doRender(scene, object3D, camera, material, backgroundColor, uv, target, renderDepth) {
    const renderer = scene.renderersRegister.lastRegisteredRenderer();
    if (!renderer) {
      return target;
    }
    if (!(renderer instanceof WebGLRenderer)) {
      console.log("renderPixel: renderer found is not WebGLRenderer");
      return target;
    }
    if (camera == null) {
      camera = coreGetDefaultCamera(scene);
    }
    this._prepare(object3D, material, backgroundColor, renderer);
    this._render(uv, camera, renderer, target, renderDepth);
    this._restore(object3D, renderer);
    return target;
  }
  _prepare(object3D, material, backgroundColor, renderer) {
    this._restoreContext.renderer.outputColorSpace = renderer.outputColorSpace;
    this._restoreContext.renderer.toneMapping = renderer.toneMapping;
    this._restoreContext.object.parent = object3D.parent;
    this._renderScene.background = backgroundColor;
    this._renderScene.overrideMaterial = material || null;
    this._renderScene.attach(object3D);
    renderer.toneMapping = NoToneMapping;
    renderer.outputColorSpace = NoColorSpace;
  }
  _render(uv, camera, renderer, target, readDepth) {
    camera.setViewOffset(
      renderer.domElement.width,
      renderer.domElement.height,
      uv.x * renderer.domElement.width,
      uv.y * renderer.domElement.height,
      1,
      1
    );
    renderer.setRenderTarget(this._colorWriteRenderTarget);
    renderer.clear();
    renderer.render(this._renderScene, camera);
    if (readDepth) {
      updateDepthSetup(this._depthReadSetup, camera, this._colorWriteRenderTarget);
      renderer.setRenderTarget(this._depthReadRenderTarget);
      renderer.render(this._depthReadSetup.scene, this._depthReadSetup.camera);
      renderer.readRenderTargetPixels(this._depthReadRenderTarget, 0, 0, 1, 1, this._read);
    } else {
      renderer.readRenderTargetPixels(this._colorWriteRenderTarget, 0, 0, 1, 1, this._read);
    }
    renderer.setRenderTarget(null);
    camera.clearViewOffset();
    target.fromArray(this._read);
  }
  _restore(object3D, renderer) {
    var _a;
    renderer.outputColorSpace = this._restoreContext.renderer.outputColorSpace;
    renderer.toneMapping = this._restoreContext.renderer.toneMapping;
    (_a = this._restoreContext.object.parent) == null ? void 0 : _a.attach(object3D);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/MouseButton.js
var MouseButton = ((MouseButton2) => {
  MouseButton2[MouseButton2["LEFT"] = 0] = "LEFT";
  MouseButton2[MouseButton2["MIDDLE"] = 1] = "MIDDLE";
  MouseButton2[MouseButton2["RIGHT"] = 2] = "RIGHT";
  return MouseButton2;
})(MouseButton || {});
var MouseButtons = ((MouseButtons2) => {
  MouseButtons2[MouseButtons2["NONE"] = 0] = "NONE";
  MouseButtons2[MouseButtons2["LEFT"] = 1] = "LEFT";
  MouseButtons2[MouseButtons2["RIGHT"] = 2] = "RIGHT";
  MouseButtons2[MouseButtons2["LEFT_RIGHT"] = 3] = "LEFT_RIGHT";
  MouseButtons2[MouseButtons2["MIDDLE"] = 4] = "MIDDLE";
  MouseButtons2[MouseButtons2["LEFT_MIDDLE"] = 5] = "LEFT_MIDDLE";
  MouseButtons2[MouseButtons2["MIDDLE_RIGHT"] = 6] = "MIDDLE_RIGHT";
  MouseButtons2[MouseButtons2["LEFT_MIDDLE_RIGHT"] = 7] = "LEFT_MIDDLE_RIGHT";
  return MouseButtons2;
})(MouseButtons || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/Common.js
function hasCPUOptions(optionsList) {
  for (const options of optionsList) {
    if (options.cpu != null) {
      return true;
    }
  }
  return false;
}
function hasGPUOptions(optionsList) {
  for (const options of optionsList) {
    if (options.gpu != null) {
      return true;
    }
  }
  return false;
}
function GPUOptionsDepthBufferRequired(optionsList) {
  for (const options of optionsList) {
    if (options.gpu != null && options.gpu.worldPosMaterial == null) {
      return true;
    }
  }
  return false;
}
function _cpuOptionsEqual(options1, options2) {
  return options1.traverseChildren == options2.traverseChildren && options1.pointsThreshold == options2.pointsThreshold && options1.lineThreshold == options2.lineThreshold;
}
function CPUOptionsEqual(optionsList) {
  let firstCPUOptions;
  for (const options of optionsList) {
    if (options.cpu != null) {
      if (firstCPUOptions == null) {
        firstCPUOptions = options.cpu;
      } else {
        if (!_cpuOptionsEqual(firstCPUOptions, options.cpu)) {
          return false;
        }
      }
    }
  }
  return true;
}
function CPUOptionsMax(optionsList, target) {
  target.traverseChildren = false;
  target.pointsThreshold = -1;
  target.lineThreshold = -1;
  for (const options of optionsList) {
    if (options.cpu != null) {
      if (target.traverseChildren == false && options.cpu.traverseChildren == true) {
        target.traverseChildren = options.cpu.traverseChildren;
      }
      if (target.pointsThreshold < options.cpu.pointsThreshold) {
        target.pointsThreshold = options.cpu.pointsThreshold;
      }
      if (target.lineThreshold < options.cpu.lineThreshold) {
        target.lineThreshold = options.cpu.lineThreshold;
      }
    }
  }
  return target;
}
var Status = ((Status2) => {
  Status2[Status2["REQUIRED"] = 0] = "REQUIRED";
  Status2[Status2["OPTIONAL"] = 1] = "OPTIONAL";
  Status2[Status2["FORBIDDEN"] = 2] = "FORBIDDEN";
  return Status2;
})(Status || {});
var STATUS_OPTIONS = [
  0,
  1,
  2
  /* FORBIDDEN */
];
var STATUS_OPTION_LABEL = ["required", "optional", "forbidden"];
var DEFAULT_STATUS_OPTION = STATUS_OPTIONS.indexOf(
  1
  /* OPTIONAL */
);
var STATUS_MENU_OPTIONS = {
  menu: {
    entries: STATUS_OPTIONS.map((value) => ({
      value,
      name: STATUS_OPTION_LABEL[value]
    }))
  }
};
function statusMatch(modifierProperty, value) {
  switch (modifierProperty) {
    case 0: {
      return value == true;
    }
    case 1: {
      return true;
    }
    case 2: {
      return value == false;
    }
  }
  TypeAssert.unreachable(modifierProperty);
}
function propertyMatchesButtonConfig(propertyConfig, buttonConfig) {
  switch (buttonConfig.button) {
    case MouseButton.LEFT: {
      if (propertyConfig.button.left == false) {
        return false;
      }
      break;
    }
    case MouseButton.MIDDLE: {
      if (propertyConfig.button.middle == false) {
        return false;
      }
      break;
    }
    case MouseButton.RIGHT: {
      if (propertyConfig.button.right == false) {
        return false;
      }
      break;
    }
  }
  return statusMatch(propertyConfig.modifier.ctrl, buttonConfig.ctrl) && statusMatch(propertyConfig.modifier.shift, buttonConfig.shift) && statusMatch(propertyConfig.modifier.alt, buttonConfig.alt);
}
function propertyMatchesButtonsConfig(propertyConfig, buttonsConfig) {
  switch (buttonsConfig.buttons) {
    case MouseButtons.LEFT: {
      if (propertyConfig.button.left == 2 || propertyConfig.button.middle == 0 || propertyConfig.button.right == 0) {
        return false;
      }
      break;
    }
    case MouseButtons.MIDDLE: {
      if (propertyConfig.button.left == 0 || propertyConfig.button.middle == 2 || propertyConfig.button.right == 0) {
        return false;
      }
      break;
    }
    case MouseButtons.RIGHT: {
      if (propertyConfig.button.left == 0 || propertyConfig.button.middle == 0 || propertyConfig.button.right == 2) {
        return false;
      }
      break;
    }
    case MouseButtons.LEFT_RIGHT: {
      if (propertyConfig.button.left == 2 || propertyConfig.button.middle == 0 || propertyConfig.button.right == 2) {
        return false;
      }
      break;
    }
    case MouseButtons.LEFT_MIDDLE: {
      if (propertyConfig.button.left == 2 || propertyConfig.button.middle == 2 || propertyConfig.button.right == 0) {
        return false;
      }
      break;
    }
    case MouseButtons.MIDDLE_RIGHT: {
      if (propertyConfig.button.left == 0 || propertyConfig.button.middle == 2 || propertyConfig.button.right == 2) {
        return false;
      }
      break;
    }
    case MouseButtons.LEFT_MIDDLE_RIGHT: {
      if (propertyConfig.button.left == 2 || propertyConfig.button.middle == 2 || propertyConfig.button.right == 2) {
        return false;
      }
      break;
    }
  }
  return statusMatch(propertyConfig.modifier.ctrl, buttonsConfig.ctrl) && statusMatch(propertyConfig.modifier.shift, buttonsConfig.shift) && statusMatch(propertyConfig.modifier.alt, buttonsConfig.alt);
}
function propertiesMatchesButtonConfig(propertiesList, buttonConfig) {
  for (const properties of propertiesList) {
    if (propertyMatchesButtonConfig(properties.config, buttonConfig)) {
      return true;
    }
  }
  return false;
}
function propertiesMatchesButtonsConfig(propertiesList, buttonConfig) {
  for (const properties of propertiesList) {
    if (propertyMatchesButtonsConfig(properties.config, buttonConfig)) {
      return true;
    }
  }
  return false;
}
function buttonConfigFromEvent(event, target) {
  target.button = event.button || MouseButton.LEFT;
  target.ctrl = event.ctrlKey;
  target.shift = event.shiftKey;
  target.alt = event.altKey;
}
function buttonsConfigFromEvent(event, target) {
  target.buttons = event.buttons || MouseButtons.LEFT;
  target.ctrl = event.ctrlKey;
  target.shift = event.shiftKey;
  target.alt = event.altKey;
}
var _buttonConfig = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
var _buttonsConfig = { buttons: MouseButtons.LEFT, ctrl: false, shift: false, alt: false };
function filterObjectsWithMatchButtonConfig(event, objects, propertiesListByObject, target) {
  target.length = 0;
  buttonConfigFromEvent(event, _buttonConfig);
  for (const object of objects) {
    const propertiesList = propertiesListByObject.get(object);
    if (propertiesList) {
      if (propertiesMatchesButtonConfig(propertiesList, _buttonConfig)) {
        target.push(object);
      }
    }
  }
}
function filterObjectsWithMatchButtonsConfig(event, objects, propertiesListByObject, target) {
  target.length = 0;
  buttonsConfigFromEvent(event, _buttonsConfig);
  for (const object of objects) {
    const propertiesList = propertiesListByObject.get(object);
    if (propertiesList) {
      if (propertiesMatchesButtonsConfig(propertiesList, _buttonsConfig)) {
        target.push(object);
      }
    }
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/_BaseRayObjectIntersectionsController.js
var RAYCAST_UPDATE_OPTIONS = {
  pointsThreshold: 0.1,
  lineThreshold: 0.1
};
var TMP_CPU_OPTIONS = {
  traverseChildren: false,
  pointsThreshold: 0.1,
  lineThreshold: 0.1,
  intersectionRef: ref(null)
};
function intersectsSort(a, b) {
  return a.distance - b.distance;
}
var pixelRenderUv = new Vector2();
var pixelRenderTarget = new Vector4();
var raycasterDirNormalised = new Vector3();
var gpuCameraRayAtNearPlane = new Vector3();
var gpuCameraRayAtFarPlane = new Vector3();
var gpuHitPos = new Vector3();
var BaseRayObjectIntersectionsController = class {
  constructor(actorsManager) {
    this.actorsManager = actorsManager;
    this._objects = [];
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectsByObject = /* @__PURE__ */ new WeakMap();
    this._closestIntersects = /* @__PURE__ */ new Map();
    this._objectByClosestIntersect = /* @__PURE__ */ new Map();
    this._closestIntersectsSorted = [];
    this._renderPixelController = new RenderPixelController();
    this._scene = actorsManager.scene;
  }
  _setIntersectedState(objects, intersectedStateByObject) {
    if (objects.length == 0) {
      return;
    }
    this._closestIntersects.clear();
    this._objectByClosestIntersect.clear();
    const pointerEventsController = this._scene.eventsDispatcher.pointerEventsController;
    const raycaster = pointerEventsController.raycaster().value;
    pointerEventsController.updateRaycast(RAYCAST_UPDATE_OPTIONS);
    const gpuObjectsPresent = this._gpuObjectsPresent();
    const camera = gpuObjectsPresent == true ? coreGetDefaultCamera(this._scene) : null;
    if (gpuObjectsPresent == true && camera) {
      const cursor = pointerEventsController.cursor().value;
      coreCursorToUv(cursor, pixelRenderUv);
      if (this._gpuDepthBufferReadRequired()) {
        raycasterDirNormalised.copy(raycaster.ray.direction).normalize();
        gpuCameraRayAtNearPlane.set(cursor.x, cursor.y, -1).unproject(camera);
        gpuCameraRayAtFarPlane.set(cursor.x, cursor.y, 1).unproject(camera);
      }
    }
    for (const object of objects) {
      intersectedStateByObject.set(
        object,
        false
        /*we reset to false here*/
      );
      const propertiesList = this._propertiesListByObject.get(object);
      const intersects = this._intersectsByObject.get(object);
      if (propertiesList && intersects) {
        intersects.length = 0;
        if (hasCPUOptions(propertiesList)) {
          const cpuOptions = CPUOptionsEqual(propertiesList) ? propertiesList[0].cpu : CPUOptionsMax(propertiesList, TMP_CPU_OPTIONS);
          RAYCAST_UPDATE_OPTIONS.pointsThreshold = cpuOptions.pointsThreshold;
          RAYCAST_UPDATE_OPTIONS.lineThreshold = cpuOptions.lineThreshold;
          raycaster.intersectObject(object, cpuOptions.traverseChildren, intersects);
          const closestIntersect = intersects[0];
          this._closestIntersects.set(object, closestIntersect);
          if (closestIntersect) {
            this._objectByClosestIntersect.set(closestIntersect, object);
          }
        }
        if (hasGPUOptions(propertiesList)) {
          const gpuOptions = propertiesList[0].gpu;
          if (gpuOptions && camera) {
            const worldPosMaterial = gpuOptions.worldPosMaterial;
            if (worldPosMaterial != null) {
              this._renderPixelController.renderColor(
                this._scene,
                object,
                gpuOptions.worldPosMaterial,
                camera,
                null,
                //necessary to have alpha=0 when no object is hit
                pixelRenderUv,
                pixelRenderTarget
              );
            } else {
              this._renderPixelController.renderDepth(
                this._scene,
                object,
                // gpuOptions.worldPosMaterial,
                camera,
                null,
                //necessary to have alpha=0 when no object is hit
                pixelRenderUv,
                pixelRenderTarget
              );
            }
            if (pixelRenderTarget.w > 0) {
              if (worldPosMaterial) {
                gpuHitPos.set(pixelRenderTarget.x, pixelRenderTarget.y, pixelRenderTarget.z);
              } else {
                gpuHitPos.copy(gpuCameraRayAtNearPlane).lerp(gpuCameraRayAtFarPlane, pixelRenderTarget.x);
              }
              const distance = gpuHitPos.distanceTo(raycaster.ray.origin);
              const gpuIntersect = { distance };
              this._closestIntersects.set(object, gpuIntersect);
              if (gpuIntersect) {
                this._objectByClosestIntersect.set(gpuIntersect, object);
              }
            } else {
              this._closestIntersects.set(object, void 0);
            }
          }
        }
      }
    }
    this._closestIntersectsSorted.length = 0;
    for (const object of objects) {
      const closestIntersect = this._closestIntersects.get(object);
      if (closestIntersect) {
        this._closestIntersectsSorted.push(closestIntersect);
      }
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        for (const properties of propertiesList) {
          const cpuOptions = properties.cpu;
          if (cpuOptions) {
            cpuOptions.intersectionRef.value = closestIntersect || null;
          } else {
            const gpuOptions = properties.gpu;
            if (gpuOptions) {
              gpuOptions.distanceRef.value = closestIntersect ? closestIntersect.distance : -1;
            }
          }
        }
      }
    }
    this._closestIntersectsSorted.sort(intersectsSort);
    let blockingObjectProcessed = false;
    for (const intersect of this._closestIntersectsSorted) {
      const object = this._objectByClosestIntersect.get(intersect);
      if (object) {
        const propertiesList = this._propertiesListByObject.get(object);
        if (propertiesList) {
          let blockObjectsBehind = false;
          for (const properties of propertiesList) {
            if (blockingObjectProcessed == false || properties.priority.skipIfObjectsInFront == true) {
              intersectedStateByObject.set(object, true);
            }
            if (properties.priority.blockObjectsBehind == true) {
              blockObjectsBehind = true;
            }
          }
          blockingObjectProcessed = blockObjectsBehind;
        }
      }
    }
    this._objectByClosestIntersect.clear();
  }
  // protected _postProcess() {
  // 	this._objectByClosestIntersect.clear();
  // }
  _gpuObjectsPresent() {
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList && hasGPUOptions(propertiesList)) {
        return true;
      }
    }
    return false;
  }
  _gpuDepthBufferReadRequired() {
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList && GPUOptionsDepthBufferRequired(propertiesList)) {
        return true;
      }
    }
    return false;
  }
  addPropertiesForObject(object, properties) {
    if (object == ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT) {
      return;
    }
    pushOnArrayAtEntry(this._propertiesListByObject, object, properties);
    const index = this._objects.indexOf(object);
    if (index < 0) {
      this._objects.push(object);
      this._intersectsByObject.set(object, []);
    }
  }
  removePropertiesForObject(object, properties) {
    if (object == ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT) {
      return;
    }
    const propertiesForObject = this._propertiesListByObject.get(object);
    if (propertiesForObject) {
      const propertyIndex = propertiesForObject.indexOf(properties);
      propertiesForObject.splice(propertyIndex, 1);
      if (propertiesForObject.length == 0) {
        const objectIndex = this._objects.indexOf(object);
        if (objectIndex >= 0) {
          this._objects.splice(objectIndex, 1);
          this._intersectsByObject.delete(object);
          this._propertiesListByObject.delete(object);
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsHoverController.js
var RayObjectIntersectionsHoverController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateByObject = /* @__PURE__ */ new Map();
  }
  process() {
    this._setIntersectedState(this._objects, this._intersectedStateByObject);
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        for (const properties of propertiesList) {
          const currentHoveredState = properties.hover.hoveredStateRef.value;
          const newHoveredState = this._intersectedStateByObject.get(object) || false;
          if (newHoveredState != currentHoveredState) {
            properties.hover.hoveredStateRef.value = newHoveredState;
            properties.hover.onHoveredStateChange();
          }
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsPointerdownController.js
var _buttonConfig2 = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
var RayObjectIntersectionsPointerdownController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateByObject = /* @__PURE__ */ new Map();
    this._objectsMatchingEventConfig = [];
  }
  onPointerdown(event) {
    filterObjectsWithMatchButtonConfig(
      event,
      this._objects,
      this._propertiesListByObject,
      this._objectsMatchingEventConfig
    );
    if (this._objectsMatchingEventConfig.length == 0) {
      return;
    }
    this._setIntersectedState(this._objectsMatchingEventConfig, this._intersectedStateByObject);
    buttonConfigFromEvent(event, _buttonConfig2);
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersecting = this._intersectedStateByObject.get(object);
        if (isIntersecting == true) {
          for (const properties of propertiesList) {
            if (propertyMatchesButtonConfig(properties.config, _buttonConfig2)) {
              properties.pointerdown.callback();
            }
          }
        }
      }
    }
  }
  // protected override _setEvent() {
  // 	console.log('_setEvent', this._objects.length);
  // 	if (this._objects.length > 0) {
  // 		document.addEventListener('pointerdown', this._processBound);
  // 	} else {
  // 		document.removeEventListener('pointerdown', this._processBound);
  // 	}
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsPointerupController.js
var _buttonConfig3 = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
var RayObjectIntersectionsPointerupController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateByObject = /* @__PURE__ */ new Map();
    this._objectsMatchingEventConfig = [];
  }
  // private _processBound = this._process.bind(this);
  onPointerup(event) {
    filterObjectsWithMatchButtonConfig(
      event,
      this._objects,
      this._propertiesListByObject,
      this._objectsMatchingEventConfig
    );
    if (this._objectsMatchingEventConfig.length == 0) {
      return;
    }
    this._setIntersectedState(this._objectsMatchingEventConfig, this._intersectedStateByObject);
    buttonConfigFromEvent(event, _buttonConfig3);
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersecting = this._intersectedStateByObject.get(object);
        if (isIntersecting == true) {
          for (const properties of propertiesList) {
            if (propertyMatchesButtonConfig(properties.config, _buttonConfig3)) {
              properties.pointerup.callback();
            }
          }
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/CursorMoveMonitor.js
var _cursorDelta = new Vector2();
var _currentCursorPos = new Vector2();
var CursorMoveMonitor = class {
  constructor() {
    this._lastCursorPosSet = false;
    this._movedCursorDistance = 0;
    this._lastCursorPos = new Vector2();
    this._bound = {
      pointermove: this._onPointermove.bind(this)
    };
  }
  addPointermoveEventListener(cursorRef) {
    this.cursorRef = cursorRef;
    this._movedCursorDistance = 0;
    this._lastCursorPosSet = false;
    document.addEventListener("pointermove", this._bound.pointermove);
    document.addEventListener("touchmove", this._bound.pointermove);
  }
  removeEventListener() {
    document.removeEventListener("pointermove", this._bound.pointermove);
    document.removeEventListener("touchmove", this._bound.pointermove);
  }
  movedCursorDistance() {
    return this._movedCursorDistance;
  }
  _onPointermove() {
    if (!this.cursorRef) {
      return;
    }
    const cursor = this.cursorRef.value;
    if (this._lastCursorPosSet == false) {
      this._lastCursorPos.copy(cursor);
      this._lastCursorPosSet = true;
    }
    _currentCursorPos.copy(cursor);
    _cursorDelta.copy(_currentCursorPos).sub(this._lastCursorPos);
    this._movedCursorDistance += _cursorDelta.manhattanLength() / 2;
    this._lastCursorPos.copy(_currentCursorPos);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsClickController.js
var _buttonConfig4 = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
function hasPropertiesWithCursorMoveLessThan(options, distance) {
  for (const option of options) {
    if (distance < option.click.maxCursorMoveDistance) {
      return true;
    }
  }
  return false;
}
var RayObjectIntersectionsClickController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnPointerdownByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnPointerupByObject = /* @__PURE__ */ new Map();
    this._objectsMatchingEventConfig = [];
    this._objectsIntersectedOnPointerdown = [];
    this._cursorMoveMonitor = new CursorMoveMonitor();
    this._pointerdownReceivedAt = 0;
    this._bound = {
      pointerup: this._onPointerup.bind(this)
    };
  }
  onPointerdown(event) {
    this._pointerdownEvent = event;
    this._pointerdownReceivedAt = performance.now();
    if (this._objects.length == 0) {
      return;
    }
    filterObjectsWithMatchButtonConfig(
      event,
      this._objects,
      this._propertiesListByObject,
      this._objectsMatchingEventConfig
    );
    if (this._objectsMatchingEventConfig.length == 0) {
      return;
    }
    document.addEventListener("pointerup", this._bound.pointerup);
    document.addEventListener("touchend", this._bound.pointerup);
    this._cursorMoveMonitor.addPointermoveEventListener(
      this._scene.eventsDispatcher.pointerEventsController.cursor()
    );
    this._setIntersectedState(this._objectsMatchingEventConfig, this._intersectedStateOnPointerdownByObject);
  }
  _onPointerup() {
    document.removeEventListener("pointerup", this._bound.pointerup);
    document.removeEventListener("touchend", this._bound.pointerup);
    this._cursorMoveMonitor.removeEventListener();
    const event = this._pointerdownEvent;
    if (!event) {
      return;
    }
    this._pointerdownEvent = void 0;
    const duration = performance.now() - this._pointerdownReceivedAt;
    const movedCursorDistance = this._cursorMoveMonitor.movedCursorDistance();
    const objects = this._objectsMatchingEventConfig;
    this._objectsIntersectedOnPointerdown.length = 0;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList && hasPropertiesWithCursorMoveLessThan(propertiesList, movedCursorDistance)) {
        const isIntersectingOnPointerdown = this._intersectedStateOnPointerdownByObject.get(object);
        if (isIntersectingOnPointerdown) {
          this._objectsIntersectedOnPointerdown.push(object);
        }
      }
    }
    if (this._objectsIntersectedOnPointerdown.length == 0) {
      return;
    }
    this._setIntersectedState(objects, this._intersectedStateOnPointerupByObject);
    buttonConfigFromEvent(event, _buttonConfig4);
    const objectsIntersectedOnPointerdown = this._objectsIntersectedOnPointerdown;
    for (const object of objectsIntersectedOnPointerdown) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersectingOnPointerup = this._intersectedStateOnPointerupByObject.get(object);
        if (isIntersectingOnPointerup == true) {
          for (const properties of propertiesList) {
            if (movedCursorDistance < properties.click.maxCursorMoveDistance && duration < properties.click.maxDuration && propertyMatchesButtonConfig(properties.config, _buttonConfig4)) {
              properties.click.callback();
            }
          }
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsMouseClickController.js
var _buttonsConfig2 = { buttons: MouseButtons.LEFT, ctrl: false, shift: false, alt: false };
function hasPropertiesWithCursorMoveLessThan2(options, distance) {
  for (const option of options) {
    if (distance < option.click.maxCursorMoveDistance) {
      return true;
    }
  }
  return false;
}
var RayObjectIntersectionsMouseClickController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnMousedownByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnMouseupByObject = /* @__PURE__ */ new Map();
    this._objectsMatchingEventConfig = [];
    this._objectsIntersectedOnMousedown = [];
    this._cursorMoveMonitor = new CursorMoveMonitor();
    this._mousedownReceivedAt = 0;
    this._bound = {
      mouseup: this._onMouseup.bind(this)
    };
  }
  onMousedown(event) {
    this._mousedownEvent = event;
    this._mousedownReceivedAt = performance.now();
    if (this._objects.length == 0) {
      return;
    }
    filterObjectsWithMatchButtonsConfig(
      event,
      this._objects,
      this._propertiesListByObject,
      this._objectsMatchingEventConfig
    );
    if (this._objectsMatchingEventConfig.length == 0) {
      return;
    }
    document.addEventListener("mouseup", this._bound.mouseup);
    document.addEventListener("touchend", this._bound.mouseup);
    this._cursorMoveMonitor.addPointermoveEventListener(
      this._scene.eventsDispatcher.pointerEventsController.cursor()
    );
    this._setIntersectedState(this._objectsMatchingEventConfig, this._intersectedStateOnMousedownByObject);
  }
  _onMouseup() {
    document.removeEventListener("mouseup", this._bound.mouseup);
    document.removeEventListener("touchend", this._bound.mouseup);
    this._cursorMoveMonitor.removeEventListener();
    const event = this._mousedownEvent;
    if (!event) {
      return;
    }
    this._mousedownEvent = void 0;
    const duration = performance.now() - this._mousedownReceivedAt;
    const movedCursorDistance = this._cursorMoveMonitor.movedCursorDistance();
    const objects = this._objectsMatchingEventConfig;
    this._objectsIntersectedOnMousedown.length = 0;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList && hasPropertiesWithCursorMoveLessThan2(propertiesList, movedCursorDistance)) {
        const isIntersectingOnMousedown = this._intersectedStateOnMousedownByObject.get(object);
        if (isIntersectingOnMousedown) {
          this._objectsIntersectedOnMousedown.push(object);
        }
      }
    }
    if (this._objectsIntersectedOnMousedown.length == 0) {
      return;
    }
    this._setIntersectedState(objects, this._intersectedStateOnMouseupByObject);
    buttonsConfigFromEvent(event, _buttonsConfig2);
    const objectsIntersectedOnMousedown = this._objectsIntersectedOnMousedown;
    for (const object of objectsIntersectedOnMousedown) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersectingOnMouseup = this._intersectedStateOnMouseupByObject.get(object);
        if (isIntersectingOnMouseup == true) {
          for (const properties of propertiesList) {
            if (movedCursorDistance < properties.click.maxCursorMoveDistance && duration < properties.click.maxDuration && propertyMatchesButtonsConfig(properties.config, _buttonsConfig2)) {
              properties.click.callback();
            }
          }
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsContextmenuController.js
var RayObjectIntersectionsContextmenuController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateByObject = /* @__PURE__ */ new Map();
  }
  onContextmenu(event) {
    this._setIntersectedState(this._objects, this._intersectedStateByObject);
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersecting = this._intersectedStateByObject.get(object);
        if (isIntersecting == true) {
          for (const properties of propertiesList) {
            properties.contextmenu.callback();
          }
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsLongPressController.js
var _buttonConfig5 = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
function hasPropertiesWithCursorMoveLessThan3(options, distance) {
  for (const option of options) {
    if (distance < option.longPress.maxCursorMoveDistance) {
      return true;
    }
  }
  return false;
}
var RayObjectIntersectionsLongPressController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnPointerdownByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnTimeoutByObject = /* @__PURE__ */ new Map();
    this._objectsMatchingEventConfig = [];
    this._objectsByLongPressDuration = /* @__PURE__ */ new Map();
    this._timerByDuration = /* @__PURE__ */ new Map();
    this._cursorMoveMonitor = new CursorMoveMonitor();
    this._bound = {
      pointerup: this._onPointerup.bind(this)
      // pointermove: this._onPointermove.bind(this),
    };
  }
  onPointerdown(event) {
    if (this._objects.length == 0) {
      return;
    }
    filterObjectsWithMatchButtonConfig(
      event,
      this._objects,
      this._propertiesListByObject,
      this._objectsMatchingEventConfig
    );
    if (this._objectsMatchingEventConfig.length == 0) {
      return;
    }
    document.addEventListener("pointerup", this._bound.pointerup);
    document.addEventListener("touchend", this._bound.pointerup);
    this._cursorMoveMonitor.addPointermoveEventListener(
      this._scene.eventsDispatcher.pointerEventsController.cursor()
    );
    this._objectsByLongPressDuration.clear();
    this._timerByDuration.clear();
    this._setIntersectedState(this._objectsMatchingEventConfig, this._intersectedStateOnPointerdownByObject);
    const _groupIntersectedObjectsByDuration = () => {
      const objects = this._objects;
      for (const object of objects) {
        const propertiesList = this._propertiesListByObject.get(object);
        if (propertiesList) {
          const isIntersecting = this._intersectedStateOnPointerdownByObject.get(object);
          if (isIntersecting == true) {
            for (const properties of propertiesList) {
              pushOnArrayAtEntry(this._objectsByLongPressDuration, properties.longPress.duration, object);
            }
          }
        }
      }
    };
    _groupIntersectedObjectsByDuration();
    buttonConfigFromEvent(event, _buttonConfig5);
    this._objectsByLongPressDuration.forEach((objects, duration) => {
      const wrappedTriggeredMethod = () => {
        const movedCursorDistance = this._cursorMoveMonitor.movedCursorDistance();
        this._timerByDuration.delete(duration);
        this._setIntersectedState(this._objects, this._intersectedStateOnTimeoutByObject);
        for (const object of objects) {
          const propertiesList = this._propertiesListByObject.get(object);
          if (propertiesList && hasPropertiesWithCursorMoveLessThan3(propertiesList, movedCursorDistance)) {
            const isIntersecting = this._intersectedStateOnTimeoutByObject.get(object);
            if (isIntersecting) {
              for (const properties of propertiesList) {
                if (movedCursorDistance < properties.longPress.maxCursorMoveDistance && propertyMatchesButtonConfig(properties.config, _buttonConfig5)) {
                  properties.longPress.callback();
                }
              }
            }
          }
        }
      };
      const timer = setTimeout(wrappedTriggeredMethod, duration);
      this._timerByDuration.set(duration, timer);
    });
  }
  _onPointerup() {
    document.removeEventListener("pointerup", this._bound.pointerup);
    document.removeEventListener("touchend", this._bound.pointerup);
    this._cursorMoveMonitor.removeEventListener();
    this._timerByDuration.forEach((timer, duration) => {
      clearTimeout(timer);
    });
    this._timerByDuration.clear();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/RayObjectIntersectionsSwipeController.js
var _tmp = new Vector2();
var _buttonConfig6 = { button: MouseButton.LEFT, ctrl: false, shift: false, alt: false };
function degAngle(radians) {
  if (radians > Math.PI) {
    radians -= Math.PI * 2;
  }
  return radToDeg(radians);
}
var ANGLE_DEGREES = {
  LEFT: degAngle(_tmp.set(-1, 0).angle()),
  RIGHT: degAngle(_tmp.set(1, 0).angle()),
  UP: degAngle(_tmp.set(0, 1).angle()),
  DOWN: degAngle(_tmp.set(0, -1).angle())
};
function optionsContainsAngle(options, angle) {
  return angle >= options.angle - options.angleMargin && angle <= options.angle + options.angleMargin;
}
var _cursorDelta2 = new Vector2();
var RayObjectIntersectionsSwipeController = class extends BaseRayObjectIntersectionsController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnPointerdownByObject = /* @__PURE__ */ new Map();
    this._intersectedStateOnPointerupByObject = /* @__PURE__ */ new Map();
    this._objectsMatchingEventConfig = [];
    this._objectsIntersectedOnPointerdown = [];
    this._cursorOnPointerdown = new Vector2();
    this._cursorOnPointerup = new Vector2();
    this._bound = {
      pointerup: this._onPointerup.bind(this)
    };
  }
  onPointerdown(event) {
    this._pointerdownEvent = event;
    if (this._objects.length == 0) {
      return;
    }
    filterObjectsWithMatchButtonConfig(
      event,
      this._objects,
      this._propertiesListByObject,
      this._objectsMatchingEventConfig
    );
    if (this._objectsMatchingEventConfig.length == 0) {
      return;
    }
    document.addEventListener("pointerup", this._bound.pointerup);
    document.addEventListener("touchend", this._bound.pointerup);
    this._setIntersectedState(this._objectsMatchingEventConfig, this._intersectedStateOnPointerdownByObject);
    this._getCursor(this._cursorOnPointerdown);
  }
  _onPointerup(_event) {
    document.removeEventListener("pointerup", this._bound.pointerup);
    document.removeEventListener("touchend", this._bound.pointerup);
    const event = this._pointerdownEvent;
    if (!event) {
      return;
    }
    this._pointerdownEvent = void 0;
    const objects = this._objects;
    this._objectsIntersectedOnPointerdown.length = 0;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersectingOnPointerdown = this._intersectedStateOnPointerdownByObject.get(object);
        if (isIntersectingOnPointerdown) {
          this._objectsIntersectedOnPointerdown.push(object);
        }
      }
    }
    if (this._objectsIntersectedOnPointerdown.length == 0) {
      return;
    }
    this._getCursor(this._cursorOnPointerup);
    _cursorDelta2.copy(this._cursorOnPointerup).sub(this._cursorOnPointerdown);
    let radians = _cursorDelta2.angle();
    const degrees = degAngle(radians);
    const distance = _cursorDelta2.manhattanLength();
    this._setIntersectedState(objects, this._intersectedStateOnPointerupByObject);
    buttonConfigFromEvent(event, _buttonConfig6);
    const objectsIntersectedOnPointerdown = this._objectsIntersectedOnPointerdown;
    for (const object of objectsIntersectedOnPointerdown) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        const isIntersectingOnPointerup = this._intersectedStateOnPointerupByObject.get(object);
        if (isIntersectingOnPointerup == true) {
          for (const properties of propertiesList) {
            if (distance > properties.swipe.minDistance && optionsContainsAngle(properties.swipe, degrees) && propertyMatchesButtonConfig(properties.config, _buttonConfig6)) {
              properties.swipe.callback();
            }
          }
        }
      }
    }
  }
  _getCursor(target) {
    const pointerEventsController = this._scene.eventsDispatcher.pointerEventsController;
    const cursor = pointerEventsController.cursor().value;
    target.copy(cursor);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/_BaseUserInputController.js
var BaseUserInputController = class {
  constructor(actorsManager) {
    this.actorsManager = actorsManager;
    this._objects = [];
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._scene = actorsManager.scene;
  }
  addPropertiesForObject(object, properties) {
    if (object == ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT) {
      return;
    }
    pushOnArrayAtEntry(this._propertiesListByObject, object, properties);
    const index = this._objects.indexOf(object);
    if (index < 0) {
      this._objects.push(object);
    }
  }
  removePropertiesForObject(object, properties) {
    if (object == ACTOR_COMPILATION_CONTROLLER_DUMMY_OBJECT) {
      return;
    }
    const propertiesForObject = this._propertiesListByObject.get(object);
    if (propertiesForObject) {
      const propertyIndex = propertiesForObject.indexOf(properties);
      propertiesForObject.splice(propertyIndex, 1);
      if (propertiesForObject.length == 0) {
        const objectIndex = this._objects.indexOf(object);
        if (objectIndex >= 0) {
          this._objects.splice(objectIndex, 1);
          this._propertiesListByObject.delete(object);
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/PointerdownController.js
var PointerdownController = class extends BaseUserInputController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateByObject = /* @__PURE__ */ new Map();
  }
  onPointerdown(event) {
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        for (const properties of propertiesList) {
          properties.pointerdown.callback();
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/actors/rayObjectIntersection/PointerupController.js
var PointerupController = class extends BaseUserInputController {
  constructor() {
    super(...arguments);
    this._propertiesListByObject = /* @__PURE__ */ new Map();
    this._intersectedStateByObject = /* @__PURE__ */ new Map();
  }
  onPointerup(event) {
    const objects = this._objects;
    for (const object of objects) {
      const propertiesList = this._propertiesListByObject.get(object);
      if (propertiesList) {
        for (const properties of propertiesList) {
          properties.pointerup.callback();
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/ActorsManager.js
var ACTOR_BUILDER_NODE_IDS_KEY = "actorBuilderNodeIds";
var EventHandlerType = ((EventHandlerType2) => {
  EventHandlerType2["instant"] = "instant";
  EventHandlerType2["onTick"] = "onTick";
  return EventHandlerType2;
})(EventHandlerType || {});
var EVENT_MAP_LOGIC = {
  [JsType.ON_KEY]: "onTick",
  [JsType.ON_KEYDOWN]: "onTick",
  [JsType.ON_KEYPRESS]: "onTick",
  [JsType.ON_KEYUP]: "onTick",
  // [JsType.ON_MANUAL_TRIGGER]: EventHandlerType.instant,
  [JsType.ON_MAPBOX_CAMERA_MOVE]: "onTick",
  [JsType.ON_MAPBOX_CAMERA_MOVE_START]: "onTick",
  [JsType.ON_MAPBOX_CAMERA_MOVE_END]: "onTick",
  [JsType.ON_OBJECT_ATTRIBUTE_UPDATE]: "onTick",
  // ['onClick']: EventHandlerType.onTick,
  ["onContextMenu"]: "onTick",
  [JsType.ON_OBJECT_DISPATCH_EVENT]: "instant",
  // TODO
  ["onPointermove"]: "onTick",
  // [JsType.ON_OBJECT_POINTERDOWN]: EventHandlerType.onTick,
  // [JsType.ON_OBJECT_POINTERUP]: EventHandlerType.onTick,
  [JsType.ON_PERFORMANCE_CHANGE]: "instant",
  [JsType.ON_POINTERDOWN]: "onTick",
  [JsType.ON_POINTERUP]: "onTick",
  [JsType.ON_SCENE_PAUSE]: "instant",
  [JsType.ON_SCENE_PLAY]: "instant",
  [JsType.ON_SCENE_RESET]: "instant",
  [JsType.ON_TICK]: "onTick",
  [JsType.ON_VIDEO_EVENT]: "onTick",
  [JsType.ON_WEBXR_CONTROLLER_EVENT]: "onTick"
  /* onTick */
  // TODO
};
var ON_TICK_METHOD_NAMES = new Set(
  EVALUATOR_METHOD_NAMES.filter(
    (methodName) => EVENT_MAP_LOGIC[methodName] == "onTick"
    /* onTick */
  )
);
var INSTANT_METHOD_NAMES = new Set(
  EVALUATOR_METHOD_NAMES.filter(
    (methodName) => EVENT_MAP_LOGIC[methodName] == "instant"
    /* instant */
  )
);
if (0 + 0) {
  console.log({ ON_TICK_METHOD_NAMES, INSTANT_METHOD_NAMES });
}
var ActorsManager = class {
  constructor(scene) {
    this.scene = scene;
    this.rayObjectIntersectionClick = new RayObjectIntersectionsClickController(this);
    this.rayObjectIntersectionMouseClick = new RayObjectIntersectionsMouseClickController(this);
    this.rayObjectIntersectionContextmenu = new RayObjectIntersectionsContextmenuController(this);
    this.rayObjectIntersectionHover = new RayObjectIntersectionsHoverController(this);
    this.rayObjectIntersectionLongPress = new RayObjectIntersectionsLongPressController(this);
    this.rayObjectIntersectionPointerdown = new RayObjectIntersectionsPointerdownController(this);
    this.rayObjectIntersectionPointerup = new RayObjectIntersectionsPointerupController(this);
    this.rayObjectIntersectionSwipe = new RayObjectIntersectionsSwipeController(this);
    this.pointerdown = new PointerdownController(this);
    this.pointerup = new PointerupController(this);
    this._onEventTickBound = this._onEventTick.bind(this);
    this._onEventSceneResetBound = this._onEventSceneReset.bind(this);
    this._onEventScenePlayBound = this._onEventScenePlay.bind(this);
    this._onEventScenePauseBound = this._onEventScenePause.bind(this);
    this._onEventPerformanceChangeBound = this._onEventPerformanceChange.bind(this);
  }
  registerEvaluatorGenerator(evaluatorGenerator) {
    this.scene.eventsDispatcher.registerEvaluatorGenerator(evaluatorGenerator);
  }
  unregisterEvaluatorGenerator(evaluatorGenerator) {
    this.scene.eventsDispatcher.unregisterEvaluatorGenerator(evaluatorGenerator);
  }
  assignActorBuilder(object, node) {
    let ids = this.objectActorNodeIds(object);
    if (!ids) {
      ids = [];
      object.userData[ACTOR_BUILDER_NODE_IDS_KEY] = ids;
    }
    const id = node.graphNodeId();
    if (!ids.includes(id)) {
      ids.push(id);
    }
    Poly.onObjectsAddRemoveHooks.assignOnRemoveHookHandler(object, node);
  }
  objectActorNodeIds(object) {
    return object.userData[ACTOR_BUILDER_NODE_IDS_KEY];
  }
  /*
   *
   * EVENTS
   *
   */
  get keyboardEventsController() {
    return this._keyboardEventsController = this._keyboardEventsController || new ActorKeyboardEventsController(this);
  }
  get manualTriggerController() {
    return this._manualTriggerController = this._manualTriggerController || new ActorManualTriggersController(this);
  }
  /*
   *
   * PUBLIC METHODS
   *
   */
  tick() {
    var _a;
    this.rayObjectIntersectionHover.process();
    (_a = this._keyboardEventsController) == null ? void 0 : _a.runTriggers();
    hierarchyTraverse(this.scene.threejsScene(), (object) => {
      this.triggerEventNodes(object, "onPointermove");
      this._onEventTickBound(object);
    });
  }
  runOnEventSceneReset() {
    this._onEventSceneResetTraverse();
  }
  runOnEventScenePlay() {
    this._onEventScenePlayTraverse();
  }
  runOnEventScenePause() {
    this._onEventScenePauseTraverse();
  }
  runOnEventPerformanceChange() {
    this._onEventPerformanceChangeTraverse();
  }
  _onEventTick(object) {
    this.triggerEventNodes(object, JsType.ON_TICK);
  }
  _onEventSceneReset(object) {
    this.triggerEventNodes(object, JsType.ON_SCENE_RESET);
  }
  _onEventSceneResetTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventSceneResetBound);
  }
  _onEventScenePlay(object) {
    this.triggerEventNodes(object, JsType.ON_SCENE_PLAY);
  }
  _onEventScenePlayTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventScenePlayBound);
  }
  _onEventScenePause(object) {
    this.triggerEventNodes(object, JsType.ON_SCENE_PAUSE);
  }
  _onEventScenePauseTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventScenePauseBound);
  }
  _onEventPerformanceChange(object) {
    this.triggerEventNodes(object, JsType.ON_PERFORMANCE_CHANGE);
  }
  _onEventPerformanceChangeTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventPerformanceChangeBound);
  }
  //
  triggerEventNodes(object, methodName) {
    const nodeIds = this.objectActorNodeIds(object);
    if (!nodeIds) {
      return;
    }
    for (const nodeId of nodeIds) {
      if (object.parent == null) {
        return;
      }
      const node = this.scene.graph.nodeFromId(nodeId);
      if (node) {
        this.triggerEventNode(node, object, methodName);
      }
    }
  }
  triggerEventNode(node, object, methodName) {
    const evaluatorGenerator = node.compilationController.evaluatorGenerator();
    this._triggerEvaluatorGenerator(evaluatorGenerator, object, methodName);
  }
  _triggerEvaluatorGenerator(evaluatorGenerator, object, methodName) {
    const evaluator = evaluatorGenerator.findOrCreateEvaluator(object);
    if (evaluator[methodName]) {
      evaluator[methodName]();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/SceneCamerasController.js
var _cameras = [];
var SceneCamerasController = class {
  constructor(scene) {
    this.scene = scene;
    this._cameraObjectsRecentlyUpdated = [];
    this._errorMessageDisplayed = false;
    this._onCameraObjectsUpdatedCallbacks = [];
    this._coreGraphNode = new CoreGraphNode(this.scene, "SceneCamerasController");
  }
  coreGraphNode() {
    return this._coreGraphNode;
  }
  dispose() {
    this._coreGraphNode.dispose();
  }
  updateFromChangeInObject(object) {
    this._cameraObjects(object, this._cameraObjectsRecentlyUpdated);
    if (this._cameraObjectsRecentlyUpdated.length > 0) {
      this._coreGraphNode.setDirty();
    }
    for (const callback of this._onCameraObjectsUpdatedCallbacks) {
      callback();
    }
  }
  cameraObjects(target) {
    this._cameraObjects(this.scene.threejsScene(), target);
    return target;
  }
  _cameraObjects(parent, cameraObjects) {
    cameraObjects.splice(0, cameraObjects.length);
    parent.traverse((object) => {
      if (Poly.camerasRegister.objectRegistered(object)) {
        cameraObjects.push(object);
      }
    });
  }
  cameraObjectsRecentlyUpdated() {
    return this._cameraObjectsRecentlyUpdated;
  }
  // _mainCameraObjectPath: string | null = null;
  setMainCamera(camera) {
    this.scene.root().mainCameraController.setCamera(camera);
  }
  setMainCameraPath(path) {
    this.scene.root().mainCameraController.setCameraPath(path);
  }
  mainCameraPath() {
    return this.scene.root().mainCameraController.rawCameraPath();
  }
  async mainCamera(options) {
    if (this.scene.disposed()) {
      return null;
    }
    let printCameraNotFoundError = true;
    if ((options == null ? void 0 : options.printCameraNotFoundError) != null) {
      printCameraNotFoundError = options.printCameraNotFoundError;
    }
    const cameraMaskOverride = options == null ? void 0 : options.cameraMaskOverride;
    if (cameraMaskOverride != null) {
      this.scene.root().mainCameraController.setCameraPath(cameraMaskOverride);
    }
    const _printWarningMessage = (warningMessage2) => {
      if (this._errorMessageDisplayed == true) {
        return;
      }
      if (printCameraNotFoundError) {
        console.error(warningMessage2);
        this._errorMessageDisplayed = true;
      }
    };
    const camera = await this.scene.root().mainCameraController.camera();
    if (camera) {
      return camera;
    }
    let findAnyCamera = true;
    if ((options == null ? void 0 : options.findAnyCamera) != null) {
      findAnyCamera = options.findAnyCamera;
    }
    const cameraPath = await this.scene.root().mainCameraController.cameraPath();
    const warningMessage = `No camera found at path '${cameraPath}'. Make sure to set the root parameter 'mainCameraPath' to match a camera (from the top menu Windows->Root Node Params)`;
    if (findAnyCamera) {
      const firstAnyCamera = this._findAnyCameraObject();
      if (firstAnyCamera) {
        _printWarningMessage(warningMessage);
        return firstAnyCamera;
      }
    }
    _printWarningMessage(warningMessage);
    return null;
  }
  _findAnyCameraObject() {
    this.cameraObjects(_cameras);
    return _cameras[0];
  }
  async createMainViewer(options) {
    const camera = await this.mainCamera({
      cameraMaskOverride: options == null ? void 0 : options.cameraMaskOverride
    });
    if (!camera) {
      return;
    }
    return Poly.camerasRegister.createViewer({
      ...options,
      camera,
      scene: this.scene
    });
  }
  onCameraObjectsUpdated(callback) {
    const index = this._onCameraObjectsUpdatedCallbacks.indexOf(callback);
    if (index >= 0) {
      return;
    }
    this._onCameraObjectsUpdatedCallbacks.push(callback);
  }
  removeOnCameraObjectsUpdated(callback) {
    const index = this._onCameraObjectsUpdatedCallbacks.indexOf(callback);
    if (index >= 0) {
      this._onCameraObjectsUpdatedCallbacks.splice(index, 1);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/Cooker.js
var Cooker = class {
  constructor(_scene) {
    this._scene = _scene;
    this._queue = /* @__PURE__ */ new Map();
    this._nodeIdsInFlushingQueue = /* @__PURE__ */ new Set();
    this._blockLevel = 0;
  }
  // private _processesCount: number = 0;
  block() {
    this._blockLevel += 1;
  }
  unblock() {
    this._blockLevel -= 1;
    if (this._blockLevel > 0) {
      return;
    }
    if (this._blockLevel < 0) {
      this._blockLevel = 0;
    }
    this._processQueue();
  }
  blocked() {
    return this._blockLevel > 0 || this._scene.loadingController.isLoading();
  }
  enqueue(node, originalTriggerGraphNode) {
    if (!node.dirtyController.hasPostDirtyHooks()) {
      return;
    }
    if (this._queue.has(node.graphNodeId()) || this._nodeIdsInFlushingQueue.has(node.graphNodeId())) {
      return;
    }
    this._queue.set(node.graphNodeId(), originalTriggerGraphNode);
  }
  _processQueue() {
    if (this.blocked()) {
      return;
    }
    if (this._queue.size == 0) {
      return;
    }
    const originalTriggerGraphNodes = [];
    const nodeIds = [];
    this._queue.forEach((originalTriggerGraphNode, nodeId) => {
      originalTriggerGraphNodes.push(originalTriggerGraphNode);
      nodeIds.push(nodeId);
      this._nodeIdsInFlushingQueue.add(nodeId);
    });
    this._queue.clear();
    let i = 0;
    for (const originalTriggerGraphNode of originalTriggerGraphNodes) {
      const nodeId = nodeIds[i];
      this._processItem(originalTriggerGraphNode, nodeId);
      this._nodeIdsInFlushingQueue.delete(nodeId);
      i++;
    }
  }
  _processItem(originalTriggerGraphNode, nodeId) {
    const node = this._scene.graph.nodeFromId(nodeId);
    if (node) {
      node.dirtyController.runPostDirtyHooks(originalTriggerGraphNode);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/CookController.js
var SceneCookController = class {
  constructor() {
    this._cookingNodesById = /* @__PURE__ */ new Map();
    this._nodeIdsHavingCookedAtLeastOnce = /* @__PURE__ */ new Set();
    this._nodeIdsCookingMoreThanOnce = /* @__PURE__ */ new Set();
    this._resolves = [];
  }
  addNode(node) {
    const id = node.graphNodeId();
    this._cookingNodesById.set(id, node);
    if (!this._nodeIdsHavingCookedAtLeastOnce.has(id)) {
      this._nodeIdsCookingMoreThanOnce.add(id);
    }
    this._nodeIdsHavingCookedAtLeastOnce.add(id);
  }
  removeNode(node) {
    const id = node.graphNodeId();
    this._cookingNodesById.delete(id);
    this._nodeIdsCookingMoreThanOnce.delete(id);
    if (this._cookingNodesById.size == 0) {
      this.flush();
    }
  }
  cookingNodes(target = []) {
    target.length = 0;
    this._cookingNodesById.forEach((node, id) => {
      target.push(node);
    });
    return target;
  }
  allNodesHaveCookedAtLeastOnce() {
    return this._nodeIdsCookingMoreThanOnce.size == 0;
  }
  flush() {
    let callback;
    while (callback = this._resolves.pop()) {
      callback();
    }
  }
  async waitForCooksCompleted() {
    if (this._cookingNodesById.size == 0) {
      return;
    } else {
      return new Promise((resolve, reject) => {
        this._resolves.push(resolve);
      });
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/graph/CoreGraph.js
var _idStack = [];
var _idsSet = /* @__PURE__ */ new Set();
var CoreGraph = class {
  constructor() {
    this._nextId = 0;
    this._successors = /* @__PURE__ */ new Map();
    this._predecessors = /* @__PURE__ */ new Map();
    this._nodesById = /* @__PURE__ */ new Map();
    this._forbiddenTriggerNodeIds = /* @__PURE__ */ new Map();
    this._selfDirtyForbidden = /* @__PURE__ */ new Set();
    this._nodesCount = 0;
    this._debugging = false;
    this._addedNodesDuringDebugging = /* @__PURE__ */ new Map();
    this._boundPredecessorIds = this.predecessorIds.bind(this);
    this._boundSuccessorIds = this.successorIds.bind(this);
  }
  startDebugging() {
    this._debugging = true;
  }
  stopDebugging() {
    this._debugging = false;
  }
  printDebug() {
    this._addedNodesDuringDebugging.forEach((node, nodeId) => {
      console.log(nodeId, node, node.graphPredecessors(), node.graphSuccessors());
    });
  }
  // print() {
  // 	this._nodesById.forEach((node, nodeId) => {
  // 		console.log(nodeId, node, node.graphPredecessors(), node.graphSuccessors());
  // 	});
  // }
  setScene(scene) {
    this._scene = scene;
  }
  scene() {
    return this._scene;
  }
  nextId() {
    this._nextId += 1;
    return this._nextId;
  }
  nodesFromIds(ids, target) {
    target.length = 0;
    for (const id of ids) {
      const node = this.nodeFromId(id);
      if (node) {
        target.push(node);
      }
    }
  }
  nodeFromId(id) {
    return this._nodesById.get(id);
  }
  hasNode(node) {
    return this._nodesById.get(node.graphNodeId()) != null;
  }
  addNode(node) {
    this._nodesById.set(node.graphNodeId(), node);
    this._nodesCount += 1;
    if (this._debugging) {
      this._addedNodesDuringDebugging.set(node.graphNodeId(), node);
    }
  }
  removeNode(node) {
    this.disconnectPredecessors(node);
    this.disconnectSuccessors(node);
    const nodeId = node.graphNodeId();
    this._nodesById.delete(nodeId);
    this._successors.delete(nodeId);
    this._predecessors.delete(nodeId);
    this._nodesCount -= 1;
    this._forbiddenTriggerNodeIds.delete(nodeId);
    this._forbiddenTriggerNodeIds.forEach((set, nodeId2) => {
      if (set.has(nodeId2)) {
        set.delete(nodeId2);
      }
    });
    this._selfDirtyForbidden.delete(nodeId);
    if (this._debugging) {
      this._addedNodesDuringDebugging.delete(nodeId);
    }
  }
  nodesCount() {
    return this._nodesCount;
  }
  connect(src, dest, checkCycle = true) {
    const srcId = src.graphNodeId();
    const destId = dest.graphNodeId();
    if (!(this.hasNode(src) && this.hasNode(dest))) {
      console.warn(`attempt to connect non existing node ${srcId} or ${destId}`);
      return false;
    }
    if (checkCycle) {
      const sceneLoading = this._scene ? this._scene.loadingController.isLoading() : true;
      checkCycle = !sceneLoading;
    }
    const graphWouldHaveCycle = checkCycle ? src.hasPredecessor(dest) : false;
    if (graphWouldHaveCycle) {
      return false;
    } else {
      this._createConnection(srcId, destId);
      src.clearCachesWithPredecessorsAndSuccessors();
      return true;
    }
  }
  disconnect(src, dest) {
    this._removeConnection(src.graphNodeId(), dest.graphNodeId());
    src.clearCachesWithPredecessorsAndSuccessors();
    dest.clearCachesWithPredecessorsAndSuccessors();
  }
  disconnectPredecessors(node) {
    const predecessors = this.predecessors(node);
    if (!predecessors) {
      return;
    }
    for (const predecessor of predecessors) {
      this.disconnect(predecessor, node);
    }
  }
  disconnectSuccessors(node) {
    const successors = this.successors(node);
    if (!successors) {
      return;
    }
    for (const successor of successors) {
      this.disconnect(node, successor);
    }
  }
  predecessorIds(id) {
    var _a;
    return (_a = this._predecessors.get(id)) == null ? void 0 : _a.idsArray;
  }
  predecessors(node) {
    var _a;
    return (_a = this._predecessors.get(node.graphNodeId())) == null ? void 0 : _a.nodes;
  }
  successorIds(id) {
    var _a;
    return (_a = this._successors.get(id)) == null ? void 0 : _a.idsArray;
  }
  successors(node) {
    var _a;
    return (_a = this._successors.get(node.graphNodeId())) == null ? void 0 : _a.nodes;
  }
  // private _allNodeIds(node: CoreGraphNode, method: TraverseCallback, target: CoreGraphNodeId[]): void {
  // 	target.length = 0;
  // 	_idsSet.clear();
  // 	_idStack.length = 1;
  // 	_idStack[0] = node.graphNodeId();
  // 	const forbiddenIds = this._forbiddenTriggerNodeIds.get(node.graphNodeId())
  // 	while (_idStack.length > 0) {
  // 		const currentId = _idStack.pop()!;
  // 		const ids = method(currentId);
  // 		if (ids) {
  // 			for (const id of ids) {
  // 				if (!_idsSet.has(id)) {
  // 					_idsSet.add(id);
  // 					target.push(id);
  // 					_idStack.push(id);
  // 				}
  // 			}
  // 		}
  // 	}
  // }
  allPredecessorIds(node, target) {
    target.length = 0;
    _idsSet.clear();
    _idStack.length = 1;
    _idStack[0] = node.graphNodeId();
    while (_idStack.length > 0) {
      const currentId = _idStack.pop();
      const ids = this._boundPredecessorIds(currentId);
      if (ids) {
        for (const id of ids) {
          if (!_idsSet.has(id)) {
            _idsSet.add(id);
            target.push(id);
            _idStack.push(id);
          }
        }
      }
    }
  }
  allSuccessorIds(node, target) {
    target.length = 0;
    _idsSet.clear();
    _idStack.length = 1;
    _idStack[0] = node.graphNodeId();
    const forbiddenIds = this._forbiddenTriggerNodeIds.get(node.graphNodeId());
    while (_idStack.length > 0) {
      const currentId = _idStack.pop();
      const ids = this._boundSuccessorIds(currentId);
      if (ids) {
        for (const id of ids) {
          if (!_idsSet.has(id)) {
            _idsSet.add(id);
            if (forbiddenIds == null || !forbiddenIds.has(id)) {
              target.push(id);
              _idStack.push(id);
            }
          }
        }
      }
    }
  }
  // private _allNodes(node: CoreGraphNode, method: TraverseCallback, target: CoreGraphNode[]): void {
  // 	target.length = 0;
  // 	_idsSet.clear();
  // 	_idStack.length = 1;
  // 	_idStack[0] = node.graphNodeId();
  // 	while (_idStack.length > 0) {
  // 		const currentId = _idStack.pop()!;
  // 		const ids = method(currentId);
  // 		if (ids) {
  // 			for (const id of ids) {
  // 				if (!_idsSet.has(id)) {
  // 					_idsSet.add(id);
  // 					const otherNode = this._nodesById.get(id);
  // 					if (otherNode) {
  // 						target.push(otherNode);
  // 					}
  // 					_idStack.push(id);
  // 				}
  // 			}
  // 		}
  // 	}
  // }
  allPredecessors(node, target) {
    target.length = 0;
    _idsSet.clear();
    _idStack.length = 1;
    _idStack[0] = node.graphNodeId();
    while (_idStack.length > 0) {
      const currentId = _idStack.pop();
      const ids = this._boundPredecessorIds(currentId);
      if (ids) {
        for (const id of ids) {
          if (!_idsSet.has(id)) {
            _idsSet.add(id);
            const otherNode = this._nodesById.get(id);
            if (otherNode) {
              target.push(otherNode);
            }
            _idStack.push(id);
          }
        }
      }
    }
  }
  allSuccessors(node, target) {
    target.length = 0;
    _idsSet.clear();
    _idStack.length = 1;
    _idStack[0] = node.graphNodeId();
    const forbiddenIds = this._forbiddenTriggerNodeIds.get(node.graphNodeId());
    while (_idStack.length > 0) {
      const currentId = _idStack.pop();
      const ids = this._boundSuccessorIds(currentId);
      if (ids) {
        for (const id of ids) {
          if (!_idsSet.has(id)) {
            _idsSet.add(id);
            if (forbiddenIds == null || !forbiddenIds.has(id)) {
              const otherNode = this._nodesById.get(id);
              if (otherNode) {
                target.push(otherNode);
              }
              _idStack.push(id);
            }
          }
        }
      }
    }
  }
  _createConnection(srcId, destId) {
    let successorsData = this._successors.get(srcId);
    let predecessorsData = this._predecessors.get(destId);
    if (!successorsData) {
      successorsData = { idsSet: /* @__PURE__ */ new Set(), idsArray: [], nodes: [] };
      this._successors.set(srcId, successorsData);
    }
    if (!predecessorsData) {
      predecessorsData = { idsSet: /* @__PURE__ */ new Set(), idsArray: [], nodes: [] };
      this._predecessors.set(destId, predecessorsData);
    }
    if (!successorsData.idsSet.has(destId)) {
      successorsData.idsSet.add(destId);
      successorsData.idsArray.push(destId);
      const destNode = this._nodesById.get(destId);
      if (destNode) {
        successorsData.nodes.push(destNode);
      } else {
        throw new Error(`creating connection with node not in graph ${destId}`);
      }
    }
    if (!predecessorsData.idsSet.has(srcId)) {
      predecessorsData.idsSet.add(srcId);
      predecessorsData.idsArray.push(srcId);
      const srcNode = this._nodesById.get(srcId);
      if (srcNode) {
        predecessorsData.nodes.push(srcNode);
      } else {
        throw new Error(`creating connection with node not in graph ${srcId}`);
      }
    }
  }
  _removeConnection(srcId, destId) {
    const successorsData = this._successors.get(srcId);
    if (successorsData && successorsData.idsSet.has(destId)) {
      successorsData.idsSet.delete(destId);
      const idIndex = successorsData.idsArray.indexOf(destId);
      if (idIndex >= 0) {
        successorsData.idsArray.splice(idIndex, 1);
        successorsData.nodes.splice(idIndex, 1);
      } else {
        console.warn(`could not find id ${destId} in successorsData.idsArray`, successorsData.idsArray);
      }
    }
    const predecessorsData = this._predecessors.get(destId);
    if (predecessorsData && predecessorsData.idsSet.has(srcId)) {
      predecessorsData.idsSet.delete(srcId);
      const idIndex = predecessorsData.idsArray.indexOf(srcId);
      if (idIndex >= 0) {
        predecessorsData.idsArray.splice(idIndex, 1);
        predecessorsData.nodes.splice(idIndex, 1);
      } else {
        console.warn(`could not find id ${srcId} in predecessorsData.idsArray`, predecessorsData.idsArray);
      }
    }
  }
  setForbiddenTriggerNodes(src, dest) {
    var _a;
    (_a = this._forbiddenTriggerNodeIds.get(src.graphNodeId())) == null ? void 0 : _a.clear();
    if (isArray(dest)) {
      for (const destNode of dest) {
        addToSetAtEntry(this._forbiddenTriggerNodeIds, src.graphNodeId(), destNode.graphNodeId());
      }
    } else {
      addToSetAtEntry(this._forbiddenTriggerNodeIds, src.graphNodeId(), dest.graphNodeId());
    }
  }
  clearForbiddenTriggerNodes(src) {
    this._forbiddenTriggerNodeIds.delete(src.graphNodeId());
  }
  setSelfDirtyForbidden(node, state) {
    if (state) {
      this._selfDirtyForbidden.add(node.graphNodeId());
    } else {
      this._selfDirtyForbidden.delete(node.graphNodeId());
    }
  }
  selfDirtyForbidden(node) {
    return this._selfDirtyForbidden.has(node.graphNodeId());
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/performance/PerformanceNode.js
var PerformanceNode = class {
  constructor(_node) {
    this._node = _node;
    this._cooks_count = 0;
    this._total_cook_time = 0;
    this._total_inputs_time = 0;
    this._total_params_time = 0;
  }
  update_cook_data(performance_data) {
    this._cooks_count += 1;
    this._total_cook_time += performance_data.cookTime;
    this._total_inputs_time += performance_data.inputsTime;
    this._total_params_time += performance_data.paramsTime;
  }
  total_time() {
    return this._total_cook_time + this._total_inputs_time + this._total_params_time;
  }
  total_cook_time() {
    return this._total_cook_time;
  }
  cook_time_per_iteration() {
    if (this._cooks_count > 0) {
      return this._total_cook_time / this._cooks_count;
    } else {
      return 0;
    }
  }
  total_inputs_time() {
    return this._total_inputs_time;
  }
  inputs_time_per_iteration() {
    if (this._cooks_count > 0) {
      return this._total_inputs_time / this._cooks_count;
    } else {
      return 0;
    }
  }
  total_params_time2() {
    return this._total_params_time;
  }
  params_time_per_iteration2() {
    if (this._cooks_count > 0) {
      return this._total_params_time / this._cooks_count;
    } else {
      return 0;
    }
  }
  cooks_count() {
    return this._cooks_count;
  }
  print_object() {
    return {
      fullPath: this._node.path(),
      cooks_count: this.cooks_count(),
      total_time: this.total_time(),
      total_cook_time: this.total_cook_time(),
      cook_time_per_iteration: this.cook_time_per_iteration(),
      // cook_time_total_with_inputs: this.cook_time_total_with_inputs,
      // cook_time_total_with_inputs_per_iteration: this.cook_time_total_with_inputs_per_iteration,
      inputs_time_per_iteration: this.inputs_time_per_iteration(),
      params_time_per_iteration: this.params_time_per_iteration2()
    };
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/performance/CorePerformance.js
var CorePerformance = class {
  constructor() {
    this._started = false;
    this._start_time = 0;
    this._previous_timestamp = 0;
    this._nodes_cook_data = {};
    this._durations_by_name = {};
    this._durations_count_by_name = {};
  }
  profile(name, method) {
    const performance2 = Poly.performance.performanceManager();
    const start_time = performance2.now();
    method();
    const total_time = performance2.now() - start_time;
    console.log(`${name}: ${total_time}`);
  }
  start() {
    if (!this._started) {
      this.reset();
      this._started = true;
      const performance2 = Poly.performance.performanceManager();
      this._start_time = performance2.now();
      this._nodes_cook_data = {};
      this._previous_timestamp = this._start_time;
    }
  }
  stop() {
    this.reset();
  }
  reset() {
    this._started = false;
    this._start_time = null;
    this._durations_by_name = {};
    this._durations_count_by_name = {};
    this._nodes_cook_data = {};
  }
  started() {
    return this._started;
  }
  recordNodeCookData(node, performance_data) {
    const id = node.graphNodeId();
    if (this._nodes_cook_data[id] == null) {
      this._nodes_cook_data[id] = new PerformanceNode(node);
    }
    this._nodes_cook_data[id].update_cook_data(performance_data);
  }
  record(name) {
    if (!this.started()) {
      this.start();
    }
    const current_timestamp = performance.now();
    if (this._durations_by_name[name] == null) {
      this._durations_by_name[name] = 0;
    }
    this._durations_by_name[name] += current_timestamp - this._previous_timestamp;
    if (this._durations_count_by_name[name] == null) {
      this._durations_count_by_name[name] = 0;
    }
    this._durations_count_by_name[name] += 1;
    return this._previous_timestamp = current_timestamp;
  }
  print() {
    this.print_node_cook_data();
    this.print_recordings();
  }
  print_node_cook_data() {
    let performance_nodes = Object.values(this._nodes_cook_data);
    performance_nodes = arraySortBy(performance_nodes, (performance_node) => performance_node.total_cook_time());
    const print_objects = performance_nodes.map((performance_node) => performance_node.print_object());
    console.log("--------------- NODES COOK TIME -----------");
    const table_entries = [];
    const sorted_print_objects = arraySortBy(print_objects, (print_object) => -print_object.total_cook_time);
    for (const print_object of sorted_print_objects) {
      table_entries.push(print_object);
    }
    console.table(table_entries);
    return print_objects;
  }
  print_recordings() {
    const durations_by_name = objectClone(this._durations_by_name);
    const durations_count_by_name = objectClone(this._durations_count_by_name);
    const durations = [];
    const names_by_duration = {};
    for (const name of Object.keys(durations_by_name)) {
      const duration = durations_by_name[name];
      durations.push(duration);
      if (names_by_duration[duration] == null) {
        names_by_duration[duration] = [];
      }
      names_by_duration[duration].push(name);
    }
    durations.sort((a, b) => a - b);
    const sortedDurations = [];
    arrayUniq(durations, sortedDurations);
    console.log("--------------- PERF RECORDINGS -----------");
    const table_entries = [];
    for (const duration of sortedDurations) {
      const names = names_by_duration[duration];
      for (const name of names) {
        const count = durations_count_by_name[name];
        const duration_per_iteration = duration / count;
        const entry = { duration, name, count, duration_per_iteration };
        table_entries.push(entry);
      }
    }
    console.table(table_entries);
    return table_entries;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/DispatchController.js
var DispatchController = class {
  constructor(scene) {
    this.scene = scene;
  }
  setListener(eventsListener) {
    if (!this._eventsListener) {
      this._eventsListener = eventsListener;
      this._runOnAddListenerCallbacks();
    } else {
      console.warn("scene already has a listener");
    }
  }
  onAddListener(callback) {
    if (this._eventsListener) {
      callback();
    } else {
      this._onAddListenerCallbacks = this._onAddListenerCallbacks || [];
      this._onAddListenerCallbacks.push(callback);
    }
  }
  _runOnAddListenerCallbacks() {
    if (this._onAddListenerCallbacks) {
      let callback;
      while (callback = this._onAddListenerCallbacks.pop()) {
        callback();
      }
      this._onAddListenerCallbacks = void 0;
    }
  }
  dispatch(emitter, event, data) {
    var _a;
    (_a = this._eventsListener) == null ? void 0 : _a.processEvents(emitter, event, data);
  }
  emitAllowed() {
    return this._eventsListener != null && this.scene.loadingController.loaded() && this.scene.loadingController.autoUpdating();
  }
  processActorEvaluator(evaluator) {
    var _a;
    return (_a = this._eventsListener) == null ? void 0 : _a.processActorEvaluator(evaluator);
  }
  actorEvaluatorDebug(options) {
    var _a;
    return (_a = this._eventsListener) == null ? void 0 : _a.actorEvaluatorDebug(options);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/SceneExpressionsController.js
var SceneExpressionsController = class {
  constructor() {
    this._paramsById = /* @__PURE__ */ new Map();
  }
  registerParam(param) {
    this._paramsById.set(param.graphNodeId(), param);
  }
  deregisterParam(param) {
    this._paramsById.delete(param.graphNodeId());
  }
  //
  //
  //
  //
  regenerateReferringExpressions(node) {
    node.nameController.graphNode().setSuccessorsDirty(node);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/LifeCycleController.js
var SceneLifeCycleController = class {
  constructor(scene) {
    this.scene = scene;
    this._lifecycleOnAfterCreatedAllowed = true;
  }
  onAfterCreatedCallbackAllowed() {
    return this.scene.loadingController.loaded() && this._lifecycleOnAfterCreatedAllowed;
  }
  onAfterCreatedPrevent(callback) {
    this._lifecycleOnAfterCreatedAllowed = false;
    callback();
    this._lifecycleOnAfterCreatedAllowed = true;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/LoadingController.js
var LoadingController = class {
  constructor(scene) {
    this.scene = scene;
    this._loadingState = true;
    this._autoUpdating = false;
  }
  markAsLoading() {
    this._setLoadingState(true);
  }
  markAsLoaded() {
    this.scene.missingExpressionReferencesController.resolveMissingReferences();
    this._setLoadingState(false);
    this._triggerLoadedEvent();
  }
  dispatchReadyEvent() {
    if (globalThis.Event) {
      this.scene.eventsDispatcher.sceneEventsController.dispatch(SCENE_EVENT_READY_EVENT_CONTEXT);
    }
  }
  _triggerLoadedEvent() {
    if (globalThis.Event) {
      this.scene.eventsDispatcher.sceneEventsController.dispatch(SCENE_EVENT_CREATED_EVENT_CONTEXT);
    }
  }
  _setLoadingState(state) {
    this._loadingState = state;
    this.setAutoUpdate(!this._loadingState);
    this.scene.cooker.unblock();
  }
  isLoading() {
    return this._loadingState;
  }
  loaded() {
    return !this._loadingState;
  }
  autoUpdating() {
    return this._autoUpdating;
  }
  setAutoUpdate(newState) {
    if (this._autoUpdating !== newState) {
      this._autoUpdating = newState;
      if (this._autoUpdating) {
        const root = this.scene.root();
        if (root) {
          root.processQueue();
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/missingReferences/MissingReference.js
var MissingReference = class {
  constructor(param, path) {
    this.param = param;
    this.path = path;
  }
  absolutePath() {
    if (!this.param.node) {
      return;
    }
    return CoreWalker.makeAbsolutePath(this.param.node, this.path);
  }
  matchesPath(path) {
    return this.absolutePath() == path;
  }
  resolveMissingDependencies() {
    const input = this.param.rawInputSerialized();
    this.param.set(this.param.defaultValue());
    this.param.set(input);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/missingReferences/MissingReferencesController.js
var _resolvedReferences = [];
var _missingReferences = [];
var _missingReferencesSet = [];
var MissingReferencesController = class {
  constructor(scene) {
    this.scene = scene;
    this.references = /* @__PURE__ */ new Map();
    this._toIgnore = /* @__PURE__ */ new WeakMap();
  }
  register(param, path, jsepNode) {
    if (jsepNode && this._toIgnore.get(jsepNode) == true) {
      return;
    }
    const missingReference = new MissingReference(param, path);
    addToSetAtEntry(this.references, param.graphNodeId(), missingReference);
    return missingReference;
  }
  deregisterParam(param) {
    this.references.delete(param.graphNodeId());
  }
  registerToIgnore(jsepNode) {
    this._toIgnore.set(jsepNode, true);
  }
  //
  //
  // MISSING REFERENCES
  //
  //
  resolveMissingReferences() {
    _resolvedReferences.length = 0;
    this.references.forEach((references) => {
      references.forEach((reference) => {
        if (this._isReferenceResolvable(reference)) {
          _resolvedReferences.push(reference);
        }
      });
    });
    for (const reference of _resolvedReferences) {
      reference.resolveMissingDependencies();
    }
  }
  _isReferenceResolvable(reference) {
    const absolutePath = reference.absolutePath();
    if (absolutePath) {
      const node = this.scene.node(absolutePath);
      if (node) {
        return true;
      } else {
        const paths = CoreWalker.splitParentChild(absolutePath);
        if (paths.child) {
          const parentNode = this.scene.node(paths.parent);
          if (parentNode) {
            const param = parentNode.params.get(paths.child);
            if (param) {
              return true;
            }
          }
        }
      }
    }
  }
  // call this from node.create and node.rename
  checkForMissingNodeReferences(node) {
    if (!node.scene().loadingController.loaded()) {
      return;
    }
    this._checkForMissingReferencesForNode(node);
    for (const param of node.params.all) {
      this._checkForMissingReferencesForParam(param);
    }
  }
  // call this from spare params update
  checkForMissingParamReferences(param) {
    if (!param.scene().loadingController.loaded()) {
      return;
    }
    this._checkForMissingReferencesForParam(param);
  }
  _checkForMissingReferencesForNode(node) {
    const id = node.graphNodeId();
    mapValuesToArray(this.references, _missingReferencesSet);
    for (const missingReferenceSet of _missingReferencesSet) {
      let matchFound = false;
      setToArray(missingReferenceSet, _missingReferences);
      for (const ref2 of _missingReferences) {
        if (ref2.matchesPath(node.path())) {
          matchFound = true;
          ref2.resolveMissingDependencies();
        }
      }
      if (matchFound) {
        this.references.delete(id);
      }
    }
  }
  _checkForMissingReferencesForParam(param) {
    const id = param.graphNodeId();
    mapValuesToArray(this.references, _missingReferencesSet);
    for (const missingReferenceSet of _missingReferencesSet) {
      let matchFound = false;
      setToArray(missingReferenceSet, _missingReferences);
      for (const ref2 of _missingReferences) {
        if (ref2.matchesPath(param.path())) {
          matchFound = true;
          ref2.resolveMissingDependencies();
        }
      }
      if (matchFound) {
        this.references.delete(id);
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/GraphNodesController.js
var GraphNodesController = class {
  constructor(scene) {
    this.scene = scene;
    this._graphNodeIdByPath = /* @__PURE__ */ new Map();
    this._pathByGraphNodeId = /* @__PURE__ */ new Map();
  }
  notifyNodePathChanged(node) {
    var _a;
    this._notifyGraphNodePathChanged(node);
    const params = node.params.all;
    for (const param of params) {
      this.notifyParamPathChanged(param);
    }
    (_a = node.childrenController) == null ? void 0 : _a.traverseChildren((child) => {
      this._notifyGraphNodePathChanged(child);
    });
  }
  notifyParamPathChanged(param) {
    this._notifyGraphNodePathChanged(param);
  }
  _notifyGraphNodePathChanged(node) {
    const id = node.graphNodeId();
    const newPath = node.path();
    const previousPath = this._pathByGraphNodeId.get(id);
    if (previousPath != null) {
      const _ref2 = this._graphNodeIdByPath.get(previousPath);
      if (_ref2) {
        _ref2.value = null;
      }
    }
    if (node.disposed()) {
      return;
    }
    const _ref = this._findOrCreateRef(newPath);
    _ref.value = id;
    this._pathByGraphNodeId.set(id, newPath);
  }
  pathRef(path) {
    return this._findOrCreateRef(path);
  }
  _findOrCreateRef(path) {
    let _ref = this._graphNodeIdByPath.get(path);
    if (!_ref) {
      _ref = ref(null);
      this._graphNodeIdByPath.set(path, _ref);
    }
    return _ref;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/_Base.js
var TypedBaseManagerNode = class extends TypedNode {
  static context() {
    return NodeContext.MANAGER;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/ObjectsController.js
var ROOT_NAME = "/";
var ObjectsController = class {
  constructor(scene) {
    this.scene = scene;
  }
  findObjectByMask(mask) {
    return CorePath.findObjectByMask(mask, this.scene.threejsScene());
  }
  objectsByMask(mask, parent) {
    return objectsByMask(mask, parent || this.scene.threejsScene(), false);
  }
  traverseObjectsWithMask(mask, callback, object, invertMask = false) {
    CorePath.traverseObjectsWithMaskInObject(mask, object || this.scene.threejsScene(), callback, invertMask);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/Audio.js
var CallbackOptions = {
  computeOnDirty: false,
  callback: (node) => {
    RootAudioController.update(node);
  }
};
function RootAudioParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.displayAudioIcon = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions,
        separatorBefore: true
      });
      this.audioIconColor = ParamConfig.COLOR([0, 0, 0], {
        ...CallbackOptions,
        visibleIf: { displayAudioIcon: 1 }
      });
      this.audioIconStyle = ParamConfig.STRING(
        "position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; cursor: pointer",
        {
          ...CallbackOptions,
          visibleIf: { displayAudioIcon: 1 }
        }
      );
    }
  };
}
var RootAudioController = class {
  constructor(node) {
    this.node = node;
    this._callbacksByName = /* @__PURE__ */ new Map();
  }
  async toggleSound() {
    this.audioListeners().forEach((node) => {
      node.toggleSound();
    });
    this.update();
    this._runOnToggleSoundCallbacks();
  }
  soundOn() {
    const listener = this.audioListeners()[0];
    if (listener) {
      return isBooleanTrue(listener.pv.soundOn) || false;
    } else {
      return false;
    }
  }
  update() {
    this._updateViewers();
  }
  audioListeners() {
    return this.node.nodesByType("audioListener");
  }
  _updateViewers() {
    this.node.scene().viewersRegister.traverseViewers((viewer) => {
      viewer.audioController().update();
    });
  }
  static update(node) {
    node.audioController.update();
  }
  onToggleSound(callbackName, callback) {
    if (this._callbacksByName.get(callbackName)) {
      console.warn(`callback already registered ith name '${callbackName}'`);
      return;
    }
    this._callbacksByName.set(callbackName, callback);
  }
  _runOnToggleSoundCallbacks() {
    const soundOn = this.soundOn();
    this._callbacksByName.forEach((callback) => {
      callback(soundOn);
    });
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/AutoUpdate.js
var CallbackOptions2 = {
  computeOnDirty: false,
  callback: (node) => {
    SceneAutoUpdateController.update(node);
  }
};
function SceneAutoUpdateParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.autoUpdate = ParamConfig.BOOLEAN(1, {
        ...CallbackOptions2,
        separatorBefore: true
      });
    }
  };
}
var SceneAutoUpdateController = class {
  constructor(node) {
    this.node = node;
  }
  async update() {
    const scene = this.node.object;
    const pv = this.node.pv;
    if (isBooleanTrue(pv.autoUpdate) != scene.matrixWorldAutoUpdate) {
      scene.matrixWorldAutoUpdate = isBooleanTrue(pv.autoUpdate);
    }
  }
  static async update(node) {
    node.sceneAutoUpdateController.update();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/Background.js
var BackgroundMode = ((BackgroundMode2) => {
  BackgroundMode2["NONE"] = "none";
  BackgroundMode2["COLOR"] = "color";
  BackgroundMode2["TEXTURE"] = "texture";
  return BackgroundMode2;
})(BackgroundMode || {});
var BACKGROUND_MODES = [
  "none",
  "color",
  "texture"
  /* TEXTURE */
];
var CallbackOptions3 = {
  cook: false,
  callback: (node) => {
    SceneBackgroundController.update(node);
  }
};
function SceneBackgroundParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.backgroundMode = ParamConfig.INTEGER(BACKGROUND_MODES.indexOf(
        "color"
        /* COLOR */
      ), {
        menu: {
          entries: BACKGROUND_MODES.map((mode, i) => {
            return { name: mode, value: i };
          })
        },
        ...CallbackOptions3,
        separatorBefore: true
      });
      this.bgColor = ParamConfig.COLOR([0.01, 0.01, 0.01], {
        visibleIf: { backgroundMode: BACKGROUND_MODES.indexOf(
          "color"
          /* COLOR */
        ) },
        ...CallbackOptions3
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      this.bgTexture = ParamConfig.NODE_PATH("", {
        visibleIf: { backgroundMode: BACKGROUND_MODES.indexOf(
          "texture"
          /* TEXTURE */
        ) },
        nodeSelection: {
          context: NodeContext.COP
        },
        // dependentOnFoundNode: false,
        ...CallbackOptions3
      });
      this.bgBlur = ParamConfig.FLOAT(0, {
        visibleIf: { backgroundMode: BACKGROUND_MODES.indexOf(
          "texture"
          /* TEXTURE */
        ) },
        range: [0, 1],
        rangeLocked: [true, false],
        ...CallbackOptions3
      });
      this.bgIntensity = ParamConfig.FLOAT(1, {
        visibleIf: { backgroundMode: BACKGROUND_MODES.indexOf(
          "texture"
          /* TEXTURE */
        ) },
        range: [0, 2],
        rangeLocked: [true, false],
        ...CallbackOptions3
      });
    }
  };
}
var CALLBACK_NAME = "SceneBackgroundController";
var SceneBackgroundController = class {
  constructor(node) {
    this.node = node;
    this._updateBound = this.update.bind(this);
  }
  addHooks() {
    const p = this.node.p;
    const params = [p.backgroundMode, p.bgColor, p.bgTexture];
    for (const param of params) {
      param.addPostDirtyHook(CALLBACK_NAME, this._updateBound);
    }
  }
  setMode(mode) {
    this.node.p.backgroundMode.set(BACKGROUND_MODES.indexOf(mode));
  }
  backgroundMode() {
    return BACKGROUND_MODES[this.node.pv.backgroundMode];
  }
  async update() {
    const backgroundMode = this.backgroundMode();
    switch (backgroundMode) {
      case "none": {
        return this._setBackgroundNone();
      }
      case "color": {
        return await this._setBackgroundColor();
      }
      case "texture": {
        return await this._setBackgroundTexture();
      }
    }
    TypeAssert.unreachable(backgroundMode);
  }
  _setBackgroundNone() {
    const scene = this.node.object;
    scene.background = null;
  }
  async _setBackgroundColor() {
    const scene = this.node.object;
    const pv = this.node.pv;
    await this.node.p.bgColor.compute();
    if (scene.background && scene.background instanceof Color) {
      scene.background.copy(pv.bgColor);
    } else {
      scene.background = pv.bgColor;
    }
  }
  async _setBackgroundTexture() {
    const scene = this.node.object;
    const pv = this.node.pv;
    const node = pv.bgTexture.nodeWithContext(NodeContext.COP);
    if (node) {
      const container = await node.compute();
      scene.background = container.texture();
    } else {
      this.node.states.error.set("bgTexture node not found");
      scene.background = null;
    }
    scene.backgroundBlurriness = pv.bgBlur;
    scene.backgroundIntensity = pv.bgIntensity;
  }
  static update(node) {
    node.sceneBackgroundController.update();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/Env.js
var CallbackOptions4 = {
  cook: false,
  callback: (node) => {
    SceneEnvController.update(node);
  }
};
function SceneEnvParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useEnvironment = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions4,
        separatorBefore: true
      });
      this.environment = ParamConfig.NODE_PATH("", {
        visibleIf: { useEnvironment: 1 },
        nodeSelection: {
          context: NodeContext.COP
        },
        // dependentOnFoundNode: false,
        ...CallbackOptions4
      });
    }
  };
}
var CALLBACK_NAME2 = "SceneEnvController";
var SceneEnvController = class {
  constructor(node) {
    this.node = node;
    this._updateBound = this.update.bind(this);
  }
  addHooks() {
    const p = this.node.p;
    const params = [p.useEnvironment, p.environment];
    for (const param of params) {
      param.addPostDirtyHook(CALLBACK_NAME2, this._updateBound);
    }
  }
  async update() {
    const scene = this.node.object;
    const pv = this.node.pv;
    if (isBooleanTrue(pv.useEnvironment)) {
      const node = pv.environment.nodeWithContext(NodeContext.COP);
      if (node) {
        node.compute().then((container) => {
          scene.environment = container.texture();
        });
      } else {
        scene.environment = null;
        this.node.states.error.set("environment node not found");
      }
    } else {
      scene.environment = null;
    }
  }
  static async update(node) {
    node.sceneEnvController.update();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/Fog.js
var CallbackOptions5 = {
  computeOnDirty: false,
  callback: (node) => {
    SceneFogController.update(node);
  }
};
var FogType = ((FogType2) => {
  FogType2["LINEAR"] = "linear";
  FogType2["EXPONENTIAL"] = "exponential";
  return FogType2;
})(FogType || {});
var FOG_TYPES = [
  "linear",
  "exponential"
  /* EXPONENTIAL */
];
function SceneFogParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useFog = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions5,
        separatorBefore: true
      });
      this.fogType = ParamConfig.INTEGER(FOG_TYPES.indexOf(
        "exponential"
        /* EXPONENTIAL */
      ), {
        visibleIf: { useFog: 1 },
        menu: {
          entries: FOG_TYPES.map((mode, i) => {
            return { name: mode, value: i };
          })
        },
        ...CallbackOptions5
      });
      this.fogColor = ParamConfig.COLOR([1, 1, 1], {
        visibleIf: { useFog: 1 },
        ...CallbackOptions5
      });
      this.fogNear = ParamConfig.FLOAT(1, {
        range: [0, 100],
        rangeLocked: [true, false],
        visibleIf: { useFog: 1, fogType: FOG_TYPES.indexOf(
          "linear"
          /* LINEAR */
        ) },
        ...CallbackOptions5
      });
      this.fogFar = ParamConfig.FLOAT(100, {
        range: [0, 100],
        rangeLocked: [true, false],
        visibleIf: { useFog: 1, fogType: FOG_TYPES.indexOf(
          "linear"
          /* LINEAR */
        ) },
        ...CallbackOptions5
      });
      this.fogDensity = ParamConfig.FLOAT(25e-5, {
        visibleIf: { useFog: 1, fogType: FOG_TYPES.indexOf(
          "exponential"
          /* EXPONENTIAL */
        ) },
        ...CallbackOptions5
      });
    }
  };
}
var SceneFogParamsConfig = class extends SceneFogParamConfig(NodeParamsConfig) {
};
var SceneFogController = class {
  constructor(node) {
    this.node = node;
  }
  async update() {
    const scene = this.node.object;
    const pv = this.node.pv;
    if (isBooleanTrue(pv.useFog)) {
      if (pv.fogType == FOG_TYPES.indexOf(
        "linear"
        /* LINEAR */
      )) {
        const fog = this.fog2(pv);
        scene.fog = fog;
        fog.color = pv.fogColor;
        fog.near = pv.fogNear;
        fog.far = pv.fogFar;
      } else {
        const fogExp2 = this.fogExp2(pv);
        scene.fog = this.fogExp2(pv);
        fogExp2.color = pv.fogColor;
        fogExp2.density = pv.fogDensity;
      }
    } else {
      const current_fog = scene.fog;
      if (current_fog) {
        scene.fog = null;
      }
    }
  }
  fog2(pv) {
    return this._fog = this._fog || new Fog(16777215, pv.fogNear, pv.fogFar);
  }
  fogExp2(pv) {
    return this._fogExp2 = this._fogExp2 || new FogExp2(16777215, pv.fogDensity);
  }
  static async update(node) {
    node.sceneFogController.update();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/LoadProgress.js
var NodeGroup = class {
  constructor(nodes) {
    this.nodes = nodes;
    this._remaining = /* @__PURE__ */ new Set();
    if (CoreFeaturesController.debugLoadProgress()) {
      console.log(nodes);
    }
    this.totalCount = nodes.length;
    this._processed = /* @__PURE__ */ new Set();
    arrayToSet(nodes, this._remaining);
  }
  markNodeAsProcessed(node) {
    this._processed.add(node);
    this._remaining.delete(node);
    if (CoreFeaturesController.debugLoadProgress()) {
      console.log("markNodeAsProcessed", node.path(), {
        processed: setToArray(this._processed, []).map((n) => n.path()),
        remaining: setToArray(this._remaining, []).map((n) => n.path())
      });
    }
  }
  isNodeProcessed(node) {
    return this._processed.has(node);
  }
  processedCount() {
    return this._processed.size;
  }
};
function RootLoadProgressParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.nodesMask = ParamConfig.STRING("*/image* */envMap*", {
        cook: false,
        separatorBefore: true,
        objectMask: false
        // do not use objectMask, since it is a node mask, not object
      });
      this.printNodes = ParamConfig.BUTTON(null, {
        cook: false,
        callback: (node) => {
          RootLoadProgressController.PARAM_CALLBACK_printResolve(node);
        }
        // objectMask: false // do not use objectMask, since it is a node mask, not object
      });
    }
  };
}
var RootLoadProgressController = class _RootLoadProgressController {
  constructor(node) {
    this.node = node;
  }
  static async PARAM_CALLBACK_printResolve(node) {
    const nodes = await node.loadProgress.resolvedNodes();
    console.log(nodes);
    const nodePaths = nodes.map((node2) => node2.path()).sort();
    console.log(nodePaths);
  }
  async resolvedNodes() {
    const param = this.node.p.nodesMask;
    if (param.isDirty()) {
      await param.compute();
    }
    const mask = param.value;
    const scene = this.node.scene();
    const nodes = scene.nodesController.nodesFromMask(mask || "");
    const nodeDisplayNodes = await this._loadDisplayNodes();
    const uniqNodes = [];
    arrayUniq(nodes.concat(nodeDisplayNodes), uniqNodes);
    return uniqNodes;
  }
  async _loadDisplayNodes() {
    const scene = this.node.scene();
    const cameraNodeTypes = Poly.camerasRegister.registeredNodeTypes();
    const cameraNodes = cameraNodeTypes.map((type) => scene.nodesByType(type)).flat();
    const displayNodes = this._displayNodes();
    const nodes = cameraNodes.concat(displayNodes);
    const cameraCreatorNode = await this.cameraCreatorNode();
    if (cameraCreatorNode) {
      nodes.push(cameraCreatorNode);
    }
    const uniqNodes = [];
    arrayUniq(nodes, uniqNodes);
    return uniqNodes;
  }
  _displayNodes() {
    const objNodesWithDisplayNodeController = this._objectNodesWithDisplayNodeController();
    const displayNodes = [];
    arrayCompact(
      objNodesWithDisplayNodeController.map((node) => node.displayNodeController.firstNonBypassedDisplayNode()),
      displayNodes
    );
    return displayNodes;
  }
  _objectNodesWithDisplayNodeController() {
    const scene = this.node.scene();
    const objNodesWithDisplayNodeController = scene.root().children().filter((node) => node.displayNodeController != null).filter((node) => {
      var _a, _b;
      return (_b = (_a = node.flags) == null ? void 0 : _a.display) == null ? void 0 : _b.active();
    });
    return objNodesWithDisplayNodeController;
  }
  // private _getNodesWithSopGroup() {
  // 	return this._displayNodes().filter((node) => (node as GeoObjNode).childrenDisplayController != null);
  // }
  cameraCreatorNode() {
    return this.node.mainCameraController.cameraCreatorNode();
  }
  _runCallback(progress, nodeTrigger) {
    this._debug2("_runCallback", { progress, nodeTrigger });
    if (!(this._onProgressUpdateCallback && this._nodeGroups)) {
      return;
    }
    this._debug2("_onProgressUpdateCallback", this._nodeGroups);
    this._onProgressUpdateCallback(progress, {
      scene: this.node.scene(),
      triggerNode: void 0,
      groups: this._nodeGroups
    });
  }
  _updateProgressAndRunCallback(nodeTrigger) {
    if (!(this._onProgressUpdateCallback && this._nodeGroups)) {
      return;
    }
    const totalNodesCount = this._nodeGroups.toCook.totalCount + this._nodeGroups.sopGroupToUpdate.totalCount;
    const processedNodesCount = this._nodeGroups.toCook.processedCount() + this._nodeGroups.sopGroupToUpdate.processedCount();
    const progress = processedNodesCount / totalNodesCount;
    this._runCallback(progress, nodeTrigger);
  }
  async watchNodesProgress(callback) {
    this._onProgressUpdateCallback = callback;
    const resolvedNodes = await this.resolvedNodes();
    const nodesToCook = resolvedNodes.filter((node) => node.isDirty());
    this._debug({ nodesToCook });
    const nodesToUpdateSopGroup = this._objectNodesWithDisplayNodeController().filter((node) => {
      var _a;
      const displayNode = node.displayNodeController.displayNode();
      return displayNode != null && !((_a = displayNode.flags.bypass) == null ? void 0 : _a.active());
    }).filter((node) => node.isDirty());
    this._debug({ nodesToUpdateSopGroup });
    this._nodeGroups = {
      toCook: new NodeGroup(nodesToCook),
      sopGroupToUpdate: new NodeGroup(nodesToUpdateSopGroup)
    };
    const totalNodesCount = this._nodeGroups.toCook.totalCount + this._nodeGroups.sopGroupToUpdate.totalCount;
    this._debug({ totalNodesCount });
    if (totalNodesCount == 0) {
      this._runCallback(1);
      return;
    }
    this._watchNodesWithSopGroup();
    this._watchNodesToCook();
  }
  async _watchNodesToCook() {
    var _a;
    const nodesGroup = (_a = this._nodeGroups) == null ? void 0 : _a.toCook;
    if (!nodesGroup) {
      return;
    }
    const callbackName = "RootLoadProgressController";
    const onNodeCooked = (node) => {
      if (!nodesGroup.isNodeProcessed(node)) {
        nodesGroup.markNodeAsProcessed(node);
        this._updateProgressAndRunCallback(node);
        node.cookController.deregisterOnCookEnd(callbackName);
      }
    };
    for (const node of nodesGroup.nodes) {
      node.cookController.registerOnCookEnd(callbackName, () => {
        this._debug2("nodeToCook - completed", node.path());
        onNodeCooked(node);
      });
      this._debug2("nodeToCook - start", node.path());
      node.compute();
    }
  }
  _watchNodesWithSopGroup() {
    var _a;
    const nodesGroup = (_a = this._nodeGroups) == null ? void 0 : _a.sopGroupToUpdate;
    if (!nodesGroup) {
      return;
    }
    const callbackName = "RootLoadProgressController";
    const onNodeCooked = (node) => {
      if (!nodesGroup.isNodeProcessed(node)) {
        nodesGroup.markNodeAsProcessed(node);
        this._updateProgressAndRunCallback(node);
        const childrenDisplayController = node.childrenDisplayController;
        childrenDisplayController.deregisterOnSopGroupUpdated(callbackName);
      }
    };
    for (const node of nodesGroup.nodes) {
      const childrenDisplayController = node.childrenDisplayController;
      this._debug2("nodeWithSopGroup - watch", node.path());
      childrenDisplayController.registerOnSopGroupUpdated(callbackName, () => {
        this._debug2("nodeWithSopGroup - completed", node.path());
        onNodeCooked(node);
      });
    }
  }
  static debugActive() {
    return CoreFeaturesController.debugLoadProgress();
  }
  static debug(arg0) {
    if (!this.debugActive()) {
      return;
    }
    console.log(arg0);
  }
  static debug2(arg0, arg1) {
    if (!this.debugActive()) {
      return;
    }
    console.log(arg0, arg1);
  }
  _debug(arg0) {
    _RootLoadProgressController.debug(arg0);
  }
  _debug2(arg0, arg1) {
    _RootLoadProgressController.debug2(arg0, arg1);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/MaterialOverride.js
var CallbackOptions6 = {
  computeOnDirty: false,
  callback: (node) => {
    SceneMaterialOverrideController.update(node);
  }
};
function SceneMaterialOverrideParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useOverrideMaterial = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions6,
        separatorBefore: true
      });
      this.overrideMaterial = ParamConfig.NODE_PATH("", {
        visibleIf: { useOverrideMaterial: 1 },
        nodeSelection: {
          context: NodeContext.MAT
        },
        dependentOnFoundNode: false,
        ...CallbackOptions6
      });
    }
  };
}
var SceneMaterialOverrideController = class {
  constructor(node) {
    this.node = node;
  }
  async update() {
    const scene = this.node.object;
    const pv = this.node.pv;
    if (isBooleanTrue(pv.useOverrideMaterial)) {
      const node = pv.overrideMaterial.nodeWithContext(NodeContext.MAT);
      if (node) {
        const container = await node.compute();
        scene.overrideMaterial = container.material();
      } else {
        scene.overrideMaterial = null;
        this.node.states.error.set("overrideMaterial node not found");
      }
    } else {
      scene.overrideMaterial = null;
    }
  }
  static async update(node) {
    node.sceneMaterialOverrideController.update();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/utils/Scene/RootMainCamera.js
var __defaultDummyPerspectiveCamera;
function _defaultDummyPerspectiveCamera() {
  return __defaultDummyPerspectiveCamera = __defaultDummyPerspectiveCamera || new PerspectiveCamera();
}
function RootMainCameraParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.mainCameraPath = ParamConfig.STRING("", {
        cook: false,
        separatorBefore: true,
        objectMask: true
      });
    }
  };
}
var RootMainCameraController = class {
  constructor(node) {
    this.node = node;
  }
  setCamera(object) {
    const path = CorePath.objectPath(object);
    this.setCameraPath(path);
  }
  setCameraPath(path) {
    this.mainCameraPathParam().set(path);
  }
  mainCameraPathParam() {
    return this.node.p.mainCameraPath;
  }
  rawCameraPath() {
    return this.mainCameraPathParam().rawInput();
  }
  async cameraPath() {
    const param = this.mainCameraPathParam();
    if (param.isDirty()) {
      await param.compute();
    }
    return param.value;
  }
  _cameraPathSync() {
    const param = this.mainCameraPathParam();
    return param.value;
  }
  cameraSync() {
    const path = this._cameraPathSync();
    const object = this.node.scene().objectsController.findObjectByMask(path);
    return object;
  }
  dummyPerspectiveCamera() {
    return _defaultDummyPerspectiveCamera();
  }
  cameraSyncOrDummy() {
    return this.cameraSync();
  }
  async camera() {
    const path = await this.cameraPath();
    const object = this.node.scene().objectsController.findObjectByMask(path);
    return object;
  }
  async cameraCreatorNode() {
    const path = await this.cameraPath();
    const elements = path.split(CoreWalker.SEPARATOR);
    const nodeName = elements[1];
    const objNode = this.node.node(nodeName);
    if (objNode && elements.length != 2) {
      const displayNodeController = objNode.displayNodeController;
      if (displayNodeController) {
        return objNode.displayNodeController.displayNode() || objNode;
      }
    }
    return objNode;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/manager/Root.js
var ROOT_NODE_NAME = "RootNode";
var ObjectsManagerParamsConfig = class extends RootLoadProgressParamConfig(
  RootAudioParamConfig(
    SceneMaterialOverrideParamConfig(
      SceneEnvParamConfig(
        SceneFogParamConfig(
          RootMainCameraParamConfig(SceneBackgroundParamConfig(SceneAutoUpdateParamConfig(NodeParamsConfig)))
        )
      )
    )
  )
) {
};
var ParamsConfig = new ObjectsManagerParamsConfig();
var RootManagerNode = class extends TypedBaseManagerNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._object = this._createScene();
    this._queuedNodesById = /* @__PURE__ */ new Map();
    this.audioController = new RootAudioController(this);
    this.sceneAutoUpdateController = new SceneAutoUpdateController(this);
    this.sceneBackgroundController = new SceneBackgroundController(this);
    this.sceneEnvController = new SceneEnvController(this);
    this.sceneFogController = new SceneFogController(this);
    this.loadProgress = new RootLoadProgressController(this);
    this.sceneMaterialOverrideController = new SceneMaterialOverrideController(
      this
    );
    this.mainCameraController = new RootMainCameraController(this);
    this._childrenControllerContext = NodeContext.OBJ;
  }
  static type() {
    return "root";
  }
  cook() {
    this.cookController.endCook();
  }
  initializeNode() {
    this.params.onParamsCreated("init controllers", () => {
      this.sceneEnvController.addHooks();
      this.sceneBackgroundController.addHooks();
    });
    this.lifecycle.onChildAdd(this._onChildAdd.bind(this));
    this.lifecycle.onChildRemove(this._onChildRemove.bind(this));
  }
  _createScene() {
    const scene = new Scene();
    scene.name = ROOT_NAME;
    scene.matrixAutoUpdate = true;
    return scene;
  }
  get object() {
    return this._object;
  }
  createNode(nodeClass, options) {
    return super.createNode(nodeClass, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  // multiple_display_flags_allowed() {
  // 	return true;
  // }
  _updateScene() {
    this.sceneAutoUpdateController.update();
    this.sceneBackgroundController.update();
    this.sceneEnvController.update();
    this.sceneFogController.update();
    this.sceneMaterialOverrideController.update();
  }
  _addToQueue(node) {
    const id = node.graphNodeId();
    if (!this._queuedNodesById.has(id)) {
      this._queuedNodesById.set(id, node);
    }
    return node;
  }
  processQueue() {
    this._updateScene();
    const queuedNodesByPath = /* @__PURE__ */ new Map();
    const paths = [];
    this._queuedNodesById.forEach((node, id) => {
      const fullPath = `_____${node.renderOrder}__${node.path()}`;
      paths.push(fullPath);
      queuedNodesByPath.set(fullPath, node);
    });
    this._queuedNodesById.clear();
    for (const path_id of paths) {
      const node = queuedNodesByPath.get(path_id);
      if (node) {
        queuedNodesByPath.delete(path_id);
        this._addToScene(node);
      }
    }
  }
  _updateObject(node) {
    if (!this.scene().loadingController.autoUpdating()) {
      return this._addToQueue(node);
    } else {
      if (node.isDisplayed() && !node.cookController.isCooking()) {
        node.compute();
      }
      return this._addToScene(node);
    }
  }
  //
  //
  // OBJ PARENTING
  //
  //
  getParentForNode(node) {
    if (node.attachableToHierarchy()) {
      const node_input = node.io.inputs.input(0);
      if (node_input) {
        return node_input.childrenGroup();
      } else {
        return this._object;
      }
    } else {
      return null;
    }
  }
  _addToScene(node) {
    if (node.attachableToHierarchy()) {
      const parentObject = this.getParentForNode(node);
      if (parentObject) {
        if (node.usedInScene()) {
          if (node.childrenDisplayController) {
            node.childrenDisplayController.requestDisplayNodeContainer();
          } else {
            node.compute();
          }
          node.addObjectToParent(parentObject);
        } else {
          node.removeObjectFromParent();
        }
      } else {
      }
    }
  }
  _removeFromScene(node) {
    node.removeObjectFromParent();
  }
  areChildrenCooking() {
    const children = this.children();
    for (const child of children) {
      if (child.cookController.isCooking() || child.isDisplayNodeCooking()) {
        return true;
      }
    }
    return false;
  }
  // private async expected_loading_geo_nodes_by_id() {
  // 	const geo_nodes = this.nodesByType('geo');
  // 	const node_by_id: PolyDictionary<GeoObjNode> = {};
  // 	for (let geo_node of geo_nodes) {
  // 		const isDisplayed = await geo_node.isDisplayed();
  // 		if (isDisplayed) {
  // 			node_by_id[geo_node.graphNodeId()] = geo_node;
  // 		}
  // 	}
  // 	return node_by_id;
  // }
  addToParentTransform(node) {
    this._updateObject(node);
  }
  removeFromParentTransform(node) {
    this._updateObject(node);
  }
  _onChildAdd(node) {
    if (node) {
      this._updateObject(node);
    }
  }
  _onChildRemove(node) {
    if (node) {
      this._removeFromScene(node);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/NodesController.js
var NodesController = class {
  constructor(scene) {
    this.scene = scene;
    this._nodeContextSignatures = {};
    this._instanciatedNodesByContextAndType = /* @__PURE__ */ new Map();
  }
  createRoot(options) {
    this._root = new RootManagerNode(this.scene, ROOT_NODE_NAME, options);
    this._root.initializeBaseAndNode();
    this._root.params.init();
  }
  root() {
    return this._root;
  }
  _traverseNode(parent, callback) {
    const nodes = parent.children();
    if (!nodes || nodes.length == 0) {
      return;
    }
    for (const node of nodes) {
      if (node.childrenController) {
        this._traverseNode(node, callback);
      }
      callback(node);
    }
  }
  traverseNodes(callback) {
    this._traverseNode(this._root, callback);
  }
  // objectsFromMask(mask: string): Object3D[] {
  // 	const masks = mask.split(' ');
  // 	const child_nodes = this.root.children() as BaseObjNodeType[];
  // 	const objects: Object3D[] = [];
  // 	for (let child_node of child_nodes) {
  // 		if (CoreString.matchesOneMask(child_node.name, masks)) {
  // 			if (child_node.object) {
  // 				objects.push(child_node.object);
  // 			}
  // 		}
  // 	}
  // 	return objects;
  // }
  clear() {
    var _a;
    const children = this.root().children();
    for (const child of children) {
      (_a = this.root().childrenController) == null ? void 0 : _a.removeNode(child);
    }
  }
  node(path) {
    if (path === "/") {
      return this.root();
    } else {
      return this.root().node(path);
    }
  }
  allNodes() {
    let nodes = [this.root()];
    let current_parents = [this.root()];
    let cmptr = 0;
    while (current_parents.length > 0 && cmptr < 10) {
      const children = current_parents.map((current_parent) => {
        if (current_parent.childrenAllowed()) {
          return current_parent.children();
        } else {
          return [];
        }
      }).flat();
      nodes = nodes.concat(children);
      current_parents = children;
      cmptr += 1;
    }
    return nodes.flat();
  }
  nodesFromMask(mask) {
    const nodes = this.allNodes();
    const matching_nodes = [];
    for (const node of nodes) {
      const path = node.path();
      if (stringMatchMask(path, mask)) {
        matching_nodes.push(node);
      }
    }
    return matching_nodes;
  }
  resetNodeContextSignatures() {
    this._nodeContextSignatures = {};
  }
  registerNodeContextSignature(node) {
    if (node.childrenAllowed() && node.childrenController) {
      this._nodeContextSignatures[node.childrenController.nodeContextSignature()] = true;
    }
  }
  nodeContextSignatures() {
    return Object.keys(this._nodeContextSignatures).sort().map((s) => s.toLowerCase());
  }
  addToInstanciatedNode(node) {
    const context = node.context();
    const nodeType = node.type();
    let mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (!mapForContext) {
      mapForContext = /* @__PURE__ */ new Map();
      this._instanciatedNodesByContextAndType.set(context, mapForContext);
    }
    let mapForType = mapForContext.get(nodeType);
    if (!mapForType) {
      mapForType = /* @__PURE__ */ new Map();
      mapForContext.set(nodeType, mapForType);
    }
    mapForType.set(node.graphNodeId(), node);
  }
  removeFromInstanciatedNode(node) {
    const context = node.context();
    const nodeType = node.type();
    const mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (!mapForContext) {
      return;
    }
    const mapForType = mapForContext.get(nodeType);
    if (!mapForType) {
      return;
    }
    mapForType.delete(node.graphNodeId());
  }
  nodesByType(type) {
    const list = [];
    this._traverseNode(this.scene.root(), (node) => {
      if (node.type() == type) {
        list.push(node);
      }
    });
    return list;
  }
  nodesByContextAndType(context, nodeType) {
    const nodes = [];
    const mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (mapForContext) {
      const mapForType = mapForContext.get(nodeType);
      if (mapForType) {
        mapForType.forEach((node) => {
          nodes.push(node);
        });
      }
    }
    return nodes;
  }
  hasNodesByContextAndType(context, nodeType) {
    const mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (!mapForContext) {
      return false;
    }
    const mapForType = mapForContext.get(nodeType);
    if (!mapForType) {
      return false;
    }
    return mapForType.size != 0;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/event/PointerEventType.js
var PointerEventType = ((PointerEventType2) => {
  PointerEventType2["contextmenu"] = "contextmenu";
  PointerEventType2["pointerdown"] = "pointerdown";
  PointerEventType2["pointermove"] = "pointermove";
  PointerEventType2["pointerup"] = "pointerup";
  PointerEventType2["touchstart"] = "touchstart";
  PointerEventType2["touchmove"] = "touchmove";
  PointerEventType2["touchend"] = "touchend";
  return PointerEventType2;
})(PointerEventType || {});
var ACCEPTED_POINTER_EVENT_TYPES = [
  // PointerEventType.click,
  "contextmenu",
  "pointerdown",
  "pointermove",
  "pointerup"
  /* pointerup */
];

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/_BaseEventsController.js
var BaseSceneEventsController = class {
  constructor(dispatcher) {
    this.dispatcher = dispatcher;
    this._activeEventDatas = [];
    this._activeEventDataTypes = /* @__PURE__ */ new Set();
    this._eventNodes = /* @__PURE__ */ new Set();
    this._requireCanvasEventListeners = false;
    this._actorEvaluators = /* @__PURE__ */ new Set();
    this._actorEvaluatorsByEventNames = /* @__PURE__ */ new Map();
  }
  registerEventNode(node) {
    this._eventNodes.add(node);
    this.updateViewerEventListeners();
  }
  unregisterEventNode(node) {
    this._eventNodes.delete(node);
    this.updateViewerEventListeners();
  }
  registerEvaluatorGenerator(evaluator) {
    this._actorEvaluators.add(evaluator);
    this._updateActorEvaluatorCache();
    this.updateViewerEventListeners();
  }
  unregisterEvaluatorGenerator(evaluator) {
    this._actorEvaluators.delete(evaluator);
    this._updateActorEvaluatorCache();
    this.updateViewerEventListeners();
  }
  _updateActorEvaluatorCache() {
    this._actorEvaluatorsByEventNames.clear();
    this._actorEvaluators.forEach((evaluator) => {
      const eventDatas = evaluator.eventDatas;
      if (eventDatas) {
        eventDatas.forEach((eventData) => {
          const eventName = eventData.type;
          const emitter = eventData.emitter;
          let mapForEventName = this._actorEvaluatorsByEventNames.get(eventName);
          if (!mapForEventName) {
            mapForEventName = /* @__PURE__ */ new Map();
            this._actorEvaluatorsByEventNames.set(eventName, mapForEventName);
          }
          MapUtils.addToSetAtEntry(mapForEventName, emitter, evaluator);
        });
      }
    });
  }
  // abstract accepts_event(event: Event): boolean;
  processEvent(eventContext) {
    var _a;
    if (this._activeEventDatas.length == 0) {
      return;
    }
    const eventType = (_a = eventContext.event) == null ? void 0 : _a.type;
    if (eventType) {
      if (!this._activeEventDataTypes.has(eventType)) {
        return;
      }
    }
    this._eventNodes.forEach((node) => {
      node.processEvent(eventContext);
    });
  }
  updateViewerEventListeners() {
    this._updateActiveEventTypes();
    if (this._requireCanvasEventListeners) {
      this.dispatcher.scene.viewersRegister.traverseViewers((viewer) => {
        viewer.eventsController().updateEvents(this);
      });
    }
  }
  activeEventDatas() {
    return this._activeEventDatas;
  }
  _updateActiveEventTypes() {
    const _storeEventData = (eventData) => {
      this._activeEventDatas.push(eventData);
      this._activeEventDataTypes.add(eventData.type);
    };
    const _reset = () => {
      this._activeEventDatas.splice(0, this._activeEventDatas.length);
      this._activeEventDataTypes.clear();
    };
    const _actorEventDatas = () => {
      let eventTypeByEmitter = /* @__PURE__ */ new Map();
      this._actorEvaluatorsByEventNames.forEach((mapForEventName, eventName) => {
        mapForEventName.forEach((nodes, emitter) => {
          nodes.forEach((node) => {
            MapUtils.addToSetAtEntry(eventTypeByEmitter, emitter, eventName);
          });
        });
      });
      const eventDatas = [];
      eventTypeByEmitter.forEach((eventNames, emitter) => {
        for (const eventName of eventNames) {
          const eventData = {
            type: eventName,
            emitter
          };
          eventDatas.push(eventData);
        }
      });
      return eventDatas;
    };
    const _updateActorNodesEventData = () => {
      const actorEventDatas = _actorEventDatas();
      if (actorEventDatas) {
        for (const data of actorEventDatas) {
          _storeEventData(data);
        }
      }
    };
    const _updateEventNodesEventData = () => {
      const activeNodeEventTypesState = /* @__PURE__ */ new Set();
      this._eventNodes.forEach((node) => {
        if (node.parent()) {
          const nodeActiveEventDatas = node.activeEventDatas();
          for (const data of nodeActiveEventDatas) {
            activeNodeEventTypesState.add(data);
          }
        }
      });
      activeNodeEventTypesState.forEach((state, data) => {
        _storeEventData(data);
      });
    };
    _reset();
    _storeEventData({
      type: PointerEventType.pointermove,
      emitter: CoreEventEmitter.DOCUMENT
    });
    _storeEventData({
      type: PointerEventType.touchmove,
      emitter: CoreEventEmitter.DOCUMENT
    });
    _updateActorNodesEventData();
    _updateEventNodesEventData();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/event/DragEventType.js
var DragEventType = ((DragEventType2) => {
  DragEventType2["dragover"] = "dragover";
  return DragEventType2;
})(DragEventType || {});
var ACCEPTED_DRAG_EVENT_TYPES = [
  "dragover"
  /* dragover */
];

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/DragEventsController.js
var DragEventsController = class extends BaseSceneEventsController {
  constructor() {
    super(...arguments);
    this._requireCanvasEventListeners = true;
  }
  type() {
    return "drag";
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([...ACCEPTED_DRAG_EVENT_TYPES]);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/KeyboardEventsController.js
var methodNameByEventType = {
  [KeyboardEventType.keydown]: [JsType.ON_KEY, JsType.ON_KEYDOWN],
  [KeyboardEventType.keypress]: [JsType.ON_KEYPRESS],
  [KeyboardEventType.keyup]: [JsType.ON_KEY, JsType.ON_KEYUP]
};
var KeyboardEventsController = class extends BaseSceneEventsController {
  constructor(dispatcher) {
    super(dispatcher);
    this._requireCanvasEventListeners = true;
    this._currentEvents = [];
    this._lastProcessedFrame = -1;
    this.timeController = this.dispatcher.scene.timeController;
    this.keyboardEventsController = this.dispatcher.scene.actorsManager.keyboardEventsController;
  }
  type() {
    return "keyboard";
  }
  acceptedEventTypes() {
    return new Set(ACCEPTED_KEYBOARD_EVENT_TYPES.map((n) => `${n}`));
  }
  currentEvents() {
    return this._currentEvents;
  }
  processEvent(eventContext) {
    super.processEvent(eventContext);
    const { event } = eventContext;
    if (!event) {
      return;
    }
    const eventType = event.type;
    const mapForEvent = this._actorEvaluatorsByEventNames.get(eventType);
    if (!mapForEvent) {
      return;
    }
    if (this.timeController.playing()) {
      const frame = this.timeController.frame();
      if (frame != this._lastProcessedFrame) {
        this._lastProcessedFrame = frame;
        this._currentEvents.length = 0;
      }
      this._currentEvents.push(event);
    } else {
      this._currentEvents[0] = event;
    }
    const eventEmitter = eventContext.emitter;
    if (!eventEmitter) {
      return;
    }
    const evaluatorGenerators = mapForEvent.get(eventEmitter);
    if (!evaluatorGenerators) {
      return;
    }
    const methodNames = methodNameByEventType[eventType];
    if (!methodNames) {
      return;
    }
    for (const methodName of methodNames) {
      this.keyboardEventsController.addTriggeredEvaluators(evaluatorGenerators, methodName);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/event/MouseEventType.js
var MouseEventType = ((MouseEventType2) => {
  MouseEventType2["auxclick"] = "auxclick";
  MouseEventType2["click"] = "click";
  MouseEventType2["contextmenu"] = "contextmenu";
  MouseEventType2["dblclick"] = "dblclick";
  MouseEventType2["mousedown"] = "mousedown";
  MouseEventType2["mouseenter"] = "mouseenter";
  MouseEventType2["mouseleave"] = "mouseleave";
  MouseEventType2["mousemove"] = "mousemove";
  MouseEventType2["mouseover"] = "mouseover";
  MouseEventType2["mouseout"] = "mouseout";
  MouseEventType2["mouseup"] = "mouseup";
  MouseEventType2["pointerlockchange"] = "pointerlockchange";
  MouseEventType2["pointerlockerror"] = "pointerlockerror";
  MouseEventType2["select"] = "select";
  MouseEventType2["wheel"] = "wheel";
  return MouseEventType2;
})(MouseEventType || {});
var ACCEPTED_MOUSE_EVENT_TYPES = [
  "auxclick",
  "click",
  "contextmenu",
  "dblclick",
  "mousedown",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "mouseover",
  "mouseout",
  "mouseup",
  "pointerlockchange",
  "pointerlockerror",
  "select",
  "wheel"
  /* wheel */
];

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/MouseEventsController.js
var MouseEventsController = class extends BaseSceneEventsController {
  constructor() {
    super(...arguments);
    this._requireCanvasEventListeners = true;
  }
  type() {
    return "mouse";
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([...ACCEPTED_MOUSE_EVENT_TYPES]);
  }
  // accepts_event(event: MouseEvent) {
  // 	return ACCEPTED_MOUSE_EVENT_TYPES.includes(event.type as MouseEventType);
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/event/TouchEventType.js
var TouchEventType = ((TouchEventType2) => {
  TouchEventType2["touchstart"] = "touchstart";
  TouchEventType2["touchmove"] = "touchmove";
  TouchEventType2["touchend"] = "touchend";
  return TouchEventType2;
})(TouchEventType || {});
var ACCEPTED_TOUCH_EVENT_TYPES = [
  "touchstart",
  "touchmove",
  "touchend"
  /* touchend */
];

// node_modules/@polygonjs/polygonjs/dist/src/core/Vector.js
var CoreVector = class {
  static isVector2Valid(vector) {
    return !isNaN(vector.x) && !isNaN(vector.y) && isFinite(vector.x) && isFinite(vector.y);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/event/utils/CursorHelper.js
var MouseHelperClass = class _MouseHelperClass {
  constructor() {
    this._rectByCanvas = /* @__PURE__ */ new Map();
    this._resetCacheBound = this._resetCache.bind(this);
    window.addEventListener("resize", this._resetCacheBound);
    document.addEventListener("scroll", this._resetCacheBound);
  }
  static instance() {
    return this._instance = this._instance || new _MouseHelperClass();
  }
  setEventOffset(cursorPage, canvas, offset) {
    let rect = this._rectByCanvas.get(canvas);
    if (!rect) {
      rect = canvas.getBoundingClientRect();
      this._rectByCanvas.set(canvas, rect);
    }
    offset.offsetX = cursorPage.clientX - rect.left;
    offset.offsetY = cursorPage.clientY - rect.top;
  }
  _resetCache() {
    this._rectByCanvas.clear();
  }
};
var MouseHelper = MouseHelperClass.instance();
var _offset = { offsetX: 0, offsetY: 0 };
var CursorHelper = class {
  // protected _cursor: Vector2 = new Vector2();
  setCursorForCPU(context, target) {
    this.setCursor(context, target);
    target.x = target.x * 2 - 1;
    target.y = -target.y * 2 + 1;
  }
  setCursorForGPU(context, target) {
    this.setCursor(context, target);
    target.y = 1 - target.y;
  }
  setCursor(context, target) {
    var _a;
    const canvas = (_a = context.viewer) == null ? void 0 : _a.canvas();
    if (!canvas) {
      return;
    }
    const event = context.event;
    if (event instanceof PointerEvent || event instanceof MouseEvent || event instanceof DragEvent) {
      MouseHelper.setEventOffset(event, canvas, _offset);
    }
    if (window.TouchEvent && event instanceof TouchEvent) {
      const touch = event.touches[0];
      if (touch) {
        MouseHelper.setEventOffset(touch, canvas, _offset);
      }
    }
    this._updateFromCursor(canvas, target);
  }
  _updateFromCursor(canvas, target) {
    if (canvas.offsetWidth <= 0 || canvas.offsetHeight <= 0) {
      console.warn("zero size canvas", canvas);
      target.set(0, 0);
    } else {
      target.x = _offset.offsetX / canvas.offsetWidth;
      target.y = _offset.offsetY / canvas.offsetHeight;
    }
    if (!CoreVector.isVector2Valid(target)) {
      console.warn("invalid number detected");
      console.warn(target.toArray(), _offset.offsetX, _offset.offsetY, canvas.offsetWidth, canvas.offsetHeight);
      return;
    }
  }
  // protected _remapCursor() {}
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/PointerEventsController.js
var PointerEventsController = class extends BaseSceneEventsController {
  constructor(dispatcher) {
    super(dispatcher);
    this._requireCanvasEventListeners = true;
    this._cursorHelper = new CursorHelper();
    this._cursor0 = ref(new Vector2(-1e3, -1e3));
    this._raycaster0 = ref(createRaycaster());
  }
  type() {
    return "pointer";
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([...ACCEPTED_POINTER_EVENT_TYPES]);
  }
  setRaycaster(raycaster) {
    this._raycaster0.value = raycaster;
  }
  processEvent(eventContext) {
    this._cursorHelper.setCursorForCPU(eventContext, this._cursor0.value);
    super.processEvent(eventContext);
    const { viewer, event } = eventContext;
    if (!(event && viewer)) {
      console.log("either event or viewer missing");
      return;
    }
    viewer.raycastersController.setCursor0(this._cursor0.value);
    viewer.raycastersController.updateRaycasters();
    const eventType = event.type;
    if (eventType == PointerEventType.pointermove) {
      return;
    }
    const mapForEvent = this._actorEvaluatorsByEventNames.get(eventType);
    if (!mapForEvent) {
      return;
    }
    const eventEmitter = eventContext.emitter;
    if (!eventEmitter) {
      return;
    }
    const evaluatorGenerators = mapForEvent.get(eventEmitter);
    if (!evaluatorGenerators) {
      return;
    }
    if (eventContext.event) {
      const actorsManager = this.dispatcher.scene.actorsManager;
      switch (eventType) {
        case MouseEventType.mousedown: {
          actorsManager.rayObjectIntersectionMouseClick.onMousedown(eventContext.event);
          return;
        }
        case PointerEventType.pointerdown: {
          actorsManager.rayObjectIntersectionClick.onPointerdown(eventContext.event);
          actorsManager.rayObjectIntersectionLongPress.onPointerdown(eventContext.event);
          actorsManager.rayObjectIntersectionPointerdown.onPointerdown(eventContext.event);
          actorsManager.pointerdown.onPointerdown(eventContext.event);
          actorsManager.rayObjectIntersectionSwipe.onPointerdown(eventContext.event);
          return;
        }
        case PointerEventType.pointerup: {
          if (!isTouchDevice()) {
            actorsManager.rayObjectIntersectionPointerup.onPointerup(eventContext.event);
            actorsManager.pointerup.onPointerup(eventContext.event);
            return;
          }
        }
        case PointerEventType.contextmenu: {
          actorsManager.rayObjectIntersectionContextmenu.onContextmenu(eventContext.event);
          return;
        }
        case TouchEventType.touchend: {
          if (isTouchDevice()) {
            actorsManager.rayObjectIntersectionPointerup.onPointerup(eventContext.event);
            actorsManager.pointerup.onPointerup(eventContext.event);
            return;
          }
        }
      }
    }
  }
  raycaster() {
    return this._raycaster0;
  }
  cursor() {
    return this._cursor0;
  }
  // camera() {
  // 	return this._camera;
  // }
  updateRaycast(options) {
    const pointsParam = this._raycaster0.value.params.Points;
    if (pointsParam) {
      pointsParam.threshold = options.pointsThreshold;
    }
    const lineParam = this._raycaster0.value.params.Line;
    if (lineParam) {
      lineParam.threshold = options.lineThreshold;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/WindowEventsController.js
var WindowEventType = ((WindowEventType2) => {
  WindowEventType2["resize"] = "resize";
  return WindowEventType2;
})(WindowEventType || {});
var ACCEPTED_WINDOW_EVENT_TYPES = [
  "resize"
  /* resize */
];
var WindowEventsController = class extends BaseSceneEventsController {
  constructor() {
    super(...arguments);
    this._requireCanvasEventListeners = true;
  }
  type() {
    return "window";
  }
  acceptedEventTypes() {
    return new Set(ACCEPTED_WINDOW_EVENT_TYPES.map((n) => `${n}`));
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/TouchEventsController.js
var TouchEventsController = class extends BaseSceneEventsController {
  constructor() {
    super(...arguments);
    this._requireCanvasEventListeners = true;
  }
  type() {
    return "touch";
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([...ACCEPTED_TOUCH_EVENT_TYPES]);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/ConnectionTriggerDispatcher.js
var SceneConnectionTriggerDispatcher = class {
  // private _dispatchedConnections: Set<TypedNodeConnection<any>> = new Set();
  constructor() {
  }
  dispatchTrigger(connection) {
    var _a;
    (_a = connection._eventDispatcher()) == null ? void 0 : _a.dispatchEvent(NODE_CONNECTION_TRIGGERED_EVENT);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/poly/registers/nodes/types/Event.js
var EventInputType = ((EventInputType2) => {
  EventInputType2["DRAG"] = "drag";
  EventInputType2["KEYBOARD"] = "keyboard";
  EventInputType2["MOUSE"] = "mouse";
  EventInputType2["POINTER"] = "pointer";
  EventInputType2["TOUCH"] = "touch";
  EventInputType2["WINDOW"] = "window";
  return EventInputType2;
})(EventInputType || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/events/EventsDispatcher.js
var SceneEventsDispatcher = class {
  constructor(scene) {
    this.scene = scene;
    this._controllers = [];
    this.sceneEventsController = new SceneEventsController();
    this.pointerEventsController = this._createController(PointerEventsController);
  }
  registerEvaluatorGenerator(evaluatorGenerator) {
    const controllers = this._findOrCreateControllerForEvaluator(evaluatorGenerator);
    if (controllers) {
      controllers.forEach((c) => c.registerEvaluatorGenerator(evaluatorGenerator));
    }
  }
  unregisterEvaluatorGenerator(evaluatorGenerator) {
    const controllers = this._findOrCreateControllerForEvaluator(evaluatorGenerator);
    if (controllers) {
      controllers.forEach((c) => c.unregisterEvaluatorGenerator(evaluatorGenerator));
    }
  }
  // updateControllersFromJsNodes() {
  // 	const eventDatas = this.scene.actorsManager.eventDatas();
  // 	eventDatas.forEach((type) => {
  // 		this._findOrCreateControllerForEventInputType(type);
  // 	});
  // }
  registerEventNode(node) {
    const controller = this._findOrCreateControllerForEventNode(node);
    if (controller) {
      controller.registerEventNode(node);
    }
  }
  unregisterEventNode(node) {
    const controller = this._findOrCreateControllerForEventNode(node);
    if (controller) {
      controller.unregisterEventNode(node);
    }
  }
  updateViewerEventListeners(node) {
    const controller = this._findOrCreateControllerForEventNode(node);
    if (controller) {
      controller.updateViewerEventListeners();
    }
  }
  traverseControllers(callback) {
    for (const controller of this._controllers) {
      callback(controller);
    }
  }
  setRaycaster(raycaster) {
    this.pointerEventsController.setRaycaster(raycaster);
  }
  // processEvent(event_content: EventContext<Event>) {
  // 	if (!event_content.event) {
  // 		return;
  // 	}
  // 	for (let controller of this._controllers) {
  // 		if (controller.accepts_event(event_content.event)) {
  // 			controller.processEvent(event_content);
  // 			return;
  // 		}
  // 	}
  // }
  _findOrCreateControllerForEventNode(node) {
    return this._findOrCreateControllerForEventInputType(node.type());
  }
  _findOrCreateControllerForEvaluator(evaluator) {
    const eventDatas = evaluator.eventDatas;
    if (!eventDatas) {
      return;
    }
    const controllers = /* @__PURE__ */ new Set();
    eventDatas.forEach((eventData) => {
      const controller = this._findOrCreateControllerForJsType(eventData.jsType);
      if (controller) {
        controllers.add(controller);
      }
    });
    return controllers;
  }
  _findOrCreateControllerForEventInputType(type) {
    switch (type) {
      case EventInputType.KEYBOARD:
        return this.keyboardEventsController;
      case EventInputType.MOUSE:
        return this.mouseEventsController;
      case EventInputType.DRAG:
        return this.dragEventsController;
      case EventInputType.POINTER:
        return this.pointerEventsController;
      case EventInputType.TOUCH:
        return this.touchEventsController;
      case EventInputType.WINDOW:
        return this.windowEventsController;
    }
  }
  _findOrCreateControllerForJsType(jsType) {
    switch (jsType) {
      case JsType.CURSOR:
      case JsType.ON_OBJECT_CLICK:
      case JsType.ON_OBJECT_CONTEXT_MENU:
      case JsType.ON_OBJECT_HOVER:
      case JsType.ON_OBJECT_LONG_PRESS:
      case JsType.ON_OBJECT_MOUSE_CLICK:
      case JsType.ON_OBJECT_POINTERDOWN:
      case JsType.ON_OBJECT_POINTERUP:
      case JsType.ON_POINTERDOWN:
      case JsType.ON_POINTERUP:
      case JsType.RAY_FROM_CURSOR:
        return this.pointerEventsController;
      case JsType.ON_KEY:
      case JsType.ON_KEYDOWN:
      case JsType.ON_KEYPRESS:
      case JsType.ON_KEYUP:
        return this.keyboardEventsController;
    }
    console.warn(`no event controller defined for jsType`, jsType);
  }
  get keyboardEventsController() {
    return this._keyboardEventsController = this._keyboardEventsController || this._createController(KeyboardEventsController);
  }
  get mouseEventsController() {
    return this._mouseEventsController = this._mouseEventsController || this._createController(MouseEventsController);
  }
  get dragEventsController() {
    return this._dragEventsController = this._dragEventsController || this._createController(DragEventsController);
  }
  // get pointerEventsController(): PointerEventsController {
  // 	return (this._pointerEventsController =
  // 		this._pointerEventsController || this._createController(PointerEventsController));
  // }
  get windowEventsController() {
    return this._windowEventsController = this._windowEventsController || this._createController(WindowEventsController);
  }
  get touchEventsController() {
    return this._touchEventsController = this._touchEventsController || this._createController(TouchEventsController);
  }
  _createController(eventConstructor) {
    const controller = new eventConstructor(this);
    if (!this._controllers.includes(controller)) {
      this._controllers.push(controller);
    }
    return controller;
  }
  get connectionTriggerDispatcher() {
    return this._connectionTriggerDispatcher = this._connectionTriggerDispatcher || new SceneConnectionTriggerDispatcher();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/ScenePerformanceMonitor.js
var ScenePerformanceMonitor = class {
  // private _thresholdContainers: ThresholdContainer[] = [];
  constructor(scene) {
    this.scene = scene;
    this._performanceRef = ref(1);
  }
  // reset() {
  // 	this._thresholdContainers.length = 0;
  // }
  // addThreshold(threshold: number) {
  // 	// check first that a similar threshold exists
  // 	for (let container of this._thresholdContainers) {
  // 		if (container.threshold == threshold) {
  // 			// no need to add it
  // 			return;
  // 		}
  // 	}
  // 	// add if none similar found
  // 	this._thresholdContainers.push({
  // 		threshold,
  // 		state: ThresholdState.ABOVE,
  // 	});
  // }
  ref() {
    return this._performanceRef;
  }
  onPerformanceChange(perf) {
    this._performanceRef.value = perf;
  }
  // performance() {
  // 	return this._performance;
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/ReferencesController.js
var _pathParams = [];
var _nodes = [];
var ReferencesController = class {
  constructor(scene) {
    this.scene = scene;
    this._referenced_nodes_by_src_param_id = /* @__PURE__ */ new Map();
    this._referencing_params_by_referenced_node_id = /* @__PURE__ */ new Map();
    this._referencing_params_by_all_named_node_ids = /* @__PURE__ */ new Map();
  }
  setReferenceFromParam(src_param, referencedGraphNode) {
    this._referenced_nodes_by_src_param_id.set(src_param.graphNodeId(), referencedGraphNode);
    MapUtils.pushOnArrayAtEntry(
      this._referencing_params_by_referenced_node_id,
      referencedGraphNode.graphNodeId(),
      src_param
    );
  }
  setNamedNodesFromParam(src_param) {
    src_param.decomposedPath.namedNodes(_nodes);
    for (const namedNode of _nodes) {
      MapUtils.pushOnArrayAtEntry(
        this._referencing_params_by_all_named_node_ids,
        namedNode.graphNodeId(),
        src_param
      );
    }
  }
  resetReferenceFromParam(src_param) {
    const referenced_node = this._referenced_nodes_by_src_param_id.get(src_param.graphNodeId());
    if (referenced_node) {
      MapUtils.popFromArrayAtEntry(
        this._referencing_params_by_referenced_node_id,
        referenced_node.graphNodeId(),
        src_param
      );
      src_param.decomposedPath.namedNodes(_nodes);
      for (const namedNode of _nodes) {
        MapUtils.popFromArrayAtEntry(
          this._referencing_params_by_all_named_node_ids,
          namedNode.graphNodeId(),
          src_param
        );
      }
      this._referenced_nodes_by_src_param_id.delete(src_param.graphNodeId());
    }
  }
  referencing_params(node) {
    return this._referencing_params_by_referenced_node_id.get(node.graphNodeId());
  }
  referencingNodes(node, target) {
    const params = this._referencing_params_by_referenced_node_id.get(node.graphNodeId());
    target.length = 0;
    if (params) {
      const node_by_node_id = /* @__PURE__ */ new Map();
      for (const param of params) {
        const node2 = param.node;
        node_by_node_id.set(node2.graphNodeId(), node2);
      }
      node_by_node_id.forEach((node2) => {
        target.push(node2);
      });
    }
    return target;
  }
  nodesReferencedBy(node, target) {
    const path_param_types = /* @__PURE__ */ new Set([ParamType.NODE_PATH]);
    _pathParams.length = 0;
    for (const param of node.params.all) {
      if (path_param_types.has(param.type())) {
        _pathParams.push(param);
      }
    }
    const nodes_by_id = /* @__PURE__ */ new Map();
    const params = [];
    for (const pathParam of _pathParams) {
      this._check_param(pathParam, nodes_by_id, params);
    }
    for (const param of params) {
      nodes_by_id.set(param.node.graphNodeId(), param.node);
    }
    target.length = 0;
    nodes_by_id.forEach((node2) => {
      target.push(node2);
    });
    return target;
  }
  _check_param(param, nodes_by_id, params) {
    if (param instanceof NodePathParam) {
      const found_node = param.value.node();
      if (found_node) {
        nodes_by_id.set(found_node.graphNodeId(), found_node);
      }
      return;
    }
  }
  //
  //
  // TRACK NAME CHANGES
  //
  //
  notifyNameUpdated(node) {
    const referencingParams = this._referencing_params_by_all_named_node_ids.get(node.graphNodeId());
    if (referencingParams) {
      const referencingParamsCloned = arrayShallowClone(referencingParams);
      for (const referencingParam of referencingParamsCloned) {
        referencingParam.notifyPathRebuildRequired(node);
      }
    }
  }
  //
  //
  // TRACK NODE DELETIONS/ADDITIONS
  //
  //
  //
  //
  // TRACK PARAM DELETIONS/ADDITIONS
  //
  //
  notifyParamsUpdated(node) {
    const referencingParams = this._referencing_params_by_all_named_node_ids.get(node.graphNodeId());
    if (referencingParams) {
      const referencingParamsCloned = arrayShallowClone(referencingParams);
      for (const referencingParam of referencingParamsCloned) {
        if (referencingParam.options.isSelectingParam()) {
          referencingParam.notifyTargetParamOwnerParamsUpdated(node);
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/UniformsController.js
var UniformName = ((UniformName2) => {
  UniformName2["TIME"] = "time";
  UniformName2["RESOLUTION"] = "resolution";
  UniformName2["SPOTLIGHTS_RAYMARCHING"] = "spotLightsRayMarching";
  UniformName2["DIRECTIONALLIGHTS_RAYMARCHING"] = "directionalLightsRayMarching";
  UniformName2["POINTLIGHTS_RAYMARCHING"] = "pointLightsRayMarching";
  return UniformName2;
})(UniformName || {});
var GLOBAL_UNIFORMS = {
  // [UniformName.TIME]: {value: 0},
  [
    "resolution"
    /* RESOLUTION */
  ]: { value: new Vector2(1e3, 1e3) }
};
var UniformsController = class {
  constructor(scene) {
    this.scene = scene;
  }
  // private _resolution: Vector2 = new Vector2(1, 1);
  // private _resolutionDependentUniformsMap: Map<string, IUniformsWithResolutionOnly> = new Map();
  // private _resolutionDependentUniforms: IUniformsWithResolutionOnly[] = [];
  // add uniforms from assemblers
  addUniforms(uniforms, options) {
    const {
      paramConfigs,
      additionalTextureUniforms,
      timeDependent,
      resolutionDependent,
      raymarchingLightsWorldCoordsDependent
    } = options;
    for (const paramConfig of paramConfigs) {
      uniforms[paramConfig.uniformName()] = paramConfig.uniform();
    }
    const additionalUniformNames = Object.keys(additionalTextureUniforms);
    for (const uniformName of additionalUniformNames) {
      const uniformValue = additionalTextureUniforms[uniformName];
      uniforms[uniformName] = uniformValue;
    }
    if (timeDependent) {
      this.addTimeUniform(uniforms);
    } else {
      this.removeTimeUniform(uniforms);
    }
    if (resolutionDependent) {
      this.addResolutionUniforms(uniforms);
    } else {
      this.removeResolutionUniform(uniforms);
    }
    if (raymarchingLightsWorldCoordsDependent) {
      this.addRaymarchingUniforms(uniforms);
    } else {
      this.removeRaymarchingUniform(uniforms);
    }
  }
  addTimeUniform(uniforms) {
    uniforms[
      "time"
      /* TIME */
    ] = this.scene.timeController.timeUniform();
  }
  removeTimeUniform(uniforms) {
    delete uniforms[
      "time"
      /* TIME */
    ];
  }
  timeUniformValue() {
    return this.scene.timeController.timeUniform().value;
  }
  // public updateTime() {
  // 	GLOBAL_UNIFORMS[UniformName.TIME].value = this.scene.time();
  // }
  // resolution
  addResolutionUniforms(uniforms) {
    uniforms[
      "resolution"
      /* RESOLUTION */
    ] = GLOBAL_UNIFORMS[
      "resolution"
      /* RESOLUTION */
    ];
  }
  removeResolutionUniform(uniforms) {
    delete uniforms[
      "resolution"
      /* RESOLUTION */
    ];
  }
  updateResolution(resolution, pixelRatio) {
    GLOBAL_UNIFORMS[
      "resolution"
      /* RESOLUTION */
    ].value.copy(resolution).multiplyScalar(pixelRatio);
  }
  // raymarching
  addRaymarchingUniforms(uniforms) {
    this.scene.sceneTraverser.addLightsRayMarchingUniform(uniforms);
  }
  removeRaymarchingUniform(uniforms) {
    this.scene.sceneTraverser.removeLightsRayMarchingUniform(uniforms);
  }
  // updateResolutionDependentUniforms(uniforms: IUniformsWithResolutionOnly) {
  // 	const resolutionUniform = uniforms[UniformName.RESOLUTION];
  // 	resolutionUniform.value.x = this._resolution.x; // * window.devicePixelRatio;
  // 	resolutionUniform.value.y = this._resolution.y; // * window.devicePixelRatio;
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/ViewersRegister.js
var ViewersRegister = class {
  constructor(_scene) {
    this._scene = _scene;
    this._viewersById = /* @__PURE__ */ new Map();
  }
  registerViewer(viewer) {
    this._viewersById.set(viewer.id(), viewer);
    this._updateCache();
  }
  unregisterViewer(viewer) {
    this._viewersById.delete(viewer.id());
    this._updateCache();
  }
  traverseViewers(callback) {
    this._viewersById.forEach(callback);
  }
  viewer(options) {
    const createViewerOptions = {
      camera: options.camera,
      canvas: options.canvas,
      scene: this._scene
    };
    return Poly.camerasRegister.createViewer(createViewerOptions);
  }
  firstViewer() {
    return this._firstViewer;
  }
  markViewerAsRendered(viewer) {
    this._lastRenderedViewer = viewer;
  }
  lastRenderedViewer() {
    return this._lastRenderedViewer;
  }
  _updateCache() {
    this._firstViewer = void 0;
    this._viewersById.forEach((viewer) => {
      this._firstViewer = this._firstViewer || viewer;
    });
  }
  graphNode() {
    return this._graphNode = this._graphNode || this._createGraphNode();
  }
  _createGraphNode() {
    const coreGraphNode = new CoreGraphNode(this._scene, "SceneViewersRegister");
    return coreGraphNode;
  }
  // private _viewerWithResizeRequired: Set<string> = new Set();
  markViewerAsSizeUpdated(viewer) {
    var _a;
    if (!this._viewersById.has(viewer.id())) {
      return;
    }
    (_a = this._graphNode) == null ? void 0 : _a.setDirty();
  }
  // markViewerAsResizeCompleted(viewer: BaseViewerType) {
  // 	if (!this._viewersById.has(viewer.id())) {
  // 		return;
  // 	}
  // 	this._viewerWithResizeRequired.delete(viewer.id());
  // }
  // isViewerResizeRequired(viewer: BaseViewerType) {
  // 	return this._viewerWithResizeRequired.has(viewer.id());
  // }
  // updateViewersSize() {
  // 	this._viewerWithResizeRequired.forEach((viewerId) => {
  // 		const viewer = this._viewersById.get(viewerId);
  // 		if (viewer) {
  // 			viewer.updateSize();
  // 		}
  // 	});
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/WebGLController.js
var SceneWebGLController = class {
  constructor() {
    this._requireWebGL2 = false;
  }
  requireWebGL2() {
    return this._requireWebGL2;
  }
  setRequireWebGL2() {
    if (!this._requireWebGL2) {
      this._requireWebGL2 = true;
      Poly.renderersController.setRequireWebGL2();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/WindowController.js
var WindowController = class {
  constructor(_scene) {
    this._scene = _scene;
    this._onWindowResizeBound = this._onWindowResize.bind(this);
  }
  graphNode() {
    return this._graphNode = this._graphNode || this._createGraphNode();
  }
  _createGraphNode() {
    const coreGraphNode = new CoreGraphNode(this._scene, "SceneWindowController");
    window.addEventListener("resize", this._onWindowResizeBound);
    return coreGraphNode;
  }
  _onWindowResize() {
    this.graphNode().setSuccessorsDirty();
  }
  dispose() {
    window.removeEventListener("resize", this._onWindowResizeBound);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/AssetsController.js
var SceneAssetsController = class {
  constructor() {
    this._params_by_id = /* @__PURE__ */ new Map();
    this._assetsRoot = null;
  }
  register_param(param) {
    this._params_by_id.set(param.graphNodeId(), param);
  }
  deregister_param(param) {
    this._params_by_id.delete(param.graphNodeId());
  }
  traverse_params(callback) {
    this._params_by_id.forEach((param, id) => {
      callback(param);
    });
  }
  root() {
    return this._assetsRoot;
  }
  setRoot(url) {
    if (url == "") {
      url = null;
    }
    this._assetsRoot = url;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/lights/Common.js
var LightUserDataRaymarching = ((LightUserDataRaymarching2) => {
  LightUserDataRaymarching2["PENUMBRA"] = "raymarchingPenumbra";
  LightUserDataRaymarching2["SHADOW_BIAS_ANGLE"] = "raymarchingShadowBiasAngle";
  LightUserDataRaymarching2["SHADOW_BIAS_DISTANCE"] = "raymarchingShadowBiasDistance";
  return LightUserDataRaymarching2;
})(LightUserDataRaymarching || {});

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/raymarching/_Base.js
var LightType = ((LightType2) => {
  LightType2[LightType2["SPOT"] = 0] = "SPOT";
  LightType2[LightType2["DIRECTIONAL"] = 1] = "DIRECTIONAL";
  LightType2[LightType2["HEMISPHERE"] = 2] = "HEMISPHERE";
  LightType2[LightType2["POINT"] = 3] = "POINT";
  return LightType2;
})(LightType || {});
function getLightType(object) {
  if (object.isSpotLight) {
    return 0;
  }
  if (object.isDirectionalLight) {
    return 1;
  }
  if (object.isHemisphereLight) {
    return 2;
  }
  if (object.isPointLight) {
    return 3;
  }
}
function updateUserDataPenumbra(object, uniforms, index, defaultUniformCreate) {
  uniforms.value[index] = uniforms.value[index] || defaultUniformCreate();
  const uniformName = LightUserDataRaymarching.PENUMBRA;
  if (uniforms.value[index].penumbra != object.userData[uniformName]) {
    uniforms.value[index].penumbra = object.userData[uniformName];
    uniforms.value.needsUpdate = true;
  }
}
function updateUserDataShadowBias(object, uniforms, index, defaultUniformCreate) {
  uniforms.value[index] = uniforms.value[index] || defaultUniformCreate();
  if (uniforms.value[index].shadowBiasAngle != object.userData[LightUserDataRaymarching.SHADOW_BIAS_ANGLE]) {
    uniforms.value[index].shadowBiasAngle = object.userData[LightUserDataRaymarching.SHADOW_BIAS_ANGLE];
    uniforms.value.needsUpdate = true;
  }
  if (uniforms.value[index].shadowBiasDistance != object.userData[LightUserDataRaymarching.SHADOW_BIAS_DISTANCE]) {
    uniforms.value[index].shadowBiasDistance = object.userData[LightUserDataRaymarching.SHADOW_BIAS_DISTANCE];
    uniforms.value.needsUpdate = true;
  }
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/raymarching/SpotLight.js
function _createSpotLightUniform() {
  return {
    penumbra: 0,
    shadowBiasAngle: 0,
    shadowBiasDistance: 0
  };
}
var spotLightIndex = 0;
var _updateUniformsWithSpotLight = (object, spotLightsRayMarching) => {
  updateUserDataPenumbra(object, spotLightsRayMarching, spotLightIndex, _createSpotLightUniform);
  updateUserDataShadowBias(object, spotLightsRayMarching, spotLightIndex, _createSpotLightUniform);
  spotLightIndex++;
};
function _resetSpotLightIndex() {
  spotLightIndex = 0;
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/raymarching/DirectionalLight.js
function _createDirectionalLightUniform() {
  return {
    penumbra: 0,
    shadowBiasAngle: 0,
    shadowBiasDistance: 0
  };
}
var directionalLightIndex = 0;
var _updateUniformsWithDirectionalLight = (object, directionalLightsRayMarching) => {
  updateUserDataPenumbra(
    object,
    directionalLightsRayMarching,
    directionalLightIndex,
    _createDirectionalLightUniform
  );
  updateUserDataShadowBias(
    object,
    directionalLightsRayMarching,
    directionalLightIndex,
    _createDirectionalLightUniform
  );
  directionalLightIndex++;
};
function _resetDirectionalLightIndex() {
  directionalLightIndex = 0;
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/raymarching/PointLight.js
function _createPointLightUniform() {
  return {
    penumbra: 0,
    shadowBiasAngle: 0,
    shadowBiasDistance: 0
  };
}
var pointLightIndex = 0;
var _updateUniformsWithPointLight = (object, pointLightsRayMarching) => {
  updateUserDataPenumbra(object, pointLightsRayMarching, pointLightIndex, _createPointLightUniform);
  updateUserDataShadowBias(object, pointLightsRayMarching, pointLightIndex, _createPointLightUniform);
  pointLightIndex++;
};
function _resetPointLightIndex() {
  pointLightIndex = 0;
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/SceneTraverser.js
function _updateUniformsFunctionForLight(object) {
  const lightType = getLightType(object);
  switch (lightType) {
    case LightType.SPOT: {
      return _updateUniformsWithSpotLight;
    }
    case LightType.DIRECTIONAL: {
      return _updateUniformsWithDirectionalLight;
    }
    case LightType.POINT: {
      return _updateUniformsWithPointLight;
    }
  }
}
var SceneTraverserController = class {
  constructor(scene) {
    this.scene = scene;
    this._spotLightsRayMarching = {
      value: []
    };
    this._directionalLightsRayMarching = {
      value: []
    };
    this._pointLightsRayMarching = {
      value: []
    };
    this._updateUniformsFunctionByLight = /* @__PURE__ */ new WeakMap();
    this._uniformsByLight = /* @__PURE__ */ new WeakMap();
    this._onObjectTraverseBound = this._onObjectTraverse.bind(this);
  }
  traverseScene(scene) {
    _resetSpotLightIndex();
    _resetDirectionalLightIndex();
    _resetPointLightIndex();
    scene = scene || this.scene.threejsScene();
    scene.traverse(this._onObjectTraverseBound);
  }
  _onObjectTraverse(object) {
    let updateFunction = this._updateUniformsFunctionByLight.get(object);
    if (!updateFunction) {
      if (object.isLight) {
        updateFunction = _updateUniformsFunctionForLight(object);
        if (updateFunction) {
          this._updateUniformsFunctionByLight.set(object, updateFunction);
        }
      }
    }
    if (!updateFunction) {
      return updateFunction;
    }
    let uniforms = this._uniformsByLight.get(object);
    if (!uniforms) {
      uniforms = this._updateUniformsForLight(object);
      if (uniforms) {
        this._uniformsByLight.set(object, uniforms);
      }
    }
    if (!uniforms) {
      return;
    }
    updateFunction(object, uniforms);
  }
  _updateUniformsForLight(object) {
    const lightType = getLightType(object);
    switch (lightType) {
      case LightType.SPOT: {
        return this._spotLightsRayMarching;
      }
      case LightType.DIRECTIONAL: {
        return this._directionalLightsRayMarching;
      }
      case LightType.POINT: {
        return this._pointLightsRayMarching;
      }
    }
  }
  addLightsRayMarchingUniform(uniforms) {
    uniforms[UniformName.SPOTLIGHTS_RAYMARCHING] = this._spotLightsRayMarching;
    uniforms[UniformName.DIRECTIONALLIGHTS_RAYMARCHING] = this._directionalLightsRayMarching;
    uniforms[UniformName.POINTLIGHTS_RAYMARCHING] = this._pointLightsRayMarching;
  }
  removeLightsRayMarchingUniform(uniforms) {
    delete uniforms[UniformName.SPOTLIGHTS_RAYMARCHING];
    delete uniforms[UniformName.DIRECTIONALLIGHTS_RAYMARCHING];
    delete uniforms[UniformName.POINTLIGHTS_RAYMARCHING];
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/SceneRenderersRegister.js
var _renderers = [];
var SceneRenderersRegister = class {
  constructor(scene) {
    this.scene = scene;
    this._renderersById = /* @__PURE__ */ new Map();
    this._registerTimeByRenderer = /* @__PURE__ */ new Map();
    this._resolves = [];
  }
  registerRenderer(renderer, options) {
    let assignId = true;
    if ((options == null ? void 0 : options.assignId) == false) {
      assignId = false;
    }
    if (assignId) {
      Poly.renderersController.assignIdToRenderer(renderer);
    }
    const id = Poly.renderersController.rendererId(renderer);
    if (id == null) {
      return;
    }
    this._renderersById.set(id, renderer);
    this._registerTimeByRenderer.set(renderer, performance.now());
    this._updateCache();
    if (this._renderersById.size == 1) {
      this._flushCallbacksWithRenderer(renderer);
    }
  }
  dispose() {
    this.renderers(_renderers);
    for (const renderer of _renderers) {
      this.deregisterRenderer(renderer);
    }
  }
  deregisterRenderer(renderer) {
    const id = Poly.renderersController.rendererId(renderer);
    if (id == null) {
      return;
    }
    this._renderersById.delete(id);
    renderer.dispose();
    this._updateCache();
  }
  lastRegisteredRenderer() {
    return this._lastRegisteredRenderer;
  }
  renderers(target) {
    this._renderersById.forEach((renderer) => {
      target.push(renderer);
    });
    return target;
  }
  _updateCache() {
    this._lastRegisteredRenderer = void 0;
    this._registerTimeByRenderer.forEach((registerTime, renderer) => {
      if (this._lastRegisteredRenderer == void 0) {
        this._lastRegisteredRenderer = renderer;
      } else {
        const lastRegisterTime = this._registerTimeByRenderer.get(this._lastRegisteredRenderer);
        if (lastRegisterTime != null) {
          if (registerTime > lastRegisterTime) {
            this._lastRegisteredRenderer = renderer;
          }
        }
      }
    });
  }
  _flushCallbacksWithRenderer(renderer) {
    const callbacks = [];
    arrayCopy(this._resolves, callbacks);
    this._resolves.length = 0;
    for (const c of callbacks) {
      c(renderer);
    }
  }
  async waitForAbstractRenderer() {
    if (this._lastRegisteredRenderer) {
      return this._lastRegisteredRenderer;
    } else {
      return new Promise((resolve, reject) => {
        this._resolves.push(resolve);
      });
    }
  }
  async waitForRenderer() {
    let renderer = await this.waitForAbstractRenderer();
    if (renderer instanceof WebGLRenderer) {
      return renderer;
    }
    renderer = renderer.webGLRenderer;
    if (renderer && renderer instanceof WebGLRenderer) {
      return renderer;
    }
    if (renderer) {
      if (!(renderer instanceof WebGLRenderer)) {
        console.log("unexpected renderer:", { renderer });
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/utils/WebXREventsController.js
var SceneWebXRController = class {
  constructor(scene) {
    this.scene = scene;
    this._activeXRController = null;
    this._activeARController = null;
    this._activeVRController = null;
  }
  _setActiveXRController(controller) {
    this._activeXRController = controller;
  }
  activeXRController() {
    return this._activeXRController;
  }
  setARControllerCreationFunction(func) {
    this._ARControllerCreateFunction = func;
  }
  ARControllerCreateFunction() {
    return this._ARControllerCreateFunction;
  }
  setActiveARController(ARController) {
    this._activeARController = ARController;
    this._setActiveXRController(ARController);
  }
  activeARController() {
    return this._activeARController;
  }
  setVRControllerCreationFunction(func) {
    this._VRControllerCreateFunction = func;
  }
  VRControllerCreateFunction() {
    return this._VRControllerCreateFunction;
  }
  setActiveVRController(VRController) {
    this._activeVRController = VRController;
    this._setActiveXRController(VRController);
  }
  activeVRController() {
    return this._activeVRController;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/scene/PolyScene.js
var PolyScene = class _PolyScene {
  //
  //
  // constructor
  //
  //
  constructor(options) {
    this._cooker = new Cooker(this);
    this.cookController = new SceneCookController();
    this._graph = new CoreGraph();
    this.lifecycleController = new SceneLifeCycleController(this);
    this.loadingController = new LoadingController(this);
    this.missingExpressionReferencesController = new MissingReferencesController(this);
    this.expressionsController = new SceneExpressionsController();
    this.nodesController = new NodesController(this);
    this.graphNodesController = new GraphNodesController(this);
    this.renderersRegister = new SceneRenderersRegister(this);
    this._objectsController = new ObjectsController(this);
    this._referencesController = new ReferencesController(this);
    this.perfMonitor = new ScenePerformanceMonitor(this);
    this.sceneTraverser = new SceneTraverserController(this);
    this.timeController = new TimeController(this);
    this._disposed = false;
    this._graph.setScene(this);
    this._paramSerializerClass = options == null ? void 0 : options.paramsSerializerClass;
    this.nodesController.createRoot(options == null ? void 0 : options.root);
    Poly.scenesRegister.registerScene(this);
  }
  /**
   * Returns the THREE.Scene.
   *
   * @remarks
   *
   * Read more about how to use a THREE.Scene on [THREE's documentation](https://threejs.org/docs/?q=scene#api/en/scenes/Scene)
   *
   */
  threejsScene() {
    return this.root().object;
  }
  setUuid(uuid) {
    return this._uuid = uuid;
  }
  get uuid() {
    return this._uuid;
  }
  setName(newName) {
    return this._name = _PolyScene.sanitizeName(newName);
  }
  static sanitizeName(newName) {
    newName = CoreString.sanitizeName(newName);
    newName = newName.toLowerCase();
    return newName;
  }
  name() {
    return this._name;
  }
  get camerasController() {
    return this._camerasController = this._camerasController || new SceneCamerasController(this);
  }
  /**
   * Returns the camera object that has been set as main
   *
   */
  mainCamera() {
    return this.camerasController.mainCamera();
  }
  get cooker() {
    return this._cooker;
  }
  get actorsManager() {
    return this._actorsManager = this._actorsManager || new ActorsManager(this);
  }
  get assets() {
    return this._assetsController = this._assetsController || new SceneAssetsController();
  }
  /**
   * Returns a promise to wait for all nodes to have cooked when loading a scene.
   *
   */
  async waitForCooksCompleted() {
    return await this.cookController.waitForCooksCompleted();
  }
  get dispatchController() {
    return this._dispatchController = this._dispatchController || new DispatchController(this);
  }
  get eventsDispatcher() {
    return this._eventsDispatcher = this._eventsDispatcher || new SceneEventsDispatcher(this);
  }
  get webXR() {
    return this._webXRController = this._webXRController || new SceneWebXRController(this);
  }
  /**
   * When using Polygonjs viewers, a raycaster is created to use mouse events and detect if there are any object under the cursor.
   * But if no viewer is created, such as when [importing a scene in react three fiber](/docs/integrations/react_three_fiber),
   * It is then useful to give a raycaster.
   *
   */
  setRaycaster(raycaster) {
    this.eventsDispatcher.setRaycaster(raycaster);
  }
  get graph() {
    return this._graph;
  }
  createNode(nodeClass, options) {
    return this.root().createNode(nodeClass, options);
  }
  /**
   * returns all nodes with a given type
   *
   * - polyScene.nodesByType('box'): returns all BoxSopNodes
   */
  nodesByType(type) {
    return this.nodesController.nodesByType(type);
  }
  get objectsController() {
    return this._objectsController;
  }
  /**
   * returns a THREE.Object3D whose name matches the mask
   *
   */
  findObjectByMask(mask) {
    return this._objectsController.findObjectByMask(mask);
  }
  /**
   * returns a list THREE.Object3Ds whose names matche the mask
   *
   */
  objectsByMask(mask, parent) {
    return this._objectsController.objectsByMask(mask, parent);
  }
  get referencesController() {
    return this._referencesController;
  }
  get performance() {
    return this._performance = this._performance || new CorePerformance();
  }
  get viewersRegister() {
    return this._viewersRegister = this._viewersRegister || new ViewersRegister(this);
  }
  /**
   * updates Polygonjs scene internals. This is called automatically when using Polygonjs viewers,
   * but you would need to call it yourself in the render loop when adding your scene to threejs or react-three-fiber.
   * See [https://polygonjs.com/docs/integrations](https://polygonjs.com/docs/integrations)
   *
   */
  update(delta, state) {
    this.timeController.setDelta(delta);
    this.timeController.incrementTimeIfPlaying(TIME_CONTROLLER_UPDATE_TIME_OPTIONS_DEFAULT);
    this.sceneTraverser.traverseScene(state == null ? void 0 : state.scene);
  }
  /**
   * sets the current frame
   *
   */
  setFrame(frame) {
    this.timeController.setFrame(frame);
  }
  setFrameToStart() {
    this.timeController.setFrameToStart();
  }
  /**
   * returns the current frame
   *
   */
  frame() {
    return this.timeController.frame();
  }
  /**
   * returns the current time
   *
   */
  time() {
    return this.timeController.time();
  }
  maxFrame() {
    return this.timeController.maxFrame();
  }
  /**
   * starts playing the scene
   *
   */
  play() {
    this.timeController.play();
  }
  /**
   * pauses the scene
   *
   */
  pause() {
    this.timeController.pause();
  }
  /**
   * increments the time
   *
   */
  incrementTime(options) {
    this.timeController.incrementTime(options);
  }
  /**
   * increments the time if the scene is playing()
   *
   */
  incrementTimeIfPlaying(options) {
    this.timeController.incrementTimeIfPlaying(options);
  }
  /**
   * registers a renderer
   *
   */
  registerRenderer(renderer, options) {
    return this.renderersRegister.registerRenderer(renderer, options);
  }
  get uniformsController() {
    return this._uniformsController = this._uniformsController || new UniformsController(this);
  }
  get webglController() {
    return this._webglController = this._webglController || new SceneWebGLController();
  }
  get windowController() {
    return this._windowController = this._windowController || new WindowController(this);
  }
  dispose() {
    if (this._disposed == true) {
      return;
    }
    this._disposed = true;
    this.batchUpdates(() => {
      this.nodesController.traverseNodes((node) => {
        var _a;
        (_a = node.parent()) == null ? void 0 : _a.removeNode(node);
      });
    });
    if (this._windowController) {
      this._windowController.dispose();
      this._windowController = void 0;
    }
    this.timeController.dispose();
    this.renderersRegister.dispose();
    this.camerasController.dispose();
    this.root().dispose();
    Poly.scenesRegister.deregisterScene(this);
  }
  disposed() {
    return this._disposed;
  }
  paramSerializerClass() {
    return this._paramSerializerClass;
  }
  //
  //
  // cooker
  //
  //
  /**
   * batchUpdates can be useful to set multiple parameter values without triggering a recook for each update.
   *
   */
  async batchUpdates(callback) {
    this._cooker.block();
    await callback();
    this._cooker.unblock();
  }
  //
  //
  // nodes
  //
  //
  /**
   * returns a node based on its path
   *
   * - polyScene.node('/geo1')
   *
   */
  node(path) {
    return this.nodesController.node(path);
  }
  /**
   * returns the root node
   *
   */
  root() {
    return this.nodesController.root();
  }
  /**
   * traverse all nodes and runs a callback for each
   *
   */
  traverseNodes(callback) {
    this.nodesController.traverseNodes(callback);
  }
  //
  //
  // CALLBACKS
  //
  //
  /**
   * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
   *
   */
  registerOnBeforeTick(callbackName, callback) {
    this.timeController.registerOnBeforeTick(callbackName, callback);
  }
  /**
   * unregisters BeforeTick callback
   *
   */
  unRegisterOnBeforeTick(callbackName) {
    this.timeController.unRegisterOnBeforeTick(callbackName);
  }
  /**
   * Returns the list registered BeforeTick callback names
   *
   */
  registeredBeforeTickCallbacks() {
    return this.timeController.registeredBeforeTickCallbacks();
  }
  /**
   * return true if a callback is registered with that name
   *
   */
  hasBeforeTickCallback(callbackName) {
    return this.timeController.hasBeforeTickCallback(callbackName);
  }
  /**
   * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
   *
   */
  registerOnAfterTick(callbackName, callback) {
    this.timeController.registerOnAfterTick(callbackName, callback);
  }
  /**
   * unregisters AfterTick callback
   *
   */
  unRegisterOnAfterTick(callbackName) {
    this.timeController.unRegisterOnAfterTick(callbackName);
  }
  /**
   * Returns the list registered AfterTick callback names
   *
   */
  registeredAfterTickCallbacks() {
    return this.timeController.registeredAfterTickCallbacks();
  }
  /**
   * return true if a callback is registered with that name
   *
   */
  hasAfterTickCallback(callbackName) {
    return this.timeController.hasAfterTickCallback(callbackName);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/Node.js
var COMPLEX_PARAM_DATA_KEYS = ["overriden_options", "type"];
var NodeJsonImporter = class {
  constructor(_node, dispatcher, nodesImporter) {
    this._node = _node;
    this.dispatcher = dispatcher;
    this.nodesImporter = nodesImporter;
  }
  process_data(scene_importer, data) {
    if (this._node.sceneReadonly()) {
      scene_importer.report.markAsLoadedWithoutAssemblers();
    }
    this.set_connection_points(data["connection_points"]);
    if (this._node.childrenAllowed()) {
      this.create_nodes(scene_importer, data["nodes"], data);
    }
    if (this._node.io.inputs.overrideClonedStateAllowed()) {
      const override = data["cloned_state_overriden"];
      if (override) {
        this._node.io.inputs.overrideClonedState(override);
      }
    }
    this.set_flags(data);
    this.set_params(data);
    if (data.persisted_config) {
      const shadersData = scene_importer.shadersData();
      const jsFunctionBodiesData = scene_importer.jsFunctionBodiesData();
      if (shadersData) {
        let shaders = shadersData[this._node.path()];
        if (!shaders) {
          shaders = {};
        }
        data.persisted_config.shaders = shaders;
      }
      if (jsFunctionBodiesData) {
        const jsFunctionBodyData = jsFunctionBodiesData[this._node.path()];
        if (jsFunctionBodyData) {
          if (isString(jsFunctionBodyData)) {
            data.persisted_config.functionBody = jsFunctionBodyData;
          } else {
            data.persisted_config.functionBody = jsFunctionBodyData;
          }
        }
      }
      this.set_persisted_config(data.persisted_config);
    }
    this.setCustomData(data);
  }
  process_inputs_data(scene_importer, data) {
    const maxInputsCount = data.maxInputsCount;
    if (maxInputsCount != null) {
      const minCount = this._node.io.inputs.minCount();
      this._node.io.inputs.setCount(minCount, maxInputsCount);
    }
    try {
      this.setInputs(data["inputs"]);
    } catch (err) {
      const message = err.message || `failed connecting inputs of node ${data["type"]}`;
      scene_importer.report.addWarning(message);
      console.warn(data["inputs"]);
    }
  }
  process_ui_data(scene_importer, data) {
    if (!data) {
      return;
    }
    if (Poly.playerMode()) {
      return;
    }
    const ui_data = this._node.uiData;
    const pos = data["pos"];
    if (pos) {
      const vector = new Vector2().fromArray(pos);
      ui_data.setPosition(vector);
    }
    const comment = data["comment"];
    if (comment) {
      ui_data.setComment(comment);
    }
    const selection = data["selection"];
    if (selection) {
      this.set_selection(selection);
    }
    if (this._node.childrenAllowed()) {
      const nodesData = data["nodes"];
      if (nodesData) {
        this.processNodesUiData(scene_importer, nodesData);
      }
    }
  }
  create_nodes(scene_importer, data, nodeData) {
    if (!data) {
      return;
    }
    this.nodesImporter.process_data(scene_importer, data);
  }
  set_selection(data) {
    if (this._node.childrenAllowed() && this._node.childrenController) {
      if (data && data.length > 0) {
        const selected_nodes = [];
        data.forEach((node_name) => {
          const node = this._node.node(node_name);
          if (node) {
            selected_nodes.push(node);
          }
        });
        this._node.childrenController.selection.set(selected_nodes);
      }
    }
  }
  set_flags(data) {
    var _a, _b, _c, _d, _e, _f;
    const flags = data["flags"];
    if (flags) {
      const bypass = flags["bypass"];
      if (bypass != null) {
        (_b = (_a = this._node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.set(bypass);
      }
      const display = flags["display"];
      if (display != null) {
        (_d = (_c = this._node.flags) == null ? void 0 : _c.display) == null ? void 0 : _d.set(display);
      }
      const optimize = flags["optimize"];
      if (optimize != null) {
        (_f = (_e = this._node.flags) == null ? void 0 : _e.optimize) == null ? void 0 : _f.set(optimize);
      }
    }
  }
  set_connection_points(connection_points_data) {
    if (!connection_points_data) {
      return;
    }
    if (connection_points_data["in"]) {
      this._node.io.saved_connection_points_data.set_in(connection_points_data["in"]);
    }
    if (connection_points_data["out"]) {
      this._node.io.saved_connection_points_data.set_out(connection_points_data["out"]);
    }
    if (this._node.io.has_connection_points_controller) {
      this._node.io.connection_points.update_signature_if_required();
    }
  }
  setInputs(inputsData) {
    if (!inputsData) {
      return;
    }
    let inputData;
    for (let i = 0; i < inputsData.length; i++) {
      inputData = inputsData[i];
      if (inputData && this._node.parent()) {
        if (CoreType.isString(inputData)) {
          const inputNodeName = inputData;
          const inputNode = this._node.nodeSibling(inputNodeName);
          this._node.setInput(i, inputNode);
        } else {
          const inputNode = this._node.nodeSibling(inputData["node"]);
          let inputIndex = inputData["index"];
          const inputName = inputData["inputName"];
          let outputName = inputData["output"];
          if (inputName != null) {
            const connectionPoints = this._node.io.inputs.namedInputConnectionPoints();
            if (connectionPoints) {
              const connectionPointIndex = connectionPoints.map((point) => point == null ? void 0 : point.name().toLowerCase()).indexOf(inputName.toLowerCase());
              if (connectionPointIndex >= 0) {
                inputIndex = connectionPointIndex;
              }
            }
          }
          if (inputNode != null && outputName != null) {
            const connectionPoints = inputNode.io.outputs.namedOutputConnectionPoints();
            if (connectionPoints) {
              for (let connectionPoint of connectionPoints) {
                if (connectionPoint) {
                  if (connectionPoint.name().toLowerCase() == outputName.toLowerCase()) {
                    outputName = connectionPoint.name();
                  }
                }
              }
            }
          }
          if (inputIndex != null) {
            this._node.setInput(inputIndex, inputNode, outputName);
          }
        }
      }
    }
  }
  processNodesUiData(scene_importer, data) {
    if (!data) {
      return;
    }
    if (Poly.playerMode()) {
      return;
    }
    const node_names = Object.keys(data);
    for (let node_name of node_names) {
      const node = this._node.node(node_name);
      if (node) {
        const node_data = data[node_name];
        this.dispatcher.dispatchNode(node).process_ui_data(scene_importer, node_data);
      }
    }
  }
  //
  //
  // PARAMS
  //
  //
  set_params(nodeData) {
    const data = nodeData["params"];
    if (!data) {
      return;
    }
    const param_names = Object.keys(data);
    const params_update_options = {};
    for (let param_name of param_names) {
      const param_data = data[param_name];
      if (param_data != null) {
        const options = param_data["options"];
        let param_type = param_data["type"];
        const has_param = this._node.params.has_param(param_name);
        let has_param_and_same_type = false;
        let param;
        if (has_param) {
          param = this._node.params.get(param_name);
          if (param && param.type() == param_type || param_type == null) {
            has_param_and_same_type = true;
          }
        }
        if (has_param_and_same_type) {
          if (this._is_param_data_complex(param_data)) {
            this._process_param_data_complex(param_name, param_data);
          } else {
            this._process_param_data_simple(
              param_name,
              param_data
            );
          }
        } else {
          params_update_options.namesToDelete = params_update_options.namesToDelete || [];
          params_update_options.namesToDelete.push(param_name);
          params_update_options.toAdd = params_update_options.toAdd || [];
          params_update_options.toAdd.push({
            name: param_name,
            type: param_type,
            initValue: param_data["default_value"],
            rawInput: param_data["raw_input"],
            options
          });
        }
      }
    }
    const params_delete_required = params_update_options.namesToDelete && params_update_options.namesToDelete.length > 0;
    const params_add_required = params_update_options.toAdd && params_update_options.toAdd.length > 0;
    if (params_delete_required || params_add_required) {
      this._node.params.updateParams(params_update_options);
      for (let spare_param of this._node.params.spare) {
        const param_data = data[spare_param.name()];
        if (!spare_param.parentParam() && param_data) {
          if (this._is_param_data_complex(param_data)) {
            this._process_param_data_complex(spare_param.name(), param_data);
          } else {
            this._process_param_data_simple(
              spare_param.name(),
              param_data
            );
          }
        }
      }
    }
    this._node.params.runOnSceneLoadHooks();
  }
  _process_param_data_simple(param_name, param_data) {
    var _a;
    (_a = this._node.params.get(param_name)) == null ? void 0 : _a.set(param_data);
  }
  _process_param_data_complex(param_name, param_data) {
    const param = this._node.params.get(param_name);
    if (param) {
      this.dispatcher.dispatchParam(param).process_data(param_data);
    }
  }
  _is_param_data_complex(param_data) {
    if (CoreType.isString(param_data) || CoreType.isNumber(param_data) || CoreType.isArray(param_data) || CoreType.isBoolean(param_data)) {
      return false;
    }
    if (CoreType.isObject(param_data)) {
      const keys = Object.keys(param_data);
      for (let complex_key of COMPLEX_PARAM_DATA_KEYS) {
        if (keys.includes(complex_key)) {
          return true;
        }
      }
    }
    return false;
  }
  set_persisted_config(persisted_config_data) {
    if (this._node.persisted_config) {
      this._node.persisted_config.load(persisted_config_data);
    }
  }
  setCustomData(data) {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/Param.js
var ParamJsonImporter = class {
  constructor(_param) {
    this._param = _param;
  }
  process_data(data) {
    const raw_input = data["raw_input"];
    if (raw_input !== void 0) {
      this._param.set(raw_input);
    }
    this.add_main(data);
  }
  add_main(data) {
  }
  static spare_params_data(params_data) {
    return this.params_data(true, params_data);
  }
  static non_spare_params_data_value(params_data) {
    return this.params_data_value(false, params_data);
  }
  static params_data(spare, params_data) {
    let non_spare_params_data;
    if (params_data) {
      non_spare_params_data = {};
      const param_names = Object.keys(params_data);
      let param_data;
      for (let param_name of param_names) {
        param_data = params_data[param_name];
        if (param_data) {
          non_spare_params_data[param_name] = params_data;
        }
      }
    }
    return non_spare_params_data;
  }
  static params_data_value(spare, params_data) {
    let non_spare_params_data;
    if (params_data) {
      non_spare_params_data = {};
      const param_names = Object.keys(params_data);
      let param_data;
      for (let param_name of param_names) {
        param_data = params_data[param_name];
        if (param_data != null) {
          const options = param_data.options;
          const overriden_options = param_data.overriden_options;
          if (options || overriden_options) {
            const complex_data = param_data;
            if (options && options.spare == spare) {
              if (complex_data.raw_input != null) {
                non_spare_params_data[param_name] = { complex_data };
              }
            } else {
              if (overriden_options) {
                non_spare_params_data[param_name] = { complex_data };
              }
            }
          } else {
            const simple_data = param_data;
            if (overriden_options || simple_data != null) {
              non_spare_params_data[param_name] = {
                simple_data
              };
            }
          }
        }
      }
    }
    return non_spare_params_data;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/param/Multiple.js
var ParamMultipleJsonImporter = class extends ParamJsonImporter {
  add_main(data) {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/param/String.js
var LINE_BREAK_REGEXP = /\\n+/g;
var ParamStringJsonImporter = class extends ParamJsonImporter {
  add_main(data) {
    let raw_input = data["raw_input"];
    if (raw_input !== void 0) {
      raw_input = raw_input.replace(LINE_BREAK_REGEXP, "\n");
      this._param.set(raw_input);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/param/Ramp.js
var ParamRampJsonImporter = class extends ParamJsonImporter {
  add_main(data) {
    const raw_input = data["raw_input"];
    if (raw_input) {
      this._param.set(raw_input);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/nodes/Poly.js
var PolyNodeJsonImporter = class extends NodeJsonImporter {
  create_nodes(scene_importer, data, nodeData) {
    const node = this._node;
    const polyNodeController = node.polyNodeController;
    polyNodeController.setLockedState(false);
    if (this._isDataLocked(nodeData)) {
      polyNodeController.createChildNodesFromDefinition();
    } else {
      super.create_nodes(scene_importer, data, nodeData);
    }
  }
  setCustomData(data) {
    if (this._node.polyNodeController) {
      this._node.polyNodeController.setLockedState(this._isDataLocked(data));
    }
  }
  _isDataLocked(data) {
    if (data["polyNode"]) {
      return data["polyNode"]["locked"];
    } else {
      return false;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/OptimizedNodes.js
var OptimizedNodesJsonImporter = class _OptimizedNodesJsonImporter {
  constructor(_node) {
    this._node = _node;
    this._nodes = [];
    this._optimized_root_node_names = /* @__PURE__ */ new Set();
    this._operation_containers_by_name = /* @__PURE__ */ new Map();
    this._node_inputs = [];
  }
  nodes() {
    return this._nodes;
  }
  process_data(scene_importer, data) {
    var _a, _b, _c;
    if (!data) {
      return;
    }
    if (!(this._node.childrenAllowed() && this._node.childrenController)) {
      return;
    }
    const { optimized_names } = _OptimizedNodesJsonImporter.child_names_by_optimized_state(data);
    this._nodes = [];
    this._optimized_root_node_names = /* @__PURE__ */ new Set();
    for (let node_name of optimized_names) {
      if (_OptimizedNodesJsonImporter.is_optimized_root_node(data, node_name)) {
        this._optimized_root_node_names.add(node_name);
      }
    }
    for (let nodeName of this._optimized_root_node_names) {
      const node_data = data[nodeName];
      const nodeCreateOptions = {
        nodeName
      };
      const node = this._node.createNode(OPERATIONS_COMPOSER_NODE_TYPE, nodeCreateOptions);
      if (node) {
        this._nodes.push(node);
        if ((_a = node_data.flags) == null ? void 0 : _a.display) {
          (_c = (_b = node.flags) == null ? void 0 : _b.display) == null ? void 0 : _c.set(true);
        }
        const operation_container = this._createOperationContainer(
          scene_importer,
          node,
          node_data,
          node.name()
        );
        node.setOutputOperationContainer(
          operation_container
        );
      }
    }
    for (let node of this._nodes) {
      const operation_container = node.outputOperationContainer();
      if (operation_container) {
        this._node_inputs = [];
        this._add_optimized_node_inputs(
          scene_importer,
          node,
          data,
          node.name(),
          operation_container
        );
        node.io.inputs.setCount(this._node_inputs.length);
        for (let i = 0; i < this._node_inputs.length; i++) {
          node.setInput(i, this._node_inputs[i]);
        }
      }
    }
  }
  _add_optimized_node_inputs(scene_importer, node, data, node_name, current_operation_container) {
    var _a;
    const node_data = data[node_name];
    const inputs_data = node_data["inputs"];
    if (!inputs_data) {
      return;
    }
    for (let input_data of inputs_data) {
      if (CoreType.isString(input_data)) {
        const input_node_data = data[input_data];
        if (input_node_data) {
          if (_OptimizedNodesJsonImporter.is_node_optimized(input_node_data) && !this._optimized_root_node_names.has(input_data)) {
            let operation_container = this._operation_containers_by_name.get(input_data);
            if (!operation_container) {
              operation_container = this._createOperationContainer(
                scene_importer,
                node,
                input_node_data,
                input_data
              );
              if (operation_container) {
                this._add_optimized_node_inputs(
                  scene_importer,
                  node,
                  data,
                  input_data,
                  operation_container
                );
              }
            }
            current_operation_container.addInput(operation_container);
          } else {
            const input_node = (_a = node.parent()) == null ? void 0 : _a.node(input_data);
            if (input_node) {
              this._node_inputs.push(input_node);
              const node_input_index = this._node_inputs.length - 1;
              node.addInputConfig(current_operation_container, {
                operation_input_index: current_operation_container.currentInputIndex(),
                node_input_index
              });
              current_operation_container.incrementInputIndex();
            }
          }
        }
      }
    }
    if (node_data.cloned_state_overriden == true) {
      current_operation_container.overrideInputCloneState(node_data.cloned_state_overriden);
    }
  }
  static child_names_by_optimized_state(data) {
    const node_names = Object.keys(data);
    const optimized_names = [];
    const non_optimized_names = [];
    for (let node_name of node_names) {
      const node_data = data[node_name];
      const optimized_state = Poly.playerMode() && this.is_node_optimized(node_data);
      if (optimized_state) {
        optimized_names.push(node_name);
      } else {
        non_optimized_names.push(node_name);
      }
    }
    return { optimized_names, non_optimized_names };
  }
  // private _optimized_names_for_root(
  // 	data: PolyDictionary<NodeJsonExporterData>,
  // 	current_node_name: string,
  // 	current_node_data: NodeJsonExporterData,
  // 	input_names: string[] = []
  // ) {
  // 	input_names.push(current_node_name);
  // 	const inputs = current_node_data['inputs'];
  // 	if (inputs) {
  // 		for (let input_data of inputs) {
  // 			if (CoreType.isString(input_data)) {
  // 				const input_node_name = input_data;
  // 				// if (input_node_name != current_node_name) {
  // 				const input_node_data = data[input_node_name];
  // 				if (input_node_data) {
  // 					if (
  // 						OptimizedNodesJsonImporter.is_node_optimized(input_node_data) &&
  // 						!this._is_optimized_root_node(data, input_node_name, input_node_data)
  // 					) {
  // 						this._optimized_names_for_root(data, input_node_name, input_node_data, input_names);
  // 					}
  // 				}
  // 				// }
  // 			}
  // 		}
  // 	}
  // 	return input_names;
  // }
  // a node will be considered optimized root node if:
  // - it has no output
  // - at least one output is not optimized (as it if it has 2 outputs, and only 1 is optimized, it will not be considered root)
  static is_optimized_root_node_generic(data) {
    if (data.outputs_count == 0) {
      return true;
    }
    if (data.non_optimized_count > 0) {
      return true;
    }
    return false;
  }
  static is_optimized_root_node(data, current_node_name) {
    const output_names = this.node_outputs(data, current_node_name);
    let non_optimized_count = 0;
    output_names.forEach((node_name) => {
      const node_data = data[node_name];
      if (!this.is_node_optimized(node_data)) {
        non_optimized_count++;
      }
    });
    return this.is_optimized_root_node_generic({
      outputs_count: output_names.size,
      non_optimized_count
    });
  }
  // same algo as is_optimized_root_node, but for a node
  static is_optimized_root_node_from_node(node) {
    var _a, _b, _c, _d;
    if (!((_b = (_a = node.flags) == null ? void 0 : _a.optimize) == null ? void 0 : _b.active())) {
      return false;
    }
    const outputConnections = [];
    node.io.connections.outputConnections(outputConnections);
    const outputNodes = outputConnections.map((c) => c.nodeDest());
    let non_optimized_count = 0;
    for (let output_node of outputNodes) {
      if (!((_d = (_c = output_node.flags) == null ? void 0 : _c.optimize) == null ? void 0 : _d.active())) {
        non_optimized_count++;
      }
    }
    return this.is_optimized_root_node_generic({
      outputs_count: outputNodes.length,
      non_optimized_count
    });
  }
  static node_outputs(data, current_node_name) {
    const node_names = Object.keys(data);
    const output_node_names = /* @__PURE__ */ new Set();
    for (let node_name of node_names) {
      if (node_name != current_node_name) {
        const node_data = data[node_name];
        const inputs = node_data["inputs"];
        if (inputs) {
          for (let input_data of inputs) {
            if (CoreType.isString(input_data)) {
              const input_node_name = input_data;
              if (input_node_name == current_node_name) {
                output_node_names.add(node_name);
              }
            }
          }
        }
      }
    }
    return output_node_names;
  }
  _createOperationContainer(scene_importer, node, node_data, node_name) {
    const paramsInitValueOverrides = ParamJsonImporter.non_spare_params_data_value(node_data["params"]);
    const operation_type = _OptimizedNodesJsonImporter.operation_type(node_data);
    const createOptions = { paramsInitValueOverrides };
    const operation_container = this._node.createOperationContainer(
      operation_type,
      node_name,
      createOptions
    );
    if (operation_container) {
      this._operation_containers_by_name.set(node_name, operation_container);
      if (operation_container.pathParamResolveRequired()) {
        node.addOperationContainerWithPathParamResolveRequired(operation_container);
        scene_importer.add_operations_composer_node_with_path_param_resolve_required(node);
      }
    }
    return operation_container;
  }
  static operation_type(node_data) {
    if (_OptimizedNodesJsonImporter.is_node_bypassed(node_data)) {
      return "null";
    }
    return node_data["type"];
  }
  static is_node_optimized(node_data) {
    const node_flags = node_data["flags"];
    if (node_flags && node_flags["optimize"]) {
      return true;
    }
    return false;
  }
  static is_node_bypassed(node_data) {
    const node_flags = node_data["flags"];
    if (node_flags && node_flags["bypass"]) {
      return true;
    }
    return false;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/Nodes.js
var NodesJsonImporter = class {
  constructor(_node, dispatcher) {
    this._node = _node;
    this.dispatcher = dispatcher;
  }
  process_data(sceneImporter, data) {
    var _a;
    if (!data) {
      return;
    }
    if (!(this._node.childrenAllowed() && this._node.childrenController)) {
      return;
    }
    const { optimized_names, non_optimized_names } = OptimizedNodesJsonImporter.child_names_by_optimized_state(data);
    const nonOptimizedNodes = [];
    const migrateHelper = sceneImporter.migrateHelper();
    for (let nodeName of non_optimized_names) {
      const node_data = data[nodeName];
      const nodeType = migrateHelper ? migrateHelper.migrateNodeType(this._node, node_data) : node_data.type;
      migrateHelper == null ? void 0 : migrateHelper.migrateParams(this._node, node_data);
      const paramsInitValueOverrides = ParamJsonImporter.non_spare_params_data_value(node_data["params"]);
      const nodeCreateOptions = {
        paramsInitValueOverrides,
        nodeName
      };
      const loadNodeAttempt = (nodeType2, nodeCreateOptions2) => {
        try {
          const node2 = this._node.createNode(nodeType2, nodeCreateOptions2);
          if (node2) {
            return node2;
          }
        } catch (e) {
          console.error(`error importing node: cannot create with type ${nodeType2}`, e);
        }
      };
      let node = loadNodeAttempt(nodeType, nodeCreateOptions);
      if (!node) {
        const nodeTypeCamelCase = CoreString.camelCase(nodeType);
        node = loadNodeAttempt(nodeTypeCamelCase, nodeCreateOptions);
      }
      if (!node) {
        const nodeTypeWithNetwork = `${nodeType}Network`;
        node = loadNodeAttempt(nodeTypeWithNetwork, nodeCreateOptions);
      }
      if (node) {
        nonOptimizedNodes.push(node);
      } else {
        const message = `failed to create node with type '${nodeType}' (in '${this._node.path()}')`;
        sceneImporter.report.addWarning(message);
        Poly.warn(message);
      }
    }
    if (optimized_names.length > 0) {
      const optimized_nodes_importer = new OptimizedNodesJsonImporter(this._node);
      optimized_nodes_importer.process_data(sceneImporter, data);
      if (this._node.childrenController.context == NodeContext.SOP) {
        const nodeNames = Object.keys(data);
        let nodeNameWithDisplayFlag = void 0;
        for (let nodeName of nodeNames) {
          const nodeData = data[nodeName];
          if ((_a = nodeData.flags) == null ? void 0 : _a.display) {
            nodeNameWithDisplayFlag = nodeName;
          }
        }
        if (nodeNameWithDisplayFlag) {
          const existingNodeNames = nonOptimizedNodes.map((n) => n.name());
          const optimizedNodes = optimized_nodes_importer.nodes();
          for (let optimizedNode of optimizedNodes) {
            existingNodeNames.push(optimizedNode.name());
          }
          if (!existingNodeNames.includes(nodeNameWithDisplayFlag)) {
            const parentFullPath = this._node.path();
            const nodeFullPath = `${parentFullPath}/${nodeNameWithDisplayFlag}`;
            const message = `node '${nodeFullPath}' with display flag has been optimized and does not exist in player mode`;
            console.error(message);
          }
        }
      }
    }
    const importers_by_node_name = /* @__PURE__ */ new Map();
    for (let node of nonOptimizedNodes) {
      const child_data = data[node.name()];
      if (child_data) {
        const importer = this.dispatcher.dispatchNode(node);
        importers_by_node_name.set(node.name(), importer);
        importer.process_data(sceneImporter, data[node.name()]);
      } else {
        Poly.warn(`possible import error for node ${node.name()}`);
        Poly.log("available names are", Object.keys(data).sort(), data);
      }
    }
    for (let node of nonOptimizedNodes) {
      const importer = importers_by_node_name.get(node.name());
      if (importer) {
        importer.process_inputs_data(sceneImporter, data[node.name()]);
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/Dispatcher.js
var JsonImportDispatcher = class {
  dispatchNode(node) {
    if (node.polyNodeController) {
      return this._dispatchPolyNode(node);
    }
    return this.dispatchNonPolyNode(node);
  }
  _dispatchPolyNode(node) {
    const nodesImporter = new NodesJsonImporter(node, this);
    return new PolyNodeJsonImporter(node, this, nodesImporter);
  }
  dispatchNonPolyNode(node) {
    const nodesImporter = new NodesJsonImporter(node, this);
    return new NodeJsonImporter(node, this, nodesImporter);
  }
  dispatchParam(param) {
    if (param instanceof TypedMultipleParam) {
      return new ParamMultipleJsonImporter(param);
    }
    if (param instanceof StringParam) {
      return new ParamStringJsonImporter(param);
    }
    if (param instanceof RampParam) {
      return new ParamRampJsonImporter(param);
    }
    return new ParamJsonImporter(param);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/ImportReport.js
var ImportReport = class {
  constructor(_sceneImporter) {
    this._warnings = [];
    this._readonly = false;
    this._loadedWithoutAssemblers = false;
  }
  warnings() {
    return this._warnings;
  }
  readonly() {
    return this._readonly;
  }
  loadedWithoutAssemblers() {
    return this._loadedWithoutAssemblers;
  }
  reset() {
    this._warnings = [];
  }
  markAsLoadedWithoutAssemblers() {
    this._readonly = true;
    this._loadedWithoutAssemblers = true;
  }
  addWarning(message) {
    this._warnings.push(message);
    if (CoreFeaturesController.debugLoadProgress()) {
      console.warn(message);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/import/Scene.js
var SceneJsonImporter = class _SceneJsonImporter {
  constructor(_data, _options) {
    this._data = _data;
    this._options = _options;
    this.report = new ImportReport(this);
  }
  static async loadData(data, options) {
    const importer = new _SceneJsonImporter(data, options);
    return await importer.scene(options == null ? void 0 : options.serializers);
  }
  setMigrateHelper(migrateHelper) {
    this._migrateHelper = migrateHelper;
  }
  migrateHelper() {
    return this._migrateHelper;
  }
  oldPolygonjsSceneVersion() {
    var _a;
    const properties = this._data["properties"];
    if (properties) {
      return (_a = properties.versions) == null ? void 0 : _a.polygonjs;
    }
  }
  scene(options) {
    if (this._migrateHelper) {
      this._data = this._migrateHelper.migrateData(this._data);
    }
    if (CoreFeaturesController.debugLoadProgress()) {
      console.log(`polygonjs version:${this.oldPolygonjsSceneVersion()}`);
    }
    const rootData = this._data["root"];
    const paramsInitValueOverrides = ParamJsonImporter.non_spare_params_data_value(rootData["params"]);
    const nodeCreateOptions = {
      paramsInitValueOverrides,
      nodeName: ROOT_NODE_NAME,
      serializerClass: options == null ? void 0 : options.nodeSerializerClass
    };
    const embeddedPolyNodes = this._data.embeddedPolyNodes;
    if (embeddedPolyNodes) {
      const keys = Object.keys(embeddedPolyNodes);
      for (let key of keys) {
        const elements = key.split("/");
        const nodeContext = elements[0];
        const nodeType = elements[1];
        const data = embeddedPolyNodes[key];
        PolyNodeController.createNodeClassAndRegister({
          node_context: nodeContext,
          node_type: nodeType,
          data
        });
      }
    }
    const scene = new PolyScene({ root: nodeCreateOptions, paramsSerializerClass: options == null ? void 0 : options.paramsSerializerClass });
    if (this._options) {
      if (this._options.sceneName) {
        scene.setName(this._options.sceneName);
      }
      if (this._options.measurePerformanceOnLoad == true) {
        scene.performance.start();
      }
    }
    scene.loadingController.markAsLoading();
    const properties = this._data["properties"];
    if (properties) {
      const maxFrame = properties["maxFrame"] || 600;
      scene.timeController.setMaxFrame(maxFrame);
      const maxFrameLocked = properties["maxFrameLocked"];
      if (maxFrameLocked) {
        scene.timeController.setMaxFrameLocked(maxFrameLocked);
      }
      const realtimeState = properties["realtimeState"];
      if (realtimeState != null) {
        scene.timeController.setRealtimeState(realtimeState);
      }
      scene.setFrame(properties["frame"] || TimeController.START_FRAME);
      const mainCameraPath = properties["mainCameraNodePath"] || properties["mainCameraPath"];
      if (mainCameraPath) {
        scene.camerasController.setMainCameraPath(mainCameraPath);
      }
    }
    scene.cooker.block();
    this._base_operations_composer_nodes_with_resolve_required = void 0;
    const dispatcher = new JsonImportDispatcher();
    const importer = dispatcher.dispatchNode(scene.root());
    if (rootData) {
      importer.process_data(this, rootData);
    }
    const uiData = this._data["ui"];
    if (uiData) {
      importer.process_ui_data(this, uiData);
    }
    this._resolve_operation_containers_with_path_param_resolve();
    if (this._options) {
      if (this._options.nodeCookWatcher) {
        this._options.nodeCookWatcher(scene);
      }
      if (this._options.configureScene) {
        this._options.configureScene(scene);
      }
    }
    scene.loadingController.markAsLoaded();
    scene.cooker.unblock();
    return scene;
  }
  shadersData() {
    return this._data["shaders"];
  }
  jsFunctionBodiesData() {
    return this._data["jsFunctionBodies"];
  }
  //
  //
  // OPERATION CONTAINER RESOLVE
  //
  //
  add_operations_composer_node_with_path_param_resolve_required(operations_composer_node) {
    if (!this._base_operations_composer_nodes_with_resolve_required) {
      this._base_operations_composer_nodes_with_resolve_required = [];
    }
    this._base_operations_composer_nodes_with_resolve_required.push(operations_composer_node);
  }
  _resolve_operation_containers_with_path_param_resolve() {
    if (!this._base_operations_composer_nodes_with_resolve_required) {
      return;
    }
    for (let operations_composer_node of this._base_operations_composer_nodes_with_resolve_required) {
      operations_composer_node.resolveOperationContainersPathParams();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/sanitize.js
function sanitizeExportedString(word) {
  word = word.replace(/'/g, "'");
  word = CoreString.escapeLineBreaks(word);
  return word;
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/Node.js
var NodeJsonExporter = class {
  // = {} as NodeJsonExporterData;
  constructor(_node, dispatcher) {
    this._node = _node;
    this.dispatcher = dispatcher;
  }
  async data(options) {
    var _a, _b, _c, _d, _e, _f;
    if (!this._isRoot()) {
      this._node.scene().nodesController.registerNodeContextSignature(this._node);
    }
    this._data = {
      type: this._node.type()
    };
    if (this._node.polyNodeController) {
      this._data["polyNode"] = {
        locked: this._node.polyNodeController.locked()
      };
    }
    const nodes_data = await this.nodes_data(options);
    if (Object.keys(nodes_data).length > 0) {
      this._data["nodes"] = nodes_data;
    }
    const params_data = this.params_data();
    if (Object.keys(params_data).length > 0) {
      this._data["params"] = params_data;
    }
    if (!this._isRoot()) {
      if (this._node.io.inputs.maxInputsCountOverriden()) {
        this._data["maxInputsCount"] = this._node.io.inputs.maxInputsCount();
      }
      const inputs_data = this.inputs_data();
      if (inputs_data.length > 0) {
        this._data["inputs"] = inputs_data;
      }
      const connection_points_data = this.connection_points_data();
      if (connection_points_data) {
        this._data["connection_points"] = connection_points_data;
      }
    }
    if (this._node.flags) {
      const flags_data = {};
      if (this._node.flags.hasBypass() || this._node.flags.hasDisplay() || this._node.flags.hasOptimize()) {
        if (this._node.flags.hasBypass()) {
          if ((_a = this._node.flags.bypass) == null ? void 0 : _a.active()) {
            flags_data["bypass"] = this._node.flags.bypass.active();
          }
        }
        if (this._node.flags.hasDisplay()) {
          if (((_b = this._node.flags.display) == null ? void 0 : _b.active()) || !((_c = this._node.parent()) == null ? void 0 : _c.displayNodeController)) {
            flags_data["display"] = (_d = this._node.flags.display) == null ? void 0 : _d.active();
          }
        }
        if (this._node.flags.hasOptimize()) {
          if ((_e = this._node.flags.optimize) == null ? void 0 : _e.active()) {
            flags_data["optimize"] = (_f = this._node.flags.optimize) == null ? void 0 : _f.active();
          }
        }
      }
      if (Object.keys(flags_data).length > 0) {
        this._data["flags"] = flags_data;
      }
    }
    if (this._node.io.inputs.overrideClonedStateAllowed()) {
      const overriden = this._node.io.inputs.clonedStateOverriden();
      if (overriden) {
        this._data["cloned_state_overriden"] = overriden;
      }
    }
    const withPersistedConfig = options.withPersistedConfig == null ? true : options.withPersistedConfig;
    if (withPersistedConfig == true) {
      const persisted_config = this._node.persisted_config;
      if (persisted_config) {
        const persisted_config_data = options.showPolyNodesData ? await persisted_config.toData() : await persisted_config.toDataWithoutShaders();
        if (persisted_config_data) {
          this._data.persisted_config = persisted_config_data;
        }
      }
    }
    this.add_custom();
    return this._data;
  }
  uiData(options) {
    const data = this.ui_data_without_children();
    const children = this._node.children();
    if (children.length > 0) {
      const nodesData = {};
      for (let child of children) {
        const node_exporter = this.dispatcher.dispatchNode(child);
        nodesData[child.name()] = node_exporter.uiData(options);
      }
      data["nodes"] = nodesData;
    }
    return data;
  }
  ui_data_without_children() {
    var _a;
    const data = {};
    if (!this._isRoot()) {
      const ui_data = this._node.uiData;
      data["pos"] = ui_data.position().toArray();
      const comment = ui_data.comment();
      if (comment) {
        data["comment"] = sanitizeExportedString(comment);
      }
      if (this._node.childrenAllowed()) {
        const selection = (_a = this._node.childrenController) == null ? void 0 : _a.selection;
        if (selection && this._node.children().length > 0) {
          const selected_children = [];
          const selected_ids = {};
          const selectedNodes = [];
          selection.nodes(selectedNodes);
          for (const selected_node of selectedNodes) {
            selected_ids[selected_node.graphNodeId()] = true;
          }
          for (const child of this._node.children()) {
            if (child.graphNodeId() in selected_ids) {
              selected_children.push(child);
            }
          }
          const selection_data = selected_children.map((n) => n.name());
          if (selection_data.length > 0) {
            data["selection"] = selection_data;
          }
        }
      }
    }
    return data;
  }
  async persistedConfigData(shadersData, jsFunctionBodiesData, options) {
    const children = this._node.children();
    if (children.length > 0) {
      for (let child of children) {
        const node_exporter = this.dispatcher.dispatchNode(child);
        await node_exporter.persistedConfigData(shadersData, jsFunctionBodiesData, options);
      }
    }
    if (this._node.persisted_config) {
      const persisted_config_data = await this._node.persisted_config.toData();
      if (persisted_config_data) {
        if (persisted_config_data.shaders) {
          shadersData[this._node.path()] = persisted_config_data.shaders;
          return;
        }
        if (persisted_config_data.functionBody != null) {
          if (isString(persisted_config_data.functionBody)) {
            jsFunctionBodiesData[this._node.path()] = persisted_config_data.functionBody;
            return;
          } else {
            const dict = {};
            const keys = Object.keys(persisted_config_data.functionBody);
            for (let key of keys) {
              dict[key] = persisted_config_data.functionBody[key];
            }
            jsFunctionBodiesData[this._node.path()] = dict;
            return;
          }
        }
        console.warn(`persisted config data not handled`, persisted_config_data);
      }
    }
  }
  // async jsFunctionBodies(data: NodeJSONFunctionBodiesData, options: JSONExporterDataRequestOption = {}): Promise<void> {
  // 	const children = this._node.children();
  // 	if (children.length > 0) {
  // 		for (let child of children) {
  // 			const node_exporter = this.dispatcher.dispatchNode(child);
  // 			await node_exporter.jsFunctionBodies(data);
  // 		}
  // 	}
  // 	if (this._node.persisted_config) {
  // 		const persisted_config_data = await this._node.persisted_config.toData();
  // 		if (persisted_config_data && persisted_config_data.functionBody) {
  // 			data[this._node.path()] = persisted_config_data.functionBody
  // 		}
  // 	}
  // }
  _isRoot() {
    return this._node.parent() === null && this._node.graphNodeId() == this._node.root().graphNodeId();
  }
  inputs_data() {
    const data = [];
    this._node.io.inputs.inputs().forEach((input, input_index) => {
      var _a, _b;
      if (input) {
        const connection = this._node.io.connections.inputConnection(input_index);
        if (this._node.io.inputs.hasNamedInputs()) {
          const inputConnectionPoints = this._node.io.inputs.namedInputConnectionPoints();
          const outputConnectionPoints = input.io.outputs.namedOutputConnectionPoints();
          if (inputConnectionPoints && outputConnectionPoints) {
            const inputName = (_a = inputConnectionPoints[input_index]) == null ? void 0 : _a.name();
            const output_index = connection.outputIndex();
            const output_name = (_b = outputConnectionPoints[output_index]) == null ? void 0 : _b.name();
            if (output_name) {
              data[input_index] = {
                index: input_index,
                inputName,
                node: input.name(),
                output: output_name
              };
            }
          }
        } else {
          data[input_index] = input.name();
        }
      }
    });
    return data;
  }
  connection_points_data() {
    if (!this._node.io.has_connection_points_controller) {
      return;
    }
    if (!this._node.io.connection_points.initialized()) {
      return;
    }
    if (this._node.io.inputs.hasNamedInputs() || this._node.io.outputs.hasNamedOutputs()) {
      const data = {};
      if (this._node.io.inputs.hasNamedInputs()) {
        data["in"] = [];
        const connectionPoints = this._node.io.inputs.namedInputConnectionPoints();
        if (connectionPoints) {
          for (let cp of connectionPoints) {
            if (cp) {
              data["in"].push(cp.toJSON());
            }
          }
        }
      }
      if (this._node.io.outputs.hasNamedOutputs()) {
        data["out"] = [];
        const connectionPoints = this._node.io.outputs.namedOutputConnectionPoints();
        if (connectionPoints) {
          for (let cp of connectionPoints) {
            if (cp) {
              data["out"].push(cp.toJSON());
            }
          }
        }
      }
      return data;
    }
  }
  params_data() {
    const data = {};
    for (let param_name of this._node.params.names) {
      const param = this._node.params.get(param_name);
      if (param && !param.parentParam()) {
        const param_exporter = this.dispatcher.dispatchParam(param);
        if (param_exporter.required()) {
          const params_data = param_exporter.data();
          data[param.name()] = params_data;
        }
      }
    }
    return data;
  }
  async nodes_data(options) {
    const data = {};
    for (let child of this._node.children()) {
      const node_exporter = this.dispatcher.dispatchNode(child);
      data[child.name()] = await node_exporter.data(options);
    }
    return data;
  }
  add_custom() {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/Param.js
var ParamJsonExporter = class {
  constructor(_param) {
    this._param = _param;
    this._complex_data = {};
  }
  required() {
    const is_spare_and_not_component = this._param.options.isSpare() && !this._param.parentParam();
    const value_changed = !this._param.isDefault();
    return is_spare_and_not_component || value_changed || this._param.options.hasOptionsOverridden();
  }
  data() {
    if (this._param.parentParam()) {
      console.warn("no component should be saved");
      throw "no component should be saved";
    }
    if (this._require_data_complex()) {
      return this._data_complex();
    } else {
      return this._data_simple();
    }
  }
  _data_simple() {
    return this._param.rawInputSerialized();
  }
  _data_complex() {
    this._complex_data = {};
    if (this._param.options.isSpare() && !this._param.parentParam()) {
      this._complex_data["type"] = this._param.type();
      this._complex_data["default_value"] = this._param.defaultValueSerialized();
      this._complex_data["options"] = this._param.options.current();
    }
    if (!this._param.isDefault()) {
      this._complex_data["raw_input"] = this._param.rawInputSerialized();
    }
    if (this._param.options.hasOptionsOverridden()) {
      const overridden_options = {};
      const options_overridden = this._param.options.overriddenOptions();
      for (let option_name of Object.keys(options_overridden)) {
        const option_value = options_overridden[option_name];
        if (CoreType.isString(option_value) || CoreType.isNumber(option_value)) {
          overridden_options[option_name] = option_value;
        } else {
          overridden_options[option_name] = JSON.stringify(option_value);
        }
      }
      this._complex_data["overriden_options"] = overridden_options;
    }
    return this._complex_data;
  }
  _require_data_complex() {
    if (this._param.options.isSpare()) {
      return true;
    }
    if (this._param.options.hasOptionsOverridden()) {
      return true;
    }
    return false;
  }
  // default_value(): ParamValueSerialized {
  // 	return this._param.defaultValueSerialized();
  // }
  // cannot remember why this is useful, but it messes up
  // with gl nodes like the noise node, as the default value
  // gets saved as a string '[1,1]' instead of an array [1,1] (should be without quotes)
  // protected default_value(){
  // 	let default_value = this._param.default_value()
  // 	if(CoreType.isString(default_value)){
  // 		default_value = `'${default_value}'`
  // 	}
  // 	if (CoreType.isArray(default_value)){
  // 		default_value = `[${default_value}]`
  // 	}
  // 	return default_value
  // }
  add_main() {
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/param/Numeric.js
var ParamNumericJsonExporter = class extends ParamJsonExporter {
  add_main() {
    if (this._require_data_complex()) {
      this._complex_data["raw_input"] = this._param.rawInputSerialized();
    } else {
      return this._param.rawInputSerialized();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/param/NodePath.js
var ParamNodePathJsonExporter = class extends ParamJsonExporter {
  add_main() {
    let val = this._param.rawInput();
    val = sanitizeExportedString(val);
    if (this._require_data_complex()) {
      this._complex_data["raw_input"] = val;
    } else {
      return val;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/param/ParamPath.js
var ParamParamPathJsonExporter = class extends ParamJsonExporter {
  add_main() {
    let val = this._param.rawInput();
    val = sanitizeExportedString(val);
    if (this._require_data_complex()) {
      this._complex_data["raw_input"] = val;
    } else {
      return val;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/param/String.js
var ParamStringJsonExporter = class extends ParamJsonExporter {
  add_main() {
    let val = this._param.rawInput();
    val = sanitizeExportedString(val);
    if (this._require_data_complex()) {
      this._complex_data["raw_input"] = val;
    } else {
      return val;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/param/Ramp.js
var ParamRampJsonExporter = class extends ParamJsonExporter {
  add_main() {
    if (this._require_data_complex()) {
      this._complex_data["raw_input"] = this._param.rawInputSerialized();
    } else {
      return this._param.rawInputSerialized();
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/nodes/Poly.js
var PolyNodeJsonExporter = class extends NodeJsonExporter {
  async nodes_data(options) {
    var _a;
    if (options.showPolyNodesData || !((_a = this._node.polyNodeController) == null ? void 0 : _a.locked())) {
      return await super.nodes_data(options);
    }
    return {};
  }
  uiData(options) {
    var _a;
    if (options.showPolyNodesData || !((_a = this._node.polyNodeController) == null ? void 0 : _a.locked())) {
      return super.uiData(options);
    } else {
      return this.ui_data_without_children();
    }
  }
  async persistedConfigData(shadersData, jsFunctionBodiesData, options) {
    var _a;
    if (options.showPolyNodesData || !((_a = this._node.polyNodeController) == null ? void 0 : _a.locked())) {
      return await super.persistedConfigData(shadersData, jsFunctionBodiesData, options);
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/io/json/export/Dispatcher.js
var JsonExportDispatcher = class {
  dispatchNode(node) {
    if (node.polyNodeController) {
      return new PolyNodeJsonExporter(node, this);
    }
    return new NodeJsonExporter(node, this);
  }
  dispatchParam(param) {
    if (param instanceof TypedNumericParam) {
      return new ParamNumericJsonExporter(param);
    }
    if (param instanceof NodePathParam) {
      return new ParamNodePathJsonExporter(param);
    }
    if (param instanceof ParamPathParam) {
      return new ParamParamPathJsonExporter(param);
    }
    if (param instanceof StringParam) {
      return new ParamStringJsonExporter(param);
    }
    if (param instanceof RampParam) {
      return new ParamRampJsonExporter(param);
    }
    return new ParamJsonExporter(param);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/utils/poly/PolyNodeController.js
var _PolyNodeController = class {
  constructor(node, _definition) {
    this.node = node;
    this._definition = _definition;
    this._locked = true;
  }
  static registerCreatePolyNodeFunctionForContext(context, createPolyNodeFunction) {
    this._createPolyNodeFunctionByContext.set(context, createPolyNodeFunction);
  }
  initializeNode() {
    this._initInputs();
    this.node.lifecycle.onAfterCreated(() => {
      this.createChildNodesFromDefinition();
    });
  }
  locked() {
    return this._locked;
  }
  setLockedState(state) {
    if (state == this._locked) {
      return;
    }
    this._locked = state;
    this.node.emit(NodeEvent.POLY_NODE_LOCK_STATE_UPDATED);
  }
  _initInputs() {
    const inputsData = this._definition.inputs;
    if (!inputsData) {
      return;
    }
    const simpleData = inputsData.simple;
    if (simpleData) {
      this.node.io.inputs.setCount(simpleData.min, simpleData.max);
    }
  }
  // private _createParamsFromDefinition() {
  // 	const paramsData = this._definition.params;
  // 	if (!paramsData) {
  // 		return;
  // 	}
  // 	for (let paramData of paramsData) {
  // 		paramData.options = paramData.options || {};
  // 		paramData.options.spare = true;
  // 	}
  // 	this.node.params.updateParams({toAdd: paramsData});
  // }
  static setupParamsConfig(paramsConfig, data) {
    if (!data.params) {
      return;
    }
    for (const paramData of data.params) {
      const paramName = paramData.name;
      const paramType = paramData.type;
      const initValue = paramData.initValue;
      const options = paramData.options;
      paramsConfig[paramName] = new ParamTemplate(paramType, initValue, options);
    }
  }
  createChildNodesFromDefinition() {
    const childrenData = this._definition.nodes;
    if (!childrenData) {
      return;
    }
    const currentSceneLoadedState = this.node.scene().loadingController.loaded();
    if (currentSceneLoadedState) {
      this.node.scene().loadingController.markAsLoading();
    }
    const oldLockedState = this.locked();
    this.setLockedState(false);
    const sceneImporter = new SceneJsonImporter({});
    const dispatcher = new JsonImportDispatcher();
    const nodeImporter = dispatcher.dispatchNonPolyNode(this.node);
    const exporterData = {
      // ...this._definition,
      type: this.node.type(),
      polyNode: {
        locked: true
      }
    };
    nodeImporter.create_nodes(sceneImporter, childrenData, exporterData);
    const uiData = this._definition.ui;
    if (uiData) {
      nodeImporter.processNodesUiData(sceneImporter, uiData);
    }
    if (currentSceneLoadedState) {
      this.node.scene().loadingController.markAsLoaded();
    }
    this.setLockedState(oldLockedState);
  }
  static inputsData(node) {
    if (node.io.inputs.hasNamedInputs()) {
      const inputs = node.io.inputs;
      const connectionPoints = [];
      const namedInputConnectionPoints = inputs.namedInputConnectionPoints();
      if (namedInputConnectionPoints) {
        arrayCompact(namedInputConnectionPoints, connectionPoints);
      }
      return {
        typed: {
          types: connectionPoints.map((cp) => {
            return {
              name: cp.name(),
              type: cp.type()
            };
          })
        }
      };
    } else {
      return {
        simple: {
          min: node.io.inputs.minCount(),
          max: node.io.inputs.maxInputsCount(),
          names: node.displayedInputNames()
        }
      };
    }
  }
  static async polyNodeData(node, inputsData) {
    const dispatcher = new JsonExportDispatcher();
    const rootExporter = dispatcher.dispatchNode(node);
    const nodesData = await rootExporter.data({ showPolyNodesData: true });
    const uiData = rootExporter.uiData({ showPolyNodesData: true });
    const nodeInputsData = inputsData || this.inputsData(node);
    const data = {
      metadata: {
        version: {
          polygonjs: "1"
        },
        createdAt: 1
      },
      nodeContext: node.context(),
      inputs: nodeInputsData,
      params: node.params.non_spare.filter((p) => p.parentParam() == null).map((param) => {
        const paramData = {
          name: param.name(),
          type: param.type(),
          initValue: param.defaultValueSerialized(),
          rawInput: param.rawInputSerialized(),
          options: param.options.current()
        };
        return paramData;
      }),
      nodes: nodesData.nodes,
      ui: uiData.nodes
    };
    return data;
  }
  static _createNodeClass(nodeContext, nodeType, data) {
    const createFunction = this._createPolyNodeFunctionByContext.get(nodeContext);
    if (!createFunction) {
      return;
    }
    return createFunction(nodeType, data, _PolyNodeController);
  }
  static createNodeClassAndRegister(dataRegister) {
    const { node_context, node_type, data } = dataRegister;
    const nodeClass = this._createNodeClass(node_context, node_type, data);
    if (nodeClass) {
      let registerMapForContext = this._definitionRegister.get(node_context);
      if (!registerMapForContext) {
        registerMapForContext = /* @__PURE__ */ new Map();
        this._definitionRegister.set(node_context, registerMapForContext);
      }
      registerMapForContext.set(node_type, data);
      Poly.registerNode(nodeClass, "polyNodes", { polyNode: true });
    } else {
      console.warn("failed to create node from definition", node_context, node_type, data);
    }
  }
  static definition(context, type) {
    var _a;
    return (_a = this._definitionRegister.get(context)) == null ? void 0 : _a.get(type);
  }
  static register() {
    return this._definitionRegister;
  }
};
var PolyNodeController = _PolyNodeController;
PolyNodeController._createPolyNodeFunctionByContext = /* @__PURE__ */ new Map();
PolyNodeController._definitionRegister = /* @__PURE__ */ new Map();

export {
  RootLoadProgressController,
  PolyNodeController,
  SceneJsonImporter
};
//# sourceMappingURL=chunk-HHVLJK6G.js.map
