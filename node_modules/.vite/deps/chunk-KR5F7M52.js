import {
  ThreeToGl
} from "./chunk-BKKMVJB3.js";
import {
  BasePersistedConfig
} from "./chunk-LTBPBA52.js";
import {
  BaseController,
  PrimitiveMatNode
} from "./chunk-DPUZQYKG.js";
import {
  CustomMaterialName,
  NodeParamsConfig,
  OnBeforeCompileDataConverter,
  ParamConfig,
  TypeAssert,
  assignOnBeforeCompileDataAndFunction
} from "./chunk-FUAFRKQ7.js";
import {
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import {
  NodeContext
} from "./chunk-PQDBXNT6.js";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/UniformsTransparencyController.js
function UniformsTransparencyParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.transparent = ParamConfig.BOOLEAN(0);
      this.opacity = ParamConfig.FLOAT(1);
      this.alphaTest = ParamConfig.FLOAT(0);
    }
  };
}
var TransparencyParamsConfig = class extends UniformsTransparencyParamConfig(NodeParamsConfig) {
};
var UniformsTransparencyController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!material) {
      return;
    }
    node.controllers.uniformTransparency.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    this._updateTransparency(material, pv);
  }
  _updateTransparency(mat, pv) {
    mat.transparent = isBooleanTrue(pv.transparent);
    this._updateCommon(mat, pv);
  }
  _updateCommon(mat, pv) {
    const shaderMaterial = mat;
    if (shaderMaterial.uniforms && shaderMaterial.uniforms.opacity) {
      shaderMaterial.uniforms.opacity.value = pv.opacity;
    }
    mat.opacity = pv.opacity;
    if (shaderMaterial.uniforms && shaderMaterial.uniforms.alphaTest) {
      shaderMaterial.uniforms.alphaTest.value = pv.alphaTest;
    }
    mat.alphaTest = pv.alphaTest;
    const customMaterials = mat.customMaterials;
    if (customMaterials) {
      const customNames = Object.keys(customMaterials);
      for (const customName of customNames) {
        const customMaterial = customMaterials[customName];
        if (customMaterial) {
          this._updateCommon(customMaterial, pv);
        }
      }
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/gl/code/assemblers/materials/MaterialPersistedConfig.js
function _removeShaders(data) {
  const onBeforeCompileDataJSONWithoutShaders = {
    paramConfigs: data.paramConfigs,
    timeDependent: data.timeDependent,
    resolutionDependent: data.resolutionDependent,
    raymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent
  };
  return onBeforeCompileDataJSONWithoutShaders;
}
function _addShaders(data, options) {
  const onBeforeCompileDataJSON = {
    paramConfigs: data.paramConfigs,
    timeDependent: data.timeDependent,
    resolutionDependent: data.resolutionDependent,
    raymarchingLightsWorldCoordsDependent: data.raymarchingLightsWorldCoordsDependent,
    fragmentShader: options.fragment,
    vertexShader: options.vertex
  };
  return onBeforeCompileDataJSON;
}
function _shaderKey(shaderType, customMaterialName) {
  return customMaterialName ? `${customMaterialName}.${shaderType}` : shaderType;
}
var MaterialPersistedConfig = class extends BasePersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
  async toData() {
    const assemblerController = this.node.assemblerController();
    if (!assemblerController) {
      return;
    }
    const assembler = assemblerController.assembler;
    const onBeforeCompileData = assembler.onBeforeCompileData();
    if (!onBeforeCompileData) {
      return;
    }
    const onBeforeCompileDataJSON = OnBeforeCompileDataConverter.toJSON(onBeforeCompileData);
    const onBeforeCompileDataJSONWithoutShaders = _removeShaders(onBeforeCompileDataJSON);
    const shaders = {
      [_shaderKey("vertex")]: onBeforeCompileDataJSON.vertexShader,
      [_shaderKey("fragment")]: onBeforeCompileDataJSON.fragmentShader
    };
    const customMaterialsData = {};
    const material = await this.node.material();
    if (!material) {
      return;
    }
    const customMaterials = material.customMaterials;
    if (customMaterials) {
      assembler.traverseCustomAssemblers((customAssembler, customMaterialName) => {
        const customOnBeforeCompileData = customAssembler.onBeforeCompileData();
        if (customOnBeforeCompileData) {
          const customMaterial = customMaterials[customMaterialName];
          if (customMaterial) {
            const customMaterialData = this._materialToJson(customMaterial, {
              node: this.node,
              suffix: customMaterialName
            });
            if (customMaterialData) {
              const data2 = OnBeforeCompileDataConverter.toJSON(customOnBeforeCompileData);
              const dataWithoutShaders = _removeShaders(data2);
              customMaterialsData[customMaterialName] = {
                material: customMaterialData,
                onBeforeCompileDataJSONWithoutShaders: dataWithoutShaders
              };
              shaders[_shaderKey("vertex", customMaterialName)] = data2.vertexShader;
              shaders[_shaderKey("fragment", customMaterialName)] = data2.fragmentShader;
            }
          }
        }
      });
    }
    const materialData = this._materialToJson(material, {
      node: this.node,
      suffix: "main"
    });
    if (!materialData) {
      console.warn("failed to save material from node", this.node.path());
    }
    const data = {
      material: materialData || {},
      onBeforeCompileDataJSONWithoutShaders,
      // uniforms_time_dependent: assemblerController.assembler.uniformsTimeDependent(),
      // uniforms_resolution_dependent: assemblerController.assembler.uniformsResolutionDependent(),
      // param_uniform_pairs: param_uniform_pairs,
      customMaterials: customMaterialsData,
      shaders
    };
    return data;
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    this._material = this._loadMaterial(data.material);
    if (!this._material) {
      return;
    }
    const shaders = data.shaders;
    if (!shaders) {
      console.warn(`${this.node.path()}: persisted config has no shaders`);
      return;
    }
    const onBeforeCompileDataJSON = _addShaders(
      data.onBeforeCompileDataJSONWithoutShaders,
      {
        vertex: shaders[_shaderKey("vertex")],
        fragment: shaders[_shaderKey("fragment")]
      }
    );
    const onBeforeCompileData = OnBeforeCompileDataConverter.fromJSON(onBeforeCompileDataJSON);
    const material = this._material;
    assignOnBeforeCompileDataAndFunction(this.node.scene(), material, onBeforeCompileData);
    for (let paramConfig of onBeforeCompileData.paramConfigs) {
      paramConfig.applyToNode(this.node);
    }
    this._material.customMaterials = this._material.customMaterials || {};
    if (data.customMaterials) {
      const customMatNames = Object.keys(data.customMaterials);
      for (const customMatName of customMatNames) {
        const customMatData = data.customMaterials[customMatName];
        const customMat = this._loadMaterial(customMatData.material);
        if (customMat) {
          const onBeforeCompileDataJSON2 = _addShaders(
            customMatData.onBeforeCompileDataJSONWithoutShaders,
            {
              vertex: shaders[_shaderKey("vertex", customMatName)],
              fragment: shaders[_shaderKey("fragment", customMatName)]
            }
          );
          const customOnBeforeCompileData = OnBeforeCompileDataConverter.fromJSON(onBeforeCompileDataJSON2);
          customOnBeforeCompileData.paramConfigs = onBeforeCompileData.paramConfigs;
          assignOnBeforeCompileDataAndFunction(this.node.scene(), customMat, customOnBeforeCompileData);
          this._material.customMaterials[customMatName] = customMat;
        }
      }
    }
  }
  material() {
    return this._material;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/_BaseBuilder.js
function BaseBuilderParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.setBuilderNode = ParamConfig.BOOLEAN(0, {
        callback: (node) => {
          TypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node);
        }
      });
      this.builderNode = ParamConfig.NODE_PATH("", {
        visibleIf: { setBuilderNode: true },
        callback: (node) => {
          TypedBuilderMatNode.PARAM_CALLBACK_setCompileRequired(node);
        }
      });
    }
  };
}
var MatBuilderParamsConfig = class extends BaseBuilderParamConfig(NodeParamsConfig) {
};
var TypedBuilderMatNode = class extends PrimitiveMatNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = NodeContext.GL;
    this.persisted_config = new MaterialPersistedConfig(this);
  }
  //
  //
  // MATERIAL
  //
  //
  createMaterial() {
    var _a;
    let material;
    if (this.persisted_config) {
      material = this.persisted_config.material();
    }
    if (!material) {
      material = (_a = this.assemblerController()) == null ? void 0 : _a.assembler.createMaterial();
    }
    return material;
  }
  //
  //
  // ASSEMBLER
  //
  //
  assemblerController() {
    return this._assemblerController = this._assemblerController || this._createAssemblerController();
  }
  customMaterialRequested(customName) {
    return true;
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  //
  //
  // COMPILATION
  //
  //
  compileIfRequired(material) {
    var _a;
    if ((_a = this.assemblerController()) == null ? void 0 : _a.compileRequired()) {
      try {
        this._compile(material);
      } catch (err) {
        const message = err.message || "failed to compile";
        this.states.error.set(message);
      }
    }
  }
  _compile(material) {
    const assemblerController = this.assemblerController();
    if (material && assemblerController) {
      assemblerController.assembler.setGlParentNode(this);
      this._setAssemblerGlParentNode(assemblerController);
      assemblerController.assembler.compileMaterial(material);
      assemblerController.post_compile();
    }
  }
  _setAssemblerGlParentNode(assemblerController) {
    if (!isBooleanTrue(this.pv.setBuilderNode)) {
      return;
    }
    const resolvedNode = this.pv.builderNode.nodeWithContext(NodeContext.MAT);
    if (!resolvedNode) {
      return;
    }
    const resolvedBuilderNode = resolvedNode;
    if (!resolvedBuilderNode.assemblerController()) {
      this.states.error.set(`resolved node '${resolvedNode.path()}' is not a builder node`);
      return;
    }
    if (resolvedBuilderNode.type() != this.type()) {
      this.states.error.set(
        `resolved node '${resolvedNode.path()}' does not have the same type '${resolvedNode.type()}' as current node '${this.type()}'`
      );
      return;
    }
    assemblerController.assembler.setGlParentNode(resolvedBuilderNode);
  }
  static PARAM_CALLBACK_setCompileRequired(node) {
    node.PARAM_CALLBACK_setCompileRequired();
  }
  PARAM_CALLBACK_setCompileRequired() {
    var _a;
    (_a = this.assemblerController()) == null ? void 0 : _a.setCompilationRequired(true);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/UniformsFogController.js
function FogParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.useFog = ParamConfig.BOOLEAN(0);
    }
  };
}
var FogUniformsParamsConfig = class extends FogParamConfig(NodeParamsConfig) {
};
function isValidFogMaterial(material) {
  if (!material) {
    return false;
  }
  return material.fog != null;
}
var UniformFogController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!isValidFogMaterial(material)) {
      return;
    }
    node.controllers.uniformFog.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.fog = isBooleanTrue(pv.useFog);
  }
  getTextures(material, record) {
  }
  setParamsFromMaterial(material, record) {
    this.node.p.useFog.set(material.fog);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/WireframeShaderMaterialController.js
function WireframeShaderMaterialParamsConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.wireframe = ParamConfig.BOOLEAN(0);
      this.wireframeLinewidth = ParamConfig.FLOAT(1, {
        range: [0, 5],
        rangeLocked: [true, false],
        visibleIf: { wireframe: 1 }
      });
    }
  };
}
var WireframeShaderParamsConfig = class extends WireframeShaderMaterialParamsConfig(NodeParamsConfig) {
};
var WireframeShaderMaterialController = class extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!material) {
      return;
    }
    node.controllers.wireframeShader.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    const shaderMaterial = material;
    if (shaderMaterial.wireframe != null) {
      shaderMaterial.wireframe = isBooleanTrue(pv.wireframe);
      shaderMaterial.wireframeLinewidth = pv.wireframeLinewidth;
      shaderMaterial.needsUpdate = true;
    }
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSS.glsl.js
var PCSS_glsl_default = "#define LIGHT_WORLD_SIZE 0.005\n// #define LIGHT_FRUSTUM_WIDTH 1.0\n// #define PCSS_FILTER_SIZE 1.0\n#define LIGHT_SIZE_UV (PCSS_FILTER_SIZE * LIGHT_WORLD_SIZE)\n#define NEAR_PLANE 9.5\n\n#define NUM_SAMPLES 17\n#define NUM_RINGS 11\n#define BLOCKER_SEARCH_NUM_SAMPLES NUM_SAMPLES\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples( const in vec2 randomSeed ) {\n	float ANGLE_STEP = PI2 * float( NUM_RINGS ) / float( NUM_SAMPLES );\n	float INV_NUM_SAMPLES = 1.0 / float( NUM_SAMPLES );\n\n	// jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n	float angle = rand( randomSeed ) * PI2;\n	float radius = INV_NUM_SAMPLES;\n	float radiusStep = radius;\n\n	for( int i = 0; i < NUM_SAMPLES; i ++ ) {\n		poissonDisk[i] = vec2( cos( angle ), sin( angle ) ) * pow( radius, 0.75 );\n		radius += radiusStep;\n		angle += ANGLE_STEP;\n	}\n}\n\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n	return (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker( sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n	// This uses similar triangles to compute what\n	// area of the shadow map we should search\n	float searchRadius = LIGHT_SIZE_UV * ( zReceiver - NEAR_PLANE ) / zReceiver;\n	float blockerDepthSum = 0.0;\n	int numBlockers = 0;\n\n	for( int i = 0; i < BLOCKER_SEARCH_NUM_SAMPLES; i++ ) {\n		float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n		if ( shadowMapDepth < zReceiver ) {\n			blockerDepthSum += shadowMapDepth;\n			numBlockers ++;\n		}\n	}\n\n	if( numBlockers == 0 ) return -1.0;\n\n	return blockerDepthSum / float( numBlockers );\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius ) {\n	float sum = 0.0;\n	float depth;\n	#pragma unroll_loop_start\n	for( int i = 0; i < 17; i ++ ) {\n		depth = unpackRGBAToDepth( texture2D( shadowMap, uv + poissonDisk[ i ] * filterRadius ) );\n		if( zReceiver <= depth ) sum += 1.0;\n	}\n	#pragma unroll_loop_end\n	#pragma unroll_loop_start\n	for( int i = 0; i < 17; i ++ ) {\n		depth = unpackRGBAToDepth( texture2D( shadowMap, uv + -poissonDisk[ i ].yx * filterRadius ) );\n		if( zReceiver <= depth ) sum += 1.0;\n	}\n	#pragma unroll_loop_end\n	return sum / ( 2.0 * float( 17 ) );\n}\n\nfloat PCSS ( sampler2D shadowMap, vec4 coords ) {\n	vec2 uv = coords.xy;\n	float zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n	initPoissonSamples( uv );\n	// STEP 1: blocker search\n	float avgBlockerDepth = findBlocker( shadowMap, uv, zReceiver );\n\n	//There are no occluders so early out (this saves filtering)\n	if( avgBlockerDepth == -1.0 ) return 1.0;\n\n	// STEP 2: penumbra size\n	float penumbraRatio = penumbraSize( zReceiver, avgBlockerDepth );\n	float filterRadius = penumbraRatio * LIGHT_SIZE_UV * NEAR_PLANE / zReceiver;\n\n	// STEP 3: filtering\n	//return avgBlockerDepth;\n	return PCF_Filter( shadowMap, uv, zReceiver, filterRadius );\n}";

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/shadows/pcss/glsl/PCSSGetShadow.glsl.js
var PCSSGetShadow_glsl_default = "return PCSS( shadowMap, shadowCoord );";

// node_modules/@polygonjs/polygonjs/node_modules/three/src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl.js
var shadowmap_pars_fragment_glsl_default = (
  /* glsl */
  `
#if NUM_SPOT_LIGHT_COORDS > 0

	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];

#endif

#if NUM_SPOT_LIGHT_MAPS > 0

	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];

#endif

#ifdef USE_SHADOWMAP

	#if NUM_DIR_LIGHT_SHADOWS > 0

		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

	#endif

	#if NUM_SPOT_LIGHT_SHADOWS > 0

		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];

		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};

		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

	#endif

	#if NUM_POINT_LIGHT_SHADOWS > 0

		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};

		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

	#endif

	/*
	#if NUM_RECT_AREA_LIGHTS > 0

		// TODO (abelnation): create uniforms for area light shadows

	#endif
	*/

	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

	}

	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

		return unpackRGBATo2Half( texture2D( shadow, uv ) );

	}

	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

		float occlusion = 1.0;

		vec2 distribution = texture2DDistribution( shadow, uv );

		float hard_shadow = step( compare , distribution.x ); // Hard Shadow

		if (hard_shadow != 1.0 ) {

			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

		}
		return occlusion;

	}

	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

		float shadow = 1.0;

		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;

		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;

		if ( frustumTest ) {

		#if defined( SHADOWMAP_TYPE_PCF )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;

			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;

			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );

		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )

			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;

			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;

			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );

		#elif defined( SHADOWMAP_TYPE_VSM )

			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

		#else // no percentage-closer filtering:

			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

		#endif

		}

		return shadow;

	}

	// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
	// vector suitable for 2D texture mapping. This code uses the following layout for the
	// 2D texture:
	//
	// xzXZ
	//  y Y
	//
	// Y - Positive y direction
	// y - Negative y direction
	// X - Positive x direction
	// x - Negative x direction
	// Z - Positive z direction
	// z - Negative z direction
	//
	// Source and test bed:
	// https://gist.github.com/tschw/da10c43c467ce8afd0c4

	vec2 cubeToUV( vec3 v, float texelSizeY ) {

		// Number of texels to avoid at the edge of each square

		vec3 absV = abs( v );

		// Intersect unit cube

		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;

		// Apply scale to avoid seams

		// two texels less per square (one texel will do for NEAREST)
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

		// Unwrap

		// space: -1 ... 1 range for each square
		//
		// #X##		dim    := ( 4 , 2 )
		//  # #		center := ( 1 , 1 )

		vec2 planar = v.xy;

		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;

		if ( absV.z >= almostOne ) {

			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;

		} else if ( absV.x >= almostOne ) {

			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;

		} else if ( absV.y >= almostOne ) {

			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;

		}

		// Transform to UV space

		// scale := 0.5 / dim
		// translate := ( center + 0.5 ) / dim
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

	}

	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

		// for point lights, the uniform @vShadowCoord is re-purposed to hold
		// the vector from the light to the world-space position of the fragment.
		vec3 lightToPosition = shadowCoord.xyz;

		// dp = normalized distance from light to fragment position
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
		dp += shadowBias;

		// bd3D = base direction 3D
		vec3 bd3D = normalize( lightToPosition );

		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )

			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;

			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );

		#else // no percentage-closer filtering

			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );

		#endif

	}

#endif
`
);

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/PCSSController.js
function PCSSParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.shadowPCSS = ParamConfig.BOOLEAN(0, {
        callback: (node) => {
          PCSSController.PARAM_CALLBACK_setRecompileRequired(node);
        },
        separatorBefore: true
      });
      this.shadowPCSSFilterSize = ParamConfig.FLOAT(1, {
        visibleIf: { shadowPCSS: 1 },
        range: [0, 10],
        rangeLocked: [true, false]
      });
    }
  };
}
var PCSSParamsConfig = class extends PCSSParamConfig(NodeParamsConfig) {
};
function isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return true;
}
var PCSSController = class _PCSSController extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static filterFragmentShader(node, fragmentShader) {
    const PCSSWithDefines = `
#define PCSS_FILTER_SIZE ${ThreeToGl.float(node.pv.shadowPCSSFilterSize)}
${PCSS_glsl_default}
`;
    let shadowParsFragmentModified = shadowmap_pars_fragment_glsl_default;
    shadowParsFragmentModified = shadowParsFragmentModified.replace(
      "#ifdef USE_SHADOWMAP",
      `#ifdef USE_SHADOWMAP
${PCSSWithDefines}
				`
    );
    shadowParsFragmentModified = shadowParsFragmentModified.replace(
      "#if defined( SHADOWMAP_TYPE_PCF )",
      `
				${PCSSGetShadow_glsl_default}
				#if defined( SHADOWMAP_TYPE_PCF )`
    );
    fragmentShader = fragmentShader.replace("#include <shadowmap_pars_fragment>", shadowParsFragmentModified);
    return fragmentShader;
  }
  static async update(node) {
    const material = await node.material();
    if (!isValidMaterial(material)) {
      return;
    }
    node.controllers.PCSS.updateMaterial(material);
  }
  async update() {
    _PCSSController.update(this.node);
  }
  updateMaterial(material) {
    var _a, _b;
    const matNode = this.node;
    if (!matNode.assemblerController) {
      return;
    }
    const callbackName = "PCSS";
    if (isBooleanTrue(this.node.pv.shadowPCSS)) {
      (_a = matNode.assemblerController()) == null ? void 0 : _a.addFilterFragmentShaderCallback(
        callbackName,
        (fragmentShader) => _PCSSController.filterFragmentShader(this.node, fragmentShader)
      );
    } else {
      (_b = matNode.assemblerController()) == null ? void 0 : _b.removeFilterFragmentShaderCallback(callbackName);
    }
  }
  // static async update(node: PCSSMapMatNode) {
  // 	node.controllers.PCSS.update();
  // }
  static PARAM_CALLBACK_setRecompileRequired(node) {
    node.controllers.PCSS.update();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/customMaterials/_CustomMaterialBase.js
function customMaterialBaseSetRecompileRequired(node) {
  var _a;
  (_a = node.assemblerController()) == null ? void 0 : _a.setCompilationRequired();
}
var CUSTOM_MAT_PARAM_OPTIONS = {
  callback: (node) => customMaterialBaseSetRecompileRequired(node)
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/mat/utils/customMaterials/CustomMaterialMesh.js
function CustomMaterialMeshParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.overrideCustomMaterials = ParamConfig.BOOLEAN(0, {
        ...CUSTOM_MAT_PARAM_OPTIONS,
        separatorBefore: true,
        separatorAfter: true
      });
      this.createCustomMatDistance = ParamConfig.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 },
        ...CUSTOM_MAT_PARAM_OPTIONS
      });
      this.createCustomMatDepth = ParamConfig.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 },
        ...CUSTOM_MAT_PARAM_OPTIONS
      });
      this.createCustomMatDepthDOF = ParamConfig.BOOLEAN(1, {
        visibleIf: { overrideCustomMaterials: 1 },
        ...CUSTOM_MAT_PARAM_OPTIONS,
        separatorAfter: true
      });
    }
  };
}
var CustomMaterialMeshParamsConfig = class extends CustomMaterialMeshParamConfig(BaseBuilderParamConfig(NodeParamsConfig)) {
};
function materialMeshAssemblerCustomMaterialRequested(node, customName) {
  const param = node.p.overrideCustomMaterials;
  if (!param) {
    console.warn(`param overrideCustomMaterials not found on ${node.path()}, creating all customMaterials`);
    return true;
  }
  if (!isBooleanTrue(node.pv.overrideCustomMaterials)) {
    return true;
  }
  switch (customName) {
    case CustomMaterialName.DISTANCE: {
      return isBooleanTrue(node.pv.createCustomMatDistance);
    }
    case CustomMaterialName.DEPTH: {
      return isBooleanTrue(node.pv.createCustomMatDepth);
    }
    case CustomMaterialName.DEPTH_DOF: {
      return isBooleanTrue(node.pv.createCustomMatDepthDOF);
    }
  }
  TypeAssert.unreachable(customName);
}

export {
  UniformsTransparencyParamConfig,
  UniformsTransparencyController,
  BaseBuilderParamConfig,
  TypedBuilderMatNode,
  FogParamConfig,
  UniformFogController,
  WireframeShaderMaterialParamsConfig,
  WireframeShaderMaterialController,
  PCSSParamConfig,
  PCSSController,
  CustomMaterialMeshParamConfig,
  materialMeshAssemblerCustomMaterialRequested
};
//# sourceMappingURL=chunk-KR5F7M52.js.map
