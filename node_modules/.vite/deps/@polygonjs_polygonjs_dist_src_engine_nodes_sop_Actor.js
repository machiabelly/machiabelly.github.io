import {
  filterObjectsWithGroup
} from "./chunk-W3H7NWH6.js";
import {
  TypedSopNode
} from "./chunk-XJZFUBTR.js";
import {
  SopType
} from "./chunk-OBFUH3H6.js";
import {
  ActorCompilationController
} from "./chunk-SY7VELMA.js";
import "./chunk-VPW6KKKV.js";
import {
  BasePersistedConfig
} from "./chunk-LTBPBA52.js";
import {
  BaseParamConfig,
  InputCloneMode,
  NodeParamsConfig,
  ParamConfig,
  TypeAssert
} from "./chunk-FUAFRKQ7.js";
import "./chunk-RVFV2LA3.js";
import {
  AssemblerName,
  Poly
} from "./chunk-O564GFGZ.js";
import {
  Box3,
  Color,
  CoreType,
  Euler,
  Matrix4,
  Plane,
  Quaternion,
  Ray,
  Sphere,
  Vector2,
  Vector3,
  Vector4,
  incrementRefSafely,
  isBooleanTrue
} from "./chunk-6OBTIB4K.js";
import {
  NetworkNodeType,
  NodeContext
} from "./chunk-PQDBXNT6.js";
import "./chunk-UXIASGQL.js";

// node_modules/@polygonjs/polygonjs/dist/src/core/reactivity/ParamReactivity.js
var refByNodePathByParamName = /* @__PURE__ */ new Map();
function getParamRef(node, paramName) {
  var _a;
  return (_a = refByNodePathByParamName.get(node.path())) == null ? void 0 : _a.get(paramName);
}
function touchParamRef(node, paramName) {
  const _ref = getParamRef(node, paramName);
  if (!_ref) {
    return;
  }
  incrementRefSafely(_ref);
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/utils/JsParamConfig.js
var JsParamConfig = class _JsParamConfig extends BaseParamConfig {
  // private _uniform: IUniform | undefined;
  constructor(_type, _name, _defaultValue, _uniformName) {
    super(_type, _name, _defaultValue);
    this._uniformName = _uniformName;
  }
  toJSON() {
    return {
      type: this._type,
      name: this._name,
      defaultValue: this._defaultValue,
      uniformName: this._uniformName
    };
  }
  static fromJSON(json) {
    return new _JsParamConfig(json.type, json.name, json.defaultValue, json.uniformName);
  }
  uniformName() {
    return this._uniformName;
  }
  // override applyToNode(node: BaseNodeType) {
  // 	console.warn('not needed in js context');
  // }
  // uniform() {
  // 	return (this._uniform = this._uniform || this._createUniform());
  // }
  // private _createUniform() {
  // 	return JsParamConfig.uniformByType(this._type);
  // }
  _callback(node, param) {
    _JsParamConfig.callback(node, param.name());
  }
  static callback(node, paramName) {
    touchParamRef(node, paramName);
  }
  // TODO: refactor that to use the default values map?
  // static uniformByType(type: ParamType): IUniform {
  // 	switch (type) {
  // 		case ParamType.BOOLEAN:
  // 			return {value: 0};
  // 		case ParamType.BUTTON:
  // 			return {value: 0};
  // 		case ParamType.COLOR:
  // 			return {value: new Color(0, 0, 0)};
  // 		case ParamType.FLOAT:
  // 			return {value: 0};
  // 		case ParamType.FOLDER:
  // 			return {value: 0};
  // 		case ParamType.INTEGER:
  // 			return {value: 0};
  // 		// case ParamType.OPERATOR_PATH:
  // 		// 	return {value: 0};
  // 		case ParamType.NODE_PATH:
  // 			return {value: 0};
  // 		case ParamType.PARAM_PATH:
  // 			return {value: 0};
  // 		// case ParamType.STRING: return {type: 't', value: null} // new Texture()}
  // 		case ParamType.RAMP:
  // 			return {value: null}; // new Texture()}
  // 		case ParamType.STRING:
  // 			return {value: null};
  // 		case ParamType.VECTOR2:
  // 			return {value: new Vector2(0, 0)};
  // 		case ParamType.VECTOR3:
  // 			return {value: new Vector3(0, 0, 0)};
  // 		case ParamType.VECTOR4:
  // 			return {value: new Vector4(0, 0, 0, 0)};
  // 	}
  // 	TypeAssert.unreachable(type);
  // }
  // private static set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {
  // 	const found_node = param.found_node();
  // 	if (found_node) {
  // 		if (found_node.isDirty()) {
  // 			found_node.compute().then((container) => {
  // 				const texture = container.texture();
  // 				uniform.value = texture;
  // 			});
  // 		} else {
  // 			const container = found_node.containerController.container();
  // 			const texture = container.texture();
  // 			uniform.value = texture;
  // 		}
  // 	} else {
  // 		uniform.value = null;
  // 	}
  // }
  // private static async setUniformValueFromTextureFromNodePathParam(param: NodePathParam, uniform: IUniform) {
  // 	if (param.isDirty()) {
  // 		await param.compute();
  // 	}
  // 	const node = param.value.nodeWithContext(NodeContext.COP);
  // 	if (node) {
  // 		if (node.isDirty()) {
  // 			await node.compute();
  // 		}
  // 		const container = node.containerController.container();
  // 		const texture = container.texture();
  // 		uniform.value = texture;
  // 	} else {
  // 		uniform.value = null;
  // 	}
  // }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/assemblers/_BaseJsPersistedConfigUtils.js
var PrimitiveArray = class {
  constructor(_elements) {
    this._elements = _elements;
    this.isPrimitiveArray = true;
  }
  elements() {
    return this._elements;
  }
  clone() {
    return this._elements.map((v) => v);
  }
};
var VectorArray = class {
  constructor(_elements) {
    this._elements = _elements;
    this.isVectorArray = true;
  }
  elements() {
    return this._elements;
  }
  clone() {
    return this._elements.map((v) => v.clone());
  }
};
var SerializedVariableType = ((SerializedVariableType2) => {
  SerializedVariableType2["Box3"] = "Box3";
  SerializedVariableType2["Color"] = "Color";
  SerializedVariableType2["Euler"] = "Euler";
  SerializedVariableType2["Matrix4"] = "Matrix4";
  SerializedVariableType2["Plane"] = "Plane";
  SerializedVariableType2["Quaternion"] = "Quaternion";
  SerializedVariableType2["Ray"] = "Ray";
  SerializedVariableType2["Sphere"] = "Sphere";
  SerializedVariableType2["Vector2"] = "Vector2";
  SerializedVariableType2["Vector3"] = "Vector3";
  SerializedVariableType2["Vector4"] = "Vector4";
  SerializedVariableType2["boolean_Array"] = "boolean[]";
  SerializedVariableType2["number_Array"] = "number[]";
  SerializedVariableType2["string_Array"] = "string[]";
  SerializedVariableType2["Color_Array"] = "Color[]";
  SerializedVariableType2["Euler_Array"] = "Euler[]";
  SerializedVariableType2["Matrix4_Array"] = "Matrix4[]";
  SerializedVariableType2["Quaternion_Array"] = "Quaternion[]";
  SerializedVariableType2["Vector2_Array"] = "Vector2[]";
  SerializedVariableType2["Vector3_Array"] = "Vector3[]";
  SerializedVariableType2["Vector4_Array"] = "Vector4[]";
  return SerializedVariableType2;
})(SerializedVariableType || {});
function isVariableSerializable(variable) {
  if (variable instanceof Box3 || variable instanceof Color || variable instanceof Euler || variable instanceof Matrix4 || variable instanceof Plane || variable instanceof Quaternion || variable instanceof Ray || variable instanceof Sphere || variable instanceof Vector2 || variable instanceof Vector3 || variable instanceof Vector4 || variable instanceof PrimitiveArray || variable instanceof VectorArray) {
    return true;
  } else {
    console.warn("not serializable", variable);
    return false;
  }
}
function serializeVariable(variable) {
  if (variable instanceof Box3) {
    const data2 = {
      type: "Box3",
      data: {
        min: variable.min.toArray(),
        max: variable.min.toArray()
      }
    };
    return data2;
  }
  if (variable instanceof Color) {
    const data2 = {
      type: "Color",
      data: variable.toArray()
    };
    return data2;
  }
  if (variable instanceof Euler) {
    const data2 = {
      type: "Euler",
      data: {
        rotation: variable.toArray(),
        rotationOrder: variable.order
      }
    };
    return data2;
  }
  if (variable instanceof Matrix4) {
    const data2 = {
      type: "Matrix4",
      data: variable.toArray()
    };
    return data2;
  }
  if (variable instanceof Plane) {
    const data2 = {
      type: "Plane",
      data: {
        normal: variable.normal.toArray(),
        constant: variable.constant
      }
    };
    return data2;
  }
  if (variable instanceof Quaternion) {
    const data2 = {
      type: "Quaternion",
      data: variable.toArray()
    };
    return data2;
  }
  if (variable instanceof Ray) {
    const data2 = {
      type: "Ray",
      data: {
        origin: variable.origin.toArray(),
        direction: variable.direction.toArray()
      }
    };
    return data2;
  }
  if (variable instanceof Sphere) {
    const data2 = {
      type: "Sphere",
      data: {
        center: variable.center.toArray(),
        radius: variable.radius
      }
    };
    return data2;
  }
  if (variable instanceof Vector2) {
    const data2 = {
      type: "Vector2",
      data: variable.toArray()
    };
    return data2;
  }
  if (variable instanceof Vector3) {
    const data2 = {
      type: "Vector3",
      data: variable.toArray()
    };
    return data2;
  }
  if (variable instanceof Vector4) {
    const data2 = {
      type: "Vector4",
      data: variable.toArray()
    };
    return data2;
  }
  if (variable.isPrimitiveArray) {
    const elements = variable.elements();
    const firstElement = elements[0];
    if (CoreType.isBoolean(firstElement)) {
      const data2 = {
        type: "boolean[]",
        data: elements.map((v) => v)
      };
      return data2;
    }
    if (CoreType.isNumber(firstElement)) {
      const data2 = {
        type: "number[]",
        data: elements.map((v) => v)
      };
      return data2;
    }
    if (CoreType.isString(firstElement)) {
      const data2 = {
        type: "string[]",
        data: elements.map((v) => v)
      };
      return data2;
    }
  }
  if (variable.isVectorArray) {
    const elements = variable.elements();
    const firstElement = elements[0];
    if (firstElement instanceof Color) {
      const data2 = {
        type: "Color[]",
        data: elements.map((v) => v.toArray())
      };
      return data2;
    }
    if (firstElement instanceof Euler) {
      const data2 = {
        type: "Euler[]",
        data: elements.map((v) => ({
          rotation: v.toArray(),
          rotationOrder: v.order
        }))
      };
      return data2;
    }
    if (firstElement instanceof Matrix4) {
      const data2 = {
        type: "Matrix4[]",
        data: elements.map((v) => v.toArray())
      };
      return data2;
    }
    if (firstElement instanceof Quaternion) {
      const data2 = {
        type: "Quaternion[]",
        data: elements.map((v) => v.toArray())
      };
      return data2;
    }
    if (firstElement instanceof Vector2) {
      const data2 = {
        type: "Vector2[]",
        data: elements.map((v) => v.toArray())
      };
      return data2;
    }
    if (firstElement instanceof Vector3) {
      const data2 = {
        type: "Vector3[]",
        data: elements.map((v) => v.toArray())
      };
      return data2;
    }
    if (firstElement instanceof Vector4) {
      const data2 = {
        type: "Vector4[]",
        data: elements.map((v) => v.toArray())
      };
      return data2;
    }
    console.log("array variable serialization not implemeted", variable, firstElement);
  }
  console.log("variable serialization not implemeted", variable);
  const data = {
    type: "Vector3",
    data: new Vector3().toArray()
  };
  return data;
}
function deserializeVariable(serialized) {
  const type = serialized.type;
  switch (type) {
    case "Box3": {
      const data = serialized.data;
      const box3 = new Box3();
      box3.min.set(data.min[0], data.min[1], data.min[2]);
      box3.max.set(data.max[0], data.max[1], data.max[2]);
      return box3;
    }
    case "Color": {
      const data = serialized.data;
      const color = new Color();
      color.r = data[0];
      color.g = data[1];
      color.b = data[2];
      return color;
    }
    case "Euler": {
      const data = serialized.data;
      const euler = new Euler(data.rotation[0], data.rotation[1], data.rotation[2], data.rotationOrder);
      return euler;
    }
    case "Matrix4": {
      const data = serialized.data;
      const matrix = new Matrix4();
      matrix.set(...data);
      return matrix;
    }
    case "Plane": {
      const data = serialized.data;
      const plane = new Plane();
      plane.normal.set(...data.normal);
      plane.constant = data.constant;
      return plane;
    }
    case "Quaternion": {
      const data = serialized.data;
      const vector = new Quaternion();
      vector.set(...data);
      return vector;
    }
    case "Ray": {
      const data = serialized.data;
      const ray = new Ray();
      ray.origin.set(...data.origin);
      ray.direction.set(...data.direction);
      return ray;
    }
    case "Sphere": {
      const data = serialized.data;
      const sphere = new Sphere();
      sphere.center.set(...data.center);
      sphere.radius = data.radius;
      return sphere;
    }
    case "Vector2": {
      const data = serialized.data;
      const vector = new Vector2();
      vector.set(...data);
      return vector;
    }
    case "Vector3": {
      const data = serialized.data;
      const vector = new Vector3();
      vector.set(...data);
      return vector;
    }
    case "Vector4": {
      const data = serialized.data;
      const vector = new Vector4();
      vector.set(...data);
      return vector;
    }
    case "boolean[]": {
      const data = serialized.data;
      const values = [...data];
      const numberArray = new PrimitiveArray(values);
      return numberArray;
    }
    case "number[]": {
      const data = serialized.data;
      const values = [...data];
      const numberArray = new PrimitiveArray(values);
      return numberArray;
    }
    case "string[]": {
      const data = serialized.data;
      const values = [...data];
      const numberArray = new PrimitiveArray(values);
      return numberArray;
    }
    case "Color[]": {
      const data = serialized.data;
      const vectors = data.map((d) => {
        const color = new Color();
        color.r = d[0];
        color.g = d[1];
        color.b = d[2];
        return color;
      });
      const vectorArray = new VectorArray(vectors);
      return vectorArray;
    }
    case "Euler[]": {
      const data = serialized.data;
      const eulers = data.map((d) => {
        const euler = new Euler(d.rotation[0], d.rotation[1], d.rotation[2], d.rotationOrder);
        return euler;
      });
      const vectorArray = new VectorArray(eulers);
      return vectorArray;
    }
    case "Matrix4[]": {
      const data = serialized.data;
      const vectors = data.map((d) => {
        const v = new Matrix4();
        v.set(...d);
        return v;
      });
      const vectorArray = new VectorArray(vectors);
      return vectorArray;
    }
    case "Quaternion[]": {
      const data = serialized.data;
      const vectors = data.map((d) => {
        const v = new Quaternion();
        v.set(...d);
        return v;
      });
      const vectorArray = new VectorArray(vectors);
      return vectorArray;
    }
    case "Vector2[]": {
      const data = serialized.data;
      const vectors = data.map((d) => {
        const v = new Vector2();
        v.set(...d);
        return v;
      });
      const vectorArray = new VectorArray(vectors);
      return vectorArray;
    }
    case "Vector3[]": {
      const data = serialized.data;
      const vectors = data.map((d) => {
        const v = new Vector3();
        v.set(...d);
        return v;
      });
      const vectorArray = new VectorArray(vectors);
      return vectorArray;
    }
    case "Vector4[]": {
      const data = serialized.data;
      const vectors = data.map((d) => {
        const v = new Vector4();
        v.set(...d);
        return v;
      });
      const vectorArray = new VectorArray(vectors);
      return vectorArray;
    }
  }
  TypeAssert.unreachable(type);
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/assemblers/_BaseJsPersistedConfig.js
function serializedVariablesFromFunctionData(functionData) {
  const { variableNames, variablesByName } = functionData;
  const serializedVariables = [];
  for (const variableName of variableNames) {
    const variable = variablesByName[variableName];
    if (variable != null && isVariableSerializable(variable)) {
      const serialized = serializeVariable(variable);
      serializedVariables.push(serialized);
    }
  }
  return serializedVariables;
}
function variablesByNameFromPersistedConfigData(data) {
  const { variableNames, variables } = data;
  const variablesByName = {};
  let i = 0;
  for (const variableName of variableNames) {
    const serialized = variables[i];
    const deserialized = deserializeVariable(serialized);
    variablesByName[variableName] = deserialized;
    i++;
  }
  return variablesByName;
}
function functionsByNameFromPersistedConfigData(data, node) {
  const { functionNames } = data;
  const functionsByName = {};
  for (const functionName of functionNames) {
    const namedFunction = Poly.namedFunctionsRegister.getFunction(functionName, node);
    if (namedFunction) {
      functionsByName[functionName] = namedFunction.func.bind(namedFunction);
    }
  }
  return functionsByName;
}

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/js/code/assemblers/actor/ActorPersistedConfig.js
var ActorPersistedConfig = class extends BasePersistedConfig {
  constructor(node) {
    super(node);
    this.node = node;
  }
  async toData() {
    await this.node.compilationController.compileIfRequired();
    const assemblerController = this.node.assemblerController();
    if (!assemblerController) {
      return;
    }
    const functionData = this.node.compilationController.functionData();
    if (!functionData) {
      return;
    }
    const { functionBody, variableNames, functionNames, paramConfigs, eventDatas } = functionData;
    const data = {
      functionBody,
      variableNames,
      variables: serializedVariablesFromFunctionData(functionData),
      functionNames,
      serializedParamConfigs: paramConfigs.map((p) => p.toJSON()),
      eventDatas
    };
    return data;
  }
  load(data) {
    const assemblerController = this.node.assemblerController();
    if (assemblerController) {
      return;
    }
    const { functionBody, variableNames, functionNames, serializedParamConfigs, eventDatas } = data;
    const functionData = {
      functionBody,
      variableNames,
      variablesByName: variablesByNameFromPersistedConfigData(data),
      functionNames,
      functionsByName: functionsByNameFromPersistedConfigData(data, this.node),
      paramConfigs: serializedParamConfigs.map((json) => JsParamConfig.fromJSON(json)),
      eventDatas
    };
    this.node.compilationController.updateFromFunctionData(functionData);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/_BaseActor.js
var TypedActorSopNode = class extends TypedSopNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = NodeContext.JS;
    this.persisted_config = new ActorPersistedConfig(this);
    this._assemblerController = this._createAssemblerController();
    this.compilationController = new ActorCompilationController(this);
  }
  createNode(node_class, options) {
    return super.createNode(node_class, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  childrenAllowed() {
    if (this.assemblerController()) {
      return super.childrenAllowed();
    }
    return false;
  }
  sceneReadonly() {
    return this.assemblerController() == null;
  }
  assemblerController() {
    return this._assemblerController;
  }
  usedAssembler() {
    return AssemblerName.JS_ACTOR;
  }
  _createAssemblerController() {
    return Poly.assemblersRegister.assembler(this, this.usedAssembler());
  }
  compile() {
    this.compilationController.compile();
  }
  functionData() {
    return this.compilationController.functionData();
  }
  //
  // clean
  //
  updateObjectOnRemove(object, parent) {
    this.compilationController.evaluatorGenerator().disposeEvaluator(object);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/nodes/sop/Actor.js
var ActorSopParamsConfig = class extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.group = ParamConfig.STRING("", {
      objectMask: true
    });
    this.useThisNode = ParamConfig.BOOLEAN(1, {
      separatorAfter: true
    });
    this.node = ParamConfig.NODE_PATH("", {
      visibleIf: { useThisNode: 0 },
      nodeSelection: {
        types: [NetworkNodeType.ACTOR]
      },
      dependentOnFoundNode: false,
      separatorAfter: true
    });
  }
};
var ParamsConfig = new ActorSopParamsConfig();
var ActorSopNode = class extends TypedActorSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.ACTOR;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  async cook(inputCoreGroups) {
    this.compilationController.compileIfRequired();
    const coreGroup = inputCoreGroups[0];
    const objects = filterObjectsWithGroup(coreGroup, this.pv);
    const actorNode = await this._findActorNode();
    if (actorNode) {
      for (const object of objects) {
        this.scene().actorsManager.assignActorBuilder(object, actorNode);
      }
    }
    this.setCoreGroup(coreGroup);
  }
  async _findActorNode() {
    if (isBooleanTrue(this.pv.useThisNode)) {
      return this;
    } else {
      const node = this.pv.node.node();
      if (node) {
        await node.compute();
      }
      return node;
    }
  }
};
export {
  ActorSopNode
};
//# sourceMappingURL=@polygonjs_polygonjs_dist_src_engine_nodes_sop_Actor.js.map
