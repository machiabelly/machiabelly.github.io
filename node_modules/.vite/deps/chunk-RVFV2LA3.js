import {
  Poly,
  arrayPushItems,
  arrayUniq,
  range
} from "./chunk-O564GFGZ.js";
import {
  CoreType
} from "./chunk-6OBTIB4K.js";

// node_modules/@polygonjs/polygonjs/dist/src/core/Walker.js
var _remainingElements = [];
var _ups = [];
var GraphNodePathParamValue = class {
  constructor(_path = "") {
    this._path = _path;
    this._graphNode = null;
  }
  graphNode() {
    return this._graphNode;
  }
  _setGraphNode(graphNode) {
    this._graphNode = graphNode;
  }
  path() {
    return this._path;
  }
  setPath(path) {
    this._path = path;
  }
  clone() {
    const cloned = new this.constructor(this._path);
    cloned._setGraphNode(this._graphNode);
    return cloned;
  }
};
var TypedNodePathParamValue = class extends GraphNodePathParamValue {
  setNode(node) {
    this._graphNode = node;
  }
  node() {
    return this._graphNode;
  }
  graphNodePath() {
    var _a;
    return (_a = this.node()) == null ? void 0 : _a.path();
  }
  resolve(nodeStart, decomposedPath) {
    this._graphNode = CoreWalker.findNode(nodeStart, this._path, decomposedPath);
  }
  nodeWithContext(context, errorState) {
    const foundNode = this.node();
    if (!foundNode) {
      errorState == null ? void 0 : errorState.set(`no node found at ${this.path()}`);
      return;
    }
    const nodeContext = foundNode.context();
    if (nodeContext == context) {
      return foundNode;
    } else {
      errorState == null ? void 0 : errorState.set(`expected ${context} node, but got a ${nodeContext}`);
      return;
    }
  }
};
var TypedParamPathParamValue = class extends GraphNodePathParamValue {
  setParam(param) {
    this._graphNode = param;
  }
  param() {
    return this._graphNode;
  }
  graphNodePath() {
    var _a;
    return (_a = this.param()) == null ? void 0 : _a.path();
  }
  resolve(nodeStart, decomposedPath) {
    this._graphNode = CoreWalker.findParam(nodeStart, this._path, decomposedPath);
  }
  paramWithType(paramType, error_state) {
    const foundParam = this.param();
    if (!foundParam) {
      error_state == null ? void 0 : error_state.set(`no param found at ${this.path()}`);
      return;
    }
    if (foundParam.type() == paramType) {
      return foundParam;
    } else {
      error_state == null ? void 0 : error_state.set(`expected ${paramType} node, but got a ${foundParam.type()}`);
      return;
    }
  }
};
var _CoreWalker = class {
  static splitParentChild(path) {
    const elements = path.split(_CoreWalker.SEPARATOR).filter((e) => e.length > 0);
    const child_path = elements.pop();
    const parent_path = elements.join(_CoreWalker.SEPARATOR);
    return { parent: parent_path, child: child_path };
  }
  static findNode(nodeSrc, path, decomposedPath) {
    if (!nodeSrc) {
      return null;
    }
    const elements = path.split(_CoreWalker.SEPARATOR).filter((e) => e.length > 0);
    const firstElement = elements[0];
    let nextNode = null;
    if (path[0] === _CoreWalker.SEPARATOR) {
      const pathFromRoot = path.substring(1);
      nextNode = this.findNode(nodeSrc.root(), pathFromRoot, decomposedPath);
    } else {
      switch (firstElement) {
        case _CoreWalker.PARENT:
          nextNode = nodeSrc.parent();
          if (nextNode) {
            decomposedPath == null ? void 0 : decomposedPath.addPathElement({ path: firstElement, node: nextNode });
          }
          break;
        case _CoreWalker.CURRENT:
          nextNode = nodeSrc;
          decomposedPath == null ? void 0 : decomposedPath.addPathElement({ path: firstElement, node: nextNode });
          break;
        default:
          nextNode = nodeSrc.node(firstElement);
          if (nextNode) {
            decomposedPath == null ? void 0 : decomposedPath.addNamedNode({ name: firstElement, node: nextNode });
          }
      }
      if (nextNode != null && elements.length > 1) {
        const remainder = elements.slice(1).join(_CoreWalker.SEPARATOR);
        nextNode = this.findNode(nextNode, remainder, decomposedPath);
      }
      return nextNode;
    }
    return nextNode;
  }
  static findParam(nodeSrc, path, decomposedPath) {
    if (!nodeSrc) {
      return null;
    }
    const elements = path.split(_CoreWalker.SEPARATOR);
    if (elements.length === 1) {
      return nodeSrc.params.get(elements[0]);
    } else {
      let node = null;
      if (path[0] === _CoreWalker.SEPARATOR && elements.length == 2) {
        node = nodeSrc.root();
      } else {
        const nodePath = elements.slice(0, +(elements.length - 2) + 1 || void 0).join(_CoreWalker.SEPARATOR);
        node = this.findNode(nodeSrc, nodePath, decomposedPath);
      }
      if (node != null) {
        const paramName = elements[elements.length - 1];
        const param = node.params.get(paramName);
        if (decomposedPath && param) {
          decomposedPath.addNamedNode({ name: paramName, node: param });
        }
        return param;
      } else {
        return null;
      }
    }
  }
  static relativePath(srcGraphNode, destGraphNode) {
    const parent = this.closestCommonParent(srcGraphNode, destGraphNode);
    if (!parent) {
      return destGraphNode.path();
    } else {
      const distance = this.distanceToParent(srcGraphNode, parent);
      let up = "";
      if (distance > 0) {
        let i = 0;
        _ups.length = 0;
        while (i++ < distance) {
          _ups.push(_CoreWalker.PARENT);
        }
        up = _ups.join(_CoreWalker.SEPARATOR) + _CoreWalker.SEPARATOR;
      }
      const parent_path_elements = parent.path().split(_CoreWalker.SEPARATOR).filter((e) => e.length > 0);
      const dest_path_elements = destGraphNode.path().split(_CoreWalker.SEPARATOR).filter((e) => e.length > 0);
      _remainingElements.length = 0;
      let cmptr = 0;
      for (const dest_path_element of dest_path_elements) {
        if (!parent_path_elements[cmptr]) {
          _remainingElements.push(dest_path_element);
        }
        cmptr++;
      }
      const down = _remainingElements.join(_CoreWalker.SEPARATOR);
      return this.sanitizePath(`${up}${down}`);
    }
  }
  static sanitizePath(path) {
    return path.replace(/\/\//g, "/");
  }
  static closestCommonParent(graphNode1, graphNode2) {
    const parents1 = this.parents(graphNode1).reverse().concat([graphNode1]);
    const parents2 = this.parents(graphNode2).reverse().concat([graphNode2]);
    const minDepth = Math.min(parents1.length, parents2.length);
    let foundParent = null;
    for (let i = 0; i < minDepth; i++) {
      if (parents1[i].graphNodeId() == parents2[i].graphNodeId()) {
        foundParent = parents1[i];
      }
    }
    return foundParent;
  }
  static parents(graphNode) {
    const parents = [];
    let parent = graphNode.parent();
    while (parent) {
      parents.push(parent);
      parent = parent.parent();
    }
    return parents;
  }
  static distanceToParent(graphNode, dest) {
    let distance = 0;
    let current = graphNode;
    const destId = dest.graphNodeId();
    while (current && current.graphNodeId() != destId) {
      distance += 1;
      current = current.parent();
    }
    if (current && current.graphNodeId() == destId) {
      return distance;
    } else {
      return -1;
    }
  }
  static makeAbsolutePath(nodeSrc, path) {
    if (path[0] == _CoreWalker.SEPARATOR) {
      return path;
    }
    const pathElements = path.split(_CoreWalker.SEPARATOR);
    const firstElement = pathElements.shift();
    if (firstElement) {
      switch (firstElement) {
        case "..": {
          const parent = nodeSrc.parent();
          if (parent) {
            if (parent == nodeSrc.scene().root()) {
              return _CoreWalker.SEPARATOR + pathElements.join(_CoreWalker.SEPARATOR);
            } else {
              return this.makeAbsolutePath(parent, pathElements.join(_CoreWalker.SEPARATOR));
            }
          } else {
            return null;
          }
        }
        case ".": {
          return this.makeAbsolutePath(nodeSrc, pathElements.join(_CoreWalker.SEPARATOR));
        }
        default: {
          return [nodeSrc.path(), path].join(_CoreWalker.SEPARATOR);
        }
      }
    } else {
      return nodeSrc.path();
    }
  }
};
var CoreWalker = _CoreWalker;
CoreWalker.SEPARATOR = "/";
CoreWalker.DOT = ".";
CoreWalker.CURRENT = _CoreWalker.DOT;
CoreWalker.PARENT = "..";
CoreWalker.CURRENT_WITH_SLASH = `${_CoreWalker.CURRENT}/`;
CoreWalker.PARENT_WITH_SLASH = `${_CoreWalker.PARENT}/`;
CoreWalker.NON_LETTER_PREFIXES = [_CoreWalker.SEPARATOR, _CoreWalker.DOT];

// node_modules/@polygonjs/polygonjs/dist/src/core/graph/DirtyController.js
var DirtyController = class {
  constructor(node) {
    this.node = node;
    this._dirtyCount = 0;
    this._dirty = true;
    this._cooker = node.scene().cooker;
  }
  dispose() {
    this._postDirtyHooks = void 0;
    this._postDirtyHookNames = void 0;
  }
  isDirty() {
    return this._dirty === true;
  }
  dirtyTimestamp() {
    return this._dirtyTimestamp;
  }
  dirtyCount() {
    return this._dirtyCount;
  }
  hasPostDirtyHooks() {
    return this._postDirtyHookNames != null && this._postDirtyHookNames.length > 0;
  }
  addPostDirtyHook(name, method) {
    this._postDirtyHookNames = this._postDirtyHookNames || [];
    this._postDirtyHooks = this._postDirtyHooks || [];
    if (!this._postDirtyHookNames.includes(name)) {
      this._postDirtyHookNames.push(name);
      this._postDirtyHooks.push(method);
    } else {
      console.warn(`hook with name ${name} already exists`, this.node);
    }
  }
  removePostDirtyHook(name) {
    if (this._postDirtyHookNames && this._postDirtyHooks) {
      const index = this._postDirtyHookNames.indexOf(name);
      if (index >= 0) {
        this._postDirtyHookNames.splice(index, 1);
        this._postDirtyHooks.splice(index, 1);
      }
    }
  }
  hasHook(name) {
    if (this._postDirtyHookNames) {
      return this._postDirtyHookNames.includes(name);
    }
    return false;
  }
  removeDirtyState() {
    this._dirty = false;
  }
  setDirty(originalTriggerGraphNode, propagate = true) {
    if (originalTriggerGraphNode == null) {
      originalTriggerGraphNode = this.node;
    }
    if (originalTriggerGraphNode == this.node && this.node.selfDirtyForbidden()) {
      return;
    }
    this._dirty = true;
    this._dirtyTimestamp = Poly.performance.performanceManager().now();
    this._dirtyCount += 1;
    this.runPostDirtyHooks(originalTriggerGraphNode);
    if (propagate === true) {
      this.setSuccessorsDirty(originalTriggerGraphNode);
    }
  }
  runPostDirtyHooks(originalTriggerGraphNode) {
    if (this._postDirtyHooks == null || this._postDirtyHooks.length == 0) {
      return;
    }
    if (this._cooker.blocked()) {
      this._cooker.enqueue(this.node, originalTriggerGraphNode);
    } else {
      for (const hook of this._postDirtyHooks) {
        hook(originalTriggerGraphNode);
      }
    }
  }
  setSuccessorsDirty(originalTriggerGraphNode) {
    if (originalTriggerGraphNode == null) {
      originalTriggerGraphNode = this.node;
    }
    this._cooker.block();
    const allSuccessors = this.node.graphAllSuccessors();
    for (const successor of allSuccessors) {
      successor.dirtyController.setDirty(originalTriggerGraphNode, false);
    }
    this._cooker.unblock();
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/graph/CoreGraphNode.js
var CoreGraphNode = class {
  constructor(_scene, _name) {
    this._scene = _scene;
    this._name = _name;
    this._dirtyController = new DirtyController(this);
    this._allPredecessors = [];
    this._allSuccessors = [];
    this._allPredecessorsDirty = true;
    this._allSuccessorsDirty = true;
    this._disposed = false;
    this._graphNodeId = _scene.graph.nextId();
    _scene.graph.addNode(this);
    this._graph = _scene.graph;
  }
  dispose() {
    this._dirtyController.dispose();
    this._allPredecessors.length = 0;
    this._allSuccessors.length = 0;
    this.graphRemove();
    this._disposed = true;
  }
  disposed() {
    return this._disposed;
  }
  /**
   * returns the name
   *
   */
  name() {
    return this._name;
  }
  setName(name) {
    this._name = name;
  }
  /**
   * returns the scene
   *
   */
  scene() {
    return this._scene;
  }
  /**
   * returns the id, which is unique for the scene
   *
   */
  graphNodeId() {
    return this._graphNodeId;
  }
  //
  //
  // DIRTY CONTROLLER
  //
  //
  get dirtyController() {
    return this._dirtyController;
  }
  /**
   * makes the graphNode dirty, which in turns makes its dependencies dirty
   *
   */
  setDirty(trigger) {
    trigger = trigger || this;
    this._dirtyController.setDirty(trigger);
  }
  /**
   * makes dependencies dirty
   *
   */
  setSuccessorsDirty(trigger) {
    this._dirtyController.setSuccessorsDirty(trigger);
  }
  /**
   * removes the dirty state
   *
   */
  removeDirtyState() {
    this._dirtyController.removeDirtyState();
  }
  isDirty() {
    return this._dirtyController.isDirty();
  }
  /**
   * adds a callback that gets run when the graphNode is dirty
   *
   */
  addPostDirtyHook(name, callback) {
    this._dirtyController.addPostDirtyHook(name, callback);
  }
  removePostDirtyHook(name) {
    this._dirtyController.removePostDirtyHook(name);
  }
  //
  //
  // GRAPH
  //
  //
  graphRemove() {
    this._graph.removeNode(this);
  }
  addGraphInput(src, checkCycle = true) {
    return this._graph.connect(src, this, checkCycle);
  }
  removeGraphInput(src) {
    this._graph.disconnect(src, this);
  }
  graphDisconnectPredecessors() {
    this._graph.disconnectPredecessors(this);
  }
  graphDisconnectSuccessors() {
    this._graph.disconnectSuccessors(this);
  }
  graphPredecessorIds() {
    return this._graph.predecessorIds(this._graphNodeId);
  }
  graphPredecessors() {
    return this._graph.predecessors(this);
  }
  graphSuccessorIds() {
    return this._graph.successorIds(this._graphNodeId);
  }
  graphSuccessors() {
    return this._graph.successors(this);
  }
  _clearAllPredecessors() {
    this._allPredecessorsDirty = true;
  }
  _clearAllSuccessors() {
    this._allSuccessorsDirty = true;
  }
  graphAllPredecessors() {
    if (this._allPredecessorsDirty) {
      this._graph.allPredecessors(this, this._allPredecessors);
      this._allPredecessorsDirty = false;
    }
    return this._allPredecessors;
  }
  graphAllSuccessors() {
    if (this._allSuccessorsDirty) {
      this._graph.allSuccessors(this, this._allSuccessors);
      this._allSuccessorsDirty = false;
    }
    return this._allSuccessors;
  }
  hasPredecessor(node) {
    return this.graphAllPredecessors().includes(node);
  }
  clearCachesWithPredecessorsAndSuccessors() {
    const allPredecessors = this.graphAllPredecessors();
    const allSuccessors = this.graphAllSuccessors();
    for (const predecessor of allPredecessors) {
      predecessor._clearAllSuccessors();
    }
    for (const successor of allSuccessors) {
      successor._clearAllPredecessors();
    }
    this._clearAllPredecessors();
    this._clearAllSuccessors();
  }
  //
  setForbiddenTriggerNodes(nodes) {
    this._graph.setForbiddenTriggerNodes(this, nodes);
    this._clearAllSuccessors();
  }
  clearForbiddenTriggerNodes() {
    this._graph.clearForbiddenTriggerNodes(this);
    this._clearAllSuccessors();
  }
  setSelfDirtyForbidden(state) {
    this._graph.setSelfDirtyForbidden(this, state);
  }
  selfDirtyForbidden() {
    return this._graph.selfDirtyForbidden(this);
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/core/String.js
var ATTRIB_NAMES_SEPARATOR = /[, ]/;
var TAIL_DIGIT_MATCH_REGEXP = /\d+$/;
var LEADING_ZEROS_MATCH_REGEXP = /^0+/;
var INDICES_LIST_SEPARATOR = /,| /;
var ZERO = "0";
var SPACE = " ";
var RANGE_SEPARATOR = "-";
var NUM_REGEXP = /^-?\d+\.?\d*$/;
var BooleanString = ((BooleanString2) => {
  BooleanString2["TRUE"] = "true";
  BooleanString2["FALSE"] = "false";
  return BooleanString2;
})(BooleanString || {});
function stringIsBoolean(word) {
  return word == "true" || word == "false";
}
function stringToBoolean(word) {
  return word == "true";
}
function stringIsNumber(word) {
  return NUM_REGEXP.test(word);
}
function sanitizeName(word) {
  word = word.replace(/[^A-Za-z0-9]/g, "_");
  word = word.replace(/^[0-9]/, "_");
  return word;
}
var _tmp = [];
function stringToAttribNames(word, target) {
  const elements = word.split(ATTRIB_NAMES_SEPARATOR);
  _tmp.length = 0;
  for (const element of elements) {
    const trimmed = element.trim();
    if (trimmed.length > 0) {
      _tmp.push(trimmed);
    }
  }
  arrayUniq(_tmp, target);
  return target;
}
function stringTailDigits(word) {
  const match = word.match(TAIL_DIGIT_MATCH_REGEXP);
  if (match) {
    return parseInt(match[0]);
  } else {
    return 0;
  }
}
function stringIncrement(word) {
  const match = word.match(TAIL_DIGIT_MATCH_REGEXP);
  if (match) {
    let numbers_as_str = match[0];
    let zeros_prefix = "";
    const leading_zeros_match = numbers_as_str.match(LEADING_ZEROS_MATCH_REGEXP);
    if (leading_zeros_match) {
      zeros_prefix = leading_zeros_match[0];
    }
    const digits = parseInt(numbers_as_str);
    if (digits == 0) {
      if (zeros_prefix.length > 0) {
        if (zeros_prefix[zeros_prefix.length - 1] == ZERO) {
          zeros_prefix = zeros_prefix.slice(0, -1);
        }
      }
    }
    const prefix = word.substring(0, word.length - match[0].length);
    return `${prefix}${zeros_prefix}${digits + 1}`;
  } else {
    return `${word}1`;
  }
}
function stringPluralize(word) {
  const last_char = word[word.length - 1];
  if (last_char !== "s") {
    return `${word}s`;
  } else {
    return word;
  }
}
function stringCamelCase(str) {
  const elements = str.replace(/_/g, " ").split(" ");
  let newWord = "";
  for (let i = 0; i < elements.length; i++) {
    let element = elements[i].toLowerCase();
    if (i > 0) {
      element = stringUpperFirst(element);
    }
    newWord += element;
  }
  return newWord;
}
function stringUpperFirst(word) {
  if (word.length == 0) {
    return word;
  }
  const newString = word[0].toUpperCase() + word.substring(1);
  return newString;
}
function stringTitleize(word) {
  const elements = word.split(/\s|_/g);
  const newElements = elements.map(stringUpperFirst);
  return newElements.join(" ");
}
function precision(val, decimals = 2) {
  decimals = Math.max(decimals, 0);
  const elements = `${val}`.split(".");
  if (decimals <= 0) {
    return elements[0];
  }
  let frac = elements[1];
  if (frac !== void 0) {
    if (frac.length > decimals) {
      frac = frac.substring(0, decimals);
    }
    frac = frac.padEnd(decimals, "0");
    return `${elements[0]}.${frac}`;
  } else {
    const string_to_pad = `${val}.`;
    const pad = string_to_pad.length + decimals;
    return string_to_pad.padEnd(pad, "0");
  }
}
function ensureFloat(num) {
  const num_as_string = `${num}`;
  const dot_pos = num_as_string.indexOf(".");
  if (dot_pos >= 0) {
    return num_as_string;
  } else {
    return `${num_as_string}.0`;
  }
}
function ensureInteger(num) {
  const num_as_string = `${num}`;
  const dot_pos = num_as_string.indexOf(".");
  if (dot_pos >= 0) {
    return num_as_string.split(".")[0];
  } else {
    return num_as_string;
  }
}
function stringMatchMask(word, mask) {
  if (mask === "*") {
    return true;
  }
  if (word == mask) {
    return true;
  }
  const elements = mask.split(SPACE);
  const exclusionFilters = [];
  for (const element of elements) {
    if (element.startsWith("^")) {
      exclusionFilters.push(element.substring(1));
    } else {
    }
  }
  for (const exclusionFilter of exclusionFilters) {
    const match = stringMatchMask(word, exclusionFilter);
    if (match) {
      return false;
    }
  }
  if (elements.length > 1) {
    for (const element of elements) {
      if (stringMatchMask(word, element)) {
        return true;
      }
    }
    return false;
  }
  mask = mask.split("*").join(".*");
  mask = `^${mask}$`;
  try {
    const regex = new RegExp(mask);
    return regex.test(word);
  } catch (err) {
    return false;
  }
}
function stringMatchesOneMask(word, masks) {
  for (const mask of masks) {
    if (stringMatchMask(word, mask)) {
      return true;
    }
  }
  return false;
}
var _indices = [];
var _subIndices = [];
function stringToIndices(indicesString, target) {
  target.length = 0;
  const elements = indicesString.split(INDICES_LIST_SEPARATOR);
  if (elements.length > 1) {
    _indices.length = 0;
    for (const element of elements) {
      stringToIndices(element, _subIndices);
      arrayPushItems(_subIndices, _indices);
    }
    arrayUniq(_indices, target);
    return target.sort((a, b) => a - b);
  } else {
    const element = elements[0];
    if (element) {
      if (element.indexOf(RANGE_SEPARATOR) > 0) {
        const rangeElements = element.split(RANGE_SEPARATOR);
        const rangeStart = rangeElements[0];
        const rangeEnd = rangeElements[1];
        const rangeStartI = parseInt(rangeStart);
        const rangeEndI = parseInt(rangeEnd);
        if (CoreType.isNumberValid(rangeStartI) && CoreType.isNumberValid(rangeEndI)) {
          return range(rangeStartI, rangeEndI + 1, 1, target);
        }
      } else {
        const parsed = parseInt(element);
        if (CoreType.isNumberValid(parsed)) {
          target.push(parsed);
          return target;
        }
      }
    }
  }
  return target;
}
function stringEscapeLineBreaks(word) {
  return word.replace(/(\r\n|\n|\r)/gm, "\\n");
}
var CoreString = class {
};
CoreString.isBoolean = stringIsBoolean;
CoreString.toBoolean = stringToBoolean;
CoreString.isNumber = stringIsNumber;
CoreString.tailDigits = stringTailDigits;
CoreString.increment = stringIncrement;
CoreString.pluralize = stringPluralize;
CoreString.camelCase = stringCamelCase;
CoreString.upperFirst = stringUpperFirst;
CoreString.titleize = stringTitleize;
CoreString.precision = precision;
CoreString.ensureFloat = ensureFloat;
CoreString.ensureInteger = ensureInteger;
CoreString.matchMask = stringMatchMask;
CoreString.matchesOneMask = stringMatchesOneMask;
CoreString.attribNames = stringToAttribNames;
CoreString.indices = stringToIndices;
CoreString.escapeLineBreaks = stringEscapeLineBreaks;
CoreString.sanitizeName = sanitizeName;

// node_modules/@polygonjs/polygonjs/dist/src/core/DecomposedPath.js
var DecomposedPath = class {
  constructor() {
    this._index = -1;
    this._pathElements = [];
    this._namedNodes = [];
    this._graphNodeIds = [];
    this._nodeElementByGraphNodeId = /* @__PURE__ */ new Map();
    this._absolutePath = "/";
  }
  reset() {
    this._index = -1;
    this._pathElements = [];
    this._namedNodes = [];
    this._graphNodeIds = [];
    this._nodeElementByGraphNodeId.clear();
  }
  addNamedNode(namedNode) {
    this._index += 1;
    if (namedNode.name == namedNode.node.name()) {
      this._namedNodes[this._index] = namedNode;
    }
    this._graphNodeIds[this._index] = namedNode.node.graphNodeId();
    this._nodeElementByGraphNodeId.set(namedNode.node.graphNodeId(), namedNode.name);
    this._absolutePath = [this._absolutePath, namedNode.name].join(CoreWalker.SEPARATOR);
  }
  addPathElement(pathElement) {
    this._index += 1;
    this._pathElements[this._index] = pathElement;
    if (pathElement.node) {
      this._absolutePath = pathElement.node.path();
    }
  }
  namedGraphNodes() {
    return this._namedNodes;
  }
  namedNodes(target) {
    target.length = 0;
    for (const namedNode of this._namedNodes) {
      if (namedNode) {
        const node = namedNode.node;
        if (node.nameController) {
          target.push(node);
        }
      }
    }
    return target;
  }
  updateFromNameChange(node) {
    const namedGraphNodeIds = this._namedNodes.map((n) => n == null ? void 0 : n.node.graphNodeId());
    if (namedGraphNodeIds.includes(node.graphNodeId())) {
      this._nodeElementByGraphNodeId.set(node.graphNodeId(), node.name());
    }
  }
  toPath() {
    const elements = new Array(this._index);
    for (let i = 0; i <= this._index; i++) {
      const namedNode = this._namedNodes[i];
      if (namedNode) {
        const nodeName = this._nodeElementByGraphNodeId.get(namedNode.node.graphNodeId());
        if (nodeName) {
          elements[i] = nodeName;
        }
      } else {
        const pathElement = this._pathElements[i];
        if (pathElement) {
          elements[i] = pathElement.path;
        }
      }
    }
    let joinedPath = elements.join(CoreWalker.SEPARATOR);
    const firstChar = joinedPath[0];
    if (firstChar) {
      if (!CoreWalker.NON_LETTER_PREFIXES.includes(firstChar)) {
        joinedPath = `${CoreWalker.SEPARATOR}${joinedPath}`;
      }
    }
    return joinedPath;
  }
  toAbsolutePath() {
    return this._absolutePath;
  }
};

// node_modules/@polygonjs/polygonjs/dist/src/engine/expressions/MethodDependency.js
var MethodDependency = class _MethodDependency extends CoreGraphNode {
  constructor(param, pathArgs, decomposedPath) {
    var _a;
    super(param.scene(), "MethodDependency");
    this.param = param;
    this.pathArgs = pathArgs;
    this.decomposedPath = decomposedPath;
    this._updateFromNameChangeBound = this._updateFromNameChange.bind(this);
    (_a = param.expressionController) == null ? void 0 : _a.registerMethodDependency(this);
    this.addPostDirtyHook("_updateFromNameChange", this._updateFromNameChangeBound);
  }
  _updateFromNameChange(trigger) {
    if (trigger && this.decomposedPath) {
      const node = trigger;
      this.decomposedPath.updateFromNameChange(node);
      const new_path = this.decomposedPath.toPath();
      const literal = this.jsep_node;
      const { indexOrPath } = this.pathArgs;
      if (literal && CoreType.isString(indexOrPath)) {
        literal.value = `${literal.value}`.replace(`${indexOrPath}`, new_path);
        literal.raw = literal.raw.replace(`${indexOrPath}`, new_path);
      }
      if (this.param.expressionController) {
        this.param.expressionController.updateFromMethodDependencyNameChange();
      }
    }
  }
  reset() {
    this.graphDisconnectPredecessors();
  }
  listen_for_name_changes() {
    if (this.jsep_node && this.decomposedPath) {
      const nodes = [];
      this.decomposedPath.namedNodes(nodes);
      for (const nodeInPath of nodes) {
        if (nodeInPath) {
          const node = nodeInPath;
          if (node.nameController) {
            this.addGraphInput(node.nameController.graphNode());
          }
        }
      }
    }
  }
  set_jsep_node(jsep_node) {
    this.jsep_node = jsep_node;
  }
  set_resolved_graph_node(node) {
    this.resolved_graph_node = node;
  }
  set_unresolved_path(path) {
    this.unresolved_path = path;
  }
  static create(param, pathArgs, node, decomposedPath) {
    const instance = new _MethodDependency(param, pathArgs, decomposedPath);
    if (node) {
      instance.set_resolved_graph_node(node);
    } else {
      const { indexOrPath } = pathArgs;
      if (CoreType.isString(indexOrPath)) {
        instance.set_unresolved_path(indexOrPath);
      }
    }
    return instance;
  }
};

export {
  TypedNodePathParamValue,
  TypedParamPathParamValue,
  CoreWalker,
  CoreGraphNode,
  MethodDependency,
  stringToAttribNames,
  stringTailDigits,
  stringMatchMask,
  CoreString,
  DecomposedPath
};
//# sourceMappingURL=chunk-RVFV2LA3.js.map
