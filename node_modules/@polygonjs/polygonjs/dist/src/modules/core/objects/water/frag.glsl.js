export default "uniform sampler2D mirrorSampler;\nuniform float alpha;\nuniform float time;\nuniform float timeScale;\nuniform float size;\nuniform float distortionScale;\nuniform float normalBias;\n// uniform sampler2D normalSampler;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform float wavesHeight;\nuniform vec3 waterColor;\nuniform vec3 reflectionColor;\nuniform float reflectionFresnel;\nuniform vec3 direction;\n\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\nvarying vec2 geoUV;\n\n// https://www.shadertoy.com/view/Xdlczl\n#define DRAG_MULT 0.048\n#define ITERATIONS_NORMAL 48\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n	float x = dot(direction, position) * frequency + timeshift * speed;\n	float wave = exp(sin(x) - 1.0);\n	float dx = wave * cos(x);\n	return vec2(wave, -dx);\n}\nfloat getwaves(vec2 position, float currentTime){\n	float iter = 0.0;\n	float phase = 6.0;\n	float speed = 2.0;\n	float weight = 1.0;\n	float w = 0.0;\n	float ws = 0.0;\n	for(int i=0;i<ITERATIONS_NORMAL;i++){\n		vec2 p = vec2(sin(iter), cos(iter));\n		vec2 res = wavedx(position, p, speed, phase, currentTime);\n		position += p * res.y * weight * DRAG_MULT;\n		w += res.x * weight;\n		iter += 12.0;\n		ws += weight;\n		weight = mix(weight, 0.0, 0.2);\n		phase *= 1.18;\n		speed *= 1.07;\n	}\n	return (w / ws);\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth, float currentTime){\n	vec2 ex = vec2(e, 0);\n	H = getwaves(pos.xy * 0.1, currentTime) * depth;\n	vec3 a = vec3(pos.x, H, pos.y);\n	return normalize(cross(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, currentTime) * depth, pos.y),\n						a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, currentTime) * depth, pos.y + e)));\n}\n\n\nvoid sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {\n	vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );\n	float direction = max( 0.0, dot( eyeDirection, reflection ) );\n	specularColor += pow( direction, shiny ) * sunColor * spec;\n	diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;\n}\n\n\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\nvoid main() {\n\n	#include <logdepthbuf_fragment>\n	float waterDepth = -wavesHeight;\n	vec3 surfaceNormal = normal(geoUV * size, normalBias /*0.01*/, waterDepth, time * timeScale);\n\n	vec3 diffuseLight = vec3(0.0);\n	vec3 specularLight = vec3(0.0);\n\n	vec3 worldToEye = eye-worldPosition.xyz;\n	vec3 eyeDirection = normalize( worldToEye );\n	sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );\n\n	float distance = length(worldToEye);\n\n	vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;\n	vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );\n\n	float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );\n	float rf0 = 0.05;\n	float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 2.0 );//rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );\n	reflectance = mix(1.0, reflectance, reflectionFresnel);\n	vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;\n	vec3 reflection = ( vec3( 0.0 ) + reflectionSample * 0.9 + reflectionSample * specularLight ) * reflectionColor;\n	vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), reflection, reflectance);\n	vec3 outgoingLight = albedo;\n	gl_FragColor = vec4( outgoingLight, 1.0 );\n\n	#include <tonemapping_fragment>\n	#include <fog_fragment>\n}";
