"use strict";
import { ClothMaterialController } from "./modules/ClothMaterialsController";
import { ClothGeometryInitController } from "./modules/ClothGeometryInitController";
import { ClothFBOController } from "./modules/ClothFBOController";
import { Vector3 } from "three";
import { GlParamConfig } from "../../engine/nodes/gl/code/utils/GLParamConfig";
export class ClothController {
  constructor(scene, _node, clothObject) {
    this.scene = scene;
    this._node = _node;
    this.clothObject = clothObject;
    //
    this.stepsCount = 40;
    this.constraintInfluence = 0.1;
    this.viscosity = 0.1;
    this.spring = 1;
    this._selectedVertexIndex = -1;
    this._selectedVertexPosition = new Vector3();
    this._node.initCoreClothControllerFromPersistedConfig(this);
    this.materials = new ClothMaterialController(this);
    this.geometryInit = new ClothGeometryInitController(this.clothObject);
    this.fbo = new ClothFBOController(this);
  }
  dispose() {
    if (this._persistedTextureAllocationsController) {
      this._persistedTextureAllocationsController.dispose();
      this._persistedTextureAllocationsController = void 0;
    }
  }
  setPersistedTextureAllocationController(controller) {
    this._persistedTextureAllocationsController = controller;
  }
  integrationFragmentShader() {
    let fragmentShader;
    this._node.shadersByName().forEach((shader, shaderName) => {
      fragmentShader = shader;
    });
    return fragmentShader;
  }
  textureAllocationsController() {
    var _a;
    const node = this._node;
    return ((_a = node.assemblerController()) == null ? void 0 : _a.assembler.textureAllocationsController()) || this._persistedTextureAllocationsController;
  }
  assignReadonlyTextures(material, texturesByName) {
    const textureNames = Object.keys(texturesByName);
    for (const textureName of textureNames) {
      const texture = texturesByName[textureName];
      const uniformName = textureName;
      material.uniforms[uniformName] = { value: texture };
    }
  }
  addMaterialUniforms(material) {
    var _a;
    const node = this._node;
    const assembler = (_a = node.assemblerController()) == null ? void 0 : _a.assembler;
    if (assembler) {
      for (const param_config of assembler.param_configs()) {
        material.uniforms[param_config.uniformName()] = param_config.uniform();
      }
    } else {
      const persisted_data = node.persisted_config.loaded_data();
      if (persisted_data) {
        const persisted_uniforms = node.persisted_config.uniforms();
        if (persisted_uniforms) {
          const param_uniform_pairs = persisted_data.param_uniform_pairs;
          for (const pair of param_uniform_pairs) {
            const param_name = pair[0];
            const uniform_name = pair[1];
            const param = node.params.get(param_name);
            const uniform = persisted_uniforms[uniform_name];
            material.uniforms[uniform_name] = uniform;
            if (param && uniform) {
              const callback = () => {
                GlParamConfig.callback(param, material.uniforms[uniform_name]);
              };
              param.options.setOption("callback", callback);
              callback();
            }
          }
        }
      }
    }
  }
  init(renderer) {
    this.fbo.init(renderer);
  }
  update(config) {
    this.fbo.update(config);
  }
  _setSelectedVertexIndex(index) {
    if (index == null) {
      this._selectedVertexIndex = -1;
    } else {
      this._selectedVertexIndex = index;
    }
  }
  createConstraint(index) {
    this._setSelectedVertexIndex(index);
  }
  deleteConstraint() {
    this._setSelectedVertexIndex(null);
  }
  selectedVertexIndex() {
    return this._selectedVertexIndex;
  }
  setConstraintPosition(position) {
    this._selectedVertexPosition.copy(position);
  }
  constraintPosition(target) {
    target.copy(this._selectedVertexPosition);
  }
}
