"use strict";
import { Vector3 } from "three";
import {
  degToRad as _degToRad,
  radToDeg as _radToDeg,
  smoothstep as _smoothstep,
  smootherstep as _smootherstep
} from "three/src/math/MathUtils";
import { Easing } from "./Easing";
import { CoreType } from "../Type";
const RAND_A = 12.9898;
const RAND_B = 78.233;
const RAND_C = 43758.5453;
export const degToRad = _degToRad;
export const radToDeg = _radToDeg;
export function clamp(val, min, max) {
  if (val < min) {
    return min;
  } else if (val > max) {
    return max;
  } else {
    return val;
  }
}
export const smoothstep = _smoothstep;
export const smootherstep = _smootherstep;
export function fit(val, srcMin, srcMax, destMin, destMax) {
  const src_range = srcMax - srcMin;
  const dest_range = destMax - destMin;
  const r = (val - srcMin) / src_range;
  return r * dest_range + destMin;
}
export function fit01(val, destMin, destMax) {
  return fit(val, 0, 1, destMin, destMax);
}
export function fitClamp(val, srcMin, srcMax, destMin, destMax) {
  const r = fit(val, srcMin, srcMax, destMin, destMax);
  return clamp(r, destMin, destMax);
}
export function mix(num0, num1, blend) {
  return (1 - blend) * num0 + blend * num1;
}
export const fract = (number) => number - Math.floor(number);
const DEFAULT_Y = 136574;
const _vec = { x: 0, y: DEFAULT_Y };
export function randFloat(x, y = DEFAULT_Y) {
  _vec.x = x;
  _vec.y = y;
  return randVec2(_vec);
}
export function randVec2(uv) {
  const dt = uv.x * RAND_A + uv.y * RAND_B;
  const sn = dt % Math.PI;
  return fract(Math.sin(sn) * RAND_C);
}
export function rand(number) {
  if (CoreType.isNumber(number)) {
    return randFloat(number);
  } else {
    return randVec2(number);
  }
}
export function round(number, stepSize) {
  const stepsCount = number / stepSize;
  const roundedStepsCount = number < 0 ? Math.ceil(stepsCount) : Math.floor(stepsCount);
  return roundedStepsCount * stepSize;
}
export function mod(number, _mod) {
  return (number % _mod + _mod) % _mod;
}
export function highestEven(number) {
  return 2 * Math.ceil(number * 0.5);
}
export function nearestPower2(num) {
  return Math.pow(2, Math.ceil(Math.log(num) / Math.log(2)));
}
export function pow2Inverse(num) {
  return Math.log(num) / Math.log(2);
}
export function geodesicDistance(lnglat1, lnglat2) {
  var R = 6371e3;
  var d1 = degToRad(lnglat1.lat);
  var d2 = degToRad(lnglat2.lat);
  var ad1 = degToRad(lnglat2.lat - lnglat1.lat);
  var ad2 = degToRad(lnglat2.lng - lnglat1.lng);
  var a = Math.sin(ad1 / 2) * Math.sin(ad1 / 2) + Math.cos(d1) * Math.cos(d2) * Math.sin(ad2 / 2) * Math.sin(ad2 / 2);
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  var d = R * c;
  return d;
}
const _triangleMid = new Vector3();
const _triangleMidToCorner = new Vector3();
export function expandTriangle(triangle, margin) {
  triangle.getMidpoint(_triangleMid);
  _triangleMidToCorner.copy(triangle.a).sub(_triangleMid);
  _triangleMidToCorner.normalize().multiplyScalar(margin);
  triangle.a.add(_triangleMidToCorner);
  _triangleMidToCorner.copy(triangle.b).sub(_triangleMid);
  _triangleMidToCorner.normalize().multiplyScalar(margin);
  triangle.b.add(_triangleMidToCorner);
  _triangleMidToCorner.copy(triangle.c).sub(_triangleMid);
  _triangleMidToCorner.normalize().multiplyScalar(margin);
  triangle.c.add(_triangleMidToCorner);
}
export function lerpFloat(current, target, blend) {
  return current * (1 - blend) + target * blend;
}
export class CoreMath {
}
CoreMath.Easing = Easing;
// used in expressions
CoreMath.degToRad = degToRad;
// used in expressions
CoreMath.radToDeg = radToDeg;
// used in expressions
CoreMath.clamp = clamp;
// used in expressions
CoreMath.smoothstep = smoothstep;
CoreMath.smootherstep = smootherstep;
CoreMath.fit01 = fit01;
// used in expressions
CoreMath.fit = fit;
// used in expressions
CoreMath.fitClamp = fitClamp;
// used in expressions
CoreMath.mix = mix;
// used in expressions
CoreMath.fract = fract;
// used in expressions
CoreMath.rand = rand;
// from threejs glsl rand
CoreMath.round = round;
CoreMath.highestEven = highestEven;
CoreMath.nearestPower2 = nearestPower2;
CoreMath.pow2Inverse = pow2Inverse;
CoreMath.randFloat = randFloat;
CoreMath.randVec2 = randVec2;
CoreMath.lerpFloat = lerpFloat;
