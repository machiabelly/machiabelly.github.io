"use strict";
import { CoreParticlesAttribute } from "./CoreParticlesAttribute";
import { CoreParticlesGpuComputeController } from "./CoreParticlesGpuComputeController";
import { CoreParticlesRenderController } from "./CoreParticlesRenderController";
export class CoreParticlesController {
  constructor(scene, _node) {
    this.scene = scene;
    this._node = _node;
    this._shadersByName = /* @__PURE__ */ new Map();
    this._shaderNames = [];
    this._uniformNames = [];
    this._debugCook = false;
    this.gpuController = new CoreParticlesGpuComputeController(this);
    this.renderController = new CoreParticlesRenderController(this);
    this._node.initCoreParticlesControllerFromPersistedConfig(this);
  }
  object() {
    return this._object;
  }
  renderer() {
    return this._renderer;
  }
  dispose() {
    this.gpuController.dispose();
    this.renderController.dispose();
  }
  async init(object, renderer) {
    this._object = object;
    this._renderer = renderer;
    this.setShadersByName(this._node.shadersByName());
    this.gpuController.reset();
    const configRef = this.gpuController.init();
    if (!configRef) {
      console.warn("no configRef created");
      return;
    }
    await this.renderController.init();
    const preRollFramesCount = CoreParticlesAttribute.getPreRollFramesCount(this._object);
    for (let i = 0; i < preRollFramesCount; i++) {
      this.gpuController.computeSimulation(1 / 60, configRef);
    }
    return configRef;
  }
  stepSimulation(delta, configRef) {
    this.gpuController.computeSimulation(delta, configRef);
  }
  async reset() {
    this.gpuController.reset();
    this.renderController.reset();
    if (this._object && this._renderer) {
      return await this.init(this._object, this._renderer);
    } else {
      console.log("no object or renderer", this._object, this._renderer);
    }
  }
  setError(message) {
    this._node.states.error.set(message);
  }
  // assemblerController(){
  // 	return this._node.assemblerController()
  // }
  node() {
    return this._node;
  }
  setShadersByName(shadersByName) {
    this._shadersByName.clear();
    this._shaderNames.length = 0;
    this._uniformNames.length = 0;
    shadersByName.forEach((shader, shaderName) => {
      this._shadersByName.set(shaderName, shader);
      this._shaderNames.push(shaderName);
      this._uniformNames.push(`texture_${shaderName}`);
    });
  }
  shadersByName() {
    return this._shadersByName;
  }
  shaderNames() {
    return this._shaderNames;
  }
  uniformNames() {
    return this._uniformNames;
  }
  setPersistedTextureAllocationController(controller) {
    this.gpuController.setPersistedTextureAllocationController(controller);
  }
  debugMessage(message) {
    if (!this._debugCook) {
      return;
    }
    console.log(message);
  }
}
