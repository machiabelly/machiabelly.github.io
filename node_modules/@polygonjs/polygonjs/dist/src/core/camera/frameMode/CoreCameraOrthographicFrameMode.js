"use strict";
import { OrthographicCamera } from "three";
import { OrthographicCameraAttribute } from "../CoreCamera";
import { CameraFrameMode } from "../CoreCameraFrameMode";
import { ORTHOGRAPHIC_CAMERA_DEFAULT } from "../CoreOrthographicCamera";
import { BaseCoreCameraFrameMode } from "./_BaseCoreCameraFrameMode";
import { cameraSetViewOffset } from "../CoreCameraViewOffset";
import { coreObjectClassFactory } from "../../geometry/CoreObjectFactory";
OrthographicCamera;
export class CoreCameraOrthographicFrameMode {
  static updateCameraAspect(camera, aspect, options) {
    const cameraWithAttributes = (options == null ? void 0 : options.cameraWithAttributes) || camera;
    const frameMode = BaseCoreCameraFrameMode.frameMode(cameraWithAttributes);
    const expectedAspectRatio = BaseCoreCameraFrameMode.expectedAspectRatio(cameraWithAttributes);
    const size = coreObjectClassFactory(cameraWithAttributes).attribValue(
      cameraWithAttributes,
      OrthographicCameraAttribute.SIZE
    );
    if (size != null) {
      this._update({
        mode: frameMode,
        camera,
        size,
        aspect,
        expectedAspectRatio
      });
    }
    if (options && options.resolution) {
      cameraSetViewOffset(camera, options.resolution);
    }
    camera.updateProjectionMatrix();
  }
  static _update(options) {
    const mode = options.mode;
    if (mode == CameraFrameMode.DEFAULT || options.expectedAspectRatio == null) {
      this._adjustFOVFromModeDefault(options);
    } else {
      const { expectedAspectRatio } = options;
      if (mode == CameraFrameMode.COVER) {
        this._adjustFOVFromModeCover({ ...options, expectedAspectRatio });
      } else {
        this._adjustFOVFromModeContain({ ...options, expectedAspectRatio });
      }
    }
  }
  static _adjustFOVFromModeDefault(options) {
    this._adjustFOVFromSize(options.size || 1, options);
  }
  static _adjustFOVFromModeCover(options) {
    const size = options.size || 1;
    if (options.aspect > options.expectedAspectRatio) {
      this._adjustFOVFromSize(options.expectedAspectRatio * size / options.aspect, options);
    } else {
      this._adjustFOVFromSize(size, options);
    }
  }
  static _adjustFOVFromModeContain(options) {
    const size = options.size || 1;
    if (options.aspect > options.expectedAspectRatio) {
      this._adjustFOVFromSize(size, options);
    } else {
      this._adjustFOVFromSize(options.expectedAspectRatio * size / options.aspect, options);
    }
  }
  static _adjustFOVFromSize(size, options) {
    const horizontalSize = size * options.aspect;
    const zoom = 1;
    options.camera.left = ORTHOGRAPHIC_CAMERA_DEFAULT.left * horizontalSize * zoom;
    options.camera.right = ORTHOGRAPHIC_CAMERA_DEFAULT.right * horizontalSize * zoom;
    options.camera.top = ORTHOGRAPHIC_CAMERA_DEFAULT.top * size * zoom;
    options.camera.bottom = ORTHOGRAPHIC_CAMERA_DEFAULT.bottom * size * zoom;
  }
}
