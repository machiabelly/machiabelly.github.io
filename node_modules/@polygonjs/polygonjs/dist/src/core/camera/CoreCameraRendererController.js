"use strict";
import { Poly } from "../../engine/Poly";
import {
  DEFAULT_OUTPUT_COLOR_SPACE,
  DEFAULT_SHADOW_MAP_TYPE,
  DEFAULT_TONE_MAPPING
} from "../../engine/nodes/rop/WebGLRenderer";
import { defaultPixelRatio } from "../render/defaultPixelRatio";
import { CameraAttribute } from "./CoreCamera";
import { CoreType } from "../Type";
import { RopType } from "../../engine/poly/registers/nodes/types/Rop";
import { NodeContext } from "../../engine/poly/NodeContext";
import { TypedNode } from "../../engine/nodes/_Base";
import { coreObjectClassFactory } from "../geometry/CoreObjectFactory";
const UPDATE_STYLE = false;
const SIZE_MULT = 1;
const _CoreCameraRendererController = class {
  // private static _superSamplingSize = new Vector2();
  // static canvasResolution(canvas: HTMLCanvasElement) {
  // 	return this._resolutionByCanvasId.get(canvas.id);
  // }
  static renderer(canvas) {
    return this._renderersByCanvas.get(canvas);
  }
  static rendererNode(options) {
    const { scene, camera } = options;
    const rendererROPId = coreObjectClassFactory(camera).attribValue(camera, CameraAttribute.RENDERER_NODE_ID);
    if (rendererROPId && CoreType.isNumber(rendererROPId)) {
      const rendererROP = scene.graph.nodeFromId(rendererROPId);
      return rendererROP;
    }
  }
  static rendererConfig(options) {
    const { canvas, scene } = options;
    const gl = Poly.renderersController.getRenderingContext(canvas);
    if (!gl) {
      console.error("failed to create webgl context");
      return;
    }
    let renderer;
    let rendererNode;
    const rendererROP = this.rendererNode(options);
    if (rendererROP != null && rendererROP instanceof TypedNode && rendererROP.context() == NodeContext.ROP) {
      const type = rendererROP.type();
      switch (type) {
        case RopType.WEBGL: {
          renderer = rendererROP.createRenderer(canvas, gl);
          rendererNode = rendererROP;
          break;
        }
        case RopType.PATH_TRACING: {
          renderer = rendererROP.renderer(canvas, gl);
          rendererNode = rendererROP;
          break;
        }
      }
    }
    if (!renderer) {
      renderer = this._defaultRendererByContext.get(gl);
      if (!renderer) {
        renderer = _CoreCameraRendererController.createDefaultRenderer(canvas, gl);
        this._defaultRendererByContext.set(gl, renderer);
      }
    }
    scene.renderersRegister.registerRenderer(renderer);
    this._renderersByCanvas.set(canvas, renderer);
    if (!renderer) {
      return;
    }
    const renderConfig = {
      renderer,
      rendererNode
    };
    return renderConfig;
  }
  static setRendererSize(canvas, size) {
    const renderer = this.renderer(canvas);
    if (renderer) {
      renderer.setSize(SIZE_MULT * size.x, SIZE_MULT * size.y, UPDATE_STYLE);
    }
  }
  static createDefaultRenderer(canvas, gl) {
    const renderer = Poly.renderersController.defaultWebGLRendererForCanvas(canvas);
    const pixelRatio = defaultPixelRatio();
    renderer.setPixelRatio(pixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = DEFAULT_SHADOW_MAP_TYPE;
    renderer.toneMapping = DEFAULT_TONE_MAPPING;
    renderer.toneMappingExposure = 1;
    renderer.outputColorSpace = DEFAULT_OUTPUT_COLOR_SPACE;
    if (Poly.renderersController.printDebug()) {
      Poly.renderersController.printDebugMessage("create default renderer");
    }
    return renderer;
  }
};
export let CoreCameraRendererController = _CoreCameraRendererController;
// private static _resolutionByCanvas: Map<HTMLCanvasElement, Vector2> = new Map();
CoreCameraRendererController._defaultRendererByContext = /* @__PURE__ */ new Map();
CoreCameraRendererController._renderersByCanvas = /* @__PURE__ */ new Map();
