import { Vector3, TypedArray } from 'three';
import { TetEmbed } from './Common';
import { SoftBodyConstraint } from './SoftBodyConstraint';
import { TetSoftBodySolverSopNode } from '../../engine/nodes/sop/TetSoftBodySolver';
export type VelocityFunction = () => Vector3;
export type SDFFunction = () => number;
export type SDFEvaluator = (p: Vector3) => number;
interface SoftBodyOptions {
    node: TetSoftBodySolverSopNode;
    tetEmbed: TetEmbed;
    highResSkinning: {
        lookup: {
            spacing: number;
            padding: number;
        };
    };
}
export declare class SoftBody {
    private options;
    readonly numParticles: number;
    readonly numTets: number;
    readonly pos: Float32Array;
    readonly prevPos: TypedArray;
    readonly vel: Float32Array;
    readonly tetIds: number[];
    readonly edgeIds: number[];
    readonly restVol: Float32Array;
    readonly edgeLengths: Float32Array;
    readonly invMass: Float32Array;
    readonly temp: Float32Array;
    readonly grads: Float32Array;
    readonly constraintsById: Map<number, SoftBodyConstraint>;
    private readonly bufferGeometry;
    private numVisVerts;
    private skinningInfo;
    private highResGeometry;
    private highResObjectPosition;
    private _node;
    constructor(options: SoftBodyOptions);
    private _computeSkinningInfo;
    updateLowResObject(): void;
    updateHighResMesh(): void;
    getTetVolume(nr: number): number;
    initPhysics(): void;
    preSolve(dt: number, gravity: number[], velFunc: VelocityFunction, sdfEvaluator: SDFEvaluator): void;
    solve(dt: number, edgeCompliance: number, volumeCompliance: number, preciseCollisions: boolean, sdfEvaluator: SDFEvaluator): void;
    postSolve(dt: number): void;
    solveEdges(dt: number, compliance: number, preciseCollisions: boolean, sdfEvaluator: SDFEvaluator): void;
    solveVolumes(dt: number, compliance: number, preciseCollisions: boolean, sdfEvaluator: SDFEvaluator): void;
    translate(offset: Vector3): void;
    velocityMult(mult: number): void;
    createConstraint(index: number): SoftBodyConstraint;
    getConstraint(constraintId: number): SoftBodyConstraint | undefined;
    private _constraintVel;
    deleteConstraint(constraintId: number): void;
}
export {};
