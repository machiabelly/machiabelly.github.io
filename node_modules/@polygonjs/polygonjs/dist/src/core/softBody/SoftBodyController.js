"use strict";
export class SoftBodyController {
  constructor(scene, options) {
    this.scene = scene;
    this._gravity = [0, -9.8, 0];
    this._node = options.node;
  }
  setSoftBody(softBody) {
    this._softBody = softBody;
  }
  dispose() {
    this._softBody = void 0;
  }
  step(stepsCount, edgeCompliance, volumeCompliance, preciseCollisions) {
    const softBody = this._softBody;
    if (!softBody) {
      return;
    }
    const functions = this._node.function();
    if (!(functions.collider && functions.velocity)) {
      return;
    }
    const args = this._node.functionEvalArgsWithParamConfigs();
    const velFunc = functions.velocity(...args.velocity);
    const sdfFunc = functions.collider(...args.collider);
    const sdfEvaluator = (p) => {
      this._node.setPositionGlobals(p);
      return sdfFunc();
    };
    const delta = this.scene.timeController.delta();
    const sdt = delta / stepsCount;
    for (let step = 0; step < stepsCount; step++) {
      this._node.updateSceneGlobals(step, sdt);
      softBody.preSolve(sdt, this._gravity, velFunc, sdfEvaluator);
      softBody.solve(sdt, edgeCompliance, volumeCompliance, preciseCollisions, sdfEvaluator);
      softBody.postSolve(sdt);
    }
    softBody.updateLowResObject();
    softBody.updateHighResMesh();
  }
}
