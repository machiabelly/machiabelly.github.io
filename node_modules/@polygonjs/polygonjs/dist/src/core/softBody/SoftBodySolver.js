"use strict";
import { Vector3 } from "three";
import { softBodyControllerFromObject, softBodyFromObject } from "./SoftBodyControllerRegister";
const bboxCenter = new Vector3();
const targetPosition = new Vector3();
const delta = new Vector3();
export function softBodySolverStepSimulation(softBodyObject, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions) {
  const controller = softBodyControllerFromObject(softBodyObject);
  if (!controller) {
    console.log("no controller for", softBodyObject.uuid, softBodyObject);
    return;
  }
  controller.step(stepsCount, edgeCompliance, volumeCompliance, preciseCollisions);
}
export function setSoftBodySolverGravity(softBodyObject, gravity, lerp) {
  const controller = softBodyControllerFromObject(softBodyObject);
  if (!controller) {
    console.log("no controller for", softBodyObject.uuid);
    return;
  }
  console.warn("setGravity not implemented");
}
export function softBodySetPosition(softBodyObject, position, lerp) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  if (!softBodyObject.geometry) {
    return;
  }
  softBodyObject.geometry.computeBoundingBox();
  if (!softBodyObject.geometry.boundingBox) {
    return;
  }
  softBodyObject.geometry.boundingBox.getCenter(bboxCenter);
  targetPosition.copy(bboxCenter).lerp(position, lerp);
  delta.copy(targetPosition).sub(bboxCenter);
  softBody.translate(delta);
}
export function softBodyMultiplyVelocity(softBodyObject, mult) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  softBody.velocityMult(mult);
}
export function softBodyConstraintCreate(softBodyObject, index) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  return softBody.createConstraint(index);
}
export function softBodyConstraintSetPosition(softBodyObject, constraintId, pos, lerp, delta2) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  const constraint = softBody.getConstraint(constraintId);
  if (!constraint) {
    return;
  }
  constraint.setPosition(pos, lerp, delta2);
}
export function softBodyConstraintDelete(softBodyObject, constraintId) {
  const softBody = softBodyFromObject(softBodyObject);
  if (!softBody) {
    console.log("no softBody for", softBodyObject.uuid);
    return;
  }
  softBody.deleteConstraint(constraintId);
}
