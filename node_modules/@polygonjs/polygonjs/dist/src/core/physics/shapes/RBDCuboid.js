"use strict";
import { Vector3 } from "three";
import {
  CorePhysicsAttribute,
  PhysicsRBDColliderType,
  physicsAttribNameLive,
  PhysicsRBDCuboidAttribute
} from "../PhysicsAttribute";
import { _getRBDFromObject } from "../PhysicsRBD";
import { touchRBDProperty } from "../../reactivity/RBDPropertyReactivity";
import { coreObjectClassFactory } from "../../geometry/CoreObjectFactory";
const EXPECTED_TYPE = PhysicsRBDColliderType.CUBOID;
export var RBDCuboidProperty = /* @__PURE__ */ ((RBDCuboidProperty2) => {
  RBDCuboidProperty2["SIZES"] = "sizes";
  return RBDCuboidProperty2;
})(RBDCuboidProperty || {});
const tmp = new Vector3();
let _currentSizes = new Vector3();
let _targetSizes = new Vector3();
let _targetHalfSizes = new Vector3();
let _originalSizes = new Vector3();
const SAFETY_OFFSET = 1e-3;
const attribSizeLiveByObject = /* @__PURE__ */ new WeakMap();
function _getAttribSizeLiveByObject(object3D) {
  let v = attribSizeLiveByObject.get(object3D);
  if (!v) {
    v = new Vector3();
    attribSizeLiveByObject.set(object3D, v);
  }
  return v;
}
export function createPhysicsCuboid(PhysicsLib2, object) {
  CorePhysicsAttribute.getCuboidSizes(object, tmp);
  const size = CorePhysicsAttribute.getCuboidSize(object);
  tmp.multiplyScalar(size * 0.5);
  tmp.multiply(object.scale);
  const borderRadius = CorePhysicsAttribute.getBorderRadius(object);
  if (borderRadius <= 0) {
    return PhysicsLib2.ColliderDesc.cuboid(tmp.x, tmp.y, tmp.z);
  } else {
    const minDim = Math.min(tmp.x, tmp.y, tmp.z);
    const borderRadiusAdjusted = Math.min(borderRadius, minDim - SAFETY_OFFSET);
    tmp.subScalar(borderRadiusAdjusted);
    return PhysicsLib2.ColliderDesc.roundCuboid(tmp.x, tmp.y, tmp.z, borderRadiusAdjusted);
  }
}
const attributeSizesLive = physicsAttribNameLive(PhysicsRBDCuboidAttribute.SIZES);
export function currentSizes(object, collider, target) {
  const coreObjectClass = coreObjectClassFactory(object);
  let result = coreObjectClass.attribValue(object, attributeSizesLive, 0, target);
  if (result == null) {
    const shape = collider.shape;
    const v = shape.halfExtents;
    target.set(v.x, v.y, v.z).multiplyScalar(2);
    coreObjectClass.setAttribute(object, attributeSizesLive, new Vector3().copy(target));
  }
}
export function _getPhysicsRBDCuboidSizes(object, target) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = CorePhysicsAttribute.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collider = body.collider(0);
  if (!collider) {
    return;
  }
  currentSizes(object, collider, target);
}
export function _setPhysicsRBDCuboidProperty(object, targetSizes, targetSize, lerp, updateObjectMatrix) {
  const body = _getRBDFromObject(object);
  if (!body) {
    console.warn("no rbd found");
    return;
  }
  const colliderType = CorePhysicsAttribute.getColliderType(object);
  if (colliderType == null || colliderType != EXPECTED_TYPE) {
    return;
  }
  const collidersCount = body.numColliders();
  CorePhysicsAttribute.getCuboidSizes(object, _originalSizes);
  const originalSize = CorePhysicsAttribute.getCuboidSize(object);
  _originalSizes.multiplyScalar(originalSize);
  for (let i = 0; i < collidersCount; i++) {
    const collider = body.collider(i);
    if (!collider) {
      return;
    }
    _targetSizes.copy(targetSizes).multiplyScalar(targetSize);
    if (lerp < 1) {
      currentSizes(object, collider, _currentSizes);
      _targetSizes.lerp(_currentSizes, 1 - lerp);
    }
    const v = _getAttribSizeLiveByObject(object);
    v.copy(_targetSizes);
    const coreObjectClass = coreObjectClassFactory(object);
    coreObjectClass.setAttribute(object, attributeSizesLive, v);
    touchRBDProperty(object, "sizes" /* SIZES */);
    object.scale.copy(_targetSizes).divide(_originalSizes);
    if (updateObjectMatrix) {
      object.updateMatrix();
    }
    _targetHalfSizes.copy(_targetSizes).multiplyScalar(0.5);
    collider.setHalfExtents(_targetHalfSizes);
  }
}
