"use strict";
import { MapUtils } from "./MapUtils";
import { setUnion, setToArray, setIntersection, setDifference, setXOR } from "./SetUtils";
import { CoreType } from "./Type";
import { randFloat } from "./math/_Module";
const _tmp = /* @__PURE__ */ new Set();
const _tmp0 = /* @__PURE__ */ new Set();
const _tmp1 = /* @__PURE__ */ new Set();
export function range(start, end, step, target) {
  if (end == null) {
    end = start;
    start = 0;
  }
  const length = Math.floor((end - start) / step);
  target.length = length;
  for (let i = 0; i < length; i++) {
    target[i] = start + i * step;
  }
  return target;
}
export function rangeWithEnd(end) {
  const target = [];
  range(0, end, 1, target);
  return target;
}
export function rangeStartEnd(start, end) {
  const target = [];
  range(start, end, 1, target);
  return target;
}
export function arrayUniq(array, target) {
  target.length = 0;
  for (const element of array) {
    if (!target.includes(element)) {
      target.push(element);
    }
  }
  return target;
}
export function sampleIndex(array, seed) {
  return Math.floor(randFloat(seed) * array.length);
}
export function sample(array, seed) {
  return array[sampleIndex(array, seed)];
}
export function spliceSample(array, seed) {
  return array.splice(sampleIndex(array, seed), 1)[0];
}
export function uniqWithoutPreservingOrder(array, target) {
  arrayToSet(array, _tmp);
  return setToArray(_tmp, target);
}
export function arrayCompact(array, target) {
  target.length = 0;
  for (const elem of array) {
    if (elem != null) {
      target.push(elem);
    }
  }
  return target;
}
export function arrayMin(array) {
  let min = array[0];
  for (const element of array) {
    if (element < min) {
      min = element;
    }
  }
  return min;
}
export function arrayMax(array) {
  let max = array[0];
  for (const element of array) {
    if (element > max) {
      max = element;
    }
  }
  return max;
}
export function arraySum(array) {
  let sum = 0;
  for (const element of array) {
    sum += element;
  }
  return sum;
}
export function arrayChunk(array, chunkSize) {
  const newArray = [];
  let newSubArray = [];
  newArray.push(newSubArray);
  for (let i = 0; i < array.length; i++) {
    if (newSubArray.length == chunkSize) {
      newSubArray = [];
      newArray.push(newSubArray);
    }
    newSubArray.push(array[i]);
  }
  return newArray;
}
export function arrayUnion(array0, array1, target) {
  setUnion(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
export function arrayIntersection(array0, array1, target) {
  setIntersection(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
export function arrayDifference(array0, array1, target) {
  setDifference(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
export function arrayXOR(array0, array1, target) {
  setXOR(arrayToSet(array0, _tmp0), arrayToSet(array1, _tmp1), _tmp);
  target.length = 0;
  for (const item of _tmp) {
    target.push(item);
  }
  return target;
}
export function arrayToSet(array, target) {
  target.clear();
  for (const elem of array) {
    target.add(elem);
  }
  return target;
}
export function arrayIsEqual(array0, array1) {
  if (array0.length != array1.length) {
    return false;
  }
  const count = array0.length;
  for (let i = 0; i < count; i++) {
    if (array0[i] != array1[i]) {
      return false;
    }
  }
  return true;
}
export function arraySortBy(array, callback) {
  if (array.length == 0) {
    return [];
  }
  const elementsByValue = /* @__PURE__ */ new Map();
  const valuesSet = /* @__PURE__ */ new Set();
  for (const elem of array) {
    const value = callback(elem);
    valuesSet.add(value);
    MapUtils.pushOnArrayAtEntry(elementsByValue, value, elem);
  }
  const values = new Array(valuesSet.size);
  let i = 0;
  valuesSet.forEach((value) => {
    values[i] = value;
    i++;
  });
  if (CoreType.isString(values[0])) {
    values.sort();
  } else {
    values.sort((a, b) => a - b);
  }
  const sorted_elements = new Array(array.length);
  i = 0;
  for (const value of values) {
    const elements_for_value = elementsByValue.get(value);
    if (elements_for_value) {
      for (const element of elements_for_value) {
        sorted_elements[i] = element;
        i++;
      }
    }
  }
  return sorted_elements;
}
export function arrayShallowClone(array) {
  return [...array];
}
export function arrayMap(array, callback, target) {
  target.length = 0;
  for (const item of array) {
    target.push(callback(item));
  }
  return target;
}
export function arrayAverage(array) {
  return arraySum(array) / array.length;
}
export class ArrayUtils {
}
ArrayUtils.shallowClone = arrayShallowClone;
ArrayUtils.min = arrayMin;
ArrayUtils.max = arrayMax;
ArrayUtils.sum = arraySum;
ArrayUtils.compact = arrayCompact;
ArrayUtils.uniq = arrayUniq;
ArrayUtils.uniqWithoutPreservingOrder = uniqWithoutPreservingOrder;
ArrayUtils.chunk = arrayChunk;
ArrayUtils.union = arrayUnion;
ArrayUtils.intersection = arrayIntersection;
ArrayUtils.toSet = arrayToSet;
ArrayUtils.isEqual = arrayIsEqual;
ArrayUtils.sortBy = arraySortBy;
ArrayUtils.range = range;
export function arrayPushItems(srcArray, target) {
  for (const item of srcArray) {
    target.push(item);
  }
}
export function arrayCopy(srcArray, targetArray) {
  targetArray.length = 0;
  arrayPushItems(srcArray, targetArray);
}
export function typedArrayCopy(srcArray, targetArray) {
  targetArray.set(srcArray);
  return targetArray;
}
