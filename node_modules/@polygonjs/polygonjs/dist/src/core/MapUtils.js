"use strict";
export function mapFirstKey(map) {
  for (const [k] of map) {
    return k;
  }
}
export function pushOnArrayAtEntry(map, key, newElement) {
  if (map.has(key)) {
    map.get(key).push(newElement);
  } else {
    map.set(key, [newElement]);
  }
}
export function popFromArrayAtEntry(map, key, elementToRemove, removeFromMapIfEmpty = true) {
  if (map.has(key)) {
    const array = map.get(key);
    const index = array.indexOf(elementToRemove);
    if (index >= 0) {
      array.splice(index, 1);
      if (removeFromMapIfEmpty && array.length == 0) {
        map.delete(key);
      }
    }
  }
}
export function addToSetAtEntry(map, key, newElement) {
  if (map.has(key)) {
    map.get(key).add(newElement);
  } else {
    const set = /* @__PURE__ */ new Set();
    set.add(newElement);
    map.set(key, set);
  }
}
export function addToMapAtEntry(map, key0, key1, newElement) {
  let subMap = map.get(key0);
  if (!subMap) {
    subMap = /* @__PURE__ */ new Map();
    map.set(key0, subMap);
  }
  subMap.set(key1, newElement);
}
export function getMapElementAtEntry(map, key0, key1) {
  let subMap = map.get(key0);
  if (!subMap) {
    return;
  }
  return subMap.get(key1);
}
export function mapValuesToArray(map, target) {
  target.length = 0;
  map.forEach((v) => {
    target.push(v);
  });
  return target;
}
export function removeFromSetAtEntry(map, key, elementToRemove) {
  if (map.has(key)) {
    const set = map.get(key);
    set.delete(elementToRemove);
    if (set.size == 0) {
      map.delete(key);
    }
  }
}
export function unshiftOnArrayAtEntry(map, key, newElement) {
  if (map.has(key)) {
    map.get(key).unshift(newElement);
  } else {
    map.set(key, [newElement]);
  }
}
export function concatOnArrayAtEntry(map, key, newElements) {
  if (map.has(key)) {
    let array = map.get(key);
    for (const element of newElements) {
      array.push(element);
    }
  } else {
    map.set(key, newElements);
  }
}
export function mapGroupBy(array, callback) {
  const map = /* @__PURE__ */ new Map();
  array.forEach((element) => {
    const key = callback(element);
    pushOnArrayAtEntry(map, key, element);
  });
  return map;
}
export function mapIncrementAtEntry(map, key, initValue) {
  let entry = map.get(key);
  if (entry == null) {
    entry = initValue;
  }
  entry++;
  map.set(key, entry);
  return entry;
}
export function mapEntriesCount(map) {
  let count = 0;
  map.forEach(() => {
    count++;
  });
  return count;
}
export class MapUtils {
}
// static arrayFromValues = mapValuesToArray;
MapUtils.pushOnArrayAtEntry = pushOnArrayAtEntry;
MapUtils.addToSetAtEntry = addToSetAtEntry;
MapUtils.popFromArrayAtEntry = popFromArrayAtEntry;
MapUtils.removeFromSetAtEntry = removeFromSetAtEntry;
MapUtils.unshiftOnArrayAtEntry = unshiftOnArrayAtEntry;
MapUtils.concatOnArrayAtEntry = concatOnArrayAtEntry;
// static forEachSync = mapForEachSync;
MapUtils.groupBy = mapGroupBy;
MapUtils.incrementAtEntry = mapIncrementAtEntry;
MapUtils.firstKey = mapFirstKey;
