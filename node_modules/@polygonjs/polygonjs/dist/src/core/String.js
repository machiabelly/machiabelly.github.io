"use strict";
import { CoreType } from "./Type";
import { arrayUniq, range } from "./ArrayUtils";
import { arrayPushItems } from "./ArrayUtils";
const ATTRIB_NAMES_SEPARATOR = /[, ]/;
const TAIL_DIGIT_MATCH_REGEXP = /\d+$/;
const LEADING_ZEROS_MATCH_REGEXP = /^0+/;
const INDICES_LIST_SEPARATOR = /,| /;
const ZERO = "0";
const SPACE = " ";
const RANGE_SEPARATOR = "-";
const NUM_REGEXP = /^-?\d+\.?\d*$/;
var BooleanString = /* @__PURE__ */ ((BooleanString2) => {
  BooleanString2["TRUE"] = "true";
  BooleanString2["FALSE"] = "false";
  return BooleanString2;
})(BooleanString || {});
export function stringIsBoolean(word) {
  return word == "true" /* TRUE */ || word == "false" /* FALSE */;
}
export function stringToBoolean(word) {
  return word == "true" /* TRUE */;
}
export function stringIsNumber(word) {
  return NUM_REGEXP.test(word);
}
export function sanitizeName(word) {
  word = word.replace(/[^A-Za-z0-9]/g, "_");
  word = word.replace(/^[0-9]/, "_");
  return word;
}
let _tmp = [];
export function stringToAttribNames(word, target) {
  const elements = word.split(ATTRIB_NAMES_SEPARATOR);
  _tmp.length = 0;
  for (const element of elements) {
    const trimmed = element.trim();
    if (trimmed.length > 0) {
      _tmp.push(trimmed);
    }
  }
  arrayUniq(_tmp, target);
  return target;
}
export function stringTailDigits(word) {
  const match = word.match(TAIL_DIGIT_MATCH_REGEXP);
  if (match) {
    return parseInt(match[0]);
  } else {
    return 0;
  }
}
export function stringIncrement(word) {
  const match = word.match(TAIL_DIGIT_MATCH_REGEXP);
  if (match) {
    let numbers_as_str = match[0];
    let zeros_prefix = "";
    const leading_zeros_match = numbers_as_str.match(LEADING_ZEROS_MATCH_REGEXP);
    if (leading_zeros_match) {
      zeros_prefix = leading_zeros_match[0];
    }
    const digits = parseInt(numbers_as_str);
    if (digits == 0) {
      if (zeros_prefix.length > 0) {
        if (zeros_prefix[zeros_prefix.length - 1] == ZERO) {
          zeros_prefix = zeros_prefix.slice(0, -1);
        }
      }
    }
    const prefix = word.substring(0, word.length - match[0].length);
    return `${prefix}${zeros_prefix}${digits + 1}`;
  } else {
    return `${word}1`;
  }
}
export function stringPluralize(word) {
  const last_char = word[word.length - 1];
  if (last_char !== "s") {
    return `${word}s`;
  } else {
    return word;
  }
}
export function stringCamelCase(str) {
  const elements = str.replace(/_/g, " ").split(" ");
  let newWord = "";
  for (let i = 0; i < elements.length; i++) {
    let element = elements[i].toLowerCase();
    if (i > 0) {
      element = stringUpperFirst(element);
    }
    newWord += element;
  }
  return newWord;
}
export function stringUpperFirst(word) {
  if (word.length == 0) {
    return word;
  }
  const newString = word[0].toUpperCase() + word.substring(1);
  return newString;
}
export function stringTitleize(word) {
  const elements = word.split(/\s|_/g);
  const newElements = elements.map(stringUpperFirst);
  return newElements.join(" ");
}
export function precision(val, decimals = 2) {
  decimals = Math.max(decimals, 0);
  const elements = `${val}`.split(".");
  if (decimals <= 0) {
    return elements[0];
  }
  let frac = elements[1];
  if (frac !== void 0) {
    if (frac.length > decimals) {
      frac = frac.substring(0, decimals);
    }
    frac = frac.padEnd(decimals, "0");
    return `${elements[0]}.${frac}`;
  } else {
    const string_to_pad = `${val}.`;
    const pad = string_to_pad.length + decimals;
    return string_to_pad.padEnd(pad, "0");
  }
}
export function ensureFloat(num) {
  const num_as_string = `${num}`;
  const dot_pos = num_as_string.indexOf(".");
  if (dot_pos >= 0) {
    return num_as_string;
  } else {
    return `${num_as_string}.0`;
  }
}
export function ensureInteger(num) {
  const num_as_string = `${num}`;
  const dot_pos = num_as_string.indexOf(".");
  if (dot_pos >= 0) {
    return num_as_string.split(".")[0];
  } else {
    return num_as_string;
  }
}
export function stringMatchMask(word, mask) {
  if (mask === "*") {
    return true;
  }
  if (word == mask) {
    return true;
  }
  const elements = mask.split(SPACE);
  const exclusionFilters = [];
  for (const element of elements) {
    if (element.startsWith("^")) {
      exclusionFilters.push(element.substring(1));
    } else {
    }
  }
  for (const exclusionFilter of exclusionFilters) {
    const match = stringMatchMask(word, exclusionFilter);
    if (match) {
      return false;
    }
  }
  if (elements.length > 1) {
    for (const element of elements) {
      if (stringMatchMask(word, element)) {
        return true;
      }
    }
    return false;
  }
  mask = mask.split("*").join(".*");
  mask = `^${mask}$`;
  try {
    const regex = new RegExp(mask);
    return regex.test(word);
  } catch (err) {
    return false;
  }
}
export function stringMatchesOneMask(word, masks) {
  for (const mask of masks) {
    if (stringMatchMask(word, mask)) {
      return true;
    }
  }
  return false;
}
let _indices = [];
let _subIndices = [];
export function stringToIndices(indicesString, target) {
  target.length = 0;
  const elements = indicesString.split(INDICES_LIST_SEPARATOR);
  if (elements.length > 1) {
    _indices.length = 0;
    for (const element of elements) {
      stringToIndices(element, _subIndices);
      arrayPushItems(_subIndices, _indices);
    }
    arrayUniq(_indices, target);
    return target.sort((a, b) => a - b);
  } else {
    const element = elements[0];
    if (element) {
      if (element.indexOf(RANGE_SEPARATOR) > 0) {
        const rangeElements = element.split(RANGE_SEPARATOR);
        const rangeStart = rangeElements[0];
        const rangeEnd = rangeElements[1];
        const rangeStartI = parseInt(rangeStart);
        const rangeEndI = parseInt(rangeEnd);
        if (CoreType.isNumberValid(rangeStartI) && CoreType.isNumberValid(rangeEndI)) {
          return range(rangeStartI, rangeEndI + 1, 1, target);
        }
      } else {
        const parsed = parseInt(element);
        if (CoreType.isNumberValid(parsed)) {
          target.push(parsed);
          return target;
        }
      }
    }
  }
  return target;
}
export function stringEscapeLineBreaks(word) {
  return word.replace(/(\r\n|\n|\r)/gm, "\\n");
}
export class CoreString {
}
CoreString.isBoolean = stringIsBoolean;
CoreString.toBoolean = stringToBoolean;
CoreString.isNumber = stringIsNumber;
CoreString.tailDigits = stringTailDigits;
CoreString.increment = stringIncrement;
CoreString.pluralize = stringPluralize;
CoreString.camelCase = stringCamelCase;
CoreString.upperFirst = stringUpperFirst;
CoreString.titleize = stringTitleize;
CoreString.precision = precision;
CoreString.ensureFloat = ensureFloat;
CoreString.ensureInteger = ensureInteger;
CoreString.matchMask = stringMatchMask;
CoreString.matchesOneMask = stringMatchesOneMask;
CoreString.attribNames = stringToAttribNames;
CoreString.indices = stringToIndices;
CoreString.escapeLineBreaks = stringEscapeLineBreaks;
CoreString.sanitizeName = sanitizeName;
