"use strict";
import { ParamConfig } from "../../engine/nodes/utils/params/ParamsConfig";
import { Vector2, Color, Mesh, Vector3, SphereGeometry } from "three";
import { LIGHT_HELPER_MAT } from "./_Base";
export const DEFAULT_POINT_LIGHT_PARAMS = {
  color: new Color(1, 1, 1),
  intensity: 2,
  decay: 2,
  distance: 100,
  name: "pointLight",
  //
  castShadow: false,
  shadowAutoUpdate: true,
  shadowUpdateOnNextRender: false,
  shadowRes: new Vector2(1024, 1024),
  shadowBias: 1e-4,
  shadowNear: 1,
  shadowFar: 100,
  // debugShadow: false,
  //
  showHelper: false,
  helperSize: 1,
  //
  raymarchingPenumbra: 0,
  // keep as 0 by default since it's more performant
  raymarchingShadowBiasAngle: 0.01,
  raymarchingShadowBiasDistance: 0.1
};
const DEFAULT = DEFAULT_POINT_LIGHT_PARAMS;
export function PointLightParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.light = ParamConfig.FOLDER();
      /** @param light color */
      this.color = ParamConfig.COLOR(DEFAULT.color.toArray(), {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param light intensity */
      this.intensity = ParamConfig.FLOAT(DEFAULT.intensity, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param light decay */
      this.decay = ParamConfig.FLOAT(DEFAULT.decay, {
        range: [0, 10],
        rangeLocked: [true, false]
      });
      /** @param light distance */
      this.distance = ParamConfig.FLOAT(DEFAULT.distance, {
        range: [0, 100],
        rangeLocked: [true, false]
      });
      // helper
      /** @param toggle to show helper */
      this.showHelper = ParamConfig.BOOLEAN(DEFAULT.showHelper);
      /** @param helper size */
      this.helperSize = ParamConfig.FLOAT(1, { visibleIf: { showHelper: 1 } });
      /** @param light name */
      this.name = ParamConfig.STRING("`$OS`");
      // shadows
      this.shadow = ParamConfig.FOLDER();
      /** @param toggle to cast shadows */
      this.castShadow = ParamConfig.BOOLEAN(DEFAULT.castShadow);
      /** @param toggle off if the shadows do not need to be regenerated */
      this.shadowAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.shadowAutoUpdate, {
        visibleIf: { castShadow: 1 }
      });
      /** @param press button to update the shadows on next render */
      this.shadowUpdateOnNextRender = ParamConfig.BOOLEAN(DEFAULT.shadowUpdateOnNextRender, {
        visibleIf: { castShadow: 1, shadowAutoUpdate: 0 }
      });
      /** @param shadow res */
      this.shadowRes = ParamConfig.VECTOR2(DEFAULT.shadowRes.toArray(), { visibleIf: { castShadow: 1 } });
      /** @param shadow bias */
      this.shadowBias = ParamConfig.FLOAT(DEFAULT.shadowBias, {
        visibleIf: { castShadow: 1 },
        range: [-0.01, 0.01],
        rangeLocked: [false, false]
      });
      /** @param shadow camera near */
      this.shadowNear = ParamConfig.FLOAT(DEFAULT.shadowNear, { visibleIf: { castShadow: 1 } });
      /** @param shadow camera far */
      this.shadowFar = ParamConfig.FLOAT(DEFAULT.shadowFar, { visibleIf: { castShadow: 1 } });
      /** @param display shadow on a plane behind the light */
      // debugShadow = ParamConfig.BOOLEAN(DEFAULT.debugShadow, {
      // 	visibleIf: {castShadow: 1},
      // });
      // raymarching
      this.raymarching = ParamConfig.FOLDER();
      /** @param this affects the shadows cast inside raymarchingBuilder materials */
      this.raymarchingPenumbra = ParamConfig.FLOAT(DEFAULT.raymarchingPenumbra);
      /** @param shadow bias */
      this.raymarchingShadowBiasAngle = ParamConfig.FLOAT(DEFAULT.raymarchingShadowBiasAngle, {
        range: [0, 1],
        rangeLocked: [true, false]
      });
      /** @param shadow bias */
      this.raymarchingShadowBiasDistance = ParamConfig.FLOAT(DEFAULT.raymarchingShadowBiasDistance, {
        range: [0, 1],
        rangeLocked: [true, false]
      });
    }
  };
}
export class CorePointLightHelper {
  constructor() {
    this._material = LIGHT_HELPER_MAT.clone();
    this._matrixScale = new Vector3(1, 1, 1);
  }
  createObject() {
    return new Mesh();
  }
  createAndBuildObject(options) {
    const object = this.createObject();
    this.buildHelper(object);
    this.update(object, options);
    return object;
  }
  buildHelper(object) {
    const size = 1;
    object.geometry = new SphereGeometry(size, 4, 2);
    object.matrixAutoUpdate = false;
    object.material = this._material;
    return object;
  }
  update(object, options) {
    const size = options.helperSize;
    this._matrixScale.set(size, size, size);
    object.matrix.identity();
    object.matrix.scale(this._matrixScale);
    this._material.color.copy(options.light.color);
  }
}
