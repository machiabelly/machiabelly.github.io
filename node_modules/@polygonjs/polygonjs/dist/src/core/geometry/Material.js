"use strict";
import { UniformsUtils } from "three";
export var CustomMaterialName = /* @__PURE__ */ ((CustomMaterialName2) => {
  CustomMaterialName2["DISTANCE"] = "customDistanceMaterial";
  CustomMaterialName2["DEPTH"] = "customDepthMaterial";
  CustomMaterialName2["DEPTH_DOF"] = "customDepthDOFMaterial";
  return CustomMaterialName2;
})(CustomMaterialName || {});
import {
  assignUniformViaUserData,
  copyOnBeforeCompileData
} from "../../engine/nodes/gl/code/assemblers/materials/OnBeforeCompile";
const RENDER_HOOK_USER_DATA_KEY = "POLY_render_hook";
const EMPTY_RENDER_HOOK = (renderer, scene, camera, geometry, material, group) => {
};
export function cloneMaterial(scene, srcMaterial, options) {
  const clonedMaterial = srcMaterial.clone();
  const srcUniforms = srcMaterial.uniforms;
  if (srcUniforms) {
    clonedMaterial.uniforms = UniformsUtils.clone(srcUniforms);
  }
  copyOnBeforeCompileData(scene, {
    src: srcMaterial,
    dest: clonedMaterial,
    shareCustomUniforms: options.shareCustomUniforms
  });
  if (srcMaterial.customMaterials && options.addCustomMaterials) {
    const customNames = Object.keys(srcMaterial.customMaterials);
    if (customNames.length > 0) {
      clonedMaterial.customMaterials = {};
    }
    for (const customName of customNames) {
      const matName = customName;
      const customMaterial = srcMaterial.customMaterials[matName];
      if (customMaterial) {
        const clonedCustomMaterial = cloneMaterial(scene, customMaterial, {
          ...options,
          addCustomMaterials: false
        });
        clonedMaterial.customMaterials[matName] = clonedCustomMaterial;
      }
    }
  }
  return clonedMaterial;
}
export function applyCustomMaterials(object, material) {
  const materialWithCustom = material;
  if (materialWithCustom.customMaterials) {
    for (const customName of Object.keys(materialWithCustom.customMaterials)) {
      const matName = customName;
      const customMaterial = materialWithCustom.customMaterials[matName];
      if (customMaterial) {
        object[matName] = customMaterial;
        customMaterial.needsUpdate = true;
      }
    }
  }
}
export function addUserDataRenderHook(material, renderHook) {
  material.userData[RENDER_HOOK_USER_DATA_KEY] = renderHook;
}
export function applyRenderHook(object, material) {
  if (material.userData) {
    const renderHook = material.userData[RENDER_HOOK_USER_DATA_KEY];
    if (renderHook) {
      object.onBeforeRender = (renderer, scene, camera, geometry, material2, group) => {
        renderHook(renderer, scene, camera, geometry, material2, group, object);
      };
      return;
    }
  }
  object.onBeforeRender = EMPTY_RENDER_HOOK;
}
export function assignUniforms(mat, uniformName, uniform, assembler) {
  assignUniformViaUserData(mat, uniformName, uniform);
  if (assembler) {
    assignUniformForOnBeforeCompile(mat, uniformName, uniform, assembler);
  }
}
export function assignUniformForOnBeforeCompile(mat, uniformName, uniform, assembler) {
  assembler.addAdditionalTextureUniforms(uniformName, uniform);
}
export class CoreMaterial {
  static node(scene, material) {
    return scene.node(material.name);
  }
}
CoreMaterial.clone = cloneMaterial;
CoreMaterial.applyCustomMaterials = applyCustomMaterials;
CoreMaterial.assignUniforms = assignUniforms;
CoreMaterial.assignUniformForOnBeforeCompile = assignUniformForOnBeforeCompile;
