"use strict";
import {
  Color,
  Vector2,
  Vector3,
  Vector4,
  BufferAttribute,
  InstancedBufferAttribute
} from "three";
import { arrayUniq } from "../ArrayUtils";
import { stringToAttribNames, stringMatchMask } from "../String";
import { CoreType } from "../Type";
import { AttribSize } from "./Constant";
export var Attribute = /* @__PURE__ */ ((Attribute2) => {
  Attribute2["POINT_INDEX"] = "ptnum";
  Attribute2["VERTEX_INDEX"] = "vtxnum";
  Attribute2["PRIMITIVE_INDEX"] = "primnum";
  Attribute2["OBJECT_INDEX"] = "objnum";
  Attribute2["OBJECT_NAME"] = "objname";
  Attribute2["COLOR"] = "color";
  Attribute2["NORMAL"] = "normal";
  Attribute2["POSITION"] = "position";
  Attribute2["PSCALE"] = "pscale";
  Attribute2["UP"] = "up";
  Attribute2["UV"] = "uv";
  Attribute2["SCALE"] = "scale";
  Attribute2["TANGENT"] = "tangent";
  Attribute2["ID"] = "id";
  return Attribute2;
})(Attribute || {});
export var ObjectAttribute = /* @__PURE__ */ ((ObjectAttribute2) => {
  ObjectAttribute2["HOVERED"] = "hovered";
  return ObjectAttribute2;
})(ObjectAttribute || {});
const ATTRIB_NAME_MAP = {
  P: "position" /* POSITION */,
  N: "normal" /* NORMAL */,
  Cd: "color" /* COLOR */
};
const _matchingAttribNames = [];
const _masks = [];
export class CoreAttribute {
  static remapName(name) {
    return ATTRIB_NAME_MAP[name] || name;
  }
  static arrayToIndexedArrays(array) {
    const index_by_value = {};
    let current_index = 0;
    const indices = [];
    const values = [];
    let i = 0;
    while (i < array.length) {
      const value = array[i];
      const index = index_by_value[value];
      if (index != null) {
        indices.push(index);
      } else {
        values.push(value);
        indices.push(current_index);
        index_by_value[value] = current_index;
        current_index += 1;
      }
      i++;
    }
    return {
      indices,
      values
    };
  }
  static defaultValue(size) {
    switch (size) {
      case 1:
        return 0;
      case 2:
        return new Vector2(0, 0);
      case 3:
        return new Vector3(0, 0, 0);
      default:
        throw `size ${size} not yet implemented`;
    }
  }
  static copy(src, dest, markAsNeedsUpdate = true) {
    const srcArray = src == null ? void 0 : src.array;
    const destArray = dest == null ? void 0 : dest.array;
    if (srcArray && destArray) {
      const min_length = Math.min(srcArray.length, destArray.length);
      for (let i = 0; i < min_length; i++) {
        destArray[i] = srcArray[i];
      }
      if (markAsNeedsUpdate) {
        dest.needsUpdate = true;
      }
    }
  }
  static attribSizeFromValue(val) {
    if (CoreType.isString(val) || CoreType.isNumber(val)) {
      return AttribSize.FLOAT;
    }
    if (CoreType.isArray(val)) {
      return val.length;
    }
    switch (val.constructor) {
      case Color:
        return AttribSize.VECTOR3;
      case Vector2:
        return AttribSize.VECTOR2;
      case Vector3:
        return AttribSize.VECTOR3;
      case Vector4:
        return AttribSize.VECTOR4;
    }
    return null;
  }
  static attribNamesMatchingMask(masksString, existingAttribNames) {
    stringToAttribNames(masksString, _masks);
    _matchingAttribNames.length = 0;
    for (const mask of _masks) {
      for (const attribName of existingAttribNames) {
        if (stringMatchMask(attribName, mask)) {
          _matchingAttribNames.push(attribName);
        } else {
          const remapped = CoreAttribute.remapName(mask);
          if (attribName == remapped) {
            _matchingAttribNames.push(attribName);
          }
        }
      }
    }
    const uniqAttributeNames = [];
    return arrayUniq(_matchingAttribNames, uniqAttributeNames);
  }
}
export function markAttributeAsNeedsUpdateForFrame(attribute, frame) {
  if (attribute instanceof BufferAttribute || attribute instanceof InstancedBufferAttribute) {
    attribute.version = frame;
  } else {
    if (attribute.data) {
      attribute.data.version = frame;
    }
  }
}
