"use strict";
import { isPointInTetCircumSphere } from "./tetSphere";
const visitedTets = /* @__PURE__ */ new Set();
const stack = [];
export function findNonDelaunayTetsFromSinglePointCheck(tetGeometry, startTetId, addedPoint, invalidTets) {
  visitedTets.clear();
  invalidTets.length = 0;
  stack.length = 0;
  stack.push(startTetId);
  while (stack.length > 0) {
    const tetId = stack.pop();
    if (visitedTets.has(tetId)) {
      continue;
    }
    visitedTets.add(tetId);
    const tet = tetGeometry.tetrahedrons.get(tetId);
    if (!tet) {
      throw `findNonDelaunayTetsFromSinglePointCheck: tet not found (${tetId})`;
      continue;
    }
    invalidTets.push(tetId);
    for (const neighbourData of tet.neighbours) {
      if (neighbourData) {
        if (!visitedTets.has(neighbourData.id)) {
          const neighbourTet = tetGeometry.tetrahedrons.get(neighbourData.id);
          if (neighbourTet == null ? void 0 : neighbourTet.disposed) {
            console.error("is disposed");
            throw "is disposed";
          }
          if (neighbourTet && isPointInTetCircumSphere(neighbourTet, addedPoint)) {
            stack.push(neighbourTet.id);
          }
        }
      }
    }
  }
}
const badTetIds = /* @__PURE__ */ new Set();
export function findNonDelaunayTetsFromMultiplePointsCheck(tetGeometry, invalidTets) {
  badTetIds.clear();
  tetGeometry.points.forEach((point, pointId) => {
    tetGeometry.tetrahedrons.forEach((tet) => {
      if (!badTetIds.has(tet.id) && !tet.pointIds.includes(pointId)) {
        if (isPointInTetCircumSphere(tet, point.position)) {
          badTetIds.add(tet.id);
        }
      }
    });
  });
  invalidTets.length = 0;
  badTetIds.forEach((tetId) => {
    invalidTets.push(tetId);
  });
}
