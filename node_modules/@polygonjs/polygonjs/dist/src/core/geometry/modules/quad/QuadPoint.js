"use strict";
import { Vector3, BufferAttribute } from "three";
import { CorePoint } from "../../entities/point/CorePoint";
import { Attribute } from "../../Attribute";
import { attributeNumericValues } from "../../entities/utils/Common";
import { pointsCountFromObject } from "../../entities/point/CorePointUtils";
import { QuadVertex } from "./QuadVertex";
import { quadGraphFromQuadObject } from "./graph/QuadGraphUtils";
import { QuadPrimitive } from "./QuadPrimitive";
import { pushOnArrayAtEntry } from "../../../MapUtils";
const target = {
  attributeAdded: false,
  values: []
};
const _quadNodesByPointIndex = /* @__PURE__ */ new Map();
const _n = new Vector3();
const _tmp = new Vector3();
export class QuadPoint extends CorePoint {
  constructor(object, index) {
    super(object, index);
    this._object = object;
    this._updateGeometry();
  }
  object() {
    return this._object;
  }
  setIndex(index, object) {
    this._index = index;
    if (object) {
      this._object = object;
      this._updateGeometry();
    }
    return this;
  }
  _updateGeometry() {
    const geometry = this._object.geometry;
    if (geometry) {
      this._geometry = geometry;
    }
  }
  geometry() {
    return this._geometry;
  }
  static addAttribute(object, attribName, attribute) {
    const attributes = this.attributes(object);
    if (!attributes) {
      return;
    }
    attributes[attribName] = attribute;
  }
  static addNumericAttribute(object, attribName, size = 1, defaultValue = 0) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    attributeNumericValues(object, pointsCountFromObject, size, defaultValue, target);
    if (target.attributeAdded) {
      geometry.setAttribute(attribName.trim(), new BufferAttribute(new Float32Array(target.values), size));
    } else {
      console.warn(defaultValue);
      throw `QuadPoint.addNumericAttrib error: no other default value allowed for now (default given: ${defaultValue})`;
    }
  }
  static attributes(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    return geometry.attributes;
  }
  static entitiesCount(object) {
    const positionAttribute = this.attribute(object, Attribute.POSITION);
    if (!positionAttribute) {
      return 0;
    }
    return positionAttribute.count;
  }
  static position(quadObject, pointIndex, target2) {
    if (!(quadObject && quadObject.geometry)) {
      return target2;
    }
    const attribute = quadObject.geometry.attributes[Attribute.POSITION];
    if (!attribute) {
      return target2;
    }
    return target2.fromArray(attribute.array, pointIndex * 3);
  }
  position(target2) {
    return this.constructor.position(this._object, this._index, target2);
  }
  static normal(quadObject, pointIndex, target2) {
    if (!(quadObject && quadObject.geometry)) {
      return target2;
    }
    const attribute = quadObject.geometry.attributes[Attribute.NORMAL];
    if (!attribute) {
      return target2;
    }
    return target2.fromArray(attribute.array, pointIndex * 3);
  }
  normal(target2) {
    return this.constructor.normal(this._object, this._index, target2);
  }
  static computeNormals(object) {
    if (!object.geometry) {
      return;
    }
    const graph = quadGraphFromQuadObject(object);
    const pointsCount = this.entitiesCount(object);
    const primitivesCount = QuadPrimitive.entitiesCount(object);
    _quadNodesByPointIndex.clear();
    for (let i = 0; i < primitivesCount; i++) {
      const quadNode = graph.quadNode(i);
      if (!quadNode) {
        continue;
      }
      const indices = quadNode.indices;
      for (const index of indices) {
        pushOnArrayAtEntry(_quadNodesByPointIndex, index, quadNode);
      }
    }
    const normals = new Array(pointsCount * 3);
    for (let i = 0; i < pointsCount; i++) {
      const quadNodes = _quadNodesByPointIndex.get(i);
      if (!quadNodes) {
        continue;
      }
      _n.set(0, 0, 0);
      for (const quadNode of quadNodes) {
        QuadPrimitive.normal(object, quadNode.id, _tmp);
        _n.add(_tmp);
      }
      _n.divideScalar(quadNodes.length);
      _n.toArray(normals, i * 3);
    }
    const geometry = object.geometry;
    const position = new BufferAttribute(new Float32Array(normals), 3);
    geometry.setAttribute(Attribute.NORMAL, position);
  }
  static markAttribAsNeedsUpdate(object, attribName) {
  }
  //
  //
  //
  //
  //
  static userDataAttribs(object) {
    return {};
  }
  static setIndexedAttribute(object, attribName, values, indices) {
  }
  static attribValueIndex(object, index, attribName) {
    return -1;
  }
  //
  //
  //
  //
  //
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedVertexIds(object, pointIndex, target2, traversedRelatedEntityData) {
    const geometry = object.geometry;
    if (!geometry) {
      return;
    }
    const indexArray = geometry.index;
    let i = 0;
    for (const indexValue of indexArray) {
      if (indexValue == pointIndex) {
        target2.push(i);
      }
      i++;
    }
  }
  static relatedVertexClass(object) {
    return QuadVertex;
  }
}
