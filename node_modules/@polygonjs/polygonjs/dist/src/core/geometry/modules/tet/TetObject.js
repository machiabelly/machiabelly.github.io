"use strict";
import { CoreObjectType, objectContentCopyProperties } from "../../ObjectContent";
import { CoreType } from "../../../Type";
import { tetToOuterMesh } from "./toObject3D/tetToOuterMesh";
import { tetToTetMesh } from "./toObject3D/tetToTetMesh";
import { tetToLines } from "./toObject3D/tetToLines";
import { tetSharedFacesToLines } from "./toObject3D/tetToSharedFacesToLine";
import { tetToPoints } from "./toObject3D/tetToPoints";
import { tetToCenter } from "./toObject3D/tetToCenter";
import { tetToSphere } from "./toObject3D/tetToSphere";
export class TetObject {
  constructor(_geometry) {
    this._geometry = _geometry;
    this.visible = true;
    this.parent = null;
    this.children = [];
    this.userData = {};
    this.name = "";
    this.castShadow = true;
    this.receiveShadow = true;
    this.renderOrder = 0;
    this.frustumCulled = true;
    this.matrixAutoUpdate = false;
  }
  get geometry() {
    return this._geometry;
  }
  get type() {
    return CoreObjectType.TET;
  }
  setGeometry(geometry) {
    this._geometry = geometry;
  }
  tetGeometry() {
    return this.geometry;
  }
  dispose() {
  }
  applyMatrix4(matrix) {
    this.geometry.applyMatrix4(matrix);
  }
  add(...object) {
  }
  remove(...object) {
  }
  dispatchEvent(event) {
  }
  traverse(callback) {
    callback(this);
  }
  clone() {
    const geometry = this._geometry.clone();
    const clone = new TetObject(geometry);
    objectContentCopyProperties(this, clone);
    return clone;
  }
  toObject3D(tesselationParams) {
    const object = TetObject.toObject3D(this, tesselationParams);
    if (object) {
      if (CoreType.isArray(object)) {
        for (const element of object) {
          objectContentCopyProperties(this, element);
        }
      } else {
        objectContentCopyProperties(this, object);
      }
    }
    return object;
  }
  static toObject3D(tetObject, tesselationParams) {
    const objects = [];
    if (tesselationParams.displayOuterMesh) {
      objects.push(tetToOuterMesh(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayTetMesh) {
      objects.push(tetToTetMesh(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayLines) {
      objects.push(tetToLines(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displaySharedFaces) {
      objects.push(tetSharedFacesToLines(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayPoints) {
      objects.push(tetToPoints(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displayCenter) {
      objects.push(tetToCenter(tetObject.tetGeometry(), tesselationParams));
    }
    if (tesselationParams.displaySphere) {
      const spheres = tetToSphere(tetObject.tetGeometry(), tesselationParams);
      if (spheres) {
        objects.push(spheres);
      }
    }
    return objects;
  }
  boundingBox(target) {
    this.geometry.boundingBox(target);
  }
  boundingSphere(target) {
    this.geometry.boundingSphere(target);
  }
}
