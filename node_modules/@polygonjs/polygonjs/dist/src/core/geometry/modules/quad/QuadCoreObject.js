"use strict";
import { Box3 } from "three";
import { QuadObject } from "./QuadObject";
import { BaseCoreObject } from "../../entities/object/BaseCoreObject";
import { objectContentCopyProperties } from "../../ObjectContent";
import { QuadPrimitive } from "./QuadPrimitive";
import { quadGeomeryMerge } from "./builders/QuadGeometryMerge";
import { objectData } from "../../entities/object/BaseCoreObjectUtils";
import { QuadPoint } from "./QuadPoint";
import { QuadVertex } from "./QuadVertex";
import { AttribClass } from "../../Constant";
import { arrayCopy } from "../../../ArrayUtils";
const _box = new Box3();
export class QuadCoreObject extends BaseCoreObject {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  static position(object, target) {
    object.boundingBox(_box);
    _box.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this._object.boundingSphere(target);
  }
  static objectData(object) {
    const data = objectData(object);
    data.pointsCount = QuadPoint.entitiesCount(object);
    data.verticesCount = QuadVertex.entitiesCount(object);
    data.primitivesCount = QuadPrimitive.entitiesCount(object);
    data.primitiveName = "quad";
    return data;
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    object.applyMatrix4(matrix);
  }
  static mergeCompact(options) {
    const { objects, mergedObjects, onError } = options;
    const firstObject = objects[0];
    if (!firstObject) {
      return;
    }
    const quadObjects = objects;
    try {
      const mergedGeometry = quadGeomeryMerge(quadObjects);
      if (mergedGeometry) {
        const newObject = new QuadObject(mergedGeometry);
        objectContentCopyProperties(firstObject, newObject);
        mergedObjects.push(newObject);
      } else {
        onError("merge failed, check that input geometries have the same attributes");
      }
    } catch (e) {
      onError(e.message || "unknown error");
    }
  }
  //
  //
  // RELATED ENTITIES
  //
  //
  static relatedPrimitiveIds(object, index, target, traversedRelatedEntityData) {
    const count = QuadPrimitive.entitiesCount(object);
    target.length = count;
    for (let i = 0; i < count; i++) {
      target[i] = i;
    }
    if (traversedRelatedEntityData && traversedRelatedEntityData[AttribClass.PRIMITIVE].ids != target) {
      arrayCopy(target, traversedRelatedEntityData[AttribClass.PRIMITIVE].ids);
    }
  }
  static relatedPrimitiveClass(object) {
    return QuadPrimitive;
  }
}
