"use strict";
import { BaseCoreObject } from "../../entities/object/BaseCoreObject";
import { CadObject } from "./CadObject";
import { objectContentCopyProperties } from "../../ObjectContent";
import { Box3, Vector3 } from "three";
import { cadMergeCompact } from "./utils/CadMerge";
import { objectData } from "../../entities/object/BaseCoreObjectUtils";
import { CadPoint } from "./CadPoint";
import { CadVertex } from "./CadVertex";
import { primitiveClassFactoryNonAbstract } from "./CadModule";
const _bbox = new Box3();
const _bboxSize = new Vector3();
export class CadCoreObject extends BaseCoreObject {
  constructor(_object, index) {
    super(_object, index);
    this._object = _object;
  }
  type() {
    return this._object.type;
  }
  static fromGeometry(geometry, type) {
    const cadObject = new CadObject(geometry, type);
    return new CadCoreObject(cadObject, 0);
  }
  object() {
    return this._object;
  }
  static position(object, target) {
    object.boundingBox(_bbox);
    _bbox.getCenter(target);
  }
  boundingBox(target) {
    this._object.boundingBox(target);
  }
  boundingSphere(target) {
    this.boundingBox(_bbox);
    _bbox.getSize(_bboxSize);
    _bbox.getCenter(target.center);
    const diameter = Math.max(_bboxSize.x, _bboxSize.y, _bboxSize.z);
    target.radius = diameter * 0.5;
  }
  static objectData(object) {
    const data = objectData(object);
    data.pointsCount = CadPoint.entitiesCount(object);
    data.verticesCount = CadVertex.entitiesCount(object);
    const primitiveClass = primitiveClassFactoryNonAbstract(object);
    data.primitivesCount = (primitiveClass == null ? void 0 : primitiveClass.entitiesCount(object)) || 0;
    data.primitiveName = (primitiveClass == null ? void 0 : primitiveClass.primitiveName()) || "";
    return data;
  }
  static applyMatrix(object, matrix, transformTargetType, transformSpace, transformMode) {
    object.applyMatrix4(matrix);
  }
  static mergeCompact(options) {
    const { objects, material, mergedObjects, onError } = options;
    try {
      const firstObject = objects[0];
      if (!firstObject) {
        return;
      }
      const newObjects = cadMergeCompact(objects);
      for (const newObject of newObjects) {
        objectContentCopyProperties(firstObject, newObject);
        if (material) {
          newObject.material = material;
        }
      }
      mergedObjects.push(...newObjects);
    } catch (e) {
      onError(e.message || "unknown error");
    }
  }
}
