"use strict";
import { TriangleEdge } from "./TriangleEdge";
import { TriangleNode } from "./TriangleNode";
import { triangleEdge, edgeId } from "./TriangleGraphCommon";
import { setToArray } from "../../../../../../core/SetUtils";
import { PrimitiveGraph } from "../../../../entities/primitive/PrimitiveGraph";
export class TriangleGraph extends PrimitiveGraph {
  constructor() {
    super();
    this._nextTriangleId = -1;
    this._trianglesById = /* @__PURE__ */ new Map();
    this._edgesByTriangleId = /* @__PURE__ */ new Map();
    this._edgesById = /* @__PURE__ */ new Map();
    this._edgeIds = /* @__PURE__ */ new Set();
  }
  addTriangle(triangle) {
    this._nextTriangleId++;
    const triangleId = this._nextTriangleId;
    const triangleNode = new TriangleNode(triangleId, triangle);
    this._trianglesById.set(triangleId, triangleNode);
    const edges = [];
    for (let i = 0; i < 3; i++) {
      const pointIdPair = triangleEdge(triangle, i);
      const _edgeId = edgeId(pointIdPair);
      let edge = this._edgesById.get(_edgeId);
      if (!edge) {
        edge = new TriangleEdge(this, _edgeId, pointIdPair);
        this._edgesById.set(_edgeId, edge);
      }
      edge.addTriangle(triangleId);
      edges.push(edge);
      this._edgeIds.add(_edgeId);
    }
    this._edgesByTriangleId.set(triangleId, edges);
    return triangleNode;
  }
  removeTriangle(triangleId) {
    const triangleNode = this._trianglesById.get(triangleId);
    if (!triangleNode) {
      return;
    }
    this._trianglesById.delete(triangleId);
    const edges = this._edgesByTriangleId.get(triangleId);
    if (!edges) {
      return;
    }
    for (const edge of edges) {
      const index = edge.triangleIds.indexOf(triangleId);
      if (index >= 0) {
        edge.triangleIds.splice(index, 1);
      }
      if (edge.triangleIds.length == 0) {
        this._edgesById.delete(edge.id);
        this._edgeIds.delete(edge.id);
      }
    }
    this._edgesByTriangleId.delete(triangleId);
  }
  traverseTriangles(callback) {
    this._trianglesById.forEach((triangle) => {
      callback(triangle);
    });
  }
  edgesByTriangleId(id) {
    return this._edgesByTriangleId.get(id);
  }
  // firstNeighbourId(triangleId: number): number | undefined {
  // 	const edges = this._edgesByTriangleId.get(triangleId);
  // 	if (!edges) {
  // 		return;
  // 	}
  // 	for (const edge of edges) {
  // 		for (const _triangleId of edge.triangleIds) {
  // 			if (_triangleId != triangleId) {
  // 				return _triangleId;
  // 			}
  // 		}
  // 	}
  // }
  triangle(triangleId) {
    return this._trianglesById.get(triangleId);
  }
  edgeIds(target) {
    return setToArray(this._edgeIds, target);
  }
  edge(edgeId2) {
    return this._edgesById.get(edgeId2);
  }
  neighbourIndex(primitiveIndex, neighbourIndex, withSharedEdge) {
    console.warn("not implemented");
    return 0;
  }
  neighboursCount(primitiveIndex, withSharedEdge) {
    console.warn("not implemented");
    return 0;
  }
}
