"use strict";
import { BufferGeometry, BufferAttribute, Matrix4, Vector3, Quaternion } from "three";
import { ObjectType } from "../../../Constant";
import { BaseSopOperation } from "../../../../../engine/operations/sop/_Base";
import { csgMaterialLine } from "../CsgConstant";
const matrix = new Matrix4();
const t = new Vector3();
const q = new Quaternion();
const s = new Vector3();
export function path2ToObject3D(csg, tesselationParams) {
  const geometry = path2ToBufferGeometry(csg);
  return BaseSopOperation.createObject(
    geometry,
    ObjectType.LINE_SEGMENTS,
    csgMaterialLine(tesselationParams.linesColor)
  );
}
export function path2ToBufferGeometry(csg) {
  const vertices = [];
  const indices = [];
  const points2D = csg.points;
  let i = 0;
  for (const point of points2D) {
    vertices.push(point[0], 0, point[1]);
    if (i != 0) {
      indices.push(i - 1);
      indices.push(i);
    }
    i++;
  }
  const geo = new BufferGeometry();
  geo.setAttribute("position", new BufferAttribute(new Float32Array(vertices), 3));
  geo.setIndex(indices);
  matrix.elements = csg.transforms;
  matrix.decompose(t, q, s);
  t.y = 0;
  matrix.compose(t, q, s);
  geo.applyMatrix4(matrix);
  return geo;
}
export function path2Positions(csg) {
  const points = csg.points;
  const vectors = new Array(points.length);
  let i = 0;
  for (const pt of points) {
    const vec = new Vector3();
    vec.x = pt[0];
    vec.y = 0;
    vec.z = pt[1];
    vectors[i] = vec;
    i++;
  }
  return vectors;
}
