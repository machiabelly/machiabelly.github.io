"use strict";
import { Vector3 } from "three";
import { ThreejsPrimitive } from "./ThreejsPrimitive";
import { Attribute } from "../../Attribute";
const _p0 = new Vector3();
const _p1 = new Vector3();
export class ThreejsPrimitiveLineSegment extends ThreejsPrimitive {
  constructor(object, index) {
    super(object, index);
    this._geometry = object.geometry;
  }
  static primitiveName() {
    return "line";
  }
  static entitiesCount(object) {
    const geometry = object.geometry;
    if (!geometry) {
      return 0;
    }
    const index = geometry.getIndex();
    if (!index) {
      return 0;
    }
    return index.count / 2;
  }
  static position(object, primitiveIndex, target) {
    if (!(object && object.geometry)) {
      return target;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target;
    }
    const positionArray = positionAttribute.array;
    _p0.fromArray(positionArray, primitiveIndex * 3 + 0);
    _p1.fromArray(positionArray, primitiveIndex * 3 + 1);
    target.copy(_p0).add(_p1).divideScalar(2);
    return target;
  }
  static normal(object, primitiveIndex, target) {
    if (!(object && object.geometry)) {
      return target;
    }
    const positionAttribute = object.geometry.getAttribute(Attribute.POSITION);
    if (!positionAttribute) {
      return target;
    }
    const positionArray = positionAttribute.array;
    _p0.fromArray(positionArray, primitiveIndex * 3 + 0);
    _p1.fromArray(positionArray, primitiveIndex * 3 + 1);
    target.copy(_p1).sub(_p1).normalize();
    return target;
  }
  position(target) {
    return this.constructor.position(this._object, this._index, target);
  }
  normal(target) {
    return this.constructor.normal(this._object, this._index, target);
  }
  static computeVertexNormalsIfAttributeVersionChanged(object) {
  }
  static stride() {
    return 2;
  }
}
