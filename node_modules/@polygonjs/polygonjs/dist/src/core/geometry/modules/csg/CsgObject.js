"use strict";
import { Box3, Vector3 } from "three";
import { CsgGeometryType } from "./CsgCommon";
import { csgGeometryTypeFromGeometry } from "./CsgCoreType";
import { objectContentCopyProperties } from "../../ObjectContent";
import { path2ToObject3D } from "./toObject3D/CsgPath2ToObject3D";
import { geom2ToObject3D } from "./toObject3D/CsgGeom2ToObject3D";
import { geom3ToObject3D } from "./toObject3D/CsgGeom3ToObject3D";
import { matrix4ToMat4 } from "./math/CsgMat4";
import { csgBoundingBoxPath2, csgBoundingBoxGeom2, csgBoundingBoxGeom3 } from "./math/CsgBoundingBox";
import { TypeAssert } from "../../../../engine/poly/Assert";
import { CoreType } from "../../../Type";
const _box = new Box3();
const _size = new Vector3();
export class CsgObject {
  constructor(_geometry) {
    this._geometry = _geometry;
    this.visible = true;
    this.userData = {};
    this.name = "";
    this.castShadow = true;
    this.receiveShadow = true;
    this.renderOrder = 0;
    this.frustumCulled = true;
    this.matrixAutoUpdate = false;
    this.children = [];
    this.parent = null;
    this._type = csgGeometryTypeFromGeometry(this._geometry);
    this._validate();
  }
  get geometry() {
    return this._geometry;
  }
  get type() {
    return this._type;
  }
  setGeometry(geometry) {
    this._geometry = geometry;
    this._validate();
  }
  _validate() {
    const type = csgGeometryTypeFromGeometry(this._geometry);
    if (type) {
      this._type = type;
    } else {
      console.error("no type for geometry", this._geometry);
    }
  }
  csgGeometry() {
    return this.geometry;
  }
  dispose() {
  }
  applyMatrix4(matrix) {
    matrix4ToMat4(matrix, this.csgGeometry().transforms);
  }
  add(...object) {
  }
  remove(...object) {
  }
  dispatchEvent(event) {
  }
  traverse(callback) {
    callback(this);
  }
  clone() {
    const geometry = JSON.parse(JSON.stringify(this.csgGeometry()));
    const clone = new CsgObject(geometry);
    objectContentCopyProperties(this, clone);
    return clone;
  }
  toObject3D(tesselationParams) {
    const object = CsgObject.toObject3D(this, this.type, tesselationParams);
    if (object) {
      if (CoreType.isArray(object)) {
        for (const element of object) {
          objectContentCopyProperties(this, element);
        }
      } else {
        objectContentCopyProperties(this, object);
      }
    }
    return object;
  }
  static toObject3D(csgObject, type, tesselationParams) {
    switch (type) {
      case CsgGeometryType.PATH2: {
        return path2ToObject3D(csgObject.csgGeometry(), tesselationParams);
      }
      case CsgGeometryType.GEOM2: {
        return geom2ToObject3D(csgObject.csgGeometry(), tesselationParams);
      }
      case CsgGeometryType.GEOM3: {
        return geom3ToObject3D(csgObject.csgGeometry(), tesselationParams);
      }
    }
    TypeAssert.unreachable(type);
  }
  boundingBox(target) {
    const type = this.type;
    switch (type) {
      case CsgGeometryType.PATH2: {
        return csgBoundingBoxPath2(this.csgGeometry(), target);
      }
      case CsgGeometryType.GEOM2: {
        return csgBoundingBoxGeom2(this.csgGeometry(), target);
      }
      case CsgGeometryType.GEOM3: {
        return csgBoundingBoxGeom3(this.csgGeometry(), target);
      }
    }
    TypeAssert.unreachable(type);
  }
  boundingSphere(target) {
    this.boundingBox(_box);
    _box.getSize(_size);
    _box.getSize(target.center);
    const diameter = Math.max(_size.x, _size.y, _size.z);
    target.radius = diameter * 0.5;
  }
}
