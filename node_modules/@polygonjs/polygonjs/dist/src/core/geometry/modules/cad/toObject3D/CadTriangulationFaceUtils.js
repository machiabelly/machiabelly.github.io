"use strict";
import { CadGC } from "../CadCommon";
import { CadLoaderSync } from "../CadLoaderSync";
var FaceOrientation = /* @__PURE__ */ ((FaceOrientation2) => {
  FaceOrientation2[FaceOrientation2["BACKWARD"] = 0] = "BACKWARD";
  FaceOrientation2[FaceOrientation2["FORWARD"] = 1] = "FORWARD";
  return FaceOrientation2;
})(FaceOrientation || {});
function faceOrientation(oc, face) {
  return face.Orientation_1() === oc.TopAbs_Orientation.TopAbs_FORWARD ? 1 /* FORWARD */ : 0 /* BACKWARD */;
}
const STRIDE = 3;
export function faceData(oc, face, index0 = 0) {
  return CadGC.withGC((r) => {
    const location = CadLoaderSync.TopLoc_Location;
    const triangulation = oc.BRep_Tool.Triangulation(face, location, 0);
    if (triangulation.IsNull()) {
      return;
    }
    const transformation = location.Transformation();
    const tri = triangulation.get();
    const nbNodes = tri.NbNodes();
    const normalsArray = r(new oc.TColgp_Array1OfDir_2(1, nbNodes));
    const pc = r(new oc.Poly_Connect_2(triangulation));
    oc.StdPrs_ToolTriangulatedShape.Normal(face, pc, normalsArray);
    const nbTriangles = tri.NbTriangles();
    const faceData2 = {
      positions: new Array(nbNodes * 3),
      normals: new Array(normalsArray.Length() * 3),
      indices: new Array(nbTriangles * 3)
    };
    for (let i = 1; i <= nbNodes; i++) {
      const p = tri.Node(i).Transformed(transformation);
      const index = (i - 1) * STRIDE;
      faceData2.positions[index] = p.X();
      faceData2.positions[index + 1] = p.Y();
      faceData2.positions[index + 2] = p.Z();
    }
    for (let i = normalsArray.Lower(); i <= normalsArray.Upper(); i++) {
      const d = normalsArray.Value(i).Transformed(transformation);
      const index = (i - 1) * STRIDE;
      faceData2.normals[index] = d.X();
      faceData2.normals[index + 1] = d.Y();
      faceData2.normals[index + 2] = d.Z();
    }
    let trisCount = 0;
    const orientation = faceOrientation(oc, face);
    for (let nt = 1; nt <= nbTriangles; nt++) {
      const t = tri.Triangle(nt);
      let n1 = t.Value(1);
      let n2 = t.Value(2);
      const n3 = t.Value(3);
      if (orientation == 0 /* BACKWARD */) {
        const tmp = n1;
        n1 = n2;
        n2 = tmp;
      }
      const index = trisCount * STRIDE;
      faceData2.indices[index] = n1 - 1 + index0;
      faceData2.indices[index + 1] = n2 - 1 + index0;
      faceData2.indices[index + 2] = n3 - 1 + index0;
      trisCount++;
    }
    return faceData2;
  });
}
