"use strict";
import { Float32BufferAttribute, Mesh } from "three";
import { arrayChunk, arrayIntersection } from "../../ArrayUtils";
import { pointsFromObject } from "../entities/point/CorePointUtils";
import { ThreejsPoint } from "../modules/three/ThreejsPoint";
const dummyMeshSmallest = new Mesh();
const dummyMeshLargest = new Mesh();
const _smallestPoints = [];
const _largestPoints = [];
function segments(geometry) {
  var _a;
  const index = ((_a = geometry.index) == null ? void 0 : _a.array) || [];
  return arrayChunk(index, 2);
}
export class CoreGeometryOperationSkin {
  constructor(geometry, geometry1, geometry0) {
    this.geometry = geometry;
    this.geometry1 = geometry1;
    this.geometry0 = geometry0;
  }
  process() {
    const segments0 = segments(this.geometry0);
    const segments1 = segments(this.geometry1);
    if (segments0.length === 0 || segments1.length === 0) {
      return;
    }
    const geometries_by_segments_count = segments0.length < segments1.length ? [this.geometry0, this.geometry1] : [this.geometry1, this.geometry0];
    const smallest_geometry = geometries_by_segments_count[0];
    const largest_geometry = geometries_by_segments_count[1];
    dummyMeshSmallest.geometry = smallest_geometry;
    dummyMeshLargest.geometry = largest_geometry;
    const smallest_segments = segments(smallest_geometry);
    const largest_segments = segments(largest_geometry);
    pointsFromObject(dummyMeshSmallest, _smallestPoints);
    pointsFromObject(dummyMeshLargest, _largestPoints);
    const smallestGeometryAttribNames = ThreejsPoint.attributeNames(dummyMeshSmallest);
    const largestGeometryAttribNames = ThreejsPoint.attributeNames(dummyMeshLargest);
    const smallest_points_count = _smallestPoints.length;
    const all_points = _smallestPoints.concat(_largestPoints);
    const points_indices = [];
    smallest_segments.forEach((segment, i) => {
      const matched_segment = largest_segments[i];
      points_indices.push(segment[0]);
      points_indices.push(segment[1]);
      points_indices.push(matched_segment[0] + smallest_points_count);
      points_indices.push(segment[1]);
      points_indices.push(matched_segment[1] + smallest_points_count);
      points_indices.push(matched_segment[0] + smallest_points_count);
    });
    const attributes_in_common = [];
    arrayIntersection(smallestGeometryAttribNames, largestGeometryAttribNames, attributes_in_common);
    attributes_in_common.forEach((attrib_name) => {
      const attrib_size = ThreejsPoint.attribSize(dummyMeshSmallest, attrib_name);
      let attrib_values = all_points.map((point) => point.attribValue(attrib_name));
      let float_values;
      if (attrib_size == 1) {
        float_values = attrib_values;
      } else {
        float_values = attrib_values.map((v) => v.toArray()).flat();
      }
      this.geometry.setAttribute(attrib_name, new Float32BufferAttribute(float_values, attrib_size));
    });
    this.geometry.setIndex(points_indices);
    this.geometry.computeVertexNormals();
  }
}
