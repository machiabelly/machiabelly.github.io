"use strict";
import { Color, Vector3 } from "three";
import { Poly } from "../../../../engine/Poly";
import { NodeParamProxiesRegister } from "../../NodeParamProxiesRegister";
import { animBuilderCommonVars } from "../Common";
import { animBuilderStartTimeline } from "../StartTimeline";
import { AnimBuilderWithOp } from "../WithOp";
export function populateVarsForParamColor(param, targetValue, options) {
  if (!(targetValue instanceof Color || targetValue instanceof Vector3)) {
    Poly.warn(
      `TimelineBuilderProperty error: cannot animate color param '${param.path()}' with targetValue`,
      targetValue
    );
    return;
  }
  const proxy = NodeParamProxiesRegister.paramProxy(param);
  if (!proxy) {
    return;
  }
  const vars = animBuilderCommonVars(options.timelineBuilder);
  vars.onUpdate = () => {
    proxy.update();
  };
  const operation = options.timelineBuilder.operation();
  const x = targetValue instanceof Color ? targetValue.r : targetValue.x;
  const y = targetValue instanceof Color ? targetValue.g : targetValue.y;
  const z = targetValue instanceof Color ? targetValue.b : targetValue.z;
  vars.r = AnimBuilderWithOp(param.value.r, x, operation);
  vars.g = AnimBuilderWithOp(param.value.g, y, operation);
  vars.b = AnimBuilderWithOp(param.value.b, z, operation);
  animBuilderStartTimeline({ ...options, vars, target: proxy.proxyValue, registerableProp: param });
}
export function populateVarsForColor(options) {
  const { vars, targetValue, targetProperty, propertyNames, operation } = options;
  for (const propertyName of propertyNames) {
    vars[propertyName] = AnimBuilderWithOp(
      targetProperty[propertyName],
      targetValue[propertyName],
      operation
    );
  }
}
