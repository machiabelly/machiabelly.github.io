"use strict";
import { LIBRARY_INSTALL_HINT } from "./../common";
import { Poly } from "../../../engine/Poly";
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { CoreBaseLoader } from "../_Base";
import { BaseObject3DLoaderHandler } from "./_BaseLoaderHandler";
import { KTX2TextureLoader } from "../texture/KTX2";
import { sanitizeUrl } from "../../UrlHelper";
export class GLTFLoaderHandler extends BaseObject3DLoaderHandler {
  reset() {
    var _a;
    super.reset();
    (_a = this._dracoLoader) == null ? void 0 : _a.dispose();
    this._gltfLoader = void 0;
    this._gltfdracoLoader = void 0;
    this._dracoLoader = void 0;
    this._ktx2Loader = void 0;
  }
  async load(options) {
    return super.load(options);
  }
  async _getLoader(options) {
    if (options.ktx2) {
      if (options.draco) {
        return this._ktx2gltfdracoLoader = this._ktx2gltfdracoLoader || await this._createGLTFLoader(options);
      } else {
        return this._ktx2gltfLoader = this._ktx2gltfLoader || await this._createGLTFLoader(options);
      }
    } else {
      if (options.draco) {
        return this._gltfdracoLoader = this._gltfdracoLoader || await this._createGLTFLoader(options);
      } else {
        return this._gltfLoader = this._gltfLoader || await this._createGLTFLoader(options);
      }
    }
  }
  async _createGLTFLoader(options) {
    const loader = new GLTFLoader(this.loadingManager);
    if (options.draco) {
      await this._setupDRACO(loader, options);
    }
    if (options.ktx2) {
      await this._setupKTX2(loader, options);
    }
    return loader;
  }
  // private async _createGLTFLoaderWithDRACO(options: BaseLoaderLoadOptions) {
  // 	const loader = new GLTFLoader(this.loadingManager);
  // 	await this._setupDRACO(loader, options);
  // 	await this._setupKTX2(loader, options);
  // 	return loader;
  // }
  async _setupDRACO(gltfLoader, options) {
    this._dracoLoader = this._dracoLoader || await this._createDRACOLoader(options);
    gltfLoader.setDRACOLoader(this._dracoLoader);
  }
  async _setupKTX2(gltfLoader, options) {
    this._ktx2Loader = this._ktx2Loader || await KTX2TextureLoader.getLoader(options);
    gltfLoader.setKTX2Loader(this._ktx2Loader);
  }
  async _createDRACOLoader(options) {
    const useJS = false;
    const node = options.node;
    const dracoLoader = new DRACOLoader(this.loadingManager);
    const root = Poly.libs.root();
    const DRACOGLTFPath = Poly.libs.DRACOGLTFPath();
    if (root || DRACOGLTFPath) {
      const decoderPath = sanitizeUrl(`${root || ""}${DRACOGLTFPath || ""}/`);
      const timestamp = Date.now();
      const files = useJS ? ["draco_decoder.js"] : ["draco_decoder.wasm", "draco_wasm_wrapper.js"];
      await CoreBaseLoader._loadMultipleUrlsGlobal({
        files: files.map((file) => {
          return {
            fullUrl: `${decoderPath}${file}?t=${timestamp}`
          };
        }),
        node,
        error: `failed to load draco libraries. Make sure to install them to load .glb files (${LIBRARY_INSTALL_HINT})`
      });
      dracoLoader.setDecoderPath(decoderPath);
    } else {
      dracoLoader.setDecoderPath(void 0);
    }
    dracoLoader.setDecoderConfig({ type: useJS ? "js" : "wasm" });
    dracoLoader.preload();
    return dracoLoader;
  }
  _onLoadSuccess(gltf) {
    const scene = gltf.scene || gltf.scenes[0];
    scene.animations = gltf.animations;
    return [scene];
  }
}
