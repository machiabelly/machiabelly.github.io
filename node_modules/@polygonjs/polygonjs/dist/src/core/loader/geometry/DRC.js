"use strict";
import { Mesh, MeshLambertMaterial } from "three";
import { Poly } from "../../../engine/Poly";
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
import { LIBRARY_INSTALL_HINT } from "../common";
import { CoreBaseLoader } from "../_Base";
import { BaseObject3DLoaderHandler } from "./_BaseLoaderHandler";
const _defaultMatMesh = new MeshLambertMaterial();
export class DRCLoaderHandler extends BaseObject3DLoaderHandler {
  async _getLoader(options) {
    return this._loader = this._loader || await this._createDRACOLoader(options);
  }
  async _createDRACOLoader(options) {
    const useJS = false;
    const node = options.node;
    const dracoLoader = new DRACOLoader(this.loadingManager);
    const root = Poly.libs.root();
    const DRACOPath = Poly.libs.DRACOPath();
    if (root || DRACOPath) {
      const decoderPath = `${root || ""}${DRACOPath || ""}/`;
      const files = useJS ? ["draco_decoder.js"] : ["draco_decoder.wasm", "draco_wasm_wrapper.js"];
      await CoreBaseLoader._loadMultipleUrlsGlobal({
        files: files.map((file) => {
          return {
            storedUrl: `${decoderPath}${file}`,
            fullUrl: `${decoderPath}${file}`
          };
        }),
        node,
        error: `failed to load draco libraries. Make sure to install them to load .glb files (${LIBRARY_INSTALL_HINT})`
      });
      dracoLoader.setDecoderPath(decoderPath);
    } else {
      dracoLoader.setDecoderPath(void 0);
    }
    dracoLoader.setDecoderConfig({ type: useJS ? "js" : "wasm" });
    return dracoLoader;
  }
  _onLoadSuccess(geometry) {
    return [new Mesh(geometry, _defaultMatMesh)];
  }
}
