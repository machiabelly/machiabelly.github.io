"use strict";
import { Poly } from "../../../engine/Poly";
import { CoreBaseLoader } from "./../_Base";
import { FontLoader } from "./FontLoader";
import { SVGLoader } from "three/examples/jsm/loaders/SVGLoader";
import { TTFLoader } from "three/examples/jsm/loaders/TTFLoader";
var FileFontFormat = /* @__PURE__ */ ((FileFontFormat2) => {
  FileFontFormat2["JSON"] = "json";
  FileFontFormat2["TTF"] = "ttf";
  return FileFontFormat2;
})(FileFontFormat || {});
const FILE_FONT_FORMATS = ["json" /* JSON */, "ttf" /* TTF */];
export function isExtFont(ext) {
  return FILE_FONT_FORMATS.includes(ext);
}
export class CoreLoaderFont extends CoreBaseLoader {
  constructor(url, _node) {
    super(url, _node);
    this._fontLoader = new FontLoader(this.loadingManager);
  }
  async load() {
    if (this._node) {
      Poly.blobs.clearBlobsForNode(this._node);
    }
    const ext = this.extension();
    const url = this._urlToLoad();
    switch (ext) {
      case "ttf": {
        return this._loadTTF(url);
      }
      case "json": {
        return this._loadJSON(url);
      }
      default: {
        return null;
      }
    }
  }
  _loadTTF(url) {
    return new Promise(async (resolve, reject) => {
      const loadedModule = await this._loadTTFLoader();
      if (!loadedModule) {
        return;
      }
      loadedModule.load(
        url,
        (fnt) => {
          const parsed = this._fontLoader.parse(fnt);
          resolve(parsed);
        },
        void 0,
        (err) => {
          reject(err);
        }
      );
    });
  }
  _loadJSON(url) {
    return new Promise((resolve, reject) => {
      this._fontLoader.load(
        url,
        (font) => {
          resolve(font);
        },
        void 0,
        () => {
          reject();
        }
      );
    });
  }
  async _loadTTFLoader() {
    return new TTFLoader(this.loadingManager);
  }
  static async loadSVGLoader() {
    return SVGLoader;
  }
}
