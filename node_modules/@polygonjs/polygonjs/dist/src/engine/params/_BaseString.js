"use strict";
import { stringValueElements } from "./../expressions/traversers/ParsedTree";
import { ParamEvent } from "./../poly/ParamEvent";
import { TypedParam } from "./_Base";
import { ExpressionController } from "./utils/ExpressionController";
export class TypedStringParam extends TypedParam {
  expressionParsedAsString() {
    return true;
  }
  processRawInput() {
    if (stringValueElements(this._raw_input).length >= 3) {
      this._expression_controller = this._expression_controller || new ExpressionController(this);
      if (this._raw_input != this._expression_controller.expression()) {
        this.states.error.clear();
        this._expression_controller.setExpression(this._raw_input, false);
        this.setDirty();
        this.emitController.emit(ParamEvent.EXPRESSION_UPDATED);
      }
    } else {
      this.processRawInputWithoutExpression();
    }
  }
  async processComputation() {
    var _a;
    if (((_a = this.expressionController) == null ? void 0 : _a.active()) && !this.expressionController.entitiesDependent()) {
      const expressionResult = await this.expressionController.computeExpression();
      if (this.expressionController.isErrored()) {
        this.states.error.set(
          `expression error: "${this.expressionController.expression()}" (${this.expressionController.errorMessage()})`
        );
      } else {
        const converted = this.convert(expressionResult);
        if (converted != null) {
          this.states.error.clear();
          this._assignValue(converted);
          this.emitController.emit(ParamEvent.VALUE_UPDATED);
          this.options.executeCallback();
        } else {
          this.states.error.set(`expression returns an invalid type (${expressionResult})`);
        }
        this.removeDirtyState();
      }
    }
  }
}
