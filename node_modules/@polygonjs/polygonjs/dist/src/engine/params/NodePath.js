"use strict";
import { CoreType } from "./../../core/Type";
import { TypedPathParam } from "./_BasePath";
import { CoreWalker } from "../../core/Walker";
import { ParamType } from "../poly/ParamType";
import { TypedNodePathParamValue } from "../../core/Walker";
const tmpConvertedValue = new TypedNodePathParamValue();
export class NodePathParam extends TypedPathParam {
  static type() {
    return ParamType.NODE_PATH;
  }
  _initializeParam() {
    this._value = new TypedNodePathParamValue();
  }
  defaultValueSerialized() {
    return this._default_value;
  }
  rawInputSerialized() {
    return `${this._raw_input}`;
  }
  valueSerialized() {
    return `${this.value}`;
  }
  _copyValue(param) {
    this.set(param.valueSerialized());
  }
  static areRawInputEqual(raw_input1, raw_input2) {
    return raw_input1 == raw_input2;
  }
  static areValuesEqual(val1, val2) {
    return val1 == val2;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  setNode(node, options) {
    if ((options == null ? void 0 : options.relative) == true) {
      const path = CoreWalker.relativePath(this.node, node);
      this.set(path);
    } else {
      this.set(node.path());
    }
  }
  _assignValue(value) {
    const path = CoreType.isString(value) ? value : value.path();
    if (this._value.path() != path) {
      this._setValuePathAndFindTarget(path, false);
    }
  }
  convert(rawVal) {
    if (CoreType.isString(rawVal)) {
      tmpConvertedValue.setPath(rawVal);
      return tmpConvertedValue;
    } else {
      return null;
    }
  }
  // protected override async processComputation() {
  // 	this._findTarget();
  // }
  _findTarget() {
    if (!this.node) {
      return;
    }
    const path = this._value.path();
    let node = null;
    const pathNonEmpty = path != null && path !== "";
    this.scene().referencesController.resetReferenceFromParam(this);
    this.decomposedPath.reset();
    if (pathNonEmpty) {
      node = CoreWalker.findNode(this.node, path, this.decomposedPath);
    }
    const currentFoundEntity = this._value.node();
    const newlyFoundEntity = node;
    if (newlyFoundEntity) {
      if (newlyFoundEntity.graphNodeId() == this.node.graphNodeId()) {
        this.states.error.set(`param cannot refer to its own node`);
        return;
      }
    }
    this._handleReferences(node, path);
    if ((currentFoundEntity == null ? void 0 : currentFoundEntity.graphNodeId()) !== (newlyFoundEntity == null ? void 0 : newlyFoundEntity.graphNodeId())) {
      const dependentOnFoundNode = this.options.dependentOnFoundNode();
      const previouslyFoundNode = this._value.node();
      if (previouslyFoundNode) {
        if (dependentOnFoundNode) {
          this.removeGraphInput(previouslyFoundNode);
        } else {
        }
      }
      if (node) {
        this._assignFoundNode(node);
      } else {
        this._value.setNode(null);
      }
      this.options.executeCallback();
    }
    if (pathNonEmpty && !node && this.scene().loadingController.loaded()) {
      if (pathNonEmpty) {
        this.states.error.set(`no node found at path '${path}'`);
      }
    }
    this.removeDirtyState();
  }
  _assignFoundNode(node) {
    const dependentOnFoundNode = this.options.dependentOnFoundNode();
    if (this._isNodeExpectedContext(node)) {
      if (this._isNodeExpectedType(node)) {
        this.states.error.clear();
        this._value.setNode(node);
        if (dependentOnFoundNode) {
          this.addGraphInput(node);
        }
      } else {
        this.states.error.set(
          `node type is ${node.type()} but the params expects one of ${(this._expectedNodeTypes() || []).join(
            ", "
          )}`
        );
      }
    } else {
      this.states.error.set(
        `node context is ${node.context()} but the params expects a ${this._expectedContext()}`
      );
    }
  }
  _expectedContext() {
    return this.options.nodeSelectionContext();
  }
  _isNodeExpectedContext(node) {
    const expectedContext = this._expectedContext();
    if (expectedContext == null) {
      return true;
    }
    return expectedContext == node.context();
  }
  _expectedNodeTypes() {
    return this.options.nodeSelectionTypes();
  }
  _isNodeExpectedType(node) {
    const expected_types = this._expectedNodeTypes();
    if (expected_types == null) {
      return true;
    }
    return expected_types == null ? void 0 : expected_types.includes(node.type());
  }
  notifyPathRebuildRequired(node) {
    this.decomposedPath.updateFromNameChange(node);
    const newPath = this.decomposedPath.toPath();
    this.set(newPath);
  }
  notifyTargetParamOwnerParamsUpdated(node) {
    this.setDirty();
  }
}
