"use strict";
import { CoreWalker } from "../../core/Walker";
import { CoreGraphNode } from "../../core/graph/CoreGraphNode";
import { OptionsController } from "./utils/OptionsController";
import { EmitController } from "./utils/EmitController";
import { ParamStatesController } from "./utils/StatesController";
import { ParamType } from "../poly/ParamType";
import { ParamEvent } from "../poly/ParamEvent";
import { MethodDependency } from "../expressions/MethodDependency";
import { Poly } from "../Poly";
import { arrayCopy } from "../../core/ArrayUtils";
const TYPED_PARAM_DEFAULT_COMPONENT_NAMES = [];
export class TypedParam extends CoreGraphNode {
  // private _ui_data: UIData | undefined;
  // get ui_data(): UIData {
  // 	return (this._ui_data = this._ui_data || new UIData(this.scene, this));
  // }
  constructor(scene, node, options) {
    super(scene, "BaseParam");
    this._options = new OptionsController(this);
    this._emitController = new EmitController(this);
    this._isComputing = false;
    if (options.serializerClass) {
      this._serializer = new options.serializerClass(this);
    }
    this._node = node;
    this._initializeParam();
  }
  get options() {
    return this._options = this._options || new OptionsController(this);
  }
  get emitController() {
    return this._emitController = this._emitController || new EmitController(this);
  }
  get expressionController() {
    return this._expression_controller;
  }
  expressionParsedAsString() {
    return false;
  }
  get serializer() {
    return this._serializer;
  }
  get states() {
    return this._states = this._states || new ParamStatesController(this);
  }
  dispose() {
    var _a, _b;
    if (this.expressionController && this.hasExpression()) {
      this.set(this.rawInputSerialized());
    }
    const _tmpCoreGraphNodes = [];
    const predecessors = this.graphPredecessors();
    if (predecessors) {
      arrayCopy(predecessors, _tmpCoreGraphNodes);
      for (const predecessor of _tmpCoreGraphNodes) {
        if (predecessor instanceof MethodDependency) {
          predecessor.dispose();
        }
      }
    }
    const successors = this.graphSuccessors();
    if (successors) {
      arrayCopy(successors, _tmpCoreGraphNodes);
      for (const successor of _tmpCoreGraphNodes) {
        if (successor instanceof TypedParam) {
          const input = successor.rawInputSerialized();
          successor.set(successor.defaultValue());
          successor.set(input);
        } else {
          successor.setDirty();
        }
      }
    }
    this.scene().missingExpressionReferencesController.deregisterParam(this);
    (_a = this._expression_controller) == null ? void 0 : _a.dispose();
    super.dispose();
    (_b = this._options) == null ? void 0 : _b.dispose();
    this._node = void 0;
    this._parent_param = void 0;
    this._runOnDisposeCallbacks();
  }
  _initializeParam() {
  }
  postOptionsInitialize() {
  }
  // 	// this.addPostDirtyHook(this._remove_node_param_cache.bind(this))
  // }
  // initialize() {
  // 	this.initComponents();
  // 	// this.init_expression()
  // 	// this._init_ui_data()
  // }
  // accepts_visitor<T extends ParamVisitor>(visitor: T): ReturnType<T['visit_param']> {
  // 	return visitor.visit_param(this);
  // }
  //
  // init_expression() {}
  // type
  static type() {
    return ParamType.FLOAT;
  }
  type() {
    return this.constructor.type();
  }
  isNumeric() {
    return false;
  }
  // name
  setName(name) {
    super.setName(name);
  }
  get value() {
    return this._value;
  }
  copyValue(param) {
    if (param.type() == this.type()) {
      this._copyValue(param);
    } else {
      console.warn(`cannot copy value from ${param.type()} to ${this.type()}`);
    }
  }
  _copyValue(param) {
    throw "abstract method param._copy_value";
  }
  valuePreConversionSerialized() {
    return void 0;
  }
  convert(rawVal) {
    return null;
  }
  static areRawInputEqual(val1, val2) {
    return false;
  }
  isRawInputEqual(other_raw_input) {
    return this.constructor.areRawInputEqual(this._raw_input, other_raw_input);
  }
  isDefaultValueEqual(other_default_value) {
    return this.constructor.areRawInputEqual(this._default_value, other_default_value);
  }
  static areValuesEqual(val1, val2) {
    return false;
  }
  isValueEqual(other_val) {
    return this.constructor.areValuesEqual(this.value, other_val);
  }
  _cloneRawInput(raw_input) {
    return raw_input;
  }
  set(raw_input) {
    this._raw_input = this._cloneRawInput(this._prefilterInvalidRawInput(raw_input));
    this.emitController.emit(ParamEvent.RAW_INPUT_UPDATED);
    this.processRawInput();
  }
  _prefilterInvalidRawInput(raw_input) {
    return raw_input;
  }
  defaultValue() {
    return this._default_value;
  }
  isDefault() {
    return this._raw_input == this._default_value;
  }
  rawInput() {
    return this._raw_input;
  }
  processRawInput() {
  }
  isComputing() {
    return this._isComputing;
  }
  async compute() {
    if (this.scene().loadingController.isLoading()) {
      Poly.warn(`param attempt to compute ${this.path()} while scene is loading`);
    }
    if (this.isDirty()) {
      if (!this._isComputing) {
        this._isComputing = true;
        await this.processComputation();
        this._isComputing = false;
        if (this._computeResolves) {
          const resolves = [...this._computeResolves];
          this._computeResolves = void 0;
          for (const resolve of resolves) {
            resolve();
          }
        }
      } else {
        return new Promise((resolve, reject) => {
          this._computeResolves = this._computeResolves || [];
          this._computeResolves.push(resolve);
        });
      }
    }
  }
  async processComputation() {
  }
  // set_default_value(default_value: ParamValuesTypeMap[T]) {
  // 	this._default_value = default_value;
  // }
  setInitValue(init_value) {
    this._default_value = this._cloneRawInput(this._prefilterInvalidRawInput(init_value));
  }
  // eval_p(): Promise<ParamValuesTypeMap[T]> {
  // 	return new Promise((resolve, reject) => {
  // 		resolve();
  // 	});
  // }
  // node
  _setupNodeDependencies(node) {
    var _a, _b;
    if (!node) {
      if (this._node) {
        (_a = this._node.params.params_node) == null ? void 0 : _a.removeGraphInput(this);
      }
    } else {
      this.options.allowCallback();
      if (!this.parentParam()) {
        if (this.options.makesNodeDirtyWhenDirty()) {
          (_b = node.params.params_node) == null ? void 0 : _b.addGraphInput(this, false);
        } else {
          this.dirtyController.addPostDirtyHook("run callback", async () => {
            await this.compute();
            await this.options.executeCallback();
          });
        }
      }
    }
    if (this.components) {
      for (const c of this.components) {
        c._setupNodeDependencies(node);
      }
    }
  }
  get node() {
    return this._node;
  }
  parent() {
    return this.node;
  }
  // hierarchy
  set_parent_param(param) {
    param.addGraphInput(this, false);
    this._parent_param = param;
  }
  parentParam() {
    return this._parent_param;
  }
  has_parent_param() {
    return this._parent_param != null;
  }
  path() {
    var _a;
    return ((_a = this.node) == null ? void 0 : _a.path()) + "/" + this.name();
  }
  pathRelativeTo(node) {
    if (!this._node) {
      return this.name();
    }
    const nodeRelativePath = CoreWalker.relativePath(node, this._node);
    if (nodeRelativePath.length > 0) {
      return CoreWalker.sanitizePath(`${nodeRelativePath}${CoreWalker.SEPARATOR}${this.name()}`);
    } else {
      return this.name();
    }
  }
  // emit
  emit(eventName) {
    if (this.emitController.emitAllowed()) {
      this.emitController.incrementCount(eventName);
      this.scene().dispatchController.dispatch(this, eventName);
    }
  }
  // multiple
  get components() {
    return this._components;
  }
  componentNames() {
    return TYPED_PARAM_DEFAULT_COMPONENT_NAMES;
  }
  isMultiple() {
    return this.componentNames().length > 0;
  }
  initComponents() {
  }
  hasExpression() {
    return this.expressionController != null && this.expressionController.active();
  }
  // serialize
  toJSON() {
    if (!this._serializer) {
      return;
    }
    return this._serializer.toJSON();
  }
  onDispose(callback) {
    this._onDisposeCallbacks = this._onDisposeCallbacks || /* @__PURE__ */ new Set();
    this._onDisposeCallbacks.add(callback);
  }
  deregisterOnDispose(callback) {
    if (this._onDisposeCallbacks) {
      this._onDisposeCallbacks.delete(callback);
    }
  }
  _runOnDisposeCallbacks() {
    if (this._onDisposeCallbacks) {
      this._onDisposeCallbacks.forEach((callback) => {
        callback();
      });
      this._onDisposeCallbacks.clear();
      this._onDisposeCallbacks = void 0;
    }
  }
}
export class BaseParamClass extends TypedParam {
  defaultValueSerialized() {
    return "BaseParamClass.defaultValueSerialized overriden";
  }
  rawInputSerialized() {
    return "BaseParamClass.rawInputSerialized overriden";
  }
  valueSerialized() {
    return "BaseParamClass.valueSerialized overriden";
  }
}
