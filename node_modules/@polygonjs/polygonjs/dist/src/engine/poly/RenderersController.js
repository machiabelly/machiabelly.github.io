"use strict";
import {
  WebGLRenderer,
  WebGLRenderTarget,
  NoColorSpace,
  NoToneMapping
} from "three";
import { WEBGL_RENDERER_DEFAULT_PARAMS } from "../../core/render/Common";
const CONTEXT_OPTIONS = {
  // powerPreference: 'high-performance', // attempt to fix issues in safari
  // antialias: false, // leave that to the renderer node
  // preserveDrawingBuffer: true, // this could only be useful to capture static images
};
var WebGLContext = /* @__PURE__ */ ((WebGLContext2) => {
  WebGLContext2["WEBGL"] = "webgl";
  WebGLContext2["WEBGL2"] = "webgl2";
  WebGLContext2["EXPERIMENTAL_WEBGL"] = "experimental-webgl";
  WebGLContext2["EXPERIMENTAL_WEBGL2"] = "experimental-webgl2";
  return WebGLContext2;
})(WebGLContext || {});
let nextRendererId = 0;
const _RenderersController = class {
  constructor() {
    // private _firstRenderer: WebGLRenderer | null = null;
    // private _lastRenderer: WebGLRenderer | null = null;
    this._printDebug = false;
    this._requireWebGL2 = false;
    // private _env_maps: TextureByString = {};
    // private _next_env_map_id: number = 0;
    this._webGLContextByCanvas = /* @__PURE__ */ new Map();
    this._defaultRendererByCanvas = /* @__PURE__ */ new Map();
  }
  dispose() {
    this._webGLContextByCanvas.clear();
    this._defaultRendererByCanvas.forEach((renderer) => {
      renderer.dispose();
    });
    this._defaultRendererByCanvas.clear();
  }
  setPrintDebug(state = true) {
    this._printDebug = state;
  }
  printDebug() {
    return this._printDebug;
  }
  printDebugMessage(message) {
    if (!this._printDebug) {
      return;
    }
    console.warn("[Poly debug]", message);
  }
  setRequireWebGL2() {
    if (!this._requireWebGL2) {
      this._requireWebGL2 = true;
    }
  }
  webGL2Available(canvas) {
    if (this._webgl2_available === void 0) {
      this._webgl2_available = this._getWebGL2Available(canvas);
    }
    return this._webgl2_available;
  }
  _getWebGL2Available(canvas) {
    canvas = canvas || document.createElement("canvas");
    return (window.WebGL2RenderingContext && canvas.getContext("webgl2" /* WEBGL2 */)) != null;
  }
  defaultWebGLRendererForCanvas(canvas) {
    let renderer = this._defaultRendererByCanvas.get(canvas);
    if (!renderer) {
      const context = this.getRenderingContext(canvas);
      renderer = this.createWebGLRenderer({ ...WEBGL_RENDERER_DEFAULT_PARAMS, canvas, context });
      this._defaultRendererByCanvas.set(canvas, renderer);
    }
    return renderer;
  }
  // disposeWebGLRendererForCanvas(canvas: HTMLCanvasElement) {
  // 	const renderer = this._defaultRendererByCanvas.get(canvas);
  // 	if (renderer) {
  // 		renderer.dispose();
  // 		this._defaultRendererByCanvas.delete(canvas);
  // 	}
  // }
  createWebGLRenderer(params) {
    const renderer = new WebGLRenderer(params);
    this.assignIdToRenderer(renderer);
    this.printDebugMessage([`create renderer:`, params]);
    return renderer;
  }
  assignIdToRenderer(renderer) {
    if (renderer._polygonId != null) {
      return;
    }
    const nextId = nextRendererId += 1;
    renderer._polygonId = nextId;
  }
  rendererId(renderer) {
    const id = renderer._polygonId;
    if (id == null) {
      console.error("renderer has no _polygonId");
      return;
    }
    return id;
  }
  getRenderingContext(canvas) {
    let gl = this._webGLContextByCanvas.get(canvas);
    if (gl) {
      return gl;
    }
    gl = this._getRenderingContextWebgl(canvas, true);
    if (!gl) {
      console.warn("failed to create webgl2 context");
    }
    if (!gl) {
      gl = this._getRenderingContextWebgl(canvas, false);
    }
    if (!gl) {
      console.error("failed to create webgl context");
      return null;
    }
    if (gl._polygonjsContextId == null) {
      gl._polygonjsContextId = _RenderersController._nextGlContextId++;
    }
    this._webGLContextByCanvas.set(canvas, gl);
    return gl;
  }
  _getRenderingContextWebgl(canvas, webgl2) {
    let contextName;
    if (this.webGL2Available(canvas)) {
      contextName = "webgl2" /* WEBGL2 */;
    } else {
      contextName = webgl2 ? "webgl2" /* WEBGL2 */ : "webgl" /* WEBGL */;
    }
    let gl = canvas.getContext(contextName, CONTEXT_OPTIONS);
    if (gl) {
      this.printDebugMessage(`create gl context: ${contextName}.`);
    } else {
      contextName = webgl2 ? "experimental-webgl2" /* EXPERIMENTAL_WEBGL2 */ : "experimental-webgl" /* EXPERIMENTAL_WEBGL */;
      this.printDebugMessage(`create gl context: ${contextName}.`);
      gl = canvas.getContext(contextName, CONTEXT_OPTIONS);
    }
    return gl;
  }
  createRenderTarget(width, height, parameters) {
    if (this.webGL2Available()) {
      const multiSampleRenderTarget = new WebGLRenderTarget(width, height, parameters);
      multiSampleRenderTarget.samples = 2;
      return multiSampleRenderTarget;
    } else {
      return new WebGLRenderTarget(width, height, parameters);
    }
  }
  linearRenderer() {
    return this._linearRenderer = this._linearRenderer || this._createLinearRenderer();
  }
  _createLinearRenderer() {
    const canvas = document.createElement("canvas");
    const gl = this.getRenderingContext(canvas);
    if (!gl) {
      return;
    }
    const renderer = this.createWebGLRenderer({
      // antialias: true,
      // stencil: true,
      // depth: false,
      alpha: true,
      premultipliedAlpha: true,
      canvas,
      context: gl
    });
    renderer.outputColorSpace = NoColorSpace;
    renderer.toneMapping = NoToneMapping;
    return renderer;
  }
};
export let RenderersController = _RenderersController;
RenderersController._nextGlContextId = 0;
