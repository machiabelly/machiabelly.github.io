"use strict";
import { CoreType } from "../../../../core/Type";
export class NodesRegister {
  constructor(poly) {
    this.poly = poly;
    this._nodesRegister = /* @__PURE__ */ new Map();
    this._nodesRegisterCategories = /* @__PURE__ */ new Map();
    this._nodesRegisterOptions = /* @__PURE__ */ new Map();
  }
  static type(node) {
    return this.filterType(node.type());
  }
  static filterType(nodeType) {
    return nodeType.toLowerCase();
  }
  register(node, tabMenuCategory, options) {
    var _a, _b;
    const context = node.context();
    const nodeType = NodesRegister.type(node);
    let printWarnings = options == null ? void 0 : options.printWarnings;
    if (printWarnings == null) {
      printWarnings = true;
    }
    let current_nodes_for_context = this._nodesRegister.get(context);
    if (!current_nodes_for_context) {
      current_nodes_for_context = /* @__PURE__ */ new Map();
      this._nodesRegister.set(context, current_nodes_for_context);
    }
    const alreadyRegisteredNode = current_nodes_for_context.get(nodeType);
    if (alreadyRegisteredNode) {
      const isAlreadyRegisteredNodePolyNode = ((_b = (_a = this._nodesRegisterOptions.get(context)) == null ? void 0 : _a.get(nodeType)) == null ? void 0 : _b.polyNode) == true;
      const isNewNodePolyNode = (options == null ? void 0 : options.polyNode) == true;
      if (isAlreadyRegisteredNodePolyNode && isNewNodePolyNode) {
      } else {
        if (printWarnings) {
          console.warn(`node ${context}/${nodeType} already registered`);
        }
        return;
      }
    }
    current_nodes_for_context.set(nodeType, node);
    if (node.onRegister) {
      node.onRegister(this.poly);
    }
    if (tabMenuCategory) {
      let current_categories = this._nodesRegisterCategories.get(context);
      if (!current_categories) {
        current_categories = /* @__PURE__ */ new Map();
        this._nodesRegisterCategories.set(context, current_categories);
      }
      const savedCategory = CoreType.isArray(tabMenuCategory) ? tabMenuCategory : [tabMenuCategory];
      current_categories.set(nodeType, savedCategory);
    }
    if (options) {
      let current_options = this._nodesRegisterOptions.get(context);
      if (!current_options) {
        current_options = /* @__PURE__ */ new Map();
        this._nodesRegisterOptions.set(context, current_options);
      }
      current_options.set(nodeType, options);
    }
    this.poly.pluginsRegister.registerNode(node);
  }
  deregister(context, nodeType) {
    var _a, _b, _c;
    nodeType = NodesRegister.filterType(nodeType);
    (_a = this._nodesRegister.get(context)) == null ? void 0 : _a.delete(nodeType);
    (_b = this._nodesRegisterCategories.get(context)) == null ? void 0 : _b.delete(nodeType);
    (_c = this._nodesRegisterOptions.get(context)) == null ? void 0 : _c.delete(nodeType);
  }
  isRegistered(context, nodeType) {
    const nodes_for_context = this._nodesRegister.get(context);
    if (!nodes_for_context) {
      return false;
    }
    nodeType = NodesRegister.filterType(nodeType);
    return nodes_for_context.get(nodeType) != null;
  }
  nodeOptions(context, nodeType) {
    var _a;
    nodeType = NodesRegister.filterType(nodeType);
    return (_a = this._nodesRegisterOptions.get(context)) == null ? void 0 : _a.get(nodeType);
  }
  registeredNodesForParentNode(parentNode) {
    var _a, _b;
    const context = (_a = parentNode.childrenController) == null ? void 0 : _a.context;
    if (!context) {
      return [];
    }
    const map = this._nodesRegister.get(context);
    if (map) {
      const nodes_for_context = [];
      (_b = this._nodesRegister.get(context)) == null ? void 0 : _b.forEach((node, type) => {
        nodes_for_context.push(node);
      });
      return nodes_for_context.filter((node) => {
        const nodeType = NodesRegister.type(node);
        const options = this.nodeOptions(context, nodeType);
        if (!options) {
          return true;
        } else {
          const parentOptions = this.nodeOptions(parentNode.context(), parentNode.type());
          if ((parentOptions == null ? void 0 : parentOptions.polyNode) == true) {
            return true;
          }
          const option_only = options["only"];
          const option_except = options["except"];
          const context_and_type = `${parentNode.context()}/${parentNode.type()}`;
          if (option_only) {
            return option_only.includes(context_and_type);
          }
          if (option_except) {
            return !option_except.includes(context_and_type);
          }
          return true;
        }
      });
    } else {
      return [];
    }
  }
  registeredNodes(parentNode) {
    const nodesByType = {};
    const nodes = this.registeredNodesForParentNode(parentNode);
    for (let node of nodes) {
      const nodeType = NodesRegister.type(node);
      nodesByType[nodeType] = node;
    }
    return nodesByType;
  }
  registeredCategory(context, nodeType) {
    var _a;
    nodeType = NodesRegister.filterType(nodeType);
    return (_a = this._nodesRegisterCategories.get(context)) == null ? void 0 : _a.get(nodeType);
  }
  map() {
    return this._nodesRegister;
  }
}
export class OperationsRegister {
  constructor(poly) {
    this.poly = poly;
    this._operation_register = /* @__PURE__ */ new Map();
  }
  static type(node) {
    return this.filterType(node.type());
  }
  static filterType(nodeType) {
    return nodeType.toLowerCase();
  }
  register(operation, options) {
    let printWarnings = options == null ? void 0 : options.printWarnings;
    if (printWarnings == null) {
      printWarnings = true;
    }
    const context = operation.context();
    let current_operations_for_context = this._operation_register.get(context);
    if (!current_operations_for_context) {
      current_operations_for_context = /* @__PURE__ */ new Map();
      this._operation_register.set(context, current_operations_for_context);
    }
    const operationType = OperationsRegister.type(operation);
    const already_registered_operation = current_operations_for_context.get(operationType);
    if (already_registered_operation) {
      if (printWarnings) {
        const message = `operation ${context}/${operationType} already registered`;
        console.warn(message);
      }
      return;
    }
    current_operations_for_context.set(operationType, operation);
    if (operation.onRegister) {
      operation.onRegister(this.poly);
    }
    this.poly.pluginsRegister.registerOperation(operation);
  }
  registeredOperationsForContextAndParentType(context, parentNodeType) {
    var _a;
    const map = this._operation_register.get(context);
    if (map) {
      const nodes_for_context = [];
      (_a = this._operation_register.get(context)) == null ? void 0 : _a.forEach((operation, type) => {
        nodes_for_context.push(operation);
      });
      return nodes_for_context;
    } else {
      return [];
    }
  }
  registeredOperation(context, operationType) {
    const current_operations_for_context = this._operation_register.get(context);
    if (current_operations_for_context) {
      operationType = OperationsRegister.filterType(operationType);
      return current_operations_for_context.get(operationType);
    }
  }
}
