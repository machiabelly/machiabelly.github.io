"use strict";
import { CoreType } from "../../../core/Type";
export const VARIABLE_PREFIX = "$";
export class BaseTraverser {
  constructor(param) {
    this.param = param;
    this._set_error_from_error_bound = this._set_error_from_error.bind(this);
  }
  clearError() {
    this._errorMessage = void 0;
  }
  setError(message) {
    this._errorMessage = this._errorMessage || message;
  }
  _set_error_from_error(error) {
    if (CoreType.isString(error)) {
      this._errorMessage = error;
    } else {
      this._errorMessage = error.message;
    }
  }
  isErrored() {
    return this._errorMessage != null;
  }
  errorMessage() {
    return this._errorMessage;
  }
  reset() {
    this._errorMessage = void 0;
  }
  traverse_node(node) {
    const method_name = `traverse_${node.type}`;
    const method = this[method_name];
    if (method) {
      return this[method_name](node);
    } else {
      this.setError(`expression unknown node type: ${node.type}`);
    }
  }
  traverse_BinaryExpression(node) {
    return `${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)}`;
  }
  // protected traverse_LogicalExpression(node: jsep.LogicalExpression): string {
  // 	// || or &&
  // 	return `${this.traverse_node(node.left)} ${node.operator} ${this.traverse_node(node.right)}`;
  // }
  traverse_MemberExpression(node) {
    return `${this.traverse_node(node.object)}.${this.traverse_node(node.property)}`;
  }
  traverse_ConditionalExpression(node) {
    return `(${this.traverse_node(node.test)}) ? (${this.traverse_node(node.consequent)}) : (${this.traverse_node(
      node.alternate
    )})`;
  }
  // currently only used for string expressions such as
  // pt_`@ptnum+1`
  traverse_Compound(node) {
    const args = node.body;
    let traversed_args = [];
    for (let i = 0; i < args.length; i++) {
      const arg_node = args[i];
      if (arg_node.type == "Identifier") {
        if (arg_node.name[0] == VARIABLE_PREFIX) {
          traversed_args.push("`${" + this.traverse_node(arg_node) + "}`");
        } else {
          traversed_args.push(`'${arg_node.name}'`);
        }
      } else {
        traversed_args.push("`${" + this.traverse_node(arg_node) + "}`");
      }
    }
    return traversed_args.join(" + ");
  }
  traverse_Literal(node) {
    return `${node.raw}`;
  }
}
