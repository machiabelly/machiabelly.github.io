"use strict";
const ARGUMENTS_SEPARATOR = ", ";
import { BaseTraverser } from "./_Base";
export class ExpressionStringGenerator extends BaseTraverser {
  constructor(param) {
    super(param);
    this.param = param;
  }
  parseTree(parsedTree) {
    const node = parsedTree.node();
    if (parsedTree.errorMessage() == null && node) {
      try {
        return this.traverse_node(node);
      } catch (e) {
        this.setError("could not traverse tree");
      }
    } else {
      this.setError("cannot parse tree");
    }
  }
  traverse_CallExpression(node) {
    const methodArguments = node.arguments.map((arg) => {
      return this.traverse_node(arg);
    });
    const argumentsJoined = `${methodArguments.join(ARGUMENTS_SEPARATOR)}`;
    const methodName = node.callee.name;
    return `${methodName}(${argumentsJoined})`;
  }
  traverse_UnaryExpression(node) {
    return `${node.operator}${this.traverse_node(node.argument)}`;
  }
  traverse_Identifier(node) {
    return `${node.name}`;
  }
}
