"use strict";
import { CoreType } from "./../../../core/Type";
import { TypedParamPathParamValue, TypedNodePathParamValue } from "./../../../core/Walker";
import { BaseMethod } from "./_Base";
import { DecomposedPath } from "../../../core/DecomposedPath";
export class ChsopExpression extends BaseMethod {
  static requiredArguments() {
    return [["string", "path to param"]];
  }
  findDependency(args) {
    const { indexOrPath } = args;
    if (indexOrPath == null) {
      return null;
    }
    if (!CoreType.isString(indexOrPath)) {
      return null;
    }
    const decomposedPath = new DecomposedPath();
    const param = this.getReferencedParam(indexOrPath, decomposedPath);
    if (param) {
      this._referencedParam = param;
      return this.createDependency(param, { indexOrPath }, decomposedPath);
    }
    return null;
  }
  async processArguments(args) {
    if (args.length == 1) {
      const path = args[0];
      const param = this._referencedParam || this.getReferencedParam(path);
      if (param) {
        if (param.isDirty()) {
          await param.compute();
        }
        const paramValue = param.value;
        if (paramValue instanceof TypedParamPathParamValue || paramValue instanceof TypedNodePathParamValue) {
          const result = paramValue.graphNodePath();
          if (result != null) {
            return result;
          }
        }
      }
    }
    return "";
  }
}
