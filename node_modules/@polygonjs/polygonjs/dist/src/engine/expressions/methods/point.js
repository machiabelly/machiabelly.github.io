"use strict";
import { BaseMethod } from "./_Base";
const EXPECTED_ARGS_COUNT = 3;
const _pointsSrc = [];
export class PointExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "attribute name"],
      ["index", "point index"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  processArguments(args) {
    return new Promise(async (resolve, reject) => {
      if (args.length == EXPECTED_ARGS_COUNT) {
        const index_or_path = args[0];
        const attrib_name = args[1];
        const point_index = args[2];
        let container = null;
        try {
          container = await this.getReferencedNodeContainer(index_or_path);
        } catch (e) {
          reject(e);
        }
        if (container) {
          const value = this._get_value_from_container(container, attrib_name, point_index);
          resolve(value);
        }
      } else {
        console.warn(`${args.length} given when expected ${EXPECTED_ARGS_COUNT}`);
        resolve(0);
      }
    });
  }
  _get_value_from_container(container, attrib_name, point_index) {
    const coreGroup = container.coreContent();
    if (coreGroup) {
      coreGroup.points(_pointsSrc);
      const point = _pointsSrc[point_index];
      if (point) {
        return point.attribValue(attrib_name);
      } else {
        return 0;
      }
    } else {
      return null;
    }
  }
}
