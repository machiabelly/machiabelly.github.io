"use strict";
import { CoreWalker } from "../../../core/Walker";
import { DecomposedPath } from "../../../core/DecomposedPath";
import { MethodDependency } from "../MethodDependency";
import { Poly } from "../../Poly";
import { CoreType } from "../../../core/Type";
export class BaseMethod {
  constructor(param) {
    this.param = param;
  }
  node() {
    return this._node = this._node || this.param.node;
  }
  static requiredArguments() {
    console.warn("Expression.Method._Base.required_arguments virtual method call. Please override");
    return [];
  }
  static optionalArguments() {
    return [];
  }
  static minAllowedArgumentsCount() {
    return this.requiredArguments().length;
  }
  static maxAllowedArgumentsCount() {
    return this.minAllowedArgumentsCount() + this.optionalArguments().length;
  }
  static allowedArgumentsCount(count) {
    return count >= this.minAllowedArgumentsCount() && count <= this.maxAllowedArgumentsCount();
  }
  processArguments(args) {
    throw "Expression.Method._Base.process_arguments virtual method call. Please override";
  }
  async getReferencedNodeContainer(indexOrPath) {
    var _a, _b;
    const referencedNode = this.getReferencedNode(indexOrPath);
    if (referencedNode) {
      let container;
      if (referencedNode.isDirty() || ((_b = (_a = referencedNode.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.active())) {
        container = await referencedNode.compute();
      } else {
        container = referencedNode.containerController.container();
      }
      if (container) {
        const coreContent = container.coreContent();
        if (coreContent != null) {
          return container;
        }
      }
      throw `referenced node invalid: ${referencedNode.path()}`;
    } else {
      throw `invalid input (${indexOrPath})`;
    }
  }
  getReferencedParam(path, decomposedPath) {
    const node = this.node();
    if (node) {
      return CoreWalker.findParam(node, path, decomposedPath);
    }
    return null;
  }
  findReferencedGraphNode(indexOrPath, decomposedPath) {
    const is_index = CoreType.isNumber(indexOrPath);
    if (is_index) {
      const index = indexOrPath;
      const node = this.node();
      if (node) {
        const input_graph_node = node.io.inputs.inputGraphNode(index);
        return input_graph_node;
      }
    } else {
      const path = indexOrPath;
      return this.getReferencedNode(path, decomposedPath);
    }
    return null;
  }
  // caching the node by path here prevents having expressions such as points_count(0)
  // evaluate to an error when the input is disconnected
  // private _node_by_path: Map<string | number, BaseNodeType | null | undefined> = new Map();
  getReferencedNode(indexOrPath, decomposedPath) {
    let node = null;
    const current_node = this.node();
    if (CoreType.isString(indexOrPath)) {
      if (current_node) {
        const path = indexOrPath;
        node = CoreWalker.findNode(current_node, path, decomposedPath);
      }
    } else {
      if (current_node) {
        const index = indexOrPath;
        node = current_node.io.inputs.input(index);
      }
    }
    return node || null;
  }
  findDependency(arg) {
    return null;
  }
  createDependencyFromIndexOrPath(args) {
    if (this.param.disposed() == true) {
      return null;
    }
    const { indexOrPath } = args;
    const decomposedPath = new DecomposedPath();
    const node = indexOrPath != null ? this.findReferencedGraphNode(indexOrPath, decomposedPath) : args.node;
    if (node) {
      return this.createDependency(node, args, decomposedPath);
    } else {
      Poly.warn(`node not found for path '${indexOrPath}' from param '${this.param.path()}'`);
    }
    return null;
  }
  createDependency(node, pathArgs, decomposedPath) {
    const dependency = MethodDependency.create(this.param, pathArgs, node, decomposedPath);
    return dependency;
  }
}
