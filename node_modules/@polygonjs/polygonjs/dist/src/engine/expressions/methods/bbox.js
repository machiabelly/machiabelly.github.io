"use strict";
import { BaseMethod } from "./_Base";
import { Vector3, Box3 } from "three";
const tmpBox = new Box3();
const VECTOR_NAMES = ["min", "max", "size", "center"];
const COMPONENT_NAMES = ["x", "y", "z"];
export class BboxExpression extends BaseMethod {
  static requiredArguments() {
    return [
      ["string", "path to node"],
      ["string", "vector name, min, max, size or center"],
      ["string", "component_name, x,y or z"]
    ];
  }
  findDependency(args) {
    return this.createDependencyFromIndexOrPath(args);
  }
  async processArguments(args) {
    if (args.length >= 1) {
      const index_or_path = args[0];
      const vector_name = args[1];
      const component_name = args[2];
      const container = await this.getReferencedNodeContainer(index_or_path);
      if (container) {
        const value = this._get_value_from_container(container, vector_name, component_name);
        return value;
      }
    }
    return 0;
  }
  _get_value_from_container(container, vector_name, component_name) {
    const coreGroup = container.coreContent();
    if (coreGroup) {
      coreGroup.boundingBox(tmpBox);
    } else {
      tmpBox.makeEmpty();
    }
    if (!vector_name) {
      return tmpBox;
    }
    if (VECTOR_NAMES.indexOf(vector_name) >= 0) {
      let vector = new Vector3();
      switch (vector_name) {
        case "size":
          tmpBox.getSize(vector);
          break;
        case "center":
          tmpBox.getCenter(vector);
          break;
        default:
          vector = tmpBox[vector_name];
      }
      if (!component_name) {
        return vector;
      }
      if (COMPONENT_NAMES.indexOf(component_name) >= 0) {
        return vector[component_name];
      } else {
        return -1;
      }
    } else {
      return -1;
    }
  }
}
