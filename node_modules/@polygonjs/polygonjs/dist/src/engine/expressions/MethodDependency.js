"use strict";
import { CoreGraphNode } from "../../core/graph/CoreGraphNode";
import { CoreType } from "../../core/Type";
export class MethodDependency extends CoreGraphNode {
  constructor(param, pathArgs, decomposedPath) {
    var _a;
    super(param.scene(), "MethodDependency");
    this.param = param;
    this.pathArgs = pathArgs;
    this.decomposedPath = decomposedPath;
    this._updateFromNameChangeBound = this._updateFromNameChange.bind(this);
    (_a = param.expressionController) == null ? void 0 : _a.registerMethodDependency(this);
    this.addPostDirtyHook("_updateFromNameChange", this._updateFromNameChangeBound);
  }
  _updateFromNameChange(trigger) {
    if (trigger && this.decomposedPath) {
      const node = trigger;
      this.decomposedPath.updateFromNameChange(node);
      const new_path = this.decomposedPath.toPath();
      const literal = this.jsep_node;
      const { indexOrPath } = this.pathArgs;
      if (literal && CoreType.isString(indexOrPath)) {
        literal.value = `${literal.value}`.replace(`${indexOrPath}`, new_path);
        literal.raw = literal.raw.replace(`${indexOrPath}`, new_path);
      }
      if (this.param.expressionController) {
        this.param.expressionController.updateFromMethodDependencyNameChange();
      }
    }
  }
  reset() {
    this.graphDisconnectPredecessors();
  }
  listen_for_name_changes() {
    if (this.jsep_node && this.decomposedPath) {
      const nodes = [];
      this.decomposedPath.namedNodes(nodes);
      for (const nodeInPath of nodes) {
        if (nodeInPath) {
          const node = nodeInPath;
          if (node.nameController) {
            this.addGraphInput(node.nameController.graphNode());
          }
        }
      }
    }
  }
  set_jsep_node(jsep_node) {
    this.jsep_node = jsep_node;
  }
  set_resolved_graph_node(node) {
    this.resolved_graph_node = node;
  }
  set_unresolved_path(path) {
    this.unresolved_path = path;
  }
  static create(param, pathArgs, node, decomposedPath) {
    const instance = new MethodDependency(param, pathArgs, decomposedPath);
    if (node) {
      instance.set_resolved_graph_node(node);
    } else {
      const { indexOrPath } = pathArgs;
      if (CoreType.isString(indexOrPath)) {
        instance.set_unresolved_path(indexOrPath);
      }
    }
    return instance;
  }
}
