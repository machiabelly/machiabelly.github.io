"use strict";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TypedEventNode } from "./_Base";
import { TypeAssert } from "../../poly/Assert";
import { ParamType } from "../../poly/ParamType";
import { EventConnectionPoint, EventConnectionPointType } from "../utils/io/connections/Event";
import { Vector2 } from "three";
import { Vector3 } from "three";
import { Vector4 } from "three";
import { isBooleanTrue } from "../../../core/BooleanValue";
export var SetParamParamType = /* @__PURE__ */ ((SetParamParamType2) => {
  SetParamParamType2["BOOLEAN"] = "boolean";
  SetParamParamType2["BUTTON"] = "button";
  SetParamParamType2["NUMBER"] = "number";
  SetParamParamType2["VECTOR2"] = "vector2";
  SetParamParamType2["VECTOR3"] = "vector3";
  SetParamParamType2["VECTOR4"] = "vector4";
  SetParamParamType2["STRING"] = "string";
  return SetParamParamType2;
})(SetParamParamType || {});
const SET_PARAM_PARAM_TYPE = [
  "boolean" /* BOOLEAN */,
  "button" /* BUTTON */,
  "number" /* NUMBER */,
  "vector2" /* VECTOR2 */,
  "vector3" /* VECTOR3 */,
  "vector4" /* VECTOR4 */,
  "string" /* STRING */
];
const TYPE_BOOLEAN = SET_PARAM_PARAM_TYPE.indexOf("boolean" /* BOOLEAN */);
const TYPE_NUMBER = SET_PARAM_PARAM_TYPE.indexOf("number" /* NUMBER */);
const TYPE_VECTOR2 = SET_PARAM_PARAM_TYPE.indexOf("vector2" /* VECTOR2 */);
const TYPE_VECTOR3 = SET_PARAM_PARAM_TYPE.indexOf("vector3" /* VECTOR3 */);
const TYPE_VECTOR4 = SET_PARAM_PARAM_TYPE.indexOf("vector4" /* VECTOR4 */);
const TYPE_STRING = SET_PARAM_PARAM_TYPE.indexOf("string" /* STRING */);
function valueParamOptions() {
  return { cook: false };
}
const OUTPUT_NAME = "output";
class SetParamParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param the parameter to update */
    this.param = ParamConfig.PARAM_PATH("", {
      dependentOnFoundParam: false,
      paramSelection: true,
      computeOnDirty: true
    });
    // param = ParamConfig.STRING('display');
    /** @param type of the parameter to update */
    this.type = ParamConfig.INTEGER(TYPE_NUMBER, {
      menu: {
        entries: SET_PARAM_PARAM_TYPE.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param for a boolean parameter, sets to toggle its value */
    this.toggle = ParamConfig.BOOLEAN(0, {
      visibleIf: { type: TYPE_BOOLEAN }
    });
    /** @param if toggle is set to off, this will set the value of the parameter */
    this.boolean = ParamConfig.BOOLEAN(0, {
      visibleIf: {
        type: TYPE_BOOLEAN,
        toggle: 0
      },
      ...valueParamOptions()
    });
    /** @param param value for a float parameter */
    this.number = ParamConfig.FLOAT(0, {
      visibleIf: { type: TYPE_NUMBER },
      ...valueParamOptions()
    });
    /** @param param value for a vector2 parameter */
    this.vector2 = ParamConfig.VECTOR2([0, 0], {
      visibleIf: { type: TYPE_VECTOR2 },
      ...valueParamOptions()
    });
    /** @param param value for a vector3 parameter */
    this.vector3 = ParamConfig.VECTOR3([0, 0, 0], {
      visibleIf: { type: TYPE_VECTOR3 },
      ...valueParamOptions()
    });
    /** @param param value for a vector4 parameter */
    this.vector4 = ParamConfig.VECTOR4([0, 0, 0, 0], {
      visibleIf: { type: TYPE_VECTOR4 },
      ...valueParamOptions()
    });
    /** @param if on, the value will be incremented by the value, as opposed to be set to the value */
    this.increment = ParamConfig.BOOLEAN(0, {
      visibleIf: [{ type: TYPE_NUMBER }, { type: TYPE_VECTOR2 }, { type: TYPE_VECTOR3 }, { type: TYPE_VECTOR4 }],
      ...valueParamOptions()
    });
    /** @param param value for a string parameter */
    this.string = ParamConfig.STRING("", {
      visibleIf: { type: TYPE_STRING },
      ...valueParamOptions()
    });
    /** @param execute button to test the node */
    this.execute = ParamConfig.BUTTON(null, {
      callback: (node) => {
        SetParamEventNode.PARAM_CALLBACK_execute(node);
      }
    });
  }
}
const ParamsConfig = new SetParamParamsConfig();
export class SetParamEventNode extends TypedEventNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._tmp_vector2 = new Vector2();
    this._tmp_vector3 = new Vector3();
    this._tmp_vector4 = new Vector4();
    this._tmp_array2 = [0, 0];
    this._tmp_array3 = [0, 0, 0];
    this._tmp_array4 = [0, 0, 0, 0];
  }
  static type() {
    return "setParam";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new EventConnectionPoint("trigger", EventConnectionPointType.BASE)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new EventConnectionPoint(OUTPUT_NAME, EventConnectionPointType.BASE)
    ]);
  }
  setParamType(paramType) {
    const index = SET_PARAM_PARAM_TYPE.indexOf(paramType);
    this.p.type.set(index);
  }
  async processEvent(event_context) {
    if (this.p.param.isDirty()) {
      await this.p.param.compute();
    }
    const param = this.p.param.value.param();
    if (param) {
      const newValue = await this._newParamValue(param);
      if (newValue != null) {
        param.set(newValue);
      }
    } else {
      this.states.error.set("target param not found");
    }
    this.dispatchEventToOutput(OUTPUT_NAME, event_context);
  }
  async _newParamValue(param) {
    const type = SET_PARAM_PARAM_TYPE[this.pv.type];
    switch (type) {
      case "boolean" /* BOOLEAN */: {
        await this._computeParamsIfDirty([this.p.toggle]);
        if (isBooleanTrue(this.pv.toggle)) {
          return param.value ? 0 : 1;
        } else {
          return isBooleanTrue(this.pv.boolean) ? 1 : 0;
        }
      }
      case "button" /* BUTTON */: {
        return param.options.executeCallback();
      }
      case "number" /* NUMBER */: {
        await this._computeParamsIfDirty([this.p.increment, this.p.number]);
        if (isBooleanTrue(this.pv.increment)) {
          if (param.type() == ParamType.FLOAT) {
            return param.value + this.pv.number;
          } else {
            return param.value;
          }
        } else {
          return this.pv.number;
        }
      }
      case "vector2" /* VECTOR2 */: {
        await this._computeParamsIfDirty([this.p.increment, this.p.vector2]);
        if (isBooleanTrue(this.pv.increment)) {
          if (param.type() == ParamType.VECTOR2) {
            this._tmp_vector2.copy(param.value);
            this._tmp_vector2.add(this.pv.vector2);
            this._tmp_vector2.toArray(this._tmp_array2);
          } else {
            param.value.toArray(this._tmp_array2);
          }
        } else {
          this.pv.vector2.toArray(this._tmp_array2);
        }
        return this._tmp_array2;
      }
      case "vector3" /* VECTOR3 */: {
        await this._computeParamsIfDirty([this.p.increment, this.p.vector3]);
        if (isBooleanTrue(this.pv.increment)) {
          if (param.type() == ParamType.VECTOR3) {
            this._tmp_vector3.copy(param.value);
            this._tmp_vector3.add(this.pv.vector3);
            this._tmp_vector3.toArray(this._tmp_array3);
          } else {
            param.value.toArray(this._tmp_array3);
          }
        } else {
          this.pv.vector3.toArray(this._tmp_array3);
        }
        return this._tmp_array3;
      }
      case "vector4" /* VECTOR4 */: {
        await this._computeParamsIfDirty([this.p.increment, this.p.vector4]);
        if (isBooleanTrue(this.pv.increment)) {
          if (param.type() == ParamType.VECTOR4) {
            this._tmp_vector4.copy(param.value);
            this._tmp_vector4.add(this.pv.vector4);
            this._tmp_vector4.toArray(this._tmp_array4);
          } else {
            param.value.toArray(this._tmp_array4);
          }
        } else {
          this.pv.vector4.toArray(this._tmp_array4);
        }
        return this._tmp_array4;
      }
      case "string" /* STRING */: {
        await this._computeParamsIfDirty([this.p.string]);
        return this.pv.string;
      }
    }
    TypeAssert.unreachable(type);
  }
  static PARAM_CALLBACK_execute(node) {
    node.processEvent({});
  }
  async _computeParamsIfDirty(params) {
    const dirty_params = [];
    for (const param of params) {
      if (param.isDirty()) {
        dirty_params.push(param);
      }
    }
    const promises = [];
    for (const param of dirty_params) {
      promises.push(param.compute());
    }
    return await Promise.all(promises);
  }
}
