"use strict";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TypedEventNode } from "./_Base";
import { TypeAssert } from "../../poly/Assert";
import { EventConnectionPoint, EventConnectionPointType } from "../utils/io/connections/Event";
import { isBooleanTrue } from "../../../core/BooleanValue";
var FlagUpdateMode = /* @__PURE__ */ ((FlagUpdateMode2) => {
  FlagUpdateMode2["SET"] = "set";
  FlagUpdateMode2["TOGGLE"] = "toggle";
  return FlagUpdateMode2;
})(FlagUpdateMode || {});
const FLAG_UPDATE_MODES = ["set" /* SET */, "toggle" /* TOGGLE */];
class SetFlagParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param mask to select which nodes this can change the flags of */
    this.mask = ParamConfig.STRING("/geo*", { separatorAfter: true });
    /** @param toggle on to update the display flag */
    this.tdisplay = ParamConfig.BOOLEAN(0);
    /** @param sets how the display flag will be updated (set to a value or toggle) */
    this.displayMode = ParamConfig.INTEGER(FLAG_UPDATE_MODES.indexOf("set" /* SET */), {
      visibleIf: { tdisplay: 1 },
      menu: {
        entries: FLAG_UPDATE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param new display flag state */
    this.display = ParamConfig.BOOLEAN(0, {
      visibleIf: { tdisplay: 1, displayMode: FLAG_UPDATE_MODES.indexOf("set" /* SET */) },
      separatorAfter: true
    });
    /** @param toggle on to update the bypass flag */
    this.tbypass = ParamConfig.BOOLEAN(0);
    /** @param sets how the bypass flag will be updated (set to a value or toggle) */
    this.bypassMode = ParamConfig.INTEGER(FLAG_UPDATE_MODES.indexOf("set" /* SET */), {
      visibleIf: { tbypass: 1 },
      menu: {
        entries: FLAG_UPDATE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param new bypass flag state */
    this.bypass = ParamConfig.BOOLEAN(0, {
      visibleIf: { tbypass: 1, displayMode: FLAG_UPDATE_MODES.indexOf("set" /* SET */) }
    });
    /** @param button to trigger the node. Useful to debug */
    this.execute = ParamConfig.BUTTON(null, {
      callback: (node) => {
        SetFlagEventNode.PARAM_CALLBACK_execute(node);
      }
    });
  }
}
const ParamsConfig = new SetFlagParamsConfig();
export class SetFlagEventNode extends TypedEventNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "setFlag";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new EventConnectionPoint("trigger", EventConnectionPointType.BASE)
    ]);
  }
  async processEvent(eventContext) {
    let mask = this.pv.mask;
    if (eventContext.value) {
      const node = eventContext.value.node;
      if (node) {
        const parent = node.parent();
        if (parent) {
          mask = `${parent.path()}/${mask}`;
        }
      }
    }
    const nodes = this.scene().nodesController.nodesFromMask(mask);
    for (const node of nodes) {
      this._updateNodeFlags(node);
    }
  }
  _updateNodeFlags(node) {
    this._updateNodeDisplayFlag(node);
    this._updateNodeBypassFlag(node);
  }
  _updateNodeDisplayFlag(node) {
    var _a;
    if (!isBooleanTrue(this.pv.tdisplay)) {
      return;
    }
    if (!((_a = node.flags) == null ? void 0 : _a.hasDisplay())) {
      return;
    }
    const displayFlag = node.flags.display;
    if (!displayFlag) {
      return;
    }
    const mode = FLAG_UPDATE_MODES[this.pv.displayMode];
    switch (mode) {
      case "set" /* SET */: {
        displayFlag.set(isBooleanTrue(this.pv.display));
        return;
      }
      case "toggle" /* TOGGLE */: {
        displayFlag.set(!displayFlag.active());
        return;
      }
    }
    TypeAssert.unreachable(mode);
  }
  _updateNodeBypassFlag(node) {
    var _a;
    if (!isBooleanTrue(this.pv.tbypass)) {
      return;
    }
    if (!((_a = node.flags) == null ? void 0 : _a.hasBypass())) {
      return;
    }
    const bypassFlag = node.flags.bypass;
    if (!bypassFlag) {
      return;
    }
    const mode = FLAG_UPDATE_MODES[this.pv.bypassMode];
    switch (mode) {
      case "set" /* SET */: {
        bypassFlag.set(isBooleanTrue(this.pv.bypass));
        return;
      }
      case "toggle" /* TOGGLE */: {
        bypassFlag.set(!bypassFlag.active());
        return;
      }
    }
    TypeAssert.unreachable(mode);
  }
  static PARAM_CALLBACK_execute(node) {
    node.processEvent({});
  }
}
