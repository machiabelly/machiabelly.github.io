"use strict";
import { TypedEventNode } from "./_Base";
import { EventConnectionPoint, EventConnectionPointType } from "../utils/io/connections/Event";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CoreGraphNode } from "../../../core/graph/CoreGraphNode";
import { RampParam } from "../../params/Ramp";
function previousValueParamOptions() {
  return {
    cook: false,
    hidden: true
  };
}
class ParamEventParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param set to listen or stop listening to the param */
    this.active = ParamConfig.BOOLEAN(true);
    /** @param the parameter to update */
    this.param = ParamConfig.PARAM_PATH("", {
      dependentOnFoundParam: false,
      paramSelection: true,
      computeOnDirty: true
    });
    this.boolean = ParamConfig.BOOLEAN(0, previousValueParamOptions());
    this.integer = ParamConfig.INTEGER(0, previousValueParamOptions());
    this.float = ParamConfig.FLOAT(0, previousValueParamOptions());
    this.vector2 = ParamConfig.VECTOR2([0, 0], previousValueParamOptions());
    this.vector3 = ParamConfig.VECTOR3([0, 0, 0], previousValueParamOptions());
    this.vector4 = ParamConfig.VECTOR4([0, 0, 0, 0], previousValueParamOptions());
    this.ramp = ParamConfig.RAMP(RampParam.DEFAULT_VALUE, previousValueParamOptions());
    this.string = ParamConfig.STRING("", previousValueParamOptions());
  }
}
const ParamsConfig = new ParamEventParamsConfig();
const _ParamEventNode = class extends TypedEventNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._resolvedParam = null;
    this._previousValueParam = null;
    this._onParamDirtyBound = this._onParamDirty.bind(this);
  }
  static type() {
    return "param";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new EventConnectionPoint(_ParamEventNode.OUTPUT_NAME, EventConnectionPointType.BASE)
    ]);
  }
  async cook() {
    await this._listenToParam();
    this.cookController.endCook();
  }
  dispose() {
    super.dispose();
    this._reset();
  }
  _reset() {
    var _a;
    (_a = this.__paramCoreGraphNode__) == null ? void 0 : _a.graphRemove();
  }
  async _listenToParam() {
    var _a;
    if (!this.p.param) {
      return;
    }
    if (this._resolvedParam) {
      (_a = this.__paramCoreGraphNode__) == null ? void 0 : _a.removeGraphInput(this._resolvedParam);
      this._previousValueParam = null;
    }
    if (this.p.param.isDirty()) {
      await this.p.param.compute();
    }
    this._resolvedParam = this.p.param.value.param();
    if (this._resolvedParam) {
      const previousValueParams = [
        this.p.boolean,
        this.p.integer,
        this.p.float,
        this.p.vector2,
        this.p.vector3,
        this.p.vector4,
        this.p.ramp,
        this.p.string
      ];
      for (const p of previousValueParams) {
        if (p.type() == this._resolvedParam.type()) {
          this._previousValueParam = p;
          await this._resolvedParam.compute();
          this._previousValueParam.copyValue(this._resolvedParam);
        }
      }
      if (!this._previousValueParam) {
        this.states.error.set(
          `param type ${this._resolvedParam.type()} is not supported, availables are: ${previousValueParams.map((p) => p.type()).join(", ")}`
        );
      }
      this.paramGraphNode().addGraphInput(this._resolvedParam);
    }
  }
  paramGraphNode() {
    return this.__paramCoreGraphNode__ = this.__paramCoreGraphNode__ || this._createCoreGraphNode();
  }
  _createCoreGraphNode() {
    const node = new CoreGraphNode(this.scene(), "event/Param");
    node.dirtyController.addPostDirtyHook("onParamDirty", this._onParamDirtyBound);
    return node;
  }
  async _onParamDirty() {
    if (!(this._resolvedParam && this._previousValueParam)) {
      return;
    }
    await this._resolvedParam.compute();
    const valueChanged = !this._resolvedParam.isValueEqual(this._previousValueParam.value);
    if (valueChanged) {
      this._previousValueParam.copyValue(this._resolvedParam);
      this.dispatchEventToOutput(_ParamEventNode.OUTPUT_NAME, {});
    }
  }
};
export let ParamEventNode = _ParamEventNode;
ParamEventNode.OUTPUT_NAME = "valueChanged";
