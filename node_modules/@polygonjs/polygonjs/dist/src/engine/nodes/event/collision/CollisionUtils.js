"use strict";
import { NodeContext } from "../../../poly/NodeContext";
import { isBooleanTrue } from "../../../../core/BooleanValue";
import { Capsule } from "three/examples/jsm/math/Capsule";
import { Vector3 } from "three";
const gravity = new Vector3();
export async function setupCollision(controls, node) {
  var _a;
  if (isBooleanTrue(node.pv.collideWithGeo)) {
    const objNode = node.pv.collidingGeo.nodeWithContext(NodeContext.OBJ);
    if (objNode) {
      await objNode.compute();
      const displayNode = await ((_a = objNode.displayNodeController) == null ? void 0 : _a.displayNode());
      const container = await (displayNode == null ? void 0 : displayNode.compute());
      const coreGroup = container.coreContent();
      if (!coreGroup) {
        console.error("obj node contains invalid sop");
        return;
      }
      const object = coreGroup.threejsObjectsWithGeo()[0];
      controls.setCheckCollisions(object);
      controls.setCollisionCapsule(
        new Capsule(
          new Vector3(0, node.pv.playerRadius, 0),
          new Vector3(0, node.pv.playerHeight - 2 * node.pv.playerRadius, 0),
          node.pv.playerRadius
        )
      );
      controls.setJumpParams({
        force: node.pv.jumpForce,
        duration: node.pv.jumpDuration
      });
      gravity.copy(node.pv.gravity);
      if (!isBooleanTrue(node.pv.useGravity)) {
        gravity.multiplyScalar(0);
      }
      controls.setGravity(gravity);
      controls.setPlayerMass(node.pv.playerMass);
    }
  } else {
    controls.setCheckCollisions();
  }
}
