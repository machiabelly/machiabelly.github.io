"use strict";
import { Vector3 } from "three";
import { ParamType } from "../../../../poly/ParamType";
import { isBooleanTrue } from "../../../../../core/BooleanValue";
export var CPUIntersectWith = /* @__PURE__ */ ((CPUIntersectWith2) => {
  CPUIntersectWith2["GEOMETRY"] = "geometry";
  CPUIntersectWith2["PLANE"] = "plane";
  return CPUIntersectWith2;
})(CPUIntersectWith || {});
export const CPU_INTERSECT_WITH_OPTIONS = ["geometry" /* GEOMETRY */, "plane" /* PLANE */];
export class RaycastCPUVelocityController {
  constructor(_node) {
    this._node = _node;
    this._hitVelocity = new Vector3(0, 0, 0);
    this._hitVelocityArray = [0, 0, 0];
  }
  process(hitPosition) {
    var _a;
    if (!isBooleanTrue(this._node.pv.tvelocity)) {
      return;
    }
    if (!this._prevPosition) {
      this._prevPosition = this._prevPosition || new Vector3();
      this._prevPosition.copy(hitPosition);
      return;
    }
    const delta = this._node.scene().timeController.delta();
    this._hitVelocity.copy(hitPosition).sub(this._prevPosition).divideScalar(delta).multiplyScalar(1e3);
    this._hitVelocity.toArray(this._hitVelocityArray);
    if (isBooleanTrue(this._node.pv.tvelocityTarget)) {
      if (this._foundVelocityTargetParam == null || isBooleanTrue(this._foundVelocityTargetParam.disposed())) {
        const targetParam = this._node.pv.velocityTarget;
        this._foundVelocityTargetParam = targetParam.paramWithType(ParamType.VECTOR3);
      }
      (_a = this._foundVelocityTargetParam) == null ? void 0 : _a.set(this._hitVelocityArray);
    } else {
      this._node.p.velocity.set(this._hitVelocityArray);
    }
    this._prevPosition.copy(hitPosition);
  }
  reset() {
    this._prevPosition = void 0;
  }
}
