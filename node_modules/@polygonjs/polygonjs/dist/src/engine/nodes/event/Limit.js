"use strict";
import { TypedEventNode } from "./_Base";
import { EventConnectionPoint, EventConnectionPointType } from "../utils/io/connections/Event";
var LimitEventInput = /* @__PURE__ */ ((LimitEventInput2) => {
  LimitEventInput2["TRIGGER"] = "trigger";
  LimitEventInput2["RESET"] = "reset";
  return LimitEventInput2;
})(LimitEventInput || {});
var LimitEventOutput = /* @__PURE__ */ ((LimitEventOutput2) => {
  LimitEventOutput2["OUT"] = "out";
  LimitEventOutput2["LAST"] = "last";
  return LimitEventOutput2;
})(LimitEventOutput || {});
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
class LimitEventParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param max number of events that can be processed */
    this.maxCount = ParamConfig.INTEGER(5, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    /** @param resets the count */
    this.reset = ParamConfig.BUTTON(null, {
      callback: (node) => {
        LimitEventNode.PARAM_CALLBACK_reset(node);
      }
    });
  }
}
const ParamsConfig = new LimitEventParamsConfig();
export class LimitEventNode extends TypedEventNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._process_count = 0;
    this._last_dispatched = false;
  }
  static type() {
    return "limit";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new EventConnectionPoint(
        "trigger" /* TRIGGER */,
        EventConnectionPointType.BASE,
        this.processEventTrigger.bind(this)
      ),
      new EventConnectionPoint(
        "reset" /* RESET */,
        EventConnectionPointType.BASE,
        this.process_event_reset.bind(this)
      )
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new EventConnectionPoint("out" /* OUT */, EventConnectionPointType.BASE),
      new EventConnectionPoint("last" /* LAST */, EventConnectionPointType.BASE)
    ]);
  }
  processEvent(event_context) {
  }
  processEventTrigger(event_context) {
    if (this._process_count < this.pv.maxCount) {
      this._process_count += 1;
      this.dispatchEventToOutput("out" /* OUT */, event_context);
    } else {
      if (!this._last_dispatched) {
        this._last_dispatched = true;
        this.dispatchEventToOutput("last" /* LAST */, event_context);
      }
    }
  }
  process_event_reset(event_context) {
    this._process_count = 0;
    this._last_dispatched = false;
  }
  static PARAM_CALLBACK_reset(node) {
    node.process_event_reset({});
  }
}
