"use strict";
import { RGBADepthPacking, BasicDepthPacking } from "three";
import { ShaderLib } from "three";
import { ShaderAssemblerMaterial } from "../../_BaseMaterial";
import { ShaderName } from "../../../../../../utils/shaders/ShaderName";
import TemplateFragment from "../../../../templates/custom/mesh/CustomMeshDepth.frag.glsl";
import { MeshDepthMaterial } from "three";
import { includeSSSDeclarations } from "../../common/SSS";
import { INSERT_DEFINE_AFTER_MAPF_FOR_MESH } from "../../_BaseMesh";
const INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  [ShaderName.VERTEX, "#include <begin_vertex>"],
  [ShaderName.FRAGMENT, "#include <alphamap_fragment>"]
]);
export class ShaderAssemblerCustomMeshDepth extends ShaderAssemblerMaterial {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    this._addFilterFragmentShaderCallback("MeshStandardBuilderMatNode", includeSSSDeclarations);
  }
  templateShader() {
    const template = ShaderLib.depth;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: TemplateFragment,
      uniforms: template.uniforms
    };
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAPF_FOR_MESH.get(shaderName);
  }
  insertBodyAfter(shaderName) {
    return INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  depthPacking() {
    return RGBADepthPacking;
  }
  createMaterial() {
    const material = new MeshDepthMaterial({ depthPacking: this.depthPacking() });
    return material;
  }
}
export class ShaderAssemblerCustomMeshDepthForRender extends ShaderAssemblerCustomMeshDepth {
  depthPacking() {
    return BasicDepthPacking;
  }
}
