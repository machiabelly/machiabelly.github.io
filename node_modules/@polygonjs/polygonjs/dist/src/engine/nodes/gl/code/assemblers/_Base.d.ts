import { ShaderMaterial } from 'three';
import { LineType } from '../utils/LineType';
import { ShaderConfig } from '../configs/ShaderConfig';
import { VariableConfig } from '../configs/VariableConfig';
import { CodeBuilder, CodeBuilderSetCodeLinesOptions } from '../utils/CodeBuilder';
import { BaseGlNodeType } from '../../_Base';
import { TypedAssembler } from '../../../utils/shaders/BaseAssembler';
import { ShaderName } from '../../../utils/shaders/ShaderName';
import { OutputGlNode } from '../../Output';
import { GlConnectionPoint, GlConnectionPointType } from '../../../utils/io/connections/Gl';
import { GlobalsGlNode } from '../../Globals';
import { AttributeGlNode } from '../../Attribute';
import { AssemblerGlControllerNode } from '../Controller';
import { GlobalsBaseController } from '../globals/_Base';
import { ShadersCollectionController } from '../utils/ShadersCollectionController';
import { CustomMaterialName, IUniforms } from '../../../../../core/geometry/Material';
import { NodeContext } from '../../../../poly/NodeContext';
type StringArrayByShaderName = Map<ShaderName, string[]>;
interface ITemplateShader {
    vertexShader?: string;
    fragmentShader?: string;
    uniforms?: IUniforms;
}
export declare class BaseGlShaderAssembler extends TypedAssembler<NodeContext.GL> {
    protected _gl_parent_node: AssemblerGlControllerNode;
    protected _shaders_by_name: Map<ShaderName, string>;
    protected _lines: StringArrayByShaderName;
    protected _codeBuilder: CodeBuilder | undefined;
    private _param_config_owner;
    protected _root_nodes: BaseGlNodeType[];
    protected _leaf_nodes: BaseGlNodeType[];
    protected _material: ShaderMaterial | undefined;
    private _shader_configs;
    private _variable_configs;
    private _uniformsTimeDependent;
    private _uniformsResolutionDependent;
    constructor(_gl_parent_node: AssemblerGlControllerNode);
    protected _overriden_gl_parent_node: AssemblerGlControllerNode | undefined;
    setGlParentNode(gl_parent_node: AssemblerGlControllerNode): void;
    currentGlParentNode(): AssemblerGlControllerNode;
    compile(): void;
    protected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined;
    globalsHandler(): GlobalsBaseController | undefined;
    compileAllowed(): boolean;
    shaders_by_name(): Map<ShaderName, string>;
    protected _buildLines(): void;
    set_root_nodes(root_nodes: BaseGlNodeType[]): void;
    protected templateShader(): ITemplateShader | undefined;
    rootNodesByShaderName(shaderName: ShaderName, rootNodes: BaseGlNodeType[]): BaseGlNodeType[];
    set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
    set_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController): void;
    setNodeLinesAttribute(attribute_node: AttributeGlNode, shaders_collection_controller: ShadersCollectionController): void;
    codeBuilder(): CodeBuilder;
    protected _resetCodeBuilder(): void;
    private _createCodeBuilder;
    protected buildCodeFromNodes(rootNodes: BaseGlNodeType[], codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
    allow_new_param_configs(): void;
    disallow_new_param_configs(): void;
    builder_param_configs(): readonly import("../utils/GLParamConfig").GlParamConfig<import("../../../../index_all").ParamType>[];
    builder_lines(shader_name: ShaderName, line_type: LineType): string[];
    all_builder_lines(): Map<ShaderName, Map<LineType, string[]>>;
    param_configs(): readonly import("../utils/GLParamConfig").GlParamConfig<import("../../../../index_all").ParamType>[];
    set_param_configs_owner(param_config_owner: CodeBuilder): void;
    static output_input_connection_points(): GlConnectionPoint<GlConnectionPointType>[];
    add_output_inputs(output_child: OutputGlNode): void;
    static create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT> | GlConnectionPoint<GlConnectionPointType.MAT4> | GlConnectionPoint<GlConnectionPointType.MAT3>)[];
    create_globals_node_output_connections(): (GlConnectionPoint<GlConnectionPointType.VEC3> | GlConnectionPoint<GlConnectionPointType.VEC2> | GlConnectionPoint<GlConnectionPointType.VEC4> | GlConnectionPoint<GlConnectionPointType.FLOAT> | GlConnectionPoint<GlConnectionPointType.MAT4> | GlConnectionPoint<GlConnectionPointType.MAT3>)[];
    add_globals_outputs(globals_node: GlobalsGlNode): void;
    allow_attribute_exports(): boolean;
    reset_configs(): void;
    shaderConfigs(): ShaderConfig[];
    set_shader_configs(shader_configs: ShaderConfig[]): void;
    shaderNames(): ShaderName[];
    protected _reset_shader_configs(): void;
    create_shader_configs(): ShaderConfig[];
    shader_config(name: string): ShaderConfig | undefined;
    variable_configs(): VariableConfig[];
    set_variable_configs(variable_configs: VariableConfig[]): void;
    variable_config(name: string): VariableConfig;
    static create_variable_configs(): VariableConfig[];
    create_variable_configs(): VariableConfig[];
    protected _reset_variable_configs(): void;
    inputNamesForShaderName(root_node: BaseGlNodeType, shader_name: ShaderName): string[];
    protected _resetUniformsTimeDependency(): void;
    setUniformsTimeDependent(): void;
    uniformsTimeDependent(): boolean;
    protected _resetUniformsResolutionDependency(): void;
    setUniformsResolutionDependent(): void;
    uniformsResolutionDependent(): boolean;
    protected _raymarchingLightsWorldCoordsDependent(): boolean;
    protected insertDefineAfter(shaderName: ShaderName): string | undefined;
    protected insertBodyAfter(shaderName: ShaderName): string | undefined;
    protected linesToRemove(shaderName: ShaderName): string[] | undefined;
    private _replaceTemplate;
    private _insertLines;
    _addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
    _removeFilterFragmentShaderCallback(callbackName: string): void;
    getCustomMaterials(): Map<CustomMaterialName, ShaderMaterial>;
}
export {};
