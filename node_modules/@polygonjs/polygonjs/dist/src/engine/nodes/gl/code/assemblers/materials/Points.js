"use strict";
import { ShaderLib } from "three";
import { ShaderAssemblerMaterial } from "./_BaseMaterial";
import { ShaderConfig } from "../../configs/ShaderConfig";
import { VariableConfig } from "../../configs/VariableConfig";
import { BaseGlShaderAssembler } from "../_Base";
import { ShaderAssemblerCustomPointsDepth } from "./custom/points/CustomPointsDepth";
import { ShaderAssemblerCustomPointsDistance } from "./custom/points/CustomPointsDistance";
import { ShaderAssemblerCustomPointsDepthDOF } from "./custom/points/CustomPointsDepthDOF";
import { GlConnectionPointType, GlConnectionPoint } from "../../../../utils/io/connections/Gl";
import { ShaderName } from "../../../../utils/shaders/ShaderName";
import { VaryingWriteGlNode } from "../../../VaryingWrite";
import { PointsMaterial } from "three";
import { CustomMaterialName } from "../../../../../../core/geometry/Material";
import { GlobalsOutput } from "./common/GlobalOutput";
const LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([
  [ShaderName.VERTEX, ["#include <begin_vertex>", "gl_PointSize = size;"]],
  [ShaderName.FRAGMENT, []]
]);
const CUSTOM_ASSEMBLER_MAP = /* @__PURE__ */ new Map();
CUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DISTANCE, ShaderAssemblerCustomPointsDistance);
CUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DEPTH, ShaderAssemblerCustomPointsDepth);
CUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomPointsDepthDOF);
export class ShaderAssemblerPoints extends ShaderAssemblerMaterial {
  customAssemblerClassByCustomName() {
    return CUSTOM_ASSEMBLER_MAP;
  }
  templateShader() {
    const template = ShaderLib.points;
    return {
      vertexShader: template.vertexShader,
      fragmentShader: template.fragmentShader,
      uniforms: template.uniforms
    };
  }
  createMaterial() {
    const material = new PointsMaterial();
    this._addCustomMaterials(material);
    return material;
  }
  // protected insertBodyAfter(shader_name){
  // 	return {
  // 		vertex: 'gl_PointSize = size;',
  // 		fragment: 'vec4 diffuseColor = vec4( diffuse, opacity );'
  // 	}[shader_name]
  // }
  // those shadow shaders should ideally be overriden
  // to properly take into account point size
  add_output_inputs(output_child) {
    const list = BaseGlShaderAssembler.output_input_connection_points();
    list.push(new GlConnectionPoint(GlobalsOutput.GL_POINTSIZE, GlConnectionPointType.FLOAT));
    output_child.io.inputs.setNamedInputConnectionPoints(list);
  }
  create_globals_node_output_connections() {
    return BaseGlShaderAssembler.create_globals_node_output_connections().concat([
      new GlConnectionPoint(GlobalsOutput.GL_POINTCOORD, GlConnectionPointType.VEC2)
    ]);
  }
  create_shader_configs() {
    return [
      new ShaderConfig(
        ShaderName.VERTEX,
        ["position", "normal", "uv", GlobalsOutput.GL_POINTSIZE, VaryingWriteGlNode.INPUT_NAME],
        []
      ),
      new ShaderConfig(ShaderName.FRAGMENT, ["color", "alpha"], [ShaderName.VERTEX])
    ];
  }
  create_variable_configs() {
    return BaseGlShaderAssembler.create_variable_configs().concat([
      new VariableConfig(GlobalsOutput.GL_POINTSIZE, {
        default: "1.0",
        prefix: `${GlobalsOutput.GL_POINTSIZE} = `,
        suffix: " * size * 10.0"
        // currently using 10 as 1 seems really small
      })
    ]);
  }
  linesToRemove(shader_name) {
    return LINES_TO_REMOVE_MAP.get(shader_name);
  }
}
