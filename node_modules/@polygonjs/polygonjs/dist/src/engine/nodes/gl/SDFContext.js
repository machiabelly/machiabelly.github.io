"use strict";
import { SDFMaterialGlNode } from "./SDFMaterial";
import { GlType } from "./../../poly/registers/nodes/types/Gl";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
const INPUT_NAME = {
  SDF: "sdf",
  MATERIAL: "material"
};
const OUTPUT_NAME = GlType.SDF_CONTEXT;
class SDFContextGlParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SDFContextGlParamsConfig();
export class SDFContextGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return GlType.SDF_CONTEXT;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._glInputNames.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputNames.bind(this));
  }
  _expectedInputTypes() {
    return [GlConnectionPointType.FLOAT, GlConnectionPointType.SDF_MATERIAL];
  }
  _expectedOutputTypes() {
    return [GlConnectionPointType.SDF_CONTEXT];
  }
  _glInputNames(i) {
    return [INPUT_NAME.SDF, INPUT_NAME.MATERIAL][i];
  }
  _glOutputNames(i) {
    return [OUTPUT_NAME][i];
  }
  setLines(shaders_collection_controller) {
    const sdf = ThreeToGl.float(this.variableForInput(INPUT_NAME.SDF));
    const materialNode = this.io.inputs.input(1);
    let matId = -1;
    if (materialNode && materialNode instanceof SDFMaterialGlNode) {
      matId = materialNode.materialIdName();
    }
    const sdfContext = this.glVarName(OUTPUT_NAME);
    const body_line = `SDFContext ${sdfContext} = SDFContext(${sdf}, 0, ${matId}, ${matId}, 0.)`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
  }
}
