"use strict";
import { BaseShaderAssemblerRayMarchingRendered } from "./_BaseRayMarchingRendered";
import { BackSide, UniformsUtils, ShaderMaterial, ShaderLib } from "three";
import VERTEX from "../../../gl/raymarching/vert.glsl";
import FRAGMENT from "../../../gl/raymarching/frag.glsl";
import { RAYMARCHING_UNIFORMS } from "../../../gl/raymarching/uniforms";
import { CustomMaterialName } from "../../../../../../core/geometry/Material";
import { ShaderAssemblerRayMarchingDepth } from "./custom/raymarching/RayMarchingDepth";
import { ShaderAssemblerRayMarchingDistance } from "./custom/raymarching/RayMarchingDistance";
const ASSEMBLER_MAP = /* @__PURE__ */ new Map([]);
ASSEMBLER_MAP.set(CustomMaterialName.DEPTH, ShaderAssemblerRayMarchingDepth);
ASSEMBLER_MAP.set(CustomMaterialName.DISTANCE, ShaderAssemblerRayMarchingDistance);
export class ShaderAssemblerRayMarching extends BaseShaderAssemblerRayMarchingRendered {
  templateShader() {
    return {
      vertexShader: VERTEX,
      fragmentShader: FRAGMENT,
      uniforms: UniformsUtils.clone(RAYMARCHING_UNIFORMS)
    };
  }
  customAssemblerClassByCustomName() {
    return ASSEMBLER_MAP;
  }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: BackSide,
      transparent: true,
      depthTest: true,
      alphaTest: 0.5,
      lights: true,
      // defines: {
      // 	ENVMAP_TYPE_CUBE_UV: 0,
      // 	CUBEUV_TEXEL_WIDTH: ThreeToGl.float(0.1),
      // 	CUBEUV_TEXEL_HEIGHT: ThreeToGl.float(0.1),
      // 	CUBEUV_MAX_MIP: ThreeToGl.float(0),
      // },
      uniforms: {
        ...UniformsUtils.clone(ShaderLib.standard.uniforms),
        ...UniformsUtils.clone(templateShader.uniforms)
      }
    });
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    if (material.customMaterials) {
      const materialUniforms = material.uniforms;
      const customMaterials = material.customMaterials;
      const customNames = Object.keys(customMaterials);
      for (const customMaterialName of customNames) {
        const customMaterial = customMaterials[customMaterialName];
        if (customMaterial) {
          const uniforms = customMaterial.uniforms;
          uniforms.shadowDistanceMin = materialUniforms.shadowDistanceMin;
          uniforms.shadowDistanceMax = materialUniforms.shadowDistanceMax;
          uniforms.shadowDepthMin = materialUniforms.shadowDepthMin;
          uniforms.shadowDepthMax = materialUniforms.shadowDepthMax;
        }
      }
    }
    return material;
  }
}
