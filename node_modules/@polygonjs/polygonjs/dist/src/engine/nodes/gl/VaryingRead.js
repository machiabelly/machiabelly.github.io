"use strict";
import { TypedGlNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { ShaderName } from "../utils/shaders/ShaderName";
import { VaryingGLDefinition } from "./utils/GLDefinition";
import { GlType } from "../../poly/registers/nodes/types/Gl";
const VARYING_NODE_AVAILABLE_GL_TYPES = [
  GlConnectionPointType.FLOAT,
  GlConnectionPointType.VEC2,
  GlConnectionPointType.VEC3,
  GlConnectionPointType.VEC4
];
class VaryingReadGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.name = ParamConfig.STRING("");
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: VARYING_NODE_AVAILABLE_GL_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new VaryingReadGlParamsConfig();
const _VaryingReadGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return GlType.VARYING_READ;
  }
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompile.bind(this));
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_output_name_function(() => {
      return this.outputName();
    });
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [
      VARYING_NODE_AVAILABLE_GL_TYPES[this.pv.type]
    ]);
  }
  outputName() {
    return _VaryingReadGlNode.OUTPUT_NAME;
  }
  setLines(shaders_collection_controller) {
    if (shaders_collection_controller.currentShaderName() == ShaderName.FRAGMENT) {
      const varying_name = this.pv.name;
      const definition = new VaryingGLDefinition(this, this.glType(), varying_name);
      const out_value = this.glVarName(_VaryingReadGlNode.OUTPUT_NAME);
      const body_line = `${this.glType()} ${out_value} = ${varying_name}`;
      shaders_collection_controller.addDefinitions(this, [definition]);
      shaders_collection_controller.addBodyLines(this, [body_line]);
    }
  }
  attributeName() {
    return this.pv.name.trim();
  }
  glType() {
    const connectionPoints = this.io.outputs.namedOutputConnectionPoints();
    return connectionPoints ? connectionPoints[0].type() : GlConnectionPointType.FLOAT;
  }
  setGlType(type) {
    this.p.type.set(VARYING_NODE_AVAILABLE_GL_TYPES.indexOf(type));
  }
};
export let VaryingReadGlNode = _VaryingReadGlNode;
VaryingReadGlNode.OUTPUT_NAME = "fragment";
