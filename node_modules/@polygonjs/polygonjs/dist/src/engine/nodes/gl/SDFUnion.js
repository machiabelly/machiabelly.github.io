"use strict";
import { BaseSDFGlNode } from "./_BaseSDF";
import { ParamConfig } from "./../utils/params/ParamsConfig";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../../src/core/ThreeToGl";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { isBooleanTrue } from "../../../core/Type";
import { sdfSmoothLines } from "./utils/SDFSmoothUtils";
var InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  InputName2["SMOOTH_FACTOR"] = "smoothFactor";
  InputName2["MAT_BLEND_DIST"] = "matBlendDist";
  return InputName2;
})(InputName || {});
const OUTPUT_NAME = "union";
const ALLOWED_TYPES = [GlConnectionPointType.FLOAT, GlConnectionPointType.SDF_CONTEXT];
class SDFUnionGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.smooth = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new SDFUnionGlParamsConfig();
export class SDFUnionGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "SDFUnion";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["smooth"]);
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */, "smoothFactor" /* SMOOTH_FACTOR */, "matBlendDist" /* MAT_BLEND_DIST */][index];
  }
  _glOutputName(index) {
    return OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (!firstInputType || !ALLOWED_TYPES.includes(firstInputType)) {
      firstInputType = GlConnectionPointType.FLOAT;
    }
    return [firstInputType, firstInputType, GlConnectionPointType.FLOAT, GlConnectionPointType.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const smooth = isBooleanTrue(this.pv.smooth);
    const sdf0 = ThreeToGl.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl.float(this.variableForInput("sdf1" /* SDF1 */));
    const smoothFactor = ThreeToGl.float(this.variableForInput("smoothFactor" /* SMOOTH_FACTOR */));
    const firstInputType = this._expectedInputTypes()[0];
    const bodyLines = [];
    if (firstInputType == GlConnectionPointType.FLOAT) {
      const float = this.glVarName(OUTPUT_NAME);
      const withSmooth = `SDFSmoothUnion(${sdf0}, ${sdf1}, ${smoothFactor})`;
      const withoutSmooth = `SDFUnion(${sdf0}, ${sdf1})`;
      const functionCall = smooth ? withSmooth : withoutSmooth;
      const bodyLine = `float ${float} = ${functionCall}`;
      bodyLines.push(bodyLine);
    } else {
      const sdfContext = this.glVarName(OUTPUT_NAME);
      const matBlendDist = ThreeToGl.float(this.variableForInput("matBlendDist" /* MAT_BLEND_DIST */));
      sdfSmoothLines({
        node: this,
        vars: {
          sdf0,
          sdf1,
          sdfContext,
          smooth,
          matBlendDist,
          smoothFactor
        },
        functionNames: {
          smooth: "SDFSmoothUnion",
          default: "SDFUnion"
        },
        bodyLines
      });
    }
    shadersCollectionController.addBodyLines(this, bodyLines);
    BaseSDFGlNode.addSDFMethods(shadersCollectionController, this);
  }
}
