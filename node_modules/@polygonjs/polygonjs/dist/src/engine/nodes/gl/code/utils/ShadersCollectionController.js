"use strict";
import { LinesController } from "./LinesController";
export class ShadersCollectionController {
  constructor(_shaderNames, _currentShaderName, _assembler) {
    this._shaderNames = _shaderNames;
    this._currentShaderName = _currentShaderName;
    this._assembler = _assembler;
    this._linesControllerByShaderName = /* @__PURE__ */ new Map();
    for (const shaderName of this._shaderNames) {
      this._linesControllerByShaderName.set(shaderName, new LinesController(shaderName));
    }
  }
  // mergeDefinitions(shadersCollectionController: ShadersCollectionController) {
  // 	for (let shaderName of this._shaderNames) {
  // 		// this._linesControllerByShaderName.set(shaderName, new LinesController(shaderName));
  // 		shadersCollectionController.traverseDefinitions(shaderName, (definition: BaseGLDefinition) => {
  // 			this.addDefinitions(definition.node, [definition], shaderName);
  // 			console.log('add', definition.node, definition);
  // 		});
  // 	}
  // }
  assembler() {
    return this._assembler;
  }
  linesController(shaderName) {
    return this._linesControllerByShaderName.get(shaderName);
  }
  shaderNames() {
    return this._shaderNames;
  }
  setCurrentShaderName(shaderName) {
    this._currentShaderName = shaderName;
  }
  currentShaderName() {
    return this._currentShaderName;
  }
  addDefinitions(node, definitions, shaderName) {
    if (definitions.length == 0) {
      return;
    }
    shaderName = shaderName || this._currentShaderName;
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      linesController.addDefinitions(node, definitions);
    }
  }
  definitions(shaderName, node) {
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      return linesController.definitions(node);
    }
  }
  traverseDefinitions(shaderName, callback) {
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      linesController.traverseDefinitions(callback);
    }
  }
  // all_definition_nodes(shader_name: ShaderName, scene: PolyScene) {
  // 	return this._lines_controller_by_shader_name.get(shader_name)?.all_definition_nodes(scene) || [];
  // }
  addBodyLines(node, lines, shaderName, options) {
    if (lines.length == 0) {
      return;
    }
    shaderName = shaderName || this._currentShaderName;
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      linesController.addBodyLines(node, lines, options);
    }
  }
  bodyLines(shaderName, node) {
    const linesController = this._linesControllerByShaderName.get(shaderName);
    if (linesController) {
      return linesController.bodyLines(node);
    }
  }
  // traverseBodyLines(shaderName: ShaderName, callback: BodyLinesTraverseCallback) {
  // 	const lines_controller = this._linesControllerByShaderName.get(shaderName);
  // 	if (lines_controller) {
  // 		return lines_controller.traverseBodyLines(callback);
  // 	}
  // }
  // all_body_line_nodes(shader_name: ShaderName, scene: PolyScene) {
  // 	return this._lines_controller_by_shader_name.get(shader_name)?.all_body_line_nodes(scene) || [];
  // }
}
