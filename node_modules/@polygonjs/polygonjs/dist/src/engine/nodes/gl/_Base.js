"use strict";
import { TypedNode } from "../_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { NodeContext } from "../../poly/NodeContext";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { ParamsEditableStateController } from "../utils/io/ParamsEditableStateController";
const GL_VAR_NAME_PREFIX = "v_POLY";
export class TypedGlNode extends TypedNode {
  constructor() {
    super(...arguments);
    this._paramsEditableStatesController = new ParamsEditableStateController(this);
  }
  static context() {
    return NodeContext.GL;
  }
  initializeBaseNode() {
    this.uiData.setLayoutHorizontal();
    this.io.connections.initInputs();
    this.io.connection_points.spare_params.initializeNode();
    this._paramsEditableStatesController.initializeNode();
  }
  cook() {
    console.warn("gl node cooking");
  }
  _setMatToRecompile() {
    var _a, _b;
    (_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.setCompilationRequiredAndDirty(this);
  }
  materialNode() {
    const parent = this.parent();
    if (parent) {
      if (parent.context() == NodeContext.GL) {
        return parent == null ? void 0 : parent.materialNode();
      } else {
        return parent;
      }
    }
  }
  //
  //
  // VARIABLES
  //
  //
  glVarName(varName) {
    const nodes = [this];
    let currentNode = this;
    while (currentNode.parent() && currentNode.parent() != this.materialNode()) {
      const parent = currentNode.parent();
      if (parent) {
        nodes.unshift(parent);
        currentNode = parent;
      }
    }
    const baseGlVarNames = nodes.map((node) => node._glVarNameBase());
    return `${GL_VAR_NAME_PREFIX}_${baseGlVarNames.join("_")}_${varName}`;
  }
  _glVarNameBase() {
    return this.name();
  }
  variableForInputParam(param) {
    return this.variableForInput(param.name());
  }
  variableForInput(inputName) {
    var _a;
    const input_index = this.io.inputs.getInputIndex(inputName);
    const connection = this.io.connections.inputConnection(input_index);
    if (connection) {
      const input_node = connection.nodeSrc();
      const outputConnectionPoints = input_node.io.outputs.namedOutputConnectionPoints();
      if (outputConnectionPoints) {
        const output_connection_point = outputConnectionPoints[connection.outputIndex()];
        if (output_connection_point) {
          const output_name = output_connection_point.name();
          return input_node.glVarName(output_name);
        } else {
          console.warn(`no output called '${inputName}' for gl node ${input_node.path()}`);
          throw "variable_for_input ERROR";
        }
      }
    } else {
      if (this.params.has(inputName)) {
        return ThreeToGl.any((_a = this.params.get(inputName)) == null ? void 0 : _a.value);
      } else {
        const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
        if (inputConnectionPoints) {
          const connection_point = inputConnectionPoints[input_index];
          return ThreeToGl.any(connection_point.init_value);
        }
      }
    }
    throw "variable_for_input ERROR";
  }
  //
  //
  // ADDED LINES
  //
  //
  setLines(shaders_collection_controller) {
  }
  reset_code() {
    var _a;
    (_a = this._param_configs_controller) == null ? void 0 : _a.reset();
  }
  //
  //
  // PARAM CONFIGS
  //
  //
  setParamConfigs() {
  }
  param_configs() {
    var _a;
    return (_a = this._param_configs_controller) == null ? void 0 : _a.list();
  }
  paramsGenerating() {
    return false;
  }
  //
  //
  // INPUT
  //
  //
  paramDefaultValue(name) {
    return null;
  }
}
export class BaseGlNodeClass extends TypedGlNode {
}
class ParamlessGlParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new ParamlessGlParamsConfig();
export class ParamlessTypedGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
}
