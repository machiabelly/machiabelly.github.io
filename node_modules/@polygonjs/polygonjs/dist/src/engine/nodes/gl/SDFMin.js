"use strict";
import { BaseSDFGlNode } from "./_BaseSDF";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../../src/core/ThreeToGl";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
var InputName = /* @__PURE__ */ ((InputName2) => {
  InputName2["SDF0"] = "sdf0";
  InputName2["SDF1"] = "sdf1";
  return InputName2;
})(InputName || {});
const OUTPUT_NAME = "min";
const ALLOWED_TYPES = [GlConnectionPointType.FLOAT, GlConnectionPointType.SDF_CONTEXT];
class SDFMinGlParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SDFMinGlParamsConfig();
export class SDFMinGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "SDFMin";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_input_name_function(this._glInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._glOutputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _glInputName(index) {
    return ["sdf0" /* SDF0 */, "sdf1" /* SDF1 */][index];
  }
  _glOutputName(index) {
    return OUTPUT_NAME;
  }
  _expectedInputTypes() {
    let firstInputType = this.io.connection_points.first_input_connection_type();
    if (firstInputType && ALLOWED_TYPES.includes(firstInputType)) {
      return [firstInputType, firstInputType];
    }
    return [GlConnectionPointType.FLOAT, GlConnectionPointType.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const firstInputType = this._expectedInputTypes()[0];
    switch (firstInputType) {
      case GlConnectionPointType.FLOAT: {
        return this._setLinesFloat(shadersCollectionController);
      }
      case GlConnectionPointType.SDF_CONTEXT: {
        return this._setLinesSDFContext(shadersCollectionController);
      }
    }
  }
  _setLinesFloat(shadersCollectionController) {
    const sdf0 = ThreeToGl.float(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl.float(this.variableForInput("sdf1" /* SDF1 */));
    const float = this.glVarName(OUTPUT_NAME);
    const bodyLine = `float ${float} = min(${sdf0}, ${sdf1})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    BaseSDFGlNode.addSDFMethods(shadersCollectionController, this);
  }
  _setLinesSDFContext(shadersCollectionController) {
    const sdf0 = ThreeToGl.vector2(this.variableForInput("sdf0" /* SDF0 */));
    const sdf1 = ThreeToGl.vector2(this.variableForInput("sdf1" /* SDF1 */));
    const sdfContext = this.glVarName(OUTPUT_NAME);
    const side = this.glVarName("side");
    const setSide = `bool ${side} = ${sdf0}.d < ${sdf1}.d`;
    const matId = `${side} ? ${sdf0}.matId : ${sdf1}.matId`;
    const matId2 = `${side} ? ${sdf1}.matId : ${sdf0}.matId`;
    const bodyLines = [
      setSide,
      `SDFContext ${sdfContext} = SDFContext(min(${sdf0}.d, ${sdf1}.d), 0, ${matId}, ${matId2}, 0.)`
    ];
    shadersCollectionController.addBodyLines(this, bodyLines);
    BaseSDFGlNode.addSDFMethods(shadersCollectionController, this);
  }
}
