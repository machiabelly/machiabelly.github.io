"use strict";
import { GlobalsBaseController } from "./_Base";
import { GlobalsGeometryHandler } from "./Geometry";
import { ShaderName } from "../../../utils/shaders/ShaderName";
import { UniformGLDefinition, AttributeGLDefinition, VaryingGLDefinition } from "../../utils/GLDefinition";
import { GlConnectionPointType } from "../../../utils/io/connections/Gl";
import { TypeAssert } from "../../../../poly/Assert";
import { GlobalsBaseControllerType } from "./Common";
export var GlobalsTextureHandlerPurpose = /* @__PURE__ */ ((GlobalsTextureHandlerPurpose2) => {
  GlobalsTextureHandlerPurpose2["PARTICLES_SHADER"] = "particles_shader";
  GlobalsTextureHandlerPurpose2["MATERIAL"] = "material";
  return GlobalsTextureHandlerPurpose2;
})(GlobalsTextureHandlerPurpose || {});
const _GlobalsTextureHandler = class extends GlobalsBaseController {
  constructor(_uvName, _purpose) {
    super();
    this._uvName = _uvName;
    this._purpose = _purpose;
  }
  type() {
    return GlobalsBaseControllerType.TEXTURE;
  }
  set_texture_allocations_controller(controller) {
    this._textureAllocationsController = controller;
  }
  handleGlobalsNode(globals_node, output_name, shaders_collection_controller) {
    if (!this._textureAllocationsController) {
      return;
    }
    const connection_point = globals_node.io.outputs.namedOutputConnectionPointsByName(output_name);
    const var_name = globals_node.glVarName(output_name);
    const variable = this._textureAllocationsController.variable(output_name);
    if (variable && connection_point) {
      const gl_type = connection_point.type();
      const new_value = this.readAttribute(globals_node, gl_type, output_name, shaders_collection_controller);
      const body_line = `${gl_type} ${var_name} = ${new_value}`;
      shaders_collection_controller.addBodyLines(globals_node, [body_line]);
    } else {
      this._globalsGeometryHandler = this._globalsGeometryHandler || new GlobalsGeometryHandler();
      this._globalsGeometryHandler.handleGlobalsNode(globals_node, output_name, shaders_collection_controller);
    }
  }
  _textureVariableUsable(textureVariable) {
    switch (this._purpose) {
      case "particles_shader" /* PARTICLES_SHADER */: {
        return true;
      }
      case "material" /* MATERIAL */: {
        return !textureVariable.readonly();
      }
    }
    TypeAssert.unreachable(this._purpose);
  }
  attribTextureData(attribName) {
    if (!this._textureAllocationsController) {
      console.warn("no texture allocation controller");
      return;
    }
    const textureVariable = this._textureAllocationsController.variable(attribName);
    if (textureVariable && this._textureVariableUsable(textureVariable)) {
      const allocation = textureVariable.allocation();
      if (allocation) {
        const component = textureVariable.component();
        const attribTextureName = allocation.textureName();
        return {
          textureName: attribTextureName,
          component,
          uvName: this._uvName
        };
      }
    }
  }
  readAttribute(node, gl_type, attribName, shadersCollectionController) {
    if (!this._textureAllocationsController) {
      console.warn("no texture allocation controller");
      return;
    }
    const textureVariable = this._textureAllocationsController.variable(attribName);
    if (textureVariable && this._textureVariableUsable(textureVariable)) {
      this.addParticlesSimUvAttribute(node, shadersCollectionController);
      const textureData = this.attribTextureData(attribName);
      if (textureData) {
        const { textureName, component, uvName } = textureData;
        const texture_definition = new UniformGLDefinition(node, GlConnectionPointType.SAMPLER_2D, textureName);
        shadersCollectionController.addDefinitions(node, [texture_definition]);
        const body_line = `texture2D( ${textureName}, ${uvName} ).${component}`;
        return body_line;
      }
    } else {
      return GlobalsGeometryHandler.readAttribute(node, gl_type, attribName, shadersCollectionController);
    }
  }
  addParticlesSimUvAttribute(node, shaders_collection_controller) {
    const particlesSimUvAttribDefinition = new AttributeGLDefinition(
      node,
      GlConnectionPointType.VEC2,
      _GlobalsTextureHandler.PARTICLES_SIM_UV_ATTRIB
    );
    const particlesSimUvVaryingDefinition = new VaryingGLDefinition(
      node,
      GlConnectionPointType.VEC2,
      _GlobalsTextureHandler.UV_VARYING
    );
    shaders_collection_controller.addDefinitions(
      node,
      [particlesSimUvAttribDefinition, particlesSimUvVaryingDefinition],
      ShaderName.VERTEX
    );
    shaders_collection_controller.addDefinitions(node, [particlesSimUvVaryingDefinition], ShaderName.FRAGMENT);
    shaders_collection_controller.addBodyLines(
      node,
      [`${_GlobalsTextureHandler.UV_VARYING} = ${_GlobalsTextureHandler.PARTICLES_SIM_UV_ATTRIB}`],
      ShaderName.VERTEX
    );
  }
};
export let GlobalsTextureHandler = _GlobalsTextureHandler;
GlobalsTextureHandler.PARTICLES_SIM_UV_ATTRIB = "particlesSimUv";
GlobalsTextureHandler.UV_VARYING = "particlesSimUvVarying";
GlobalsTextureHandler.PARTICLE_SIM_UV = "particleUv";
