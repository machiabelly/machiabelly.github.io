"use strict";
import { GlType } from "./../../../../../poly/registers/nodes/types/Gl";
import { BackSide, UniformsUtils, ShaderMaterial, ShaderLib } from "three";
import { BaseShaderAssemblerRayMarchingAbstract } from "./_BaseRayMarchingAbstract";
import { ShaderName } from "../../../../utils/shaders/ShaderName";
import { GlConnectionPointType, GlConnectionPoint } from "../../../../utils/io/connections/Gl";
import { ShaderConfig } from "../../configs/ShaderConfig";
import { VariableConfig } from "../../configs/VariableConfig";
import VERTEX from "../../../gl/raymarching/vert.glsl";
import FRAGMENT from "../../../gl/raymarching/frag.glsl";
import { RAYMARCHING_UNIFORMS } from "../../../gl/raymarching/uniforms";
import { ShaderAssemblerRayMarchingApplyMaterial } from "./RayMarchingApplyMaterial";
const INSERT_BODY_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '// start builder body code'],
  [ShaderName.FRAGMENT, "// start GetDist builder body code"]
]);
const INSERT_DEFINE_AFTER_MAP = /* @__PURE__ */ new Map([
  // [ShaderName.VERTEX, '#include <common>'],
  [ShaderName.FRAGMENT, "// start raymarching builder define code"]
]);
const LINES_TO_REMOVE_MAP = /* @__PURE__ */ new Map([[ShaderName.FRAGMENT, []]]);
const SDF_CONTEXT_INPUT_NAME = GlConnectionPointType.SDF_CONTEXT;
export class BaseShaderAssemblerRayMarchingRendered extends BaseShaderAssemblerRayMarchingAbstract {
  constructor(_gl_parent_node) {
    super(_gl_parent_node);
    this._gl_parent_node = _gl_parent_node;
    //
    //
    //
    //
    //
    this._applyMaterialAssembler = new ShaderAssemblerRayMarchingApplyMaterial(this._gl_parent_node);
    this._applyMaterialMaterial = new ShaderMaterial();
    this._addFilterFragmentShaderCallback(
      "applyMaterialAssembler",
      (fragmentShader) => this.applyMaterialAssemblerFilterFragmentShader(fragmentShader)
    );
  }
  templateShader() {
    return {
      vertexShader: VERTEX,
      fragmentShader: FRAGMENT,
      uniforms: UniformsUtils.clone(RAYMARCHING_UNIFORMS)
    };
  }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: BackSide,
      transparent: true,
      depthTest: true,
      alphaTest: 0.5,
      lights: true,
      uniforms: {
        ...UniformsUtils.clone(ShaderLib.standard.uniforms),
        ...UniformsUtils.clone(templateShader.uniforms)
      }
    });
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    return material;
  }
  _raymarchingLightsWorldCoordsDependent() {
    return true;
  }
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new GlConnectionPoint(
        SDF_CONTEXT_INPUT_NAME,
        GlConnectionPointType.SDF_CONTEXT,
        "SDFContext(0.0, 0, 0, 0, 0.)"
      )
    ]);
  }
  static create_globals_node_output_connections() {
    return [
      new GlConnectionPoint("position", GlConnectionPointType.VEC3),
      new GlConnectionPoint("time", GlConnectionPointType.FLOAT),
      new GlConnectionPoint("cameraPosition", GlConnectionPointType.VEC3)
    ];
  }
  create_globals_node_output_connections() {
    return BaseShaderAssemblerRayMarchingRendered.create_globals_node_output_connections();
  }
  insertBodyAfter(shaderName) {
    return INSERT_BODY_AFTER_MAP.get(shaderName);
  }
  insertDefineAfter(shaderName) {
    return INSERT_DEFINE_AFTER_MAP.get(shaderName);
  }
  linesToRemove(shaderName) {
    return LINES_TO_REMOVE_MAP.get(shaderName);
  }
  create_shader_configs() {
    return [
      new ShaderConfig(ShaderName.VERTEX, [], []),
      new ShaderConfig(ShaderName.FRAGMENT, [
        /*'color', */
        SDF_CONTEXT_INPUT_NAME
      ], [ShaderName.VERTEX])
    ];
  }
  static create_variable_configs() {
    return [
      // new VariableConfig('position', {
      // 	// default_from_attribute: true,
      // 	// prefix: 'vec3 transformed = ',
      // }),
      // new VariableConfig('cameraPosition', {
      // 	// default_from_attribute: true,
      // 	// prefix: 'vec3 transformed = ',
      // }),
      // new VariableConfig('color', {
      // 	prefix: 'BUILDER_color.xyz = ',
      // }),
      new VariableConfig(SDF_CONTEXT_INPUT_NAME, {
        prefix: "sdfContext = "
      })
    ];
  }
  create_variable_configs() {
    return BaseShaderAssemblerRayMarchingRendered.create_variable_configs();
  }
  setGlParentNode(gl_parent_node) {
    super.setGlParentNode(gl_parent_node);
    this._applyMaterialAssembler.setGlParentNode(gl_parent_node);
  }
  compileMaterial(material) {
    this._applyMaterialAssembler.updateShaders();
    this._applyMaterialAssembler.prepareOnBeforeCompileData(this._applyMaterialMaterial);
    this.codeBuilder().nodeTraverser().setBlockedInputNames(GlType.SDF_CONTEXT, ["material"]);
    super.compileMaterial(material, {
      otherFragmentShaderCollectionController: this._applyMaterialAssembler.codeBuilder().shadersCollectionController()
    });
  }
  applyMaterialAssemblerFilterFragmentShader(fragmentShader) {
    var _a;
    const applyMaterial = (_a = this._applyMaterialAssembler.onBeforeCompileData()) == null ? void 0 : _a.fragmentShader;
    if (applyMaterial) {
      const elements = applyMaterial.split("// --- applyMaterial SPLIT ---");
      const applyMaterialFunctionDefinition = elements[1];
      fragmentShader = fragmentShader.replace(
        "// --- applyMaterial function definition",
        applyMaterialFunctionDefinition
      );
    }
    if (this._applyMaterialAssembler.uniformsTimeDependent()) {
      this.setUniformsTimeDependent();
    }
    if (this._applyMaterialAssembler.uniformsResolutionDependent()) {
      this.setUniformsResolutionDependent();
    }
    return fragmentShader;
  }
}
