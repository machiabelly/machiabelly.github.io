import { BaseGlShaderAssembler } from '../_Base';
import { OutputGlNode } from '../../../Output';
import { AttributeGlNode } from '../../../Attribute';
import { ShaderName } from '../../../../utils/shaders/ShaderName';
import { GlobalsGlNode } from '../../../Globals';
import { BaseGLDefinition } from '../../../utils/GLDefinition';
import { CustomMaterialName, MaterialWithCustomMaterials } from '../../../../../../core/geometry/Material';
import { ShadersCollectionController } from '../../utils/ShadersCollectionController';
import { Material } from 'three';
import { OnBeforeCompileData } from './OnBeforeCompile';
import { IUniformTexture } from '../../../../utils/code/gl/Uniforms';
import { CodeBuilderSetCodeLinesOptions } from '../../utils/CodeBuilder';
export type CustomAssemblerMap = Map<CustomMaterialName, typeof ShaderAssemblerMaterial>;
interface HandleGlobalsOutputOptions {
    globals_node: GlobalsGlNode;
    shaders_collection_controller: ShadersCollectionController;
    output_name: string;
    globals_shader_name: ShaderName;
    definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>;
    body_lines: string[];
    var_name: string;
    shader_name: ShaderName;
    dependencies: ShaderName[];
    body_lines_by_shader_name: Map<ShaderName, string[]>;
}
type CustomAssemblerCallback = (a: ShaderAssemblerMaterial, assemblerName: CustomMaterialName) => void;
export declare class ShaderAssemblerMaterial extends BaseGlShaderAssembler {
    private _assemblersByCustomName;
    createMaterial(): Material;
    customAssemblerClassByCustomName(): CustomAssemblerMap | undefined;
    traverseCustomAssemblers(callback: CustomAssemblerCallback): void;
    protected _addCustomMaterials(material: Material): void;
    private _addCustomMaterial;
    compileCustomMaterials(material: MaterialWithCustomMaterials, parentAssembler: ShaderAssemblerMaterial): void;
    private _filterFragmentShaderCallbacks;
    protected _resetFilterFragmentShaderCallbacks(): void;
    _addFilterFragmentShaderCallback(callbackName: string, callback: (s: string) => string): void;
    _removeFilterFragmentShaderCallback(callbackName: string): void;
    private _filterFragmentShaderMethodOwner;
    setFilterFragmentShaderMethodOwner(owner: ShaderAssemblerMaterial | undefined): void;
    filterFragmentShader(fragmentShader: string): string;
    processFilterFragmentShader(fragmentShader: string): string;
    private _onBeforeCompileData;
    onBeforeCompileData(): OnBeforeCompileData | undefined;
    private _additionalTextureUniforms;
    clearAdditionalTextureUniforms(): void;
    addAdditionalTextureUniforms(uniformName: string, uniform: IUniformTexture): void;
    private _setAdditionalTextureUniforms;
    compileMaterial(material: Material, codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
    prepareOnBeforeCompileData(material: Material): void;
    protected updateShaders(codeBuilderOptions?: CodeBuilderSetCodeLinesOptions): void;
    shadow_assembler_class_by_custom_name(): {};
    add_output_body_line(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController, input_name: string): void;
    set_node_lines_output(output_node: OutputGlNode, shadersCollectionController: ShadersCollectionController): void;
    setNodeLinesAttribute(attribute_node: AttributeGlNode, shadersCollectionController: ShadersCollectionController): void;
    handle_globals_output_name(options: HandleGlobalsOutputOptions): void;
    handleTime(options: HandleGlobalsOutputOptions): void;
    handle_resolution(options: HandleGlobalsOutputOptions): void;
    handle_mvPosition(options: HandleGlobalsOutputOptions): void;
    handle_gl_Position(options: HandleGlobalsOutputOptions): void;
    handle_gl_FragCoord(options: HandleGlobalsOutputOptions): void;
    handle_gl_PointCoord(options: HandleGlobalsOutputOptions): void;
    set_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController): void;
    private used_output_names_for_shader;
}
export {};
