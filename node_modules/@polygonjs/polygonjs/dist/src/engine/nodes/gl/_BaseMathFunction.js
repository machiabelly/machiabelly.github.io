"use strict";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { arrayCompact, rangeWithEnd } from "../../../core/ArrayUtils";
export class BaseGlMathFunctionParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new BaseGlMathFunctionParamsConfig();
export class BaseGlMathFunctionGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  gl_method_name() {
    return "";
  }
  gl_function_definitions() {
    return [];
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expected_input_types.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expected_output_types.bind(this));
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
  }
  _expected_input_types() {
    const type = this.io.connection_points.first_input_connection_type() || GlConnectionPointType.FLOAT;
    if (this.io.connections.firstInputConnection()) {
      const connections = this.io.connections.inputConnections();
      if (connections) {
        const compactConnections = [];
        arrayCompact(connections, compactConnections);
        let count = Math.max(compactConnections.length + 1, 2);
        return rangeWithEnd(count).map((i) => type);
      } else {
        return [];
      }
    } else {
      return rangeWithEnd(2).map((i) => type);
    }
  }
  _expected_output_types() {
    const type = this._expected_input_types()[0];
    return [type];
  }
  _gl_input_name(index) {
    return "in";
  }
  setLines(shaders_collection_controller) {
    const inputConnectionPoints = this.io.inputs.namedInputConnectionPoints();
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!(inputConnectionPoints && outputConnectionPoints)) {
      return;
    }
    const firstConnectionPoint = outputConnectionPoints[0];
    if (!firstConnectionPoint) {
      return;
    }
    const var_type = firstConnectionPoint.type();
    const args = inputConnectionPoints.map((connection, i) => {
      const name = connection.name();
      return ThreeToGl.any(this.variableForInput(name));
    });
    const joined_args = args.join(", ");
    const sum = this.glVarName(this.io.connection_points.output_name(0));
    const body_line = `${var_type} ${sum} = ${this.gl_method_name()}(${joined_args})`;
    shaders_collection_controller.addBodyLines(this, [body_line]);
    shaders_collection_controller.addDefinitions(this, this.gl_function_definitions());
  }
}
function inputTypeOrFloatExceptBool(inputType) {
  if (inputType == GlConnectionPointType.BOOL) {
    inputType = GlConnectionPointType.FLOAT;
  }
  const type = inputType || GlConnectionPointType.FLOAT;
  return type;
}
export class BaseNodeGlMathFunctionArg1GlNode extends BaseGlMathFunctionGlNode {
  _gl_input_name(index) {
    return "in";
  }
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type];
  }
}
export class BaseNodeGlMathFunctionArg2GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type];
  }
}
export class BaseNodeGlMathFunctionArg3GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type, type];
  }
}
export class BaseNodeGlMathFunctionArg4GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type, type, type];
  }
}
export class BaseNodeGlMathFunctionArg5GlNode extends BaseGlMathFunctionGlNode {
  _expected_input_types() {
    const type = inputTypeOrFloatExceptBool(this.io.connection_points.first_input_connection_type());
    return [type, type, type, type, type];
  }
}
