"use strict";
import { MapUtils } from "../../../../../core/MapUtils";
import { ShaderName } from "../../../utils/shaders/ShaderName";
import { GLDefinitionType } from "../../utils/GLDefinition";
import { TypedGLDefinitionCollection } from "../../utils/GLDefinitionCollection";
import { ParamConfigsController } from "../../../../nodes/utils/code/controllers/ParamConfigsController";
import { ShadersCollectionController } from "./ShadersCollectionController";
import { CodeFormatter } from "./CodeFormatter";
import { LineType } from "./LineType";
import { arrayUniq } from "../../../../../core/ArrayUtils";
export class CodeBuilder {
  // _function_declared: Map<ShaderName, Map<string, boolean>> = new Map();
  constructor(_nodeTraverser, _root_nodes_for_shader_method, _assembler) {
    this._nodeTraverser = _nodeTraverser;
    this._root_nodes_for_shader_method = _root_nodes_for_shader_method;
    this._assembler = _assembler;
    // private _id = (nextId += 1);
    this._param_configs_controller = new ParamConfigsController();
    this._param_configs_set_allowed = true;
    this._lines = /* @__PURE__ */ new Map();
  }
  nodeTraverser() {
    return this._nodeTraverser;
  }
  shaderNames() {
    return this._nodeTraverser.shaderNames();
  }
  buildFromNodes(rootNodes, paramNodes, setCodeLinesOptions) {
    this._nodeTraverser.traverse(rootNodes);
    const nodesByShaderName = /* @__PURE__ */ new Map();
    for (const shaderName of this.shaderNames()) {
      const nodes = this._nodeTraverser.nodesForShaderName(shaderName);
      nodesByShaderName.set(shaderName, nodes);
    }
    const sortedNodes = this._nodeTraverser.sortedNodes();
    for (const shaderName of this.shaderNames()) {
      const rootNodesForShader = this._root_nodes_for_shader_method(shaderName, rootNodes);
      for (const rootNode of rootNodesForShader) {
        MapUtils.pushOnArrayAtEntry(nodesByShaderName, shaderName, rootNode);
      }
    }
    const sorted_node_ids = /* @__PURE__ */ new Map();
    for (const node of sortedNodes) {
      sorted_node_ids.set(node.graphNodeId(), true);
    }
    for (const rootNode of rootNodes) {
      if (!sorted_node_ids.get(rootNode.graphNodeId())) {
        sortedNodes.push(rootNode);
        sorted_node_ids.set(rootNode.graphNodeId(), true);
      }
    }
    for (const node of sortedNodes) {
      node.reset_code();
    }
    for (const node of paramNodes) {
      node.reset_code();
    }
    this._shadersCollectionController = new ShadersCollectionController(
      this.shaderNames(),
      this.shaderNames()[0],
      this._assembler
    );
    this.reset();
    for (const shaderName of this.shaderNames()) {
      const nodes = [];
      const nonUniqNodes = nodesByShaderName.get(shaderName);
      if (nonUniqNodes) {
        arrayUniq(nonUniqNodes, nodes);
      }
      this._shadersCollectionController.setCurrentShaderName(shaderName);
      if (nodes) {
        for (const node of nodes) {
          node.setLines(this._shadersCollectionController);
        }
      }
    }
    if (this._param_configs_set_allowed) {
      for (const param_node of paramNodes) {
        try {
          param_node.states.error.clear();
          param_node.setParamConfigs();
        } catch (err) {
          const message = err.message || "failed to create spare param";
          param_node.states.error.set(message);
          throw new Error(`${param_node.name()} cannot create spare parameter`);
        }
      }
      this.setParamConfigs(paramNodes);
    }
    this._setCodeLines(sortedNodes, setCodeLinesOptions);
  }
  shadersCollectionController() {
    return this._shadersCollectionController;
  }
  disallow_new_param_configs() {
    this._param_configs_set_allowed = false;
  }
  allow_new_param_configs() {
    this._param_configs_set_allowed = true;
  }
  reset() {
    for (const shader_name of this.shaderNames()) {
      const lines_map = /* @__PURE__ */ new Map();
      this._lines.set(shader_name, lines_map);
    }
  }
  param_configs() {
    return this._param_configs_controller.list() || [];
  }
  lines(shader_name, line_type) {
    var _a;
    return ((_a = this._lines.get(shader_name)) == null ? void 0 : _a.get(line_type)) || [];
  }
  all_lines() {
    return this._lines;
  }
  setParamConfigs(nodes) {
    this._param_configs_controller.reset();
    for (const node of nodes) {
      const param_configs = node.param_configs();
      if (param_configs) {
        for (const param_config of param_configs) {
          this._param_configs_controller.push(param_config);
        }
      }
    }
  }
  _setCodeLines(nodes, options) {
    for (const shaderName of this.shaderNames()) {
      const additionalDefinitions = [];
      if (shaderName == ShaderName.FRAGMENT) {
        if (this._shadersCollectionController && options && options.otherFragmentShaderCollectionController) {
          options.otherFragmentShaderCollectionController.traverseDefinitions(
            ShaderName.FRAGMENT,
            (definition) => {
              additionalDefinitions.push(definition);
            }
          );
        }
      }
      this._addCodeLines(nodes, shaderName, additionalDefinitions);
    }
  }
  _addCodeLines(nodes, shaderName, additionalDefinitions) {
    this.addDefinitions(nodes, shaderName, GLDefinitionType.PRECISION, LineType.DEFINE, additionalDefinitions);
    this.addDefinitions(
      nodes,
      shaderName,
      GLDefinitionType.FUNCTION,
      LineType.FUNCTION_DECLARATION,
      additionalDefinitions
    );
    this.addDefinitions(nodes, shaderName, GLDefinitionType.UNIFORM, LineType.DEFINE, additionalDefinitions);
    this.addDefinitions(nodes, shaderName, GLDefinitionType.VARYING, LineType.DEFINE, additionalDefinitions);
    this.addDefinitions(nodes, shaderName, GLDefinitionType.ATTRIBUTE, LineType.DEFINE, additionalDefinitions);
    this.add_code_line_for_nodes_and_line_type(nodes, shaderName, LineType.BODY);
  }
  addDefinitions(nodes, shaderName, definitionType, lineType, additionalDefinitions) {
    if (!this._shadersCollectionController) {
      return;
    }
    const definitions = [];
    for (const node of nodes) {
      let nodeDefinitions = this._shadersCollectionController.definitions(shaderName, node);
      if (nodeDefinitions) {
        nodeDefinitions = nodeDefinitions.filter((d) => d.definition_type == definitionType);
        for (const definition of nodeDefinitions) {
          definitions.push(definition);
        }
      }
    }
    if (additionalDefinitions) {
      const filteredAdditionalDefinitions = additionalDefinitions.filter(
        (d) => d.definition_type == definitionType
      );
      for (const definition of filteredAdditionalDefinitions) {
        definitions.push(definition);
      }
    }
    if (definitions.length > 0) {
      const collection = new TypedGLDefinitionCollection(definitions);
      const uniqDefinitions = collection.uniq();
      if (collection.errored) {
        throw `code builder error: ${collection.error_message}`;
      }
      const definitions_by_node_id = /* @__PURE__ */ new Map();
      const nodeIds = /* @__PURE__ */ new Map();
      for (const definition of uniqDefinitions) {
        const nodeId = definition.node.graphNodeId();
        if (!nodeIds.has(nodeId)) {
          nodeIds.set(nodeId, true);
        }
        MapUtils.pushOnArrayAtEntry(definitions_by_node_id, nodeId, definition);
      }
      const lines_for_shader = this._lines.get(shaderName);
      nodeIds.forEach((_, nodeId) => {
        const definitions2 = definitions_by_node_id.get(nodeId);
        if (definitions2) {
          const first_definition = definitions2[0];
          if (first_definition) {
            const comment = CodeFormatter.nodeComment(first_definition.node, lineType);
            MapUtils.pushOnArrayAtEntry(lines_for_shader, lineType, comment);
            for (const definition of definitions2) {
              const line = CodeFormatter.lineWrap(first_definition.node, definition.line, lineType);
              MapUtils.pushOnArrayAtEntry(lines_for_shader, lineType, line);
            }
            const separator = CodeFormatter.post_line_separator(lineType);
            MapUtils.pushOnArrayAtEntry(lines_for_shader, lineType, separator);
          }
        }
      });
    }
  }
  add_code_line_for_nodes_and_line_type(nodes, shader_name, line_type) {
    nodes = nodes.filter((node) => {
      if (this._shadersCollectionController) {
        const lines = this._shadersCollectionController.bodyLines(shader_name, node);
        return lines && lines.length > 0;
      }
    });
    var nodes_count = nodes.length;
    for (let i = 0; i < nodes_count; i++) {
      const is_last = i == nodes.length - 1;
      this.add_code_line_for_node_and_line_type(nodes[i], shader_name, line_type, is_last);
    }
  }
  add_code_line_for_node_and_line_type(node, shader_name, line_type, is_last) {
    if (!this._shadersCollectionController) {
      return;
    }
    const lines = this._shadersCollectionController.bodyLines(shader_name, node);
    if (lines && lines.length > 0) {
      const lines_for_shader = this._lines.get(shader_name);
      const comment = CodeFormatter.nodeComment(node, line_type);
      MapUtils.pushOnArrayAtEntry(lines_for_shader, line_type, comment);
      lines.forEach((line) => {
        line = CodeFormatter.lineWrap(node, line, line_type);
        MapUtils.pushOnArrayAtEntry(lines_for_shader, line_type, line);
      });
      if (!(line_type == LineType.BODY && is_last)) {
        const separator = CodeFormatter.post_line_separator(line_type);
        MapUtils.pushOnArrayAtEntry(lines_for_shader, line_type, separator);
      }
    }
  }
}
