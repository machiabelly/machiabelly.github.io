"use strict";
import { BaseShaderAssemblerRayMarchingRendered } from "../../_BaseRayMarchingRendered";
import { FrontSide, UniformsUtils, ShaderMaterial, ShaderLib, BasicDepthPacking } from "three";
import VERTEX from "../../../../../gl/raymarching/vert.glsl";
import FRAGMENT from "../../../../../gl/raymarching/frag.glsl";
import { RAYMARCHING_UNIFORMS } from "../../../../../gl/raymarching/uniforms";
export class ShaderAssemblerRayMarchingDepth extends BaseShaderAssemblerRayMarchingRendered {
  templateShader() {
    return {
      vertexShader: VERTEX,
      fragmentShader: FRAGMENT,
      uniforms: UniformsUtils.clone(RAYMARCHING_UNIFORMS)
    };
  }
  // override customAssemblerClassByCustomName() {
  // 	return ASSEMBLER_MAP;
  // }
  createMaterial() {
    const templateShader = this.templateShader();
    const material = new ShaderMaterial({
      vertexShader: templateShader.vertexShader,
      fragmentShader: templateShader.fragmentShader,
      side: FrontSide,
      transparent: false,
      // important
      depthWrite: true,
      depthTest: true,
      // stencilWrite: false,
      alphaTest: 0.5,
      lights: false,
      defines: {
        SHADOW_DEPTH: 1,
        DEPTH_PACKING: BasicDepthPacking
      },
      uniforms: {
        ...UniformsUtils.clone(ShaderLib.standard.uniforms),
        ...UniformsUtils.clone(templateShader.uniforms)
      }
    });
    material.depthPacking = BasicDepthPacking;
    this._gl_parent_node.scene().sceneTraverser.addLightsRayMarchingUniform(material.uniforms);
    this._addCustomMaterials(material);
    return material;
  }
}
