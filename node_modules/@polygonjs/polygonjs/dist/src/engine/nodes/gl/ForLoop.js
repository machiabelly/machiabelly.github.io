"use strict";
import { TypedSubnetGlNode, TypedSubnetGlParamsConfigMixin } from "./Subnet";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { ThreeToGl } from "../../../core/ThreeToGl";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { isBooleanTrue } from "../../../core/Type";
import { GlType } from "../../poly/registers/nodes/types/Gl";
var ForLoopInput = /* @__PURE__ */ ((ForLoopInput2) => {
  ForLoopInput2["START"] = "start";
  ForLoopInput2["MAX"] = "max";
  ForLoopInput2["STEP"] = "step";
  ForLoopInput2["I"] = "i";
  return ForLoopInput2;
})(ForLoopInput || {});
const DEFAULT_VALUES = {
  ["start" /* START */]: 0,
  ["max" /* MAX */]: 10,
  ["step" /* STEP */]: 1
};
const OFFSET = 0;
class ForLoopGlParamsConfig extends TypedSubnetGlParamsConfigMixin(NodeParamsConfig) {
  constructor() {
    super(...arguments);
    this.start = ParamConfig.FLOAT(0);
    this.max = ParamConfig.FLOAT(10, {
      range: [0, 100],
      rangeLocked: [false, false]
    });
    this.step = ParamConfig.FLOAT(1);
    this.asFloat = ParamConfig.BOOLEAN(0, {
      separatorAfter: true,
      // hide the param until I can find a way for the subnet outputs
      // to change type when asFloat is true
      hidden: true
    });
  }
}
const ParamsConfig = new ForLoopGlParamsConfig();
export class ForLoopGlNode extends TypedSubnetGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return GlType.FOR_LOOP;
  }
  paramDefaultValue(name) {
    return DEFAULT_VALUES[name];
  }
  childExpectedInputConnectionPointTypes() {
    const { glType } = this._typesData();
    const forLoopInputTypes = [glType, glType, glType, glType];
    return forLoopInputTypes.concat(super._expectedInputTypes());
  }
  childExpectedInputConnectionPointName(index) {
    const forLoopInputNames = ["start", "end", "step", "i"];
    if (index <= 3) {
      return forLoopInputNames[index];
    } else {
      return super._expectedInputName(index - 4);
    }
  }
  // protected override _expectedInputsCount() {
  // 	const current_connections = this.io.connections.inputConnections();
  // 	return current_connections ? ArrayUtils.compact(current_connections).length + 1 : 1;
  // }
  // protected override _expectedInputTypes(): GlConnectionPointType[] {
  // 	const types: GlConnectionPointType[] = [
  // 		// GlConnectionPointType.FLOAT,
  // 		// GlConnectionPointType.FLOAT,
  // 		// GlConnectionPointType.FLOAT,
  // 	];
  // 	const default_type = GlConnectionPointType.FLOAT;
  // 	const current_connections = this.io.connections.inputConnections();
  // 	const expected_count = this._expectedInputsCount();
  // 	for (let i = OFFSET; i < expected_count; i++) {
  // 		if (current_connections) {
  // 			const connection = current_connections[i];
  // 			if (connection) {
  // 				const type = connection.src_connection_point().type();
  // 				types.push(type);
  // 			} else {
  // 				types.push(default_type);
  // 			}
  // 		} else {
  // 			types.push(default_type);
  // 		}
  // 	}
  // 	return types;
  // }
  // protected override _expectedOutputTypes() {
  // 	const types: GlConnectionPointType[] = [];
  // 	const input_types = this._expectedInputTypes();
  // 	for (let i = OFFSET; i < input_types.length; i++) {
  // 		types.push(input_types[i]);
  // 	}
  // 	return types;
  // }
  // protected override _expectedInputName(index: number) {
  // 	// switch (index) {
  // 	// 	case 0:
  // 	// 		return ForLoopInput.START_INDEX;
  // 	// 	case 1:
  // 	// 		return ForLoopInput.MAX;
  // 	// 	case 2:
  // 	// 		return ForLoopInput.STEP;
  // 	// 	default: {
  // 	const connection = this.io.connections.inputConnection(index);
  // 	if (connection) {
  // 		const name = connection.src_connection_point().name();
  // 		return name;
  // 	} else {
  // 		return `in${index}`;
  // 	}
  // 	// }
  // 	// }
  // }
  // protected override _expectedOutputName(index: number) {
  // 	return this._expectedInputName(index + OFFSET);
  // }
  //
  //
  // set_lines
  //
  //
  setLinesBlockStart(shaders_collection_controller) {
    const body_lines = [];
    const start = this.pv.start;
    const max = this.pv.max;
    const step = this.pv.step;
    const { glType, convertMethod } = this._typesData();
    const start_str = convertMethod(start);
    const max_str = convertMethod(max);
    const step_str = convertMethod(step);
    const iterator_name = this.glVarName("i" /* I */);
    const open_for_loop_line = `for(${glType} ${iterator_name} = ${start_str}; ${iterator_name} < ${max_str}; ${iterator_name}+= ${step_str}){`;
    body_lines.push(open_for_loop_line);
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
  setSubnetInputLines(shadersCollectionController, childNode) {
    const { glType, convertMethod } = this._typesData();
    const body_lines = [];
    const iterator_name = this.glVarName("i" /* I */);
    const i = childNode.glVarName("i" /* I */);
    body_lines.push(`	${glType} ${i} = ${iterator_name}`);
    const start = childNode.glVarName("start" /* START */);
    body_lines.push(`	${glType} ${start} = ${convertMethod(this.pv.start)}`);
    const max = childNode.glVarName("max" /* MAX */);
    body_lines.push(`	${glType} ${max} = ${convertMethod(this.pv.max)}`);
    const step = childNode.glVarName("step" /* STEP */);
    body_lines.push(`	${glType} ${step} = ${convertMethod(this.pv.step)}`);
    const connections = this.io.connections.inputConnections();
    if (connections) {
      for (const connection of connections) {
        if (connection) {
          if (connection.inputIndex() >= OFFSET) {
            const connection_point = connection.destConnectionPoint();
            if (connection_point) {
              const in_value = this.glVarName(connection_point.name());
              const gl_type = connection_point.type();
              const out = childNode.glVarName(connection_point.name());
              const body_line = `	${gl_type} ${out} = ${in_value}`;
              body_lines.push(body_line);
            }
          }
        }
      }
    }
    shadersCollectionController.addBodyLines(childNode, body_lines);
  }
  _typesData() {
    const asFloat = isBooleanTrue(this.pv.asFloat);
    const convertMethod = asFloat ? ThreeToGl.float : ThreeToGl.integer;
    const glType = asFloat ? GlConnectionPointType.FLOAT : GlConnectionPointType.INT;
    return { convertMethod, glType };
  }
  // override setLines(shaders_collection_controller: ShadersCollectionController) {}
}
