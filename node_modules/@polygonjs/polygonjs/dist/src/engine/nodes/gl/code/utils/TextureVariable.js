"use strict";
export class TextureVariable {
  constructor(_name, _size) {
    this._name = _name;
    this._size = _size;
    this._position = -1;
    this._readonly = false;
    if (!_name) {
      throw "TextureVariable requires a name";
    }
  }
  merge(variable) {
    var _a;
    if (!variable.readonly()) {
      this.setReadonly(false);
    }
    (_a = variable.graphNodeIds()) == null ? void 0 : _a.forEach((graphNodeId) => {
      this.addGraphNodeId(graphNodeId);
    });
  }
  setReadonly(state) {
    this._readonly = state;
  }
  readonly() {
    return this._readonly;
  }
  setAllocation(allocation) {
    this._allocation = allocation;
  }
  allocation() {
    return this._allocation;
  }
  graphNodeIds() {
    return this._graphNodeIds;
  }
  addGraphNodeId(id) {
    this._graphNodeIds = this._graphNodeIds || /* @__PURE__ */ new Set();
    this._graphNodeIds.add(id);
  }
  name() {
    return this._name;
  }
  size() {
    return this._size;
  }
  setPosition(position) {
    this._position = position;
  }
  position() {
    return this._position;
  }
  component() {
    return "xyzw".split("").splice(this._position, this._size).join("");
  }
  static fromJSON(data) {
    return new TextureVariable(data.name, data.size);
  }
  toJSON(scene) {
    const names = [];
    if (this._graphNodeIds) {
      this._graphNodeIds.forEach((graphNodeId) => {
        const node = scene.graph.nodeFromId(graphNodeId);
        if (node) {
          const name = node.path();
          if (name) {
            names.push(name);
          }
        }
      });
    }
    return {
      name: this.name(),
      size: this.size(),
      nodes: names
    };
  }
}
