"use strict";
import { TypedGlNode } from "./_Base";
import Quaternion from "./gl/quaternion.glsl";
import { FunctionGLDefinition } from "./utils/GLDefinition";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
import { ParamConfig, NodeParamsConfig } from "../utils/params/ParamsConfig";
import { ThreeToGl } from "../../../core/ThreeToGl";
export var GlRotateMode = /* @__PURE__ */ ((GlRotateMode2) => {
  GlRotateMode2[GlRotateMode2["AXIS"] = 0] = "AXIS";
  GlRotateMode2[GlRotateMode2["QUAT"] = 1] = "QUAT";
  return GlRotateMode2;
})(GlRotateMode || {});
const Modes = [0 /* AXIS */, 1 /* QUAT */];
const LabelByMode = {
  [0 /* AXIS */]: "from axis + angle",
  [1 /* QUAT */]: "from quaternion"
};
const InputNamesByMode = {
  [0 /* AXIS */]: ["vector", "axis", "angle"],
  [1 /* QUAT */]: ["vector", "quat"]
};
const MethodNameByMode = {
  [0 /* AXIS */]: "rotateWithAxisAngle",
  [1 /* QUAT */]: "rotateWithQuat"
};
const InputTypesByMode = {
  [0 /* AXIS */]: [GlConnectionPointType.VEC3, GlConnectionPointType.VEC3, GlConnectionPointType.FLOAT],
  [1 /* QUAT */]: [GlConnectionPointType.VEC3, GlConnectionPointType.VEC4]
};
const DefaultValues = {
  vector: [0, 0, 1],
  axis: [0, 1, 0]
};
class RotateParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.signature = ParamConfig.INTEGER(0 /* AXIS */, {
      menu: {
        entries: Modes.map((mode, i) => {
          const label = LabelByMode[mode];
          return { name: label, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new RotateParamsConfig();
export class RotateGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "rotate";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
  }
  setSignature(mode) {
    const index = Modes.indexOf(mode);
    this.p.signature.set(index);
  }
  mode() {
    return Modes[this.pv.signature] || 0 /* AXIS */;
  }
  _expectedInputName(index) {
    return InputNamesByMode[this.mode()][index];
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  functionName() {
    return MethodNameByMode[this.mode()];
  }
  _expectedInputTypes() {
    return InputTypesByMode[this.mode()];
  }
  _expectedOutputTypes() {
    return [GlConnectionPointType.VEC3];
  }
  functionDefinitions() {
    return [new FunctionGLDefinition(this, Quaternion)];
  }
  setLines(shadersCollectionController) {
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const varType = this._expectedInputTypes()[0];
    const args = connectionPoints.map((connection, i) => {
      const name = connection.name();
      return ThreeToGl.any(this.variableForInput(name));
    });
    const joinedArgs = args.join(", ");
    const sum = this.glVarName(this.io.connection_points.output_name(0));
    const bodyLine = `${varType} ${sum} = ${this.functionName()}(${joinedArgs})`;
    shadersCollectionController.addBodyLines(this, [bodyLine]);
    shadersCollectionController.addDefinitions(this, this.functionDefinitions());
  }
}
