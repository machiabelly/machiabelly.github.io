"use strict";
import { BaseGlShaderAssembler } from "../_Base";
import { ThreeToGl } from "../../../../../../core/ThreeToGl";
import TemplateDefault from "../../templates/textures/Default.frag.glsl";
import { ShaderConfig } from "../../configs/ShaderConfig";
import { VariableConfig } from "../../configs/VariableConfig";
import { ShaderName } from "../../../../utils/shaders/ShaderName";
import { GlConnectionPointType, GlConnectionPoint } from "../../../../utils/io/connections/Gl";
import { UniformGLDefinition } from "../../../utils/GLDefinition";
import { handleCopBuilderDependencies } from "../../../../cop/utils/BuilderUtils";
export class ShaderAssemblerTexture extends BaseGlShaderAssembler {
  templateShader() {
    return {
      fragmentShader: TemplateDefault,
      vertexShader: void 0,
      uniforms: void 0
    };
  }
  fragment_shader() {
    return this._shaders_by_name.get(ShaderName.FRAGMENT);
  }
  uniforms() {
    return this._uniforms;
  }
  updateFragmentShader() {
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    for (const shader_name of this.shaderNames()) {
      if (shader_name == ShaderName.FRAGMENT) {
        const template = this.templateShader().fragmentShader;
        this._lines.set(shader_name, template.split("\n"));
      }
    }
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    this._uniforms = this._uniforms || {};
    this._gl_parent_node.scene().uniformsController.addUniforms(this._uniforms, {
      paramConfigs: this.param_configs(),
      additionalTextureUniforms: {},
      timeDependent: this.uniformsTimeDependent(),
      resolutionDependent: this.uniformsResolutionDependent(),
      raymarchingLightsWorldCoordsDependent: this._raymarchingLightsWorldCoordsDependent()
    });
    for (const shader_name of this.shaderNames()) {
      const lines = this._lines.get(shader_name);
      if (lines) {
        this._shaders_by_name.set(shader_name, lines.join("\n"));
      }
    }
    handleCopBuilderDependencies({
      node: this.currentGlParentNode(),
      timeDependent: this.uniformsTimeDependent(),
      uniforms: this._uniforms
    });
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      new GlConnectionPoint("color", GlConnectionPointType.VEC3),
      new GlConnectionPoint("alpha", GlConnectionPointType.FLOAT)
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new GlConnectionPoint("uv", GlConnectionPointType.VEC2),
      new GlConnectionPoint("gl_FragCoord", GlConnectionPointType.VEC4),
      new GlConnectionPoint("resolution", GlConnectionPointType.VEC2),
      new GlConnectionPoint("time", GlConnectionPointType.FLOAT)
      // new Connection.Vec2('resolution'),
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [new ShaderConfig(ShaderName.FRAGMENT, ["color", "alpha"], [])];
  }
  create_variable_configs() {
    return [
      new VariableConfig("color", {
        prefix: "diffuseColor.xyz = "
      }),
      new VariableConfig("alpha", {
        prefix: "diffuseColor.a = ",
        default: "1.0"
      })
    ];
  }
  //
  //
  // TEMPLATE HOOKS
  //
  //
  insertDefineAfter(shader_name) {
    return "// INSERT DEFINE";
  }
  insertBodyAfter(shader_name) {
    return "// INSERT BODY";
  }
  linesToRemove(shader_name) {
    return ["// INSERT DEFINE", "// INSERT BODY"];
  }
  _handle_gl_FragCoord(body_lines, shaderName, var_name) {
    if (shaderName == ShaderName.FRAGMENT) {
      body_lines.push(`vec4 ${var_name} = gl_FragCoord`);
    }
  }
  _handle_resolution(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName.FRAGMENT) {
      bodyLines.push(`vec2 ${var_name} = resolution`);
    }
  }
  _handleUV(bodyLines, shaderName, var_name) {
    if (shaderName == ShaderName.FRAGMENT) {
      bodyLines.push(
        `vec2 ${var_name} = vec2(gl_FragCoord.x / (resolution.x-1.), gl_FragCoord.y / (resolution.y-1.))`
      );
    }
  }
  set_node_lines_output(output_node, shaders_collection_controller) {
    const input_names = this.inputNamesForShaderName(
      output_node,
      shaders_collection_controller.currentShaderName()
    );
    if (input_names) {
      for (const input_name of input_names) {
        const input = output_node.io.inputs.named_input(input_name);
        if (input) {
          const gl_var = output_node.variableForInput(input_name);
          let body_line;
          if (input_name == "color") {
            body_line = `diffuseColor.xyz = ${ThreeToGl.any(gl_var)}`;
          }
          if (input_name == "alpha") {
            body_line = `diffuseColor.a = ${ThreeToGl.any(gl_var)}`;
          }
          if (body_line) {
            shaders_collection_controller.addBodyLines(output_node, [body_line]);
          }
        }
      }
    }
  }
  set_node_lines_globals(globals_node, shaders_collection_controller) {
    const shader_name = shaders_collection_controller.currentShaderName();
    const shader_config = this.shader_config(shader_name);
    if (!shader_config) {
      return;
    }
    const body_lines = [];
    const definitions = [];
    for (const output_name of globals_node.io.outputs.used_output_names()) {
      const var_name = globals_node.glVarName(output_name);
      switch (output_name) {
        case "time":
          definitions.push(new UniformGLDefinition(globals_node, GlConnectionPointType.FLOAT, output_name));
          body_lines.push(`float ${var_name} = ${output_name}`);
          this.setUniformsTimeDependent();
          break;
        case "uv":
          this._handleUV(body_lines, shader_name, var_name);
          break;
        case "gl_FragCoord":
          this._handle_gl_FragCoord(body_lines, shader_name, var_name);
          break;
        case "resolution":
          this._handle_resolution(body_lines, shader_name, var_name);
          break;
      }
    }
    shaders_collection_controller.addDefinitions(globals_node, definitions, shader_name);
    shaders_collection_controller.addBodyLines(globals_node, body_lines);
  }
}
