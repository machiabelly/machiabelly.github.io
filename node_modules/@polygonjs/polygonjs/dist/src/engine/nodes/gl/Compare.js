"use strict";
import { TypedGlNode } from "./_Base";
import { ThreeToGl } from "../../../../src/core/ThreeToGl";
import { ParamConfig, NodeParamsConfig } from "../utils/params/ParamsConfig";
import { GlConnectionPointType, GlConnectionPointComponentsCountMap } from "../utils/io/connections/Gl";
export var GlCompareTestName = /* @__PURE__ */ ((GlCompareTestName2) => {
  GlCompareTestName2["EQUAL"] = "Equal";
  GlCompareTestName2["LESS_THAN"] = "Less Than";
  GlCompareTestName2["GREATER_THAN"] = "Greater Than";
  GlCompareTestName2["LESS_THAN_OR_EQUAL"] = "Less Than Or Equal";
  GlCompareTestName2["GREATER_THAN_OR_EQUAL"] = "Greater Than Or Equal";
  GlCompareTestName2["NOT_EQUAL"] = "Not Equal";
  return GlCompareTestName2;
})(GlCompareTestName || {});
var GlCompareTestOperation = /* @__PURE__ */ ((GlCompareTestOperation2) => {
  GlCompareTestOperation2["EQUAL"] = "==";
  GlCompareTestOperation2["LESS_THAN"] = "<";
  GlCompareTestOperation2["GREATER_THAN"] = ">";
  GlCompareTestOperation2["LESS_THAN_OR_EQUAL"] = "<=";
  GlCompareTestOperation2["GREATER_THAN_OR_EQUAL"] = ">=";
  GlCompareTestOperation2["NOT_EQUAL"] = "!=";
  return GlCompareTestOperation2;
})(GlCompareTestOperation || {});
const TEST_NAMES = [
  "Equal" /* EQUAL */,
  "Less Than" /* LESS_THAN */,
  "Greater Than" /* GREATER_THAN */,
  "Less Than Or Equal" /* LESS_THAN_OR_EQUAL */,
  "Greater Than Or Equal" /* GREATER_THAN_OR_EQUAL */,
  "Not Equal" /* NOT_EQUAL */
];
const TEST_OPERATIONS_FLOAT = [
  "==" /* EQUAL */,
  "<" /* LESS_THAN */,
  ">" /* GREATER_THAN */,
  "<=" /* LESS_THAN_OR_EQUAL */,
  ">=" /* GREATER_THAN_OR_EQUAL */,
  "!=" /* NOT_EQUAL */
];
const AND_SEPARATOR = " && ";
const COMPONENTS = ["x", "y", "z", "w"];
const OUTPUT_NAME = "val";
class CompareGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.test = ParamConfig.INTEGER(1, {
      menu: {
        entries: TEST_NAMES.map((name, i) => {
          const operator = TEST_OPERATIONS_FLOAT[i];
          const label = `${operator.padEnd(2, " ")} (${name})`;
          return { name: label, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new CompareGlParamsConfig();
export class CompareGlNode extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "compare";
  }
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["test"]);
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_input_name_function(this._gl_input_name.bind(this));
    this.io.connection_points.set_output_name_function((index) => OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(this._expected_input_type.bind(this));
    this.io.connection_points.set_expected_output_types_function(() => [GlConnectionPointType.BOOL]);
  }
  setTestName(test) {
    this.p.test.set(TEST_NAMES.indexOf(test));
  }
  testName() {
    return TEST_NAMES[this.pv.test];
  }
  operator() {
    return TEST_OPERATIONS_FLOAT[this.pv.test];
  }
  _gl_input_name(index) {
    return ["value0", "value1"][index];
  }
  _expected_input_type() {
    const type = this.io.connection_points.first_input_connection_type() || GlConnectionPointType.FLOAT;
    return [type, type];
  }
  setLines(shaders_collection_controller) {
    const body_lines = [];
    const value = this.glVarName(OUTPUT_NAME);
    const operator = this.operator();
    const value0 = ThreeToGl.any(this.variableForInput(this._gl_input_name(0)));
    const value1 = ThreeToGl.any(this.variableForInput(this._gl_input_name(1)));
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (!connectionPoints) {
      return;
    }
    const first_connection = connectionPoints[0];
    let components_count = 1;
    if (first_connection) {
      components_count = GlConnectionPointComponentsCountMap[first_connection.type()] || 1;
    }
    if (components_count > 1) {
      let tmp_values = [];
      for (let i = 0; i < components_count; i++) {
        const tmp_value = this.glVarName(`tmp_value_${i}`);
        const component = COMPONENTS[i];
        tmp_values.push(tmp_value);
        body_lines.push(`bool ${tmp_value} = (${value0}.${component} ${operator} ${value1}.${component})`);
      }
      body_lines.push(`bool ${value} = (${tmp_values.join(AND_SEPARATOR)})`);
    } else {
      body_lines.push(`bool ${value} = (${value0} ${operator} ${value1})`);
    }
    shaders_collection_controller.addBodyLines(this, body_lines);
  }
}
