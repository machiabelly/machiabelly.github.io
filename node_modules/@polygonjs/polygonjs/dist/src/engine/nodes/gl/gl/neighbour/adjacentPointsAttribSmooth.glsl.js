export default "\n\nfloat __FUNCTION__NAME__(\n	sampler2D texturePosition,\n	vec2 particleUv,\n	vec3 currentPosition,\n	//\n	vec2 textureSize,\n	// attribSmooth\n	sampler2D textureAttribute,\n	float currentAttributeValue,\n	float deltaThreshold,\n	float smoothAmount,\n	__ADJACENCY_SAMPLERS_ARGUMENTS__\n	){\n\n	vec3 otherPosition;\n	float dist, delta, otherAttribute;\n	// float neighbourCount = 0.0;\n	float offset = 0.0;\n\n	__ADJACENCY_VALUES_FROM_SAMPLERS__\n	vec2 adjacencyAttributesArray__ADJACENCY_ARRAY_VALUE__;\n\n	for(int faceIndex = 0; faceIndex < __ADJACENCY_COUNT__; faceIndex++){\n\n		vec2 currentAdjacentIdForFace = adjacencyAttributesArray[faceIndex];\n\n		if(currentAdjacentIdForFace.x > -0.5 && currentAdjacentIdForFace.y >= -0.5){\n\n			for( int vertexIndex = 0; vertexIndex < 1; vertexIndex++ ){\n\n				float vertexId = vertexIndex == 0 ? currentAdjacentIdForFace.x : currentAdjacentIdForFace.y;\n				vec2 adjacentPointUv = geometryAttributesLookupUv(vertexId, textureSize);\n				\n				otherPosition = texture2D( texturePosition, adjacentPointUv ).__COMPONENT__;\n				otherAttribute = texture2D( textureAttribute, adjacentPointUv ).__COMPONENT_ATTRIB__;\n\n				dist = distance( otherPosition, currentPosition );\n\n				delta = (otherAttribute - currentAttributeValue) / dist;\n\n				float excess = abs(delta) - deltaThreshold;\n\n				if(excess > 0.0){\n					offset += (excess * smoothAmount * sign(delta));\n					//neighbourCount++;\n				}\n\n			}\n\n		}\n	}\n\n	//offset = neighbourCount >= 1.0 ? (offset / neighbourCount) : 0.0;\n	return currentAttributeValue + offset;\n\n}";
