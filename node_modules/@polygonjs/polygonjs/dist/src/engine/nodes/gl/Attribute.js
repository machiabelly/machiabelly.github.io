"use strict";
import { GlType } from "./../../poly/registers/nodes/types/Gl";
import { TypedGlNode } from "./_Base";
import { GlConnectionPointType } from "../utils/io/connections/Gl";
export const ATTRIBUTE_NODE_AVAILABLE_GL_TYPES = [
  GlConnectionPointType.FLOAT,
  GlConnectionPointType.VEC2,
  GlConnectionPointType.VEC3,
  GlConnectionPointType.VEC4
];
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
class AttributeGlParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param attribute name */
    this.name = ParamConfig.STRING("attribute1");
    /** @param attribute type (float, vec2, vec3, vec4) */
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    /** @param allows to export the attribute to a material (when used inside a particles system) */
    this.texportWhenConnected = ParamConfig.BOOLEAN(0, { hidden: true });
    /** @param allows to export the attribute to a material (when used inside a particles system) */
    this.exportWhenConnected = ParamConfig.BOOLEAN(0, { visibleIf: { texportWhenConnected: 1 } });
  }
}
const ParamsConfig = new AttributeGlParamsConfig();
const _AttributeGlNode = class extends TypedGlNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._bound_setExportWhenConnectedStatus = this._setExportWhenConnectedStatus.bind(this);
  }
  static type() {
    return GlType.ATTRIBUTE;
  }
  // private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);
  // public readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);
  initializeNode() {
    this.addPostDirtyHook("_setMatToRecompile", this._setMatToRecompileIfIsExporting.bind(this));
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(() => {
      var _a, _b;
      if ((_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.allow_attribute_exports()) {
        return [ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]];
      } else {
        return [];
      }
    });
    this.io.connection_points.set_input_name_function((index) => {
      return _AttributeGlNode.INPUT_NAME;
    });
    this.io.connection_points.set_expected_output_types_function(() => [
      ATTRIBUTE_NODE_AVAILABLE_GL_TYPES[this.pv.type]
    ]);
    this.lifecycle.onAfterAdded(this._bound_setExportWhenConnectedStatus);
    this.params.addOnSceneLoadHook("prepare params", this._bound_setExportWhenConnectedStatus);
  }
  _setExportWhenConnectedStatus() {
    var _a, _b;
    if ((_b = (_a = this.materialNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.allow_attribute_exports()) {
      this.p.texportWhenConnected.set(1);
    }
  }
  setAttribSize(size) {
    this.p.type.set(size - 1);
  }
  // createParams() {}
  // inputless_params_names(): string[] {
  // 	return ['type'];
  // }
  inputName() {
    return _AttributeGlNode.INPUT_NAME;
  }
  outputName() {
    return _AttributeGlNode.OUTPUT_NAME;
  }
  // TODO:
  // ideally glVarName should know which shader it is being called in.
  // so that if it is in a vertex shader, it can return the name of the attribute directly.
  // and if it is in a fragment, it would behave as usual.
  // override glVarName() {
  // 	// if (name) {
  // 	// 	return super.glVarName(name);
  // 	// }
  // 	// return this.varyingName();
  // }
  varyingName() {
    return `v_POLY_attribute_${this.pv.name}`;
  }
  // private create_inputs_from_params() {
  // 	if (this.materialNode().allow_attribute_exports) {
  // 		// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);
  // 		this.io.inputs.setNamedInputConnectionPoints([
  // 			new TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),
  // 		]);
  // 		// this._init_graph_node_inputs();
  // 	}
  // }
  setLines(shadersCollectionController) {
    const assembler = shadersCollectionController.assembler();
    assembler.setNodeLinesAttribute(this, shadersCollectionController);
  }
  // update_output_type(constructor) {
  // 	const named_output = new constructor(Attribute.output_name());
  // 	this.set_named_outputs([named_output]);
  // }
  // update_input_type(constructor) {
  // 	const named_input = new constructor(Attribute.input_name());
  // 	this.set_named_inputs([named_input]);
  // 	this._init_graph_node_inputs();
  // }
  attributeName() {
    return this.pv.name.trim();
  }
  glType() {
    const outputConnectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!outputConnectionPoints) {
      return GlConnectionPointType.FLOAT;
    }
    return outputConnectionPoints[0].type();
  }
  setGlType(type) {
    this.p.type.set(ATTRIBUTE_NODE_AVAILABLE_GL_TYPES.indexOf(type));
  }
  //
  //
  // Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles
  //
  //
  connected_input_node() {
    return this.io.inputs.named_input(_AttributeGlNode.INPUT_NAME);
  }
  connected_input_connection_point() {
    return this.io.inputs.named_input_connection_point(_AttributeGlNode.INPUT_NAME);
  }
  // connected_input(): NamedConnection {
  // 	const connection_point = this.connected_input_connection_point();
  // 	if (connection_point) {
  // 		return this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];
  // 	}
  // }
  output_connection_point() {
    return this.io.outputs.namedOutputConnectionPointsByName(this.outputName());
  }
  // connected_output(): NamedConnection {
  // 	const output = this.named_output(0);
  // 	if (output) {
  // 		return output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]
  // 	}
  // }
  isImporting() {
    return this.io.outputs.used_output_names().length > 0;
  }
  isExporting() {
    if (isBooleanTrue(this.pv.exportWhenConnected)) {
      const input_node = this.io.inputs.named_input(_AttributeGlNode.INPUT_NAME);
      return input_node != null;
    } else {
      return false;
    }
  }
  _setMatToRecompileIfIsExporting() {
    if (isBooleanTrue(this.pv.exportWhenConnected)) {
      this._setMatToRecompile();
    }
  }
  //
  //
  // SIGNATURE
  //
  //
  // private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {
  // 	if (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {
  // 		this.update_input_and_output_types();
  // 		this.removeDirtyState();
  // 		this.make_output_nodes_dirty();
  // 	}
  // 	this.materialNode()?.assembler_controller.set_compilation_required_and_dirty(this);
  // }
  // private update_input_and_output_types() {
  // 	const set_dirty = false;
  // 	this.io.outputs.setNamedOutputConnectionPoints(
  // 		[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],
  // 		set_dirty
  // 	);
  // 	if (this.materialNode()?.assembler_controller.allow_attribute_exports()) {
  // 		this.io.inputs.setNamedInputConnectionPoints([
  // 			new TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),
  // 		]);
  // 	}
  // }
};
export let AttributeGlNode = _AttributeGlNode;
AttributeGlNode.INPUT_NAME = "in";
AttributeGlNode.OUTPUT_NAME = "val";
