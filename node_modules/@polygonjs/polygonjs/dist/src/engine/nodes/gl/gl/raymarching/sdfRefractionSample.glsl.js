export default "// // xyz for color, w for distanceInsideMedium\n// vec4 GetRefractedData(vec3 p, vec3 n, vec3 rayDir, float ior, float biasMult, sampler2D envMap, int refractionDepth){\n// 	bool hitRefraction = true;\n// 	bool changeSide = true;\n// 	float side = -1.;\n// 	float iorInverted = 1. / ior;\n// 	vec3 refractedColor = vec3(0.);\n// 	float distanceInsideMedium=0.;\n\n// 	#pragma unroll_loop_start\n// 	for(int i=0; i < refractionDepth; i++) {\n// 		if(hitRefraction){\n// 			float currentIor = side<0. ? iorInverted : ior;\n// 			vec3 rayDirPreRefract = rayDir;\n// 			rayDir = refract(rayDir, n, currentIor);\n// 			changeSide = dot(rayDir, rayDir)!=0.;\n// 			if(changeSide == true) {\n// 				p -= n*SURF_DIST*(2.+biasMult);\n// 			} else {\n// 				p += n*SURF_DIST*(   biasMult);\n// 				rayDir = reflect(rayDirPreRefract, n);\n// 			}\n// 			SDFContext sdfContext;// = RayMarch(p, rayDir, side);\n// 			if( abs(sdfContext.d) >= MAX_DIST ){\n// 				hitRefraction = false;\n// 				refractedColor = envMapSample(rayDir, envMap);\n// 			}\n// 			if(hitRefraction){\n// 				p += rayDir * sdfContext.d;\n// 				n = GetNormal(p) * side;\n// 				vec3 matCol = applyMaterialWithoutRefraction(p, n, rayDir, sdfContext.matId);\n// 				refractedColor = matCol;\n\n// 				distanceInsideMedium += side < 0. ? abs(sdfContext.d) : 0.;\n// 				if( changeSide ){\n// 					side *= -1.;\n// 				}\n// 			}\n// 		}\n// 	}\n// 	#pragma unroll_loop_end\n// 	return vec4(refractedColor, distanceInsideMedium);\n// }\n";
