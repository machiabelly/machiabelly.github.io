export default "// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-plane-and-ray-disk-intersection\n// bool intersectPlane(vec3 plane_normal, vec3 plane_center, vec3 ray_origin, vec3 ray_dir, float &intersect)\n// {\n// 	// assuming vectors are all normalized\n// 	float denom = dotProduct(plane_normal, ray_dir);\n// 	if (denom > 1e-6) {\n// 		Vec3f p0l0 = plane_center - ray_origin;\n// 		intersect = dotProduct(p0l0, plane_normal) / denom;\n// 		return (intersect >= 0);\n// 	}\n\n// 	return false;\n// }\n\n// https://gist.github.com/doxas/e9a3d006c7d19d2a0047\nstruct Intersection{\n	float t;\n	float hit;\n	vec3  hitPoint;\n	vec3  normal;\n	vec3  color;\n};\n\nstruct Sphere{\n	vec3  position;\n	float radius;\n};\n\nstruct Plane{\n	vec3 position;\n	vec3 normal;\n};\nstruct PointWithVelocity{\n	vec3 position;\n	vec3 velocity;\n};\n// void intersectSphere(vec3 ray, Sphere s, inout Intersection i){\n// 	vec3  a = cPos - s.position;\n// 	float b = dot(a, ray);\n// 	float c = dot(a, a) - (s.radius * s.radius);\n// 	float d = b * b - c;\n// 	if(d > 0.0){\n// 		float t = -b - sqrt(d);\n// 		if(t > 0.0 && t < i.t){\n// 			i.t = t;\n// 			i.hit = 1.0;\n// 			i.hitPoint = vec3(\n// 				cPos.x + ray.x * t,\n// 				cPos.y + ray.y * t,\n// 				cPos.z + ray.z * t\n// 			);\n// 			i.normal = normalize(i.hitPoint - s.position);\n// 			// float diff = clamp(dot(i.normal, lightDirection), 0.1, 1.0);\n// 			// i.color = vec3(diff);\n// 		}\n// 	}\n// }\n\nvoid intersectPlane(vec3 ray, Plane p, inout Intersection i){\n	float d = -dot(p.position, p.normal);\n	float v = dot(ray, p.normal);\n	float t = -(dot(cPos, p.normal) + d) / v;\n	if(t > 0.0 && t < i.t){\n		i.t = t;\n		i.hit = 1.0;\n		i.hitPoint = vec3(\n			cPos.x + t * ray.x,\n			cPos.y + t * ray.y,\n			cPos.z + t * ray.z\n		);\n		i.normal = p.normal;\n		// float diff = clamp(dot(i.normal, lightDirection), 0.1, 1.0);\n		// float m = mod(i.hitPoint.x, 2.0);\n		// float n = mod(i.hitPoint.z, 2.0);\n		// if((m > 1.0 && n > 1.0) || (m < 1.0 && n < 1.0)){\n		// 	diff -= 0.5;\n		// }\n		\n		// t = min(i.hitPoint.z, 100.0) * 0.01;\n		// i.color = vec3(diff + t);\n	}\n}\n// if(i.hit > 0.0)\n\nPointWithVelocity collide_with_plane(PointWithVelocity point, Plane plane){\n	Intersection intersection;\n	intersectPlane(point.velocity, plane, intersection)\n	return point\n}";
