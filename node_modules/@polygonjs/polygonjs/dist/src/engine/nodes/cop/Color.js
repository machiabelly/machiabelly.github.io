"use strict";
import { TypedCopNode } from "./_Base";
import { DataTexture } from "three";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
class ColorCopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param texture resolution */
    this.resolution = ParamConfig.VECTOR2([256, 256], {
      callback: (node) => {
        ColorCopNode.PARAM_CALLBACK_reset(node);
      }
    });
    /** @param color to generate */
    this.color = ParamConfig.COLOR([1, 1, 1]);
    /** @param alpha */
    this.alpha = ParamConfig.FLOAT(1, {
      range: [0, 1]
    });
  }
}
const ParamsConfig = new ColorCopParamsConfig();
export class ColorCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "color";
  }
  cook() {
    const w = this.pv.resolution.x;
    const h = this.pv.resolution.y;
    this._dataTexture = this._dataTexture || this._createDataTexture(w, h);
    const bufferSize = 4 * h * w;
    const c = this.pv.color.toArray();
    const r = c[0] * 255;
    const g = c[1] * 255;
    const b = c[2] * 255;
    const data = this._dataTexture.image.data;
    for (let i = 0; i < bufferSize; i += 4) {
      data[i + 0] = r;
      data[i + 1] = g;
      data[i + 2] = b;
    }
    this._dataTexture.needsUpdate = true;
    this.setTexture(this._dataTexture);
  }
  _createDataTexture(width, height) {
    const pixel_buffer = this._createPixelBuffer(width, height);
    return new DataTexture(pixel_buffer, width, height);
  }
  _createPixelBuffer(width, height) {
    const size = width * height * 4;
    const buffer = new Uint8Array(size);
    buffer.fill(this.pv.alpha * 255);
    return buffer;
  }
  static PARAM_CALLBACK_reset(node) {
    node._reset();
  }
  _reset() {
    this._dataTexture = void 0;
  }
}
