"use strict";
import { TypedCopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CopType } from "../../poly/registers/nodes/types/Cop";
import { ParamEvent } from "../../poly/ParamEvent";
import { Poly } from "../../Poly";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { TextureParamConfig, TextureParamsController } from "./utils/TextureParamsController";
import { CoreCubeTextureLoader } from "../../../core/loader/texture/Cube";
import { EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT } from "../../../core/loader/FileExtensionRegister";
import { NodeContext } from "../../poly/NodeContext";
export var CubeMapUrlKey = /* @__PURE__ */ ((CubeMapUrlKey2) => {
  CubeMapUrlKey2["P"] = "p";
  CubeMapUrlKey2["N"] = "n";
  return CubeMapUrlKey2;
})(CubeMapUrlKey || {});
export var CubeMapUrlAxis = /* @__PURE__ */ ((CubeMapUrlAxis2) => {
  CubeMapUrlAxis2["X"] = "x";
  CubeMapUrlAxis2["Y"] = "y";
  CubeMapUrlAxis2["Z"] = "z";
  return CubeMapUrlAxis2;
})(CubeMapUrlAxis || {});
export function cubeMapUrlExpression(urlKey, urlAxis) {
  return `\`ch('prefix')\`${urlKey}${urlAxis}\`ch('suffix')\``;
}
function CubeMapCopParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param url prefix */
      this.prefix = ParamConfig.STRING("", {
        fileBrowse: {
          extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.COP][CopType.CUBE_MAP]
        }
      });
      /** @param url prefix */
      this.suffix = ParamConfig.STRING(".png");
      /** @param reload the image */
      this.reload = ParamConfig.BUTTON(null, {
        callback: (node) => {
          CubeMapCopNode.PARAM_CALLBACK_reload(node);
        }
      });
      /** @param px url */
      this.px = ParamConfig.STRING(cubeMapUrlExpression("p" /* P */, "x" /* X */));
      /** @param nx url */
      this.nx = ParamConfig.STRING(cubeMapUrlExpression("n" /* N */, "x" /* X */));
      /** @param py url */
      this.py = ParamConfig.STRING(cubeMapUrlExpression("p" /* P */, "y" /* Y */));
      /** @param ny url */
      this.ny = ParamConfig.STRING(cubeMapUrlExpression("n" /* N */, "y" /* Y */));
      /** @param pz url */
      this.pz = ParamConfig.STRING(cubeMapUrlExpression("p" /* P */, "z" /* Z */));
      /** @param nz url */
      this.nz = ParamConfig.STRING(cubeMapUrlExpression("n" /* N */, "z" /* Z */));
    }
  };
}
class CubeMapCopParamsConfig extends TextureParamConfig(CubeMapCopParamConfig(NodeParamsConfig)) {
}
const ParamsConfig = new CubeMapCopParamsConfig();
export class CubeMapCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.textureParamsController = new TextureParamsController(this);
  }
  static type() {
    return CopType.CUBE_MAP;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode.NEVER);
  }
  async cook(inputContents) {
    const texture = await this._loadTexture();
    if (texture) {
      const inputTexture = inputContents[0];
      if (inputTexture) {
        TextureParamsController.copyTextureAttributes(texture, inputTexture);
      }
      await this.textureParamsController.update(texture);
      this.setTexture(texture);
    } else {
      this._clearTexture();
    }
  }
  dispose() {
    super.dispose();
    Poly.blobs.clearBlobsForNode(this);
  }
  async _loadTexture() {
    const pv = this.pv;
    const urls = [pv.px, pv.nx, pv.py, pv.ny, pv.pz, pv.nz];
    let texture = null;
    try {
      const loader = new CoreCubeTextureLoader(urls, this);
      texture = await loader.loadImage({
        tdataType: this.pv.ttype && this.pv.tadvanced,
        dataType: this.pv.type
      });
      if (texture) {
        texture.matrixAutoUpdate = false;
      }
    } catch (e) {
    }
    if (!texture) {
      this.states.error.set(`could not load texture '${urls.join(" ")}'`);
    }
    return texture;
  }
  static PARAM_CALLBACK_reload(node) {
    node.paramCallbackReload();
  }
  paramCallbackReload() {
    this.p.px.setDirty();
    this.p.px.emit(ParamEvent.ASSET_RELOAD_REQUEST);
  }
}
