/**
 * Allows to create a shader with GLSL nodes to create the texture values.
 *
 *
 */
import { WebGLRenderer, ShaderMaterial, WebGLArrayRenderTarget } from 'three';
import { Constructor, valueof } from '../../../types/GlobalTypes';
import { TypedCopNode } from './_Base';
import { GlNodeChildrenMap } from '../../poly/registers/nodes/Gl';
import { BaseGlNodeType } from '../gl/_Base';
import { NodeContext } from '../../poly/NodeContext';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
import { AssemblerName } from '../../poly/registers/assemblers/_BaseRegister';
import { TexturePersistedConfig } from '../gl/code/assemblers/textures/TexturePersistedConfig';
import { NodeCreateOptions } from '../utils/hierarchy/ChildrenController';
import { CopType } from '../../poly/registers/nodes/types/Cop';
import { TextureParamsController } from './utils/TextureParamsController';
import { GlAssemblerController } from '../gl/code/Controller';
import { ShaderAssemblerTexture2DArray } from '../gl/code/assemblers/textures/Texture2DArray';
declare const Builder2DArrayCopParamsConfig_base: {
    new (...args: any[]): {
        tcolorSpace: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        colorSpace: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.STRING>;
        tmapping: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        mapping: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        twrap: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        wrapS: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        wrapT: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tminFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        minFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tmagFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        magFilter: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tanisotropy: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        useRendererMaxAnisotropy: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        anisotropy: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        tflipY: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        flipY: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        ttransform: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        offset: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        repeat: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        rotation: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.FLOAT>;
        center: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        tadvanced: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        tformat: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        format: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        ttype: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        type: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
    };
} & {
    new (...args: any[]): {
        /** @param textures resolution */
        resolution: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.VECTOR2>;
        /** @param layers */
        layers: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.INTEGER>;
        /** @param use the main camera renderer. This can save memory, but can also lead to colors being affected by the renderer's output color space */
        useCameraRenderer: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BOOLEAN>;
        /** @param use a data texture instead of a render target, which can be useful when using that texture as and envMap */
        /** @param force Render */
        render: import("../utils/params/ParamsConfig").ParamTemplate<import("../../index_all").ParamType.BUTTON>;
    };
} & typeof NodeParamsConfig;
declare class Builder2DArrayCopParamsConfig extends Builder2DArrayCopParamsConfig_base {
}
export declare class Builder2DArrayCopNode extends TypedCopNode<Builder2DArrayCopParamsConfig> {
    paramsConfig: Builder2DArrayCopParamsConfig;
    static type(): CopType;
    readonly persisted_config: TexturePersistedConfig;
    protected _assemblerController: GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
    usedAssembler(): Readonly<AssemblerName.GL_TEXTURE_2D_ARRAY>;
    protected _createAssemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
    assemblerController(): GlAssemblerController<ShaderAssemblerTexture2DArray> | undefined;
    private _textureMesh;
    private _fragmentShader;
    private _uniforms;
    readonly textureMaterial: ShaderMaterial;
    private _textureScene;
    private _textureCamera;
    private _renderTarget;
    private _dataTextureController;
    private _rendererController;
    readonly textureParamsController: TextureParamsController;
    protected _childrenControllerContext: NodeContext;
    initializeNode(): void;
    createNode<S extends keyof GlNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): GlNodeChildrenMap[S];
    createNode<K extends valueof<GlNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
    children(): BaseGlNodeType[];
    nodesByType<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][];
    childrenAllowed(): boolean;
    sceneReadonly(): boolean;
    private _cook_main_without_inputs_when_dirty_bound;
    private _cook_main_without_inputs_when_dirty;
    cook(): Promise<void>;
    shaders_by_name(): {
        fragment: string | undefined;
    };
    compileIfRequired(): void;
    private compile;
    callbackName(): string;
    dispose(): void;
    removeCallbacks(): void;
    readonly boundRenderOnTarget: () => Promise<void>;
    renderOnTargetWithoutUpdatingTextureFromParams(): Promise<void>;
    private _renderOnTarget;
    private _postRender;
    private _prevTarget;
    private _prevOutputColorSpace;
    private _prevToneMapping;
    private _saveRendererState;
    private _prepareRenderer;
    private _setRenderLayer;
    private _restoreRendererState;
    private _renderer;
    private _createRendererIfRequired;
    private _resetRenderer;
    renderer(): WebGLRenderer | undefined;
    renderTarget(): Promise<WebGLArrayRenderTarget>;
    private createRenderTargetIfRequired;
    private _renderTargetResolutionValid;
    private _createRenderTarget;
    static PARAM_CALLBACK_render(node: Builder2DArrayCopNode): void;
    static PARAM_CALLBACK_resetRenderer(node: Builder2DArrayCopNode): void;
}
export {};
