"use strict";
import { CoreUserAgent } from "./../../../../core/UserAgent";
import { DataTexture } from "three";
import { TypeAssert } from "../../../poly/Assert";
export var DataTextureControllerBufferType = /* @__PURE__ */ ((DataTextureControllerBufferType2) => {
  DataTextureControllerBufferType2["Uint8Array"] = "Uint8Array";
  DataTextureControllerBufferType2["Uint8ClampedArray"] = "Uint8ClampedArray";
  DataTextureControllerBufferType2["Uint16Array"] = "Uint16Array";
  DataTextureControllerBufferType2["Float32Array"] = "Float32Array";
  return DataTextureControllerBufferType2;
})(DataTextureControllerBufferType || {});
export class DataTextureController {
  constructor(bufferType) {
    this.bufferType = bufferType || (CoreUserAgent.isiOS() ? "Uint16Array" /* Uint16Array */ : "Float32Array" /* Float32Array */);
  }
  fromRenderTarget(renderer, renderTarget) {
    if (!this._dataTexture || !this._sameDimensions(renderTarget.texture)) {
      this._dataTexture = this._createDataTexture(renderTarget.texture);
    }
    this._copyToDataTexture(renderer, renderTarget);
    return this._dataTexture;
  }
  // fromTexture(texture: Texture): DataTexture {
  // 	const src_data = CoreImage.data_from_image(texture.image);
  // 	if (!this._data_texture || !this._same_dimensions(texture)) {
  // 		this._data_texture = this._create_data_texture(texture);
  // 	}
  // 	const length = src_data.width * src_data.height;
  // 	const src_tex_data = src_data.data;
  // 	const dest_ext_data = this._data_texture.image.data;
  // 	const stride = 4;
  // 	const l4 = length * stride;
  // 	for (let i = 0; i < l4; i++) {
  // 		dest_ext_data[i] = src_tex_data[i];
  // 		// dest_ext_data[i + 1] = src_tex_data[i + 1];
  // 		// dest_ext_data[i + 2] = src_tex_data[i + 2];
  // 		// dest_ext_data[i + 3] = src_tex_data[i + 3];
  // 	}
  // 	return this._data_texture;
  // }
  // dataTexture() {
  // 	return this._dataTexture;
  // }
  reset() {
    this._dataTexture = void 0;
  }
  _copyToDataTexture(renderer, renderTarget) {
    const image = renderTarget.texture.image;
    this._dataTexture = this._dataTexture || this._createDataTexture(renderTarget.texture);
    renderer.readRenderTargetPixels(renderTarget, 0, 0, image.width, image.height, this._dataTexture.image.data);
    this._dataTexture.needsUpdate = true;
  }
  _createDataTexture(texture) {
    const image = texture.image;
    const pixelBuffer = this._createPixelBuffer(image.width, image.height);
    const dataTexture = new DataTexture(
      pixelBuffer,
      image.width,
      image.height,
      texture.format,
      texture.type,
      texture.mapping,
      texture.wrapS,
      texture.wrapT,
      texture.magFilter,
      texture.minFilter,
      texture.anisotropy,
      texture.colorSpace
    );
    return dataTexture;
  }
  _createPixelBuffer(width, height) {
    const size = width * height * 4;
    switch (this.bufferType) {
      case "Uint8Array" /* Uint8Array */:
        return new Uint8Array(size);
      case "Uint8ClampedArray" /* Uint8ClampedArray */:
        return new Uint8ClampedArray(size);
      case "Uint16Array" /* Uint16Array */:
        return new Uint16Array(size);
      case "Float32Array" /* Float32Array */:
        return new Float32Array(size);
    }
    TypeAssert.unreachable(this.bufferType);
  }
  _sameDimensions(texture) {
    if (this._dataTexture) {
      const sameW = this._dataTexture.image.width == texture.image.width;
      const sameH = this._dataTexture.image.height == texture.image.height;
      return sameW && sameH;
    } else {
      return true;
    }
  }
}
