"use strict";
import { WebGLRenderer } from "three";
import { PMREMGenerator } from "three";
import { TypedCopNode } from "./_Base";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { DataTextureController, DataTextureControllerBufferType } from "./utils/DataTextureController";
import { CopRendererController } from "./utils/RendererController";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { CubeUVReflectionMapping } from "three";
import { CopType } from "../../poly/registers/nodes/types/Cop";
class EnvMapCopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param defines if the shader is rendered via the same camera used to render the scene */
    this.useCameraRenderer = ParamConfig.BOOLEAN(1);
  }
  // needs to be 1, as it does not work on firefox otherwise
  /** @param defines if the texture is used for reflection or refraction */
  // mode = ParamConfig.INTEGER(0, {
  // 	menu: {
  // 		entries: MAP_MODES.map((name, value) => {
  // 			return {name, value};
  // 		}),
  // 	},
  // });
}
const ParamsConfig = new EnvMapCopParamsConfig();
export class EnvMapCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return CopType.ENV_MAP;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.NEVER);
  }
  async cook(inputTextures) {
    const texture = inputTextures[0];
    await this._convertTextureToEnvMap(texture);
  }
  async _convertTextureToEnvMap(inputTexture) {
    this._rendererController = this._rendererController || new CopRendererController(this);
    const renderer = await this._rendererController.waitForRenderer();
    if (!renderer) {
      this.states.error.set("no renderer found to convert the texture to an env map");
      return this.cookController.endCook();
    }
    if (!(renderer instanceof WebGLRenderer)) {
      this.states.error.set("renderer found is not WebGLRenderer");
      console.log({ renderer });
      return this.cookController.endCook();
    }
    const pmremGenerator = new PMREMGenerator(renderer);
    const exrCubeRenderTarget = pmremGenerator.fromEquirectangular(inputTexture);
    if (isBooleanTrue(this.pv.useCameraRenderer)) {
      this._setMapping(exrCubeRenderTarget.texture);
      this.setTexture(exrCubeRenderTarget.texture);
    } else {
      this._dataTextureController = this._dataTextureController || new DataTextureController(DataTextureControllerBufferType.Uint16Array);
      const texture = this._dataTextureController.fromRenderTarget(renderer, exrCubeRenderTarget);
      this._setMapping(texture);
      this.setTexture(texture);
    }
  }
  _setMapping(texture) {
    texture.mapping = CubeUVReflectionMapping;
  }
}
