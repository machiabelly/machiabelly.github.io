"use strict";
import { TypedCopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { downloadBlob } from "../../../core/BlobUtils";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { saveSDFMetadata } from "../../../core/loader/geometry/SDF";
class SDFExporterCopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param fileName */
    this.fileName = ParamConfig.STRING("`$OS`");
    /** @param download texture */
    this.download = ParamConfig.BUTTON(null, {
      hidden: true,
      callback: (node) => {
        SDFExporterCopNode.PARAM_CALLBACK_download(node);
      }
    });
  }
}
const ParamsConfig = new SDFExporterCopParamsConfig();
export class SDFExporterCopNode extends TypedCopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "SDFExporter";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.NEVER);
  }
  async cook(inputContents) {
    this.setTexture(inputContents[0]);
  }
  /*
   *
   * CALLBACK
   *
   */
  static PARAM_CALLBACK_download(node) {
    node._downloadTexture();
  }
  async _downloadTexture() {
    const container = await this.compute();
    const texture = container.content();
    const dataContainer = texture == null ? void 0 : texture.image;
    if (!dataContainer) {
      this.states.error.set("the input must be a 3D texture");
      return;
    }
    const dataWithMetadata = saveSDFMetadata(texture);
    if (!dataWithMetadata) {
      return;
    }
    const blob = new Blob([dataWithMetadata], { type: "octet/stream" });
    if (this.p.fileName.isDirty()) {
      await this.p.fileName.compute();
    }
    const fileNameShort = this.pv.fileName;
    downloadBlob(blob, `${fileNameShort}.bin`);
  }
}
