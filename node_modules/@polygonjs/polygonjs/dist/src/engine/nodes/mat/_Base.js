"use strict";
import { TypedNode } from "../_Base";
import { NodeContext } from "../../poly/NodeContext";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { FlagsControllerB } from "../utils/FlagsController";
import { arrayCompact } from "../../../core/ArrayUtils";
import { Poly } from "../../Poly";
export class TypedMatNode extends TypedNode {
  constructor() {
    super(...arguments);
    this._cookWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);
  }
  static context() {
    return NodeContext.MAT;
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.io.outputs.setHasOneOutput();
    this.addPostDirtyHook("_cookWhenDirty", () => {
      setTimeout(this._cookWhenDirtyBound, 0);
    });
  }
  async _cookMainWithoutInputsWhenDirty() {
    await this.cookController.cookMainWithoutInputs();
  }
  setMaterial(material) {
    Poly.onSceneUpdatedHooks.runHooks();
    this._setContainer(material);
  }
}
export class PrimitiveMatNode extends TypedMatNode {
  constructor() {
    super(...arguments);
    this.controllersList = [];
  }
  __materialSync__() {
    return this._material = this._material || this.createMaterial();
  }
  async material() {
    const container = await this.compute();
    return container.material();
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.nameController.add_post_set_fullPath_hook(this.set_material_name.bind(this));
  }
  set_material_name() {
    if (this._material) {
      this._material.name = this.path();
    }
  }
  setMaterial(material) {
    this._material = material;
    super.setMaterial(material);
  }
  getTextures(material, record) {
    for (const controller of this.controllersList) {
      controller.getTextures(material, record);
    }
  }
  setParamsFromMaterial(material, record) {
    for (const controller of this.controllersList) {
      controller.setParamsFromMaterial(material, record);
    }
  }
  controllersPromises(material) {
    const promises = this.controllersList.map((controller) => controller.updateMaterial(material));
    const compactPromises = [];
    arrayCompact(promises, compactPromises);
    return compactPromises;
  }
  initializeNode() {
    this.params.onParamsCreated("init controllers", () => {
      for (const controller of this.controllersList) {
        controller.initializeNode();
      }
    });
  }
}
export class UpdateMatNode extends TypedMatNode {
  constructor() {
    super(...arguments);
    this.flags = new FlagsControllerB(this);
    this._cookWhenDirtyBound = this._cookMainWithoutInputsWhenDirty.bind(this);
  }
  async _cookMainWithoutInputsWhenDirty() {
    await this.cookController.cookMain();
  }
  async material() {
    const container = await this.compute();
    return container.material();
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.ALWAYS);
  }
}
export class BaseMatNodeClass extends TypedMatNode {
  // createMaterial() {
  // 	return new Material();
  // }
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
