"use strict";
import { BaseController } from "./_BaseController";
import { TypedMatNode } from "../_Base";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../../core/BooleanValue";
var LineCapType = /* @__PURE__ */ ((LineCapType2) => {
  LineCapType2["ROUND"] = "round";
  LineCapType2["BUTT"] = "butt";
  LineCapType2["SQUARE"] = "square";
  return LineCapType2;
})(LineCapType || {});
const LINE_CAP_TYPES = ["round" /* ROUND */, "butt" /* BUTT */, "square" /* SQUARE */];
var LineJoinType = /* @__PURE__ */ ((LineJoinType2) => {
  LineJoinType2["ROUND"] = "round";
  LineJoinType2["BEVEL"] = "bevel";
  LineJoinType2["MITER"] = "miter";
  return LineJoinType2;
})(LineJoinType || {});
const LINE_JOIN_TYPES = ["round" /* ROUND */, "bevel" /* BEVEL */, "miter" /* MITER */];
export function WireframeParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle on to set material to wireframe */
      this.wireframe = ParamConfig.BOOLEAN(0, { separatorBefore: true });
      /** @param wireframe line width */
      this.wireframeLinewidth = ParamConfig.FLOAT(1, {
        range: [0, 5],
        rangeLocked: [true, false],
        visibleIf: { wireframe: 1 }
      });
      /** @param define appearance of line ends */
      this.wireframeLinecap = ParamConfig.INTEGER(0, {
        menu: {
          entries: LINE_CAP_TYPES.map((name, value) => {
            return { name, value };
          })
        },
        visibleIf: { wireframe: 1 }
      });
      /** @param Define appearance of line joints */
      this.wireframeLinejoin = ParamConfig.INTEGER(0, {
        menu: {
          entries: LINE_JOIN_TYPES.map((name, value) => {
            return { name, value };
          })
        },
        visibleIf: { wireframe: 1 },
        separatorAfter: true
      });
    }
  };
}
function isValidWireframeMaterial(material) {
  if (!material) {
    return false;
  }
  return material.wireframe != null;
}
class WireframeParamsConfig extends WireframeParamConfig(NodeParamsConfig) {
}
class WireframedMatNode extends TypedMatNode {
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
export class WireframeController extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const material = await node.material();
    if (!isValidWireframeMaterial(material)) {
      return;
    }
    node.controllers.wireframe.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.wireframe = isBooleanTrue(pv.wireframe);
    material.wireframeLinewidth = pv.wireframeLinewidth;
    material.wireframeLinecap = LINE_CAP_TYPES[pv.wireframeLinecap];
    material.wireframeLinejoin = LINE_JOIN_TYPES[pv.wireframeLinejoin];
    material.needsUpdate = true;
  }
  getTextures(material, record) {
  }
  setParamsFromMaterial(material, record) {
    this.node.p.wireframe.set(material.wireframe);
    this.node.p.wireframeLinewidth.set(material.wireframeLinewidth);
    this.node.p.wireframeLinecap.set(LINE_CAP_TYPES.indexOf(material.wireframeLinecap));
    this.node.p.wireframeLinejoin.set(LINE_JOIN_TYPES.indexOf(material.wireframeLinejoin));
  }
}
