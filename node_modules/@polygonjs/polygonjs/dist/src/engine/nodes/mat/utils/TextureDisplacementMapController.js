"use strict";
import { TypedMatNode } from "../_Base";
import { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from "./_BaseTextureController";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
export function DisplacementMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle if you want to use a displacement map */
      this.useDisplacementMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureDisplacementMapController)
      });
      /** @param specify the displacement map COP node */
      this.displacementMap = ParamConfig.NODE_PATH(
        "",
        NodePathOptions(TextureDisplacementMapController, "useDisplacementMap")
      );
      /** @param displacement scale */
      this.displacementScale = ParamConfig.FLOAT(1, {
        range: [0, 1],
        rangeLocked: [false, false],
        ...NodePathOptions(TextureDisplacementMapController, "useDisplacementMap")
      });
      /** @param displacement bias */
      this.displacementBias = ParamConfig.FLOAT(0, {
        range: [0, 1],
        rangeLocked: [false, false],
        ...NodePathOptions(TextureDisplacementMapController, "useDisplacementMap")
      });
    }
  };
}
function _isValidMaterial(material) {
  if (!material) {
    return false;
  }
  return material.displacementScale != null;
}
class TextureDisplacementMapParamsConfig extends DisplacementMapParamConfig(NodeParamsConfig) {
}
class TextureDisplacementMapMatNode extends TypedMatNode {
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
export class TextureDisplacementMapController extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useDisplacementMap, this.node.p.displacementMap);
  }
  static async update(node) {
    node.controllers.displacementMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!_isValidMaterial(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "displacementMap", this.node.p.useDisplacementMap, this.node.p.displacementMap);
    material.displacementScale = this.node.pv.displacementScale;
    material.displacementBias = this.node.pv.displacementBias;
  }
  getTextures(material, record) {
    record.set("displacementMap", material.displacementMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("emissiveMap");
    this.node.p.useDisplacementMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.displacementMap.setNode(mapNode, { relative: true });
    }
    this.node.p.displacementScale.set(material.displacementScale);
    this.node.p.displacementBias.set(material.displacementBias);
  }
}
