"use strict";
import { TypedMatNode } from "../_Base";
import { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from "./_BaseTextureController";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { TypedNodePathParamValue } from "../../../../core/Walker";
export const ENV_MAP_OPERATION_DEFAULT_PARAMS = {
  useEnvMap: false,
  envMap: new TypedNodePathParamValue(""),
  envMapIntensity: 1
};
const DEFAULT_PARAMS = ENV_MAP_OPERATION_DEFAULT_PARAMS;
export function EnvMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle if you want to use an environment map */
      this.useEnvMap = ParamConfig.BOOLEAN(DEFAULT_PARAMS.useEnvMap, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureEnvMapController)
      });
      /** @param specify the environment map COP node */
      this.envMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureEnvMapController, "useEnvMap"));
      /** @param environment intensity */
      this.envMapIntensity = ParamConfig.FLOAT(DEFAULT_PARAMS.envMapIntensity, { visibleIf: { useEnvMap: 1 } });
    }
  };
}
export function isValidEnvMapMaterial(material) {
  if (!material) {
    return false;
  }
  return material.isMeshStandardMaterial || material.isMeshPhysicalMaterial;
}
class TextureEnvMapParamsConfig extends EnvMapParamConfig(NodeParamsConfig) {
}
class TextureEnvMapMatNode extends TypedMatNode {
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
export class TextureEnvMapController extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useEnvMap, this.node.p.envMap);
  }
  static async update(node) {
    node.controllers.envMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!isValidEnvMapMaterial(material)) {
      return;
    }
    this.updateMaterial(material);
  }
  async updateMaterial(material) {
    await this._update(material, "envMap", this.node.p.useEnvMap, this.node.p.envMap);
    material.envMapIntensity = this.node.pv.envMapIntensity;
  }
  getTextures(material, record) {
    record.set("envMap", material.envMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("envMap");
    this.node.p.useEnvMap.set(mapNode != null);
    if (mapNode) {
      this.node.p.envMap.setNode(mapNode, { relative: true });
    }
    this.node.p.envMapIntensity.set(material.envMapIntensity);
  }
}
