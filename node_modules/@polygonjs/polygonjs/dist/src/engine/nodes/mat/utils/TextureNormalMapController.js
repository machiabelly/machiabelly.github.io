"use strict";
import { TypedMatNode } from "../_Base";
import { BaseTextureMapController, BooleanParamOptions, NodePathOptions } from "./_BaseTextureController";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { TangentSpaceNormalMap, ObjectSpaceNormalMap } from "three";
var NormalMapMode = /* @__PURE__ */ ((NormalMapMode2) => {
  NormalMapMode2["TANGENT"] = "tangent";
  NormalMapMode2["OBJECT"] = "object";
  return NormalMapMode2;
})(NormalMapMode || {});
const NORMAL_MAP_MODES = ["tangent" /* TANGENT */, "object" /* OBJECT */];
const NormalMapModeByName = {
  ["tangent" /* TANGENT */]: TangentSpaceNormalMap,
  ["object" /* OBJECT */]: ObjectSpaceNormalMap
};
const NormalNameByMode = {
  [TangentSpaceNormalMap]: "tangent" /* TANGENT */,
  [ObjectSpaceNormalMap]: "object" /* OBJECT */
};
export function NormalMapParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle if you want to use a normal map */
      this.useNormalMap = ParamConfig.BOOLEAN(0, {
        separatorBefore: true,
        ...BooleanParamOptions(TextureNormalMapController)
      });
      /** @param specify the normal map COP node */
      this.normalMap = ParamConfig.NODE_PATH("", NodePathOptions(TextureNormalMapController, "useNormalMap"));
      /** @param type of normal map being used */
      this.normalMapType = ParamConfig.INTEGER(0, {
        visibleIf: { useNormalMap: 1 },
        menu: {
          entries: NORMAL_MAP_MODES.map((name, value) => {
            return { name, value };
          })
        }
      });
      /** @param How much the normal map affects the material. Typical ranges are 0-1 */
      this.normalScale = ParamConfig.VECTOR2([1, 1], { visibleIf: { useNormalMap: 1 } });
      /** @param Normal Map Scale Multiplier, which multiples normalScale */
      this.normalScaleMult = ParamConfig.FLOAT(1, {
        range: [0, 1],
        rangeLocked: [false, false],
        visibleIf: { useNormalMap: 1 }
      });
    }
  };
}
function isTextureNormalMapMaterial(material) {
  if (!material) {
    return false;
  }
  return material.normalScale != null;
}
class TextureNormalMapParamsConfig extends NormalMapParamConfig(NodeParamsConfig) {
}
class TextureNormalMapMatNode extends TypedMatNode {
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
const tmpN2 = [0, 0];
export class TextureNormalMapController extends BaseTextureMapController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  initializeNode() {
    this.add_hooks(this.node.p.useNormalMap, this.node.p.normalMap);
  }
  static async update(node) {
    node.controllers.normalMap.update();
  }
  async update() {
    const material = await this.node.material();
    if (!isTextureNormalMapMaterial(material)) {
      return;
    }
    await this.updateMaterial(material);
  }
  async updateMaterial(material) {
    const { p, pv } = this.node;
    await this._update(material, "normalMap", p.useNormalMap, p.normalMap);
    const normalMapType = NormalMapModeByName[NORMAL_MAP_MODES[pv.normalMapType]];
    const mat = material;
    mat.normalMapType = normalMapType;
    mat.normalScale.copy(pv.normalScale).multiplyScalar(pv.normalScaleMult);
  }
  getTextures(material, record) {
    record.set("normalMap", material.normalMap);
  }
  setParamsFromMaterial(material, record) {
    const mapNode = record.get("normalMap");
    const p = this.node.p;
    p.useNormalMap.set(mapNode != null);
    if (mapNode) {
      p.normalMap.setNode(mapNode, { relative: true });
    }
    material.normalScale.toArray(tmpN2);
    p.normalScale.set(tmpN2);
    p.normalMapType.set(NORMAL_MAP_MODES.indexOf(NormalNameByMode[material.normalMapType]));
  }
}
