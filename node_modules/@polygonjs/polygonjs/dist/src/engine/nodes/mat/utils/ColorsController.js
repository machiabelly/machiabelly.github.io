"use strict";
import { BaseController } from "./_BaseController";
import { TypedMatNode } from "../_Base";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../../core/BooleanValue";
import { ColorConversion } from "../../../../core/Color";
import { Color } from "three";
export function ColorParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param material color */
      this.color = ParamConfig.COLOR([1, 1, 1], {
        // conversion: ColorConversion.SRGB_TO_LINEAR,
      });
      /** @param defines if the color attribute on the geometry is used */
      this.useVertexColors = ParamConfig.BOOLEAN(0, { separatorAfter: true });
      /** @param sets the material to transparent */
      this.transparent = ParamConfig.BOOLEAN(0);
      /** @param sets the material opacity */
      this.opacity = ParamConfig.FLOAT(1);
      /** @param sets the min alpha below which the material is invisible */
      this.alphaTest = ParamConfig.FLOAT(0);
    }
  };
}
export function isValidColoredMaterial(material) {
  if (!material) {
    return false;
  }
  return material.color != null;
}
class ColorParamsConfig extends ColorParamConfig(NodeParamsConfig) {
}
class ColoredMatNode extends TypedMatNode {
  async material() {
    const container = await this.compute();
    return container.material();
  }
}
const _tmpColor = new Color();
const _tmpColorArray = [0, 0, 0];
export class ColorsController extends BaseController {
  constructor(node) {
    super(node);
    this.node = node;
  }
  static async update(node) {
    const container = await node.compute();
    const material = container.material();
    if (!isValidColoredMaterial(material)) {
      return;
    }
    node.controllers.colors.updateMaterial(material);
  }
  updateMaterial(material) {
    const pv = this.node.pv;
    material.color.copy(pv.color);
    const newVertexColor = isBooleanTrue(pv.useVertexColors);
    if (newVertexColor != material.vertexColors) {
      material.vertexColors = newVertexColor;
      material.needsUpdate = true;
    }
    material.opacity = pv.opacity;
    material.transparent = pv.transparent;
    material.alphaTest = pv.alphaTest;
  }
  setParamsFromMaterial(material, record) {
    const p = this.node.p;
    _tmpColor.copy(material.color).toArray(_tmpColorArray);
    p.color.set(_tmpColorArray);
    p.color.setConversion(ColorConversion.NONE);
    p.useVertexColors.set(material.vertexColors);
    p.opacity.set(material.opacity);
    p.transparent.set(material.transparent);
    p.alphaTest.set(material.alphaTest);
  }
}
