"use strict";
import { TypedSopNode } from "./_Base";
import { PaletteSopOperation } from "../../operations/sop/Palette";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import {
  SORTED_PALETTE_NAMES,
  MAX_PALETTE_COLORS_COUNT,
  visibleIfColorsCountAtLeast
} from "../../../core/color/chromotomeWrapper";
import { PaletteController, paletteControllerCallbackOptions } from "../utils/color/PaletteController";
import {
  AttribClassMenuEntriesWithoutCoreGroup,
  ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP
} from "../../../core/geometry/Constant";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = PaletteSopOperation.DEFAULT_PARAMS;
class PaletteSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param the attribute class (geometry or object) */
    this.class = ParamConfig.INTEGER(DEFAULT.class, {
      menu: {
        entries: AttribClassMenuEntriesWithoutCoreGroup
      }
    });
    /** @param name of the palette */
    this.paletteName = ParamConfig.STRING(DEFAULT.paletteName, {
      menuString: {
        entries: SORTED_PALETTE_NAMES.map((name, value) => {
          return { name, value: name };
        })
      },
      ...paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_updateColors)
    });
    /** @param click to set the node to the next palette */
    this.pickNext = ParamConfig.BUTTON(null, paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickNext));
    /** @param click to set the node to the previous palette */
    this.pickPrevious = ParamConfig.BUTTON(
      null,
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickPrevious)
    );
    /** @param click to set the node to a random palette */
    this.pickRandom = ParamConfig.BUTTON(
      null,
      paletteControllerCallbackOptions(PaletteController.PARAM_CALLBACK_pickRandom)
    );
    this.colorsCount = ParamConfig.INTEGER(DEFAULT.colorsCount, {
      hidden: true,
      range: [0, MAX_PALETTE_COLORS_COUNT],
      separatorAfter: true
    });
    /** @param palette color 1 */
    this.color1 = ParamConfig.COLOR(DEFAULT.color1.toArray(), {
      visibleIf: visibleIfColorsCountAtLeast(1)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 2 */
    this.color2 = ParamConfig.COLOR(DEFAULT.color2.toArray(), {
      visibleIf: visibleIfColorsCountAtLeast(2)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 3 */
    this.color3 = ParamConfig.COLOR(DEFAULT.color3.toArray(), {
      visibleIf: visibleIfColorsCountAtLeast(3)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 4 */
    this.color4 = ParamConfig.COLOR(DEFAULT.color4.toArray(), {
      visibleIf: visibleIfColorsCountAtLeast(4)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
    /** @param palette color 5 */
    this.color5 = ParamConfig.COLOR(DEFAULT.color5.toArray(), {
      visibleIf: visibleIfColorsCountAtLeast(5)
      // conversion: ColorConversion.SRGB_TO_LINEAR,
    });
  }
}
const ParamsConfig = new PaletteSopParamsConfig();
export class PaletteSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.paletteController = new PaletteController(
      this
    );
  }
  static type() {
    return SopType.PALETTE;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(PaletteSopOperation.INPUT_CLONED_STATE);
    this.params.onParamsCreated("palette_init", () => {
      PaletteController.PARAM_CALLBACK_updateColors(this);
    });
  }
  cook(input_contents) {
    this._operation = this._operation || new PaletteSopOperation(this._scene, this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
  //
  //
  // API UTILS
  //
  //
  setAttribClass(attribClass) {
    this.p.class.set(ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP.indexOf(attribClass));
  }
  attribClass() {
    return ATTRIBUTE_CLASSES_WITHOUT_CORE_GROUP[this.pv.class];
  }
}
