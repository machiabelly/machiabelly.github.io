"use strict";
import { NetworkNodeType } from "./../../poly/NodeContext";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
class SolverPreviousFrameSopParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SolverPreviousFrameSopParamsConfig();
export class SolverPreviousFrameSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._solverNodeDependencyCreated = false;
  }
  static type() {
    return "solverPreviousFrame";
  }
  cook() {
    const solverNode = this._solverNode();
    if (!solverNode) {
      this.states.error.set(`subnet input has no parent`);
      this.cookController.endCook();
      return;
    }
    this._createSolverNodeDependencyIfRequired();
    const previousFrameCoreGroup = solverNode.previousFrameCoreGroup();
    if (previousFrameCoreGroup) {
      this.setObjects(previousFrameCoreGroup.allObjects());
    } else {
      this.setObjects([]);
    }
  }
  _createSolverNodeDependencyIfRequired() {
    if (this._solverNodeDependencyCreated) {
      return;
    }
    const solverNode = this._solverNode();
    if (!solverNode) {
      return;
    }
    this.addGraphInput(solverNode.iterationStamp());
    this._solverNodeDependencyCreated = true;
  }
  _solverNode() {
    const solverNode = this.parentController.findParent((parent) => parent.type() == NetworkNodeType.SOLVER);
    if (!solverNode) {
      this.states.error.set("parent is not a solver node");
      return;
    }
    return solverNode;
  }
}
