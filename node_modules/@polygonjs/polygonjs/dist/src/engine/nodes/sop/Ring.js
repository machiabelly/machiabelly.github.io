"use strict";
import { TypedSopNode } from "./_Base";
import { RingSopOperation } from "../../operations/sop/Ring";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = RingSopOperation.DEFAULT_PARAMS;
const step = 1e-5;
class RingSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param inner radius of the ring */
    this.innerRadius = ParamConfig.FLOAT(DEFAULT.innerRadius);
    /** @param outer radius of the ring */
    this.outerRadius = ParamConfig.FLOAT(DEFAULT.outerRadius);
    /** @param segments count */
    this.thetaSegments = ParamConfig.INTEGER(DEFAULT.thetaSegments, {
      range: [0, 128],
      rangeLocked: [true, false]
    });
    /** @param segments count */
    this.phiSegments = ParamConfig.INTEGER(DEFAULT.phiSegments, {
      range: [0, 4],
      rangeLocked: [true, false]
    });
    /** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
    this.open = ParamConfig.BOOLEAN(DEFAULT.open);
    /** @param start of phi angle */
    this.angleStart = ParamConfig.FLOAT(DEFAULT.angleStart, {
      range: [0, Math.PI * 2],
      step,
      visibleIf: { open: true }
    });
    /** @param length of phi opening */
    this.angleLength = ParamConfig.FLOAT("$PI*2", {
      range: [0, Math.PI * 2],
      step,
      visibleIf: { open: true }
    });
    /** @param axis perpendicular to the plane */
    this.direction = ParamConfig.VECTOR3(DEFAULT.direction, {
      separatorBefore: true
    });
    /** @param center of the plane */
    this.center = ParamConfig.VECTOR3(DEFAULT.center);
  }
}
const ParamsConfig = new RingSopParamsConfig();
export class RingSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.RING;
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new RingSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(core_group);
  }
}
