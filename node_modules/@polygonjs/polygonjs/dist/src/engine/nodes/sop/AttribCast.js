"use strict";
import { TypedSopNode } from "./_Base";
import { AttribCastSopOperation, ATTRIB_TYPES } from "../../operations/sop/AttribCast";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
const DEFAULT = AttribCastSopOperation.DEFAULT_PARAMS;
class IndexCastSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param toggle on to cast attributes */
    this.castAttributes = ParamConfig.BOOLEAN(DEFAULT.castAttributes);
    /** @param attrib mask */
    this.mask = ParamConfig.STRING(DEFAULT.mask, {
      visibleIf: { castAttributes: 1 }
    });
    /** @param toggle on to cast index */
    this.castIndex = ParamConfig.BOOLEAN(DEFAULT.castIndex);
    /** @param type of attribute to cast to */
    this.type = ParamConfig.INTEGER(DEFAULT.type, {
      menu: {
        entries: ATTRIB_TYPES.map((name, value) => {
          return {
            name,
            value
          };
        })
      }
    });
  }
}
const ParamsConfig = new IndexCastSopParamsConfig();
export class AttribCastSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "attribCast";
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(AttribCastSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new AttribCastSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}
