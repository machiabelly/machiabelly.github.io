"use strict";
import { CoreAttribute } from "../../../../../core/geometry/Attribute";
import { initArrayIfRequired } from "./Common";
import { AttribType } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
import { primitivesFromObjectFromGroup } from "../../../../../core/geometry/entities/primitive/CorePrimitiveUtils";
import { corePrimitiveClassFactory } from "../../../../../core/geometry/CoreObjectFactory";
const _arraysByObject = {
  X: /* @__PURE__ */ new WeakMap(),
  Y: /* @__PURE__ */ new WeakMap(),
  Z: /* @__PURE__ */ new WeakMap(),
  W: /* @__PURE__ */ new WeakMap()
};
const arraysByGeometryUuid = [_arraysByObject.X, _arraysByObject.Y, _arraysByObject.Z, _arraysByObject.W];
export async function addPrimitiveAttribute(attribType, coreGroup, params) {
  const objects = coreGroup.allObjects();
  switch (attribType) {
    case AttribType.NUMERIC: {
      for (const object of objects) {
        await _addNumericAttributeToPrimitives(object, params);
      }
      return;
    }
    case AttribType.STRING: {
      for (const object of objects) {
        await _addStringAttributeToPrimitives(object, params);
      }
      return;
    }
  }
  TypeAssert.unreachable(attribType);
}
async function _addNumericAttributeToPrimitives(object, params) {
  const primitives = [];
  primitivesFromObjectFromGroup(object, params.group.value, primitives);
  const attribName = CoreAttribute.remapName(params.name.value);
  const size = params.size.value;
  const param = [params.value1, params.value2, params.value3, params.value4][size - 1];
  if (param.hasExpression()) {
    const primitiveClass = corePrimitiveClassFactory(object);
    let attribute = primitiveClass.attribute(object, attribName);
    if (!attribute) {
      const primitivesCount = primitiveClass.entitiesCount(object);
      const values = new Array(primitivesCount * size).fill(0);
      attribute = {
        array: values,
        itemSize: size,
        isString: false
      };
      primitiveClass.addAttribute(object, attribName, attribute);
    }
    const array = attribute.array;
    if (size == 1) {
      const paramN = params.value1;
      if (paramN.expressionController) {
        if (paramN.expressionController.entitiesDependent()) {
          await paramN.expressionController.computeExpressionForPrimitives(
            primitives,
            (primitive, value) => {
              array[primitive.index() * size + 0] = value;
            }
          );
        } else {
          for (const primitive of primitives) {
            array[primitive.index() * size + 0] = paramN.value;
          }
        }
      }
    } else {
      const vparam = [params.value2, params.value3, params.value4][size - 2];
      const components = vparam.components;
      const tmpArrays = new Array(components.length);
      for (let i = 0; i < components.length; i++) {
        const componentParam = components[i];
        if (componentParam.hasExpression() && componentParam.expressionController) {
          tmpArrays[i] = initArrayIfRequired(object, arraysByGeometryUuid[i], primitives.length);
          if (componentParam.expressionController.entitiesDependent()) {
            await componentParam.expressionController.computeExpressionForPrimitives(
              primitives,
              (point, value) => {
                tmpArrays[i][point.index()] = value;
              }
            );
          } else {
            for (const primitive of primitives) {
              tmpArrays[i][primitive.index()] = componentParam.value;
            }
          }
        } else {
          const value = componentParam.value;
          for (const primitive of primitives) {
            array[primitive.index() * size + i] = value;
          }
        }
      }
      for (let j = 0; j < tmpArrays.length; j++) {
        const tmpArray = tmpArrays[j];
        if (tmpArray != null) {
          for (let i = 0; i < tmpArray.length; i++) {
            const newVal = tmpArray[i];
            if (newVal != null) {
              array[i * size + j] = newVal;
            }
          }
        }
      }
    }
  } else {
  }
}
async function _addStringAttributeToPrimitives(object, params) {
  const primitives = [];
  primitivesFromObjectFromGroup(object, params.group.value, primitives);
  const param = params.string;
  const attribName = params.name.value;
  if (param.hasExpression() && param.expressionController) {
    const primitiveClass = corePrimitiveClassFactory(object);
    const primitivesCount = primitiveClass.entitiesCount(object);
    const values = new Array(primitivesCount).fill("");
    let attribute = primitiveClass.attribute(object, attribName);
    if (!attribute) {
      attribute = { array: values, itemSize: 1, isString: true };
      primitiveClass.addAttribute(object, attribName, attribute);
    }
    if (param.expressionController.entitiesDependent()) {
      await param.expressionController.computeExpressionForPrimitives(primitives, (primitive, value) => {
        values[primitive.index()] = value;
      });
    } else {
      for (const primitive of primitives) {
        values[primitive.index()] = param.value;
      }
    }
  } else {
  }
}
