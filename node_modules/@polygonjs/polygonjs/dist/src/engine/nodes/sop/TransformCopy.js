"use strict";
import { TypedSopNode } from "./_Base";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { NodeContext } from "../../poly/NodeContext";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { SopType } from "../../poly/registers/nodes/types/Sop";
class TransformCopySopParamConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param toggle on if the second input should be used */
    this.useSecondInput = ParamConfig.BOOLEAN(1);
    /** @param use a reference object */
    this.reference = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.SOP
      },
      visibleIf: { useSecondInput: 0 }
    });
  }
}
const ParamsConfig = new TransformCopySopParamConfig();
export class TransformCopySopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.TRANSFORM_COPY;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState([InputCloneMode.FROM_NODE, InputCloneMode.NEVER]);
  }
  cook(input_contents) {
    if (isBooleanTrue(this.pv.useSecondInput) && input_contents[1]) {
      this._copy_from_src_objects(input_contents[0].threejsObjects(), input_contents[1].threejsObjects());
    } else {
      this._copy_from_found_node(input_contents[0].threejsObjects());
    }
  }
  _copy_from_src_objects(target_objects, src_objects) {
    let target_object;
    let src_object;
    for (let i = 0; i < target_objects.length; i++) {
      target_object = target_objects[i];
      src_object = src_objects[i];
      src_object.updateMatrix();
      target_object.matrix.copy(src_object.matrix);
      target_object.matrix.decompose(target_object.position, target_object.quaternion, target_object.scale);
    }
    this.setObjects(target_objects);
  }
  async _copy_from_found_node(target_objects) {
    const node = this.pv.reference.nodeWithContext(NodeContext.SOP, this.states.error);
    if (node) {
      const container = await node.compute();
      const core_group = container.coreContent();
      if (core_group) {
        const src_objects = core_group.threejsObjects();
        this._copy_from_src_objects(target_objects, src_objects);
        return;
      }
    }
    this.setObjects(target_objects);
  }
}
