"use strict";
import { TypedSopNode } from "./_Base";
import {
  HierarchyMode,
  HierarchySopOperation,
  HIERARCHY_MODES,
  ADD_CHILD_MODES
} from "../../operations/sop/Hierarchy";
export const MODES_WITH_LEVEL = [HierarchyMode.ADD_PARENT, HierarchyMode.REMOVE_PARENT];
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = HierarchySopOperation.DEFAULT_PARAMS;
class HierarchySopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param defines if parent objects will be added or removed */
    this.mode = ParamConfig.INTEGER(DEFAULT.mode, {
      menu: {
        entries: HIERARCHY_MODES.map((m, i) => {
          return { name: m, value: i };
        })
      }
    });
    /** @param defines how many parent objects will be added or removed */
    this.levels = ParamConfig.INTEGER(DEFAULT.levels, {
      range: [0, 5],
      visibleIf: [
        { mode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_PARENT) },
        { mode: HIERARCHY_MODES.indexOf(HierarchyMode.REMOVE_PARENT) }
      ]
    });
    /** @param when the mode is set to add_child, the mask defines which parent the children are added to. If the mask is an empty string, the children will be added to the objects at the top of the hierarchy. Also, the children are taken from the second input. */
    this.objectMask = ParamConfig.STRING("", {
      visibleIf: { mode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_CHILD) },
      objectMask: true
    });
    /** @param defines how the children are added to the parents */
    this.addChildMode = ParamConfig.INTEGER(DEFAULT.addChildMode, {
      visibleIf: { mode: HIERARCHY_MODES.indexOf(HierarchyMode.ADD_CHILD) },
      menu: {
        entries: ADD_CHILD_MODES.map((m, i) => {
          return { name: m, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new HierarchySopParamsConfig();
export class HierarchySopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.HIERARCHY;
  }
  initializeNode() {
    this.io.inputs.setCount(1, 2);
    this.io.inputs.initInputsClonedState(HierarchySopOperation.INPUT_CLONED_STATE);
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new HierarchySopOperation(this._scene, this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setMode(mode) {
    this.p.mode.set(HIERARCHY_MODES.indexOf(mode));
  }
  setAddChildMode(mode) {
    this.p.addChildMode.set(ADD_CHILD_MODES.indexOf(mode));
  }
}
