"use strict";
import { CoreMapboxTransform } from "../../../core/thirdParty/Mapbox/Transform";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TypedSopNode } from "./_Base";
import { TransformTargetType, TRANSFORM_TARGET_TYPES } from "../../../core/Transform";
import { TypeAssert } from "../../poly/Assert";
import { SopType } from "../../poly/registers/nodes/types/Sop";
class MapboxTransformSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param sets if this node should transform objects or geometries */
    this.applyOn = ParamConfig.INTEGER(TRANSFORM_TARGET_TYPES.indexOf(TransformTargetType.GEOMETRY), {
      menu: {
        entries: TRANSFORM_TARGET_TYPES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param camera longitude */
    this.longitude = ParamConfig.FLOAT(0, {
      range: [-360, 360]
    });
    /** @param camera latitude */
    this.latitude = ParamConfig.FLOAT(0, {
      range: [-90, 90]
    });
  }
}
const ParamsConfig = new MapboxTransformSopParamsConfig();
export class MapboxTransformSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._transformer = new CoreMapboxTransform();
  }
  static type() {
    return SopType.MAPBOX_TRANSFORM;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  cook(inputContents) {
    const coreGroup = inputContents[0];
    this._transformer.setLngLat({
      lng: this.pv.longitude,
      lat: this.pv.latitude
    });
    const objects = coreGroup.threejsObjects();
    this._applyTransform(objects);
    this.setCoreGroup(coreGroup);
  }
  _applyTransform(objects) {
    const mode = TRANSFORM_TARGET_TYPES[this.pv.applyOn];
    switch (mode) {
      case TransformTargetType.GEOMETRY: {
        return this._updateGeometries(objects);
      }
      case TransformTargetType.OBJECT: {
        return this._updateObjects(objects);
      }
    }
    TypeAssert.unreachable(mode);
  }
  _updateGeometries(objects) {
    for (const object of objects) {
      this._transformer.transform_groupGeometry_FINAL(object);
    }
  }
  _updateObjects(objects) {
    for (const object of objects) {
      this._transformer.transform_groupObject_FINAL(object);
    }
  }
  // private _transformInput(core_group: CoreGroup) {
  // }
  // _postInitController() {}
}
