"use strict";
import { TypedSopNode } from "./_Base";
import { UvUnwrapSopOperation, UV_UNWRAP_METHODS, UvUnwrapMethod } from "../../operations/sop/UvUnwrap";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = UvUnwrapSopOperation.DEFAULT_PARAMS;
class UvUnwrapSopParamConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param method */
    this.method = ParamConfig.INTEGER(DEFAULT.method, {
      menu: {
        entries: UV_UNWRAP_METHODS.map((name, value) => ({ name, value }))
      }
    });
    /** @param attribute to unwrap */
    this.uv = ParamConfig.STRING(DEFAULT.uv);
    /** @param target texture resolution */
    this.resolution = ParamConfig.INTEGER(DEFAULT.resolution, {
      range: [16, 4096],
      rangeLocked: [true, false],
      visibleIf: {
        method: UV_UNWRAP_METHODS.indexOf(UvUnwrapMethod.XATLAS)
      }
    });
    /** @param padding */
    this.padding = ParamConfig.INTEGER(DEFAULT.padding, {
      range: [0, 10],
      rangeLocked: [true, false],
      visibleIf: {
        method: UV_UNWRAP_METHODS.indexOf(UvUnwrapMethod.XATLAS)
      }
    });
  }
}
const ParamsConfig = new UvUnwrapSopParamConfig();
export class UvUnwrapSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.UV_UNWRAP;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(UvUnwrapSopOperation.INPUT_CLONED_STATE);
  }
  async cook(inputCoreGroups) {
    this._operation = this._operation || new UvUnwrapSopOperation(this.scene(), this.states, this);
    const coreGroup = await this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  setMethod(method) {
    this.p.method.set(UV_UNWRAP_METHODS.indexOf(method));
  }
}
