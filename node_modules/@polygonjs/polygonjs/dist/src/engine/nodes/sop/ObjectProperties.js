"use strict";
import { TypedSopNode } from "./_Base";
import { ObjectPropertiesSopOperation } from "../../operations/sop/ObjectProperties";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/Type";
import { filterCoreObjectsFromCoreGroup } from "../../../core/geometry/Mask";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = ObjectPropertiesSopOperation.DEFAULT_PARAMS;
class ObjectPropertiesSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param group to assign the material to */
    this.group = ParamConfig.STRING(DEFAULT.group, {
      objectMask: true
    });
    /** @param toggle on to set a new name */
    this.tname = ParamConfig.BOOLEAN(DEFAULT.tname);
    /** @param new name */
    this.name = ParamConfig.STRING(DEFAULT.name, {
      visibleIf: { tname: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to set a new render order */
    this.trenderOrder = ParamConfig.BOOLEAN(DEFAULT.trenderOrder);
    /** @param render order */
    this.renderOrder = ParamConfig.INTEGER(DEFAULT.renderOrder, {
      visibleIf: { trenderOrder: true },
      range: [0, 10],
      rangeLocked: [false, false],
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set frustrumCulled */
    this.tfrustumCulled = ParamConfig.BOOLEAN(DEFAULT.tfrustumCulled);
    /** @param sets frustrumCulled */
    this.frustumCulled = ParamConfig.BOOLEAN(DEFAULT.frustumCulled, {
      visibleIf: { tfrustumCulled: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set matrixAutoUpdate */
    this.tmatrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.tmatrixAutoUpdate);
    /** @param sets matrixAutoUpdate */
    this.matrixAutoUpdate = ParamConfig.BOOLEAN(DEFAULT.matrixAutoUpdate, {
      visibleIf: { tmatrixAutoUpdate: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set visible */
    this.tvisible = ParamConfig.BOOLEAN(DEFAULT.tvisible);
    /** @param sets visible */
    this.visible = ParamConfig.BOOLEAN(DEFAULT.visible, {
      visibleIf: { tvisible: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set castShadow */
    this.tcastShadow = ParamConfig.BOOLEAN(DEFAULT.tcastShadow);
    /** @param sets castShadow */
    this.castShadow = ParamConfig.BOOLEAN(DEFAULT.castShadow, {
      visibleIf: { tcastShadow: true },
      separatorAfter: true,
      expression: { forEntities: true }
    });
    /** @param toggle on to allow to set receiveShadow */
    this.treceiveShadow = ParamConfig.BOOLEAN(DEFAULT.treceiveShadow);
    /** @param sets receiveShadow */
    this.receiveShadow = ParamConfig.BOOLEAN(DEFAULT.receiveShadow, {
      visibleIf: { treceiveShadow: true },
      expression: { forEntities: true }
    });
  }
}
const ParamsConfig = new ObjectPropertiesSopParamsConfig();
export class ObjectPropertiesSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.OBJECT_PROPERTIES;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(ObjectPropertiesSopOperation.INPUT_CLONED_STATE);
  }
  async cook(inputCoreGroups) {
    this._operation = this._operation || new ObjectPropertiesSopOperation(this.scene(), this.states, this);
    const paramWithExpression = this.params.all.find((param) => param.hasExpression());
    if (paramWithExpression) {
      const coreGroup = inputCoreGroups[0];
      await this._cookWithExpressions(coreGroup);
      this.setCoreGroup(coreGroup);
    } else {
      const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
      this.setCoreGroup(coreGroup);
    }
  }
  async _cookWithExpressions(coreGroup) {
    const selectedCoreObjects = filterCoreObjectsFromCoreGroup(coreGroup, this.pv);
    await this._cookWithExpressionsForCoreObjects(selectedCoreObjects);
  }
  async _cookWithExpressionsForCoreObjects(entities) {
    const p = this.p;
    async function applyStringParam(booleanParam, valueParam, property) {
      if (isBooleanTrue(booleanParam.value)) {
        if (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {
          await valueParam.expressionController.computeExpressionForObjects(
            entities,
            (entity, value) => {
              entity.object()[property] = value;
            }
          );
        } else {
          for (const entity of entities) {
            const object = entity.object();
            if (object) {
              object[property] = valueParam.value;
            }
          }
        }
      }
    }
    async function applyNumberParam(booleanParam, valueParam, property) {
      if (isBooleanTrue(booleanParam.value)) {
        if (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {
          await valueParam.expressionController.computeExpressionForObjects(
            entities,
            (entity, value) => {
              entity.object()[property] = value;
            }
          );
        } else {
          for (const entity of entities) {
            const object = entity.object();
            if (object) {
              object[property] = valueParam.value;
            }
          }
        }
      }
    }
    async function applyBooleanParam(booleanParam, valueParam, property) {
      if (isBooleanTrue(booleanParam.value)) {
        if (valueParam.expressionController && valueParam.expressionController.entitiesDependent()) {
          await valueParam.expressionController.computeExpressionForObjects(
            entities,
            (entity, value) => {
              entity.object()[property] = value;
            }
          );
        } else {
          for (const entity of entities) {
            const object = entity.object();
            if (object) {
              object[property] = valueParam.value;
            }
          }
        }
      }
    }
    await Promise.all([
      applyStringParam(p.tname, p.name, "name"),
      applyNumberParam(p.trenderOrder, p.renderOrder, "renderOrder"),
      applyBooleanParam(p.tfrustumCulled, p.frustumCulled, "frustumCulled"),
      applyBooleanParam(p.tmatrixAutoUpdate, p.matrixAutoUpdate, "matrixAutoUpdate"),
      applyBooleanParam(p.tvisible, p.visible, "visible"),
      applyBooleanParam(p.tcastShadow, p.castShadow, "castShadow"),
      applyBooleanParam(p.treceiveShadow, p.receiveShadow, "receiveShadow")
    ]);
  }
}
