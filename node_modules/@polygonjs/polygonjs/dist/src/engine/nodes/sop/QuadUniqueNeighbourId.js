"use strict";
import { QuadSopNode } from "./_BaseQuad";
import { Vector3 } from "three";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { QuadPrimitive } from "../../../core/geometry/modules/quad/QuadPrimitive";
import { primitivesFromObject } from "../../../core/geometry/entities/primitive/CorePrimitiveUtils";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { quadGraphFromQuadObject } from "../../../core/geometry/modules/quad/graph/QuadGraphUtils";
const _primitives = [];
export const _indices = {
  i0: 0,
  i1: 0,
  i2: 0,
  i3: 0
};
export const _positions = {
  p0: new Vector3(),
  p1: new Vector3(),
  p2: new Vector3(),
  p3: new Vector3()
};
export const _insetPositions = {
  p0: new Vector3(),
  p1: new Vector3(),
  p2: new Vector3(),
  p3: new Vector3()
};
const neighbourIdsSharingPoint = [];
const neighbourIdsSharingEdge = [];
const neighbourColorIds = /* @__PURE__ */ new Set();
class QuadUniqueNeighbourIdSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param attribName */
    this.attribName = ParamConfig.STRING("colorId");
  }
}
const ParamsConfig = new QuadUniqueNeighbourIdSopParamsConfig();
export class QuadUniqueNeighbourIdSopNode extends QuadSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.QUAD_UNIQUE_NEIGHBOUR_ID;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    const objects = coreGroup.quadObjects();
    if (!objects) {
      this.states.error.set(`no quad objects found`);
      return;
    }
    for (const object of objects) {
      this._processObject(object);
    }
    this.setQuadObjects(objects);
  }
  _processObject(object) {
    const graph = quadGraphFromQuadObject(object);
    const colorIdByQuadId = /* @__PURE__ */ new Map();
    const firstQuad = graph.quadNode(0);
    if (!firstQuad) {
      return;
    }
    const stack = [firstQuad];
    let maxColorId = 0;
    while (stack.length > 0) {
      const currentQuad = stack.pop();
      const quadId = currentQuad.id;
      if (!colorIdByQuadId.has(quadId)) {
        graph.neighbourIdsSharingEdge(quadId, neighbourIdsSharingEdge);
        graph.neighbourIdsSharingPoint(quadId, neighbourIdsSharingPoint);
        neighbourColorIds.clear();
        for (const neighbourId of neighbourIdsSharingEdge) {
          const colorId = colorIdByQuadId.get(neighbourId);
          if (colorId != null) {
            neighbourColorIds.add(colorId);
          }
        }
        for (let i2 = 0; i2 < maxColorId; i2++) {
          if (!neighbourColorIds.has(i2)) {
            colorIdByQuadId.set(quadId, i2);
            break;
          }
        }
        if (!colorIdByQuadId.has(quadId)) {
          colorIdByQuadId.set(quadId, maxColorId);
          maxColorId++;
        }
        for (const neighbourId of neighbourIdsSharingPoint) {
          const quadNode = graph.quadNode(neighbourId);
          if (quadNode) {
            stack.push(quadNode);
          }
        }
      }
    }
    const attribName = this.pv.attribName;
    let attribute = QuadPrimitive.attribute(object, attribName);
    if (!attribute) {
      const primitivesCount = QuadPrimitive.entitiesCount(object);
      const values = new Array(primitivesCount * 1).fill(-1);
      attribute = { array: values, itemSize: 1, isString: false };
      QuadPrimitive.addAttribute(object, attribName, attribute);
    }
    primitivesFromObject(object, _primitives);
    let i = 0;
    for (const primitive of _primitives) {
      const colorId = colorIdByQuadId.get(i);
      if (colorId != null) {
        primitive.setAttribValue(attribName, colorId);
      }
      i++;
    }
  }
}
