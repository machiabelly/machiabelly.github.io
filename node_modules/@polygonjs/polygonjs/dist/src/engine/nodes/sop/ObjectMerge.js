"use strict";
import { TypedSopNode } from "./_Base";
import { NodeContext } from "../../poly/NodeContext";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
class ObjectMergeSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param which SOP node to import from */
    this.geometry = ParamConfig.NODE_PATH("", {
      nodeSelection: {
        context: NodeContext.SOP
      }
    });
  }
}
const ParamsConfig = new ObjectMergeSopParamsConfig();
export class ObjectMergeSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "objectMerge";
  }
  async cook(input_containers) {
    const geometryNode = this.pv.geometry.nodeWithContext(NodeContext.SOP, this.states.error);
    if (!geometryNode) {
      this.states.error.set(`node not found at path '${this.pv.geometry}'`);
      return;
    }
    const container = await geometryNode.compute();
    this.importInput(geometryNode, container);
  }
  importInput(geometry_node, container) {
    let core_group;
    if ((core_group = container.coreContentCloned()) != null) {
      this.setCoreGroup(core_group);
    } else {
      this.states.error.set("invalid target");
    }
  }
}
