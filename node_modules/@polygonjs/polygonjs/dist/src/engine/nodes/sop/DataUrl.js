"use strict";
import { TypedSopNode } from "./_Base";
import { JsonDataLoader } from "../../../core/loader/geometry/JSONDataLoader";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { CsvLoader } from "../../../core/loader/geometry/Csv";
import { ObjectType } from "../../../core/geometry/Constant";
import { ASSETS_ROOT } from "../../../core/loader/AssetsUtils";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { Poly } from "../../Poly";
import { ParamEvent } from "../../poly/ParamEvent";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT } from "../../../core/loader/FileExtensionRegister";
import { NodeContext } from "../../poly/NodeContext";
export var DataType = /* @__PURE__ */ ((DataType2) => {
  DataType2["JSON"] = "json";
  DataType2["CSV"] = "csv";
  return DataType2;
})(DataType || {});
export const DATA_TYPES = ["json" /* JSON */, "csv" /* CSV */];
const DEFAULT_URL = `${ASSETS_ROOT}/nodes/sop/DataUrl/basic.json`;
class DataUrlSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param sets if the data is interpreted as json or csv */
    this.dataType = ParamConfig.INTEGER(DATA_TYPES.indexOf("json" /* JSON */), {
      menu: {
        entries: DATA_TYPES.map((t, i) => {
          return {
            name: t,
            value: i
          };
        })
      }
    });
    /** @param the url to fetch the data from */
    this.url = ParamConfig.STRING(DEFAULT_URL, {
      fileBrowse: { extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.SOP][SopType.DATA_URL] }
    });
    //
    // JSON params
    //
    /** @param if the data is inside the payload, defines the prefix to read it from here */
    this.jsonDataKeysPrefix = ParamConfig.STRING("", {
      visibleIf: { dataType: DATA_TYPES.indexOf("json" /* JSON */) }
    });
    /** @param which entries are skipped */
    this.skipEntries = ParamConfig.STRING("", {
      visibleIf: { dataType: DATA_TYPES.indexOf("json" /* JSON */) }
    });
    /** @param sets if some attributes should be converted */
    this.convert = ParamConfig.BOOLEAN(0, {
      visibleIf: { dataType: DATA_TYPES.indexOf("json" /* JSON */) }
    });
    /** @param sets which attributes should be converted from string to numeric */
    this.convertToNumeric = ParamConfig.STRING("", {
      visibleIf: {
        dataType: DATA_TYPES.indexOf("json" /* JSON */),
        convert: 1
      }
    });
    //
    // CSV params
    //
    /** @param when fetching from a csv, the attribute names will not be present. Those can then be mentioned here */
    this.readAttribNamesFromFile = ParamConfig.BOOLEAN(1, {
      visibleIf: { dataType: DATA_TYPES.indexOf("csv" /* CSV */) }
    });
    /** @param list of attributes names when fetching from a csv */
    this.attribNames = ParamConfig.STRING("height scale", {
      visibleIf: {
        dataType: DATA_TYPES.indexOf("csv" /* CSV */),
        readAttribNamesFromFile: 0
      }
    });
    //
    // reload
    //
    /** @param reload the url */
    this.reload = ParamConfig.BUTTON(null, {
      callback: (node, param) => {
        DataUrlSopNode.PARAM_CALLBACK_reload(node, param);
      }
    });
  }
}
const ParamsConfig = new DataUrlSopParamsConfig();
export class DataUrlSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.DATA_URL;
  }
  async cook() {
    this._load();
  }
  _load() {
    switch (DATA_TYPES[this.pv.dataType]) {
      case "json" /* JSON */:
        return this._loadJSON();
      case "csv" /* CSV */:
        return this._loadCSV();
    }
  }
  // private _clearLoadedBlob() {
  // 	switch (DATA_TYPES[this.pv.dataType]) {
  // 		case DataType.JSON:
  // 			return this._resetJSON();
  // 		case DataType.CSV:
  // 			return this._resetCSV();
  // 	}
  // }
  dispose() {
    super.dispose();
    Poly.blobs.clearBlobsForNode(this);
  }
  _url() {
    return this.pv.url;
  }
  //
  //
  // JSON
  //
  //
  _loadJSON() {
    const loader = new JsonDataLoader(
      this._url(),
      {
        dataKeysPrefix: this.pv.jsonDataKeysPrefix,
        skipEntries: this.pv.skipEntries,
        doConvert: isBooleanTrue(this.pv.convert),
        convertToNumeric: this.pv.convertToNumeric
      },
      this
    );
    loader.load(this._onLoad.bind(this), void 0, this._onError.bind(this));
  }
  // private _resetJSON() {
  // 	const loader = new JsonDataLoader(this._url(), this.scene());
  // 	loader.deregisterUrl();
  // }
  _onLoad(geometry) {
    this.setGeometry(geometry, ObjectType.POINTS);
  }
  _onError(error) {
    this.states.error.set(`could not load geometry from ${this._url()} (${error})`);
    this.cookController.endCook();
  }
  //
  //
  // CSV
  //
  //
  async _loadCSV() {
    const attribNames = isBooleanTrue(this.pv.readAttribNamesFromFile) ? void 0 : this.pv.attribNames.split(" ");
    const loader = new CsvLoader(this._url(), attribNames, this);
    const geometry = await loader.load();
    if (geometry) {
      this.setGeometry(geometry, ObjectType.POINTS);
    } else {
      this.states.error.set("could not generate points");
    }
  }
  // private _resetCSV() {
  // 	const attribNames: string[] = [];
  // 	const loader = new CsvLoader(this._url(), this.scene(), attribNames, this);
  // 	loader.deregisterUrl();
  // }
  // async _on_open_url(){
  // 	const url = await this.param('url').eval_p()
  // 	const a = document.createElement('a')
  // 	a.href = url
  // 	a.setAttribute('target', '_blank')
  // 	a.click()
  // }
  static PARAM_CALLBACK_reload(node, param) {
    node.param_callback_reload();
  }
  param_callback_reload() {
    this.p.url.setDirty();
    this.p.url.emit(ParamEvent.ASSET_RELOAD_REQUEST);
  }
}
