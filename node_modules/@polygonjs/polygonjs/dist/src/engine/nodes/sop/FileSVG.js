"use strict";
import { ParamEvent } from "./../../poly/ParamEvent";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { FileSVGSopOperation } from "../../operations/sop/FileSVG";
import { Poly } from "../../Poly";
import { SopTypeFile } from "../../poly/registers/nodes/types/Sop";
import { EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT } from "../../../core/loader/FileExtensionRegister";
import { NodeContext } from "../../poly/NodeContext";
const DEFAULT = FileSVGSopOperation.DEFAULT_PARAMS;
class FileSVGSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param url to load the geometry from */
    this.url = ParamConfig.STRING(DEFAULT.url, {
      fileBrowse: { extensions: EXTENSIONS_BY_NODE_TYPE_BY_CONTEXT[NodeContext.SOP][SopTypeFile.FILE_SVG] }
    });
    /** @param reload the geometry */
    this.reload = ParamConfig.BUTTON(null, {
      callback: (node, param) => {
        FileSVGSopNode.PARAM_CALLBACK_reload(node);
      }
    });
    /** @param toggle on to draw the fillShapes */
    this.drawFillShapes = ParamConfig.BOOLEAN(DEFAULT.drawFillShapes);
    /** @param toggle on to draw the fillShapes as wireframe */
    this.fillShapesWireframe = ParamConfig.BOOLEAN(DEFAULT.fillShapesWireframe);
    /** @param toggle on to draw the strokes */
    this.drawStrokes = ParamConfig.BOOLEAN(DEFAULT.drawStrokes);
    /** @param toggle on to draw the strokes as wireframe */
    this.strokesWireframe = ParamConfig.BOOLEAN(DEFAULT.strokesWireframe);
    /** @param style override */
    this.tStyleOverride = ParamConfig.BOOLEAN(DEFAULT.tStyleOverride, {
      separatorBefore: true
    });
    /** @param stroke width */
    this.strokeWidth = ParamConfig.FLOAT(DEFAULT.strokeWidth, {
      visibleIf: {
        tStyleOverride: true
      }
    });
    /** @param advanced */
    this.tadvanced = ParamConfig.BOOLEAN(DEFAULT.tadvanced, {
      separatorBefore: true
    });
    /** @param is counter clock wise: defines the vertex order when parsing the font */
    this.isCCW = ParamConfig.BOOLEAN(0, {
      visibleIf: { tadvanced: true }
    });
  }
  /** @param defines if holes should be found when parsing the font */
  // noHoles = ParamConfig.BOOLEAN(0, {
  // 	visibleIf: {tadvanced: true},
  // });
}
const ParamsConfig = new FileSVGSopParamsConfig();
export class FileSVGSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopTypeFile.FILE_SVG;
  }
  dispose() {
    super.dispose();
    Poly.blobs.clearBlobsForNode(this);
  }
  async cook(inputCoreGroups) {
    this._operation = this._operation || new FileSVGSopOperation(this.scene(), this.states, this);
    const coreGroup = await this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  static PARAM_CALLBACK_reload(node) {
    node.param_callback_reload();
  }
  param_callback_reload() {
    this.p.url.setDirty();
    this.p.url.emit(ParamEvent.ASSET_RELOAD_REQUEST);
  }
}
