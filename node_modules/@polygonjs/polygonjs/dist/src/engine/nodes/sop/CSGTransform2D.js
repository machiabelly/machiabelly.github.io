"use strict";
import { CSGSopNode } from "./_BaseCSG";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { MathUtils, Vector3, Euler, Quaternion, Matrix4 } from "three";
const _t = new Vector3();
const _r = new Vector3();
const _euler = new Euler();
const _q = new Quaternion();
const _s = new Vector3();
const _mat4 = new Matrix4();
class CSGTransform2DSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param translate */
    this.t = ParamConfig.VECTOR2([0, 0]);
    /** @param rotation */
    this.r = ParamConfig.FLOAT(0, {
      range: [-180, 180],
      rangeLocked: [false, false]
    });
    /** @param scale (as a float) */
    this.s = ParamConfig.FLOAT(1, {
      range: [0, 2],
      step: 0.01
    });
  }
  /** @param pivot */
  // pivot = ParamConfig.VECTOR2([0, 0]);
}
const ParamsConfig = new CSGTransform2DSopParamsConfig();
export class CSGTransform2DSopNode extends CSGSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CSG_TRANSFORM_2D;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  async cook(inputCoreGroups) {
    const coreGroup0 = inputCoreGroups[0];
    const newObjects = [];
    const csgObjects = coreGroup0.csgObjects();
    if (csgObjects) {
      _t.set(this.pv.t.x, 0, this.pv.t.y);
      _r.set(0, this.pv.r, 0).multiplyScalar(MathUtils.DEG2RAD);
      _euler.y = _r.y;
      _q.setFromEuler(_euler);
      _s.set(1, 1, 1).multiplyScalar(this.pv.s);
      _mat4.compose(_t, _q, _s);
      for (const csgObject of csgObjects) {
        csgObject.applyMatrix4(_mat4);
        newObjects.push(csgObject);
      }
    }
    this.setCSGObjects(newObjects);
  }
}
