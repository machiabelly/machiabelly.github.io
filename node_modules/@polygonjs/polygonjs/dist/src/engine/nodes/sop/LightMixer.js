"use strict";
import { TypedSopNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { ParamType } from "../../poly/ParamType";
import { FloatParam } from "../../params/Float";
import { ColorParam } from "../../params/Color";
var SUFFIX = /* @__PURE__ */ ((SUFFIX2) => {
  SUFFIX2["INTENSITY"] = "_int";
  SUFFIX2["COLOR"] = "_col";
  return SUFFIX2;
})(SUFFIX || {});
function intensityParamName(lightName) {
  return `${lightName}${"_int" /* INTENSITY */}`;
}
function colorParamName(lightName) {
  return `${lightName}${"_col" /* COLOR */}`;
}
class LightMixerParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param size of the box */
    this.setup = ParamConfig.BUTTON(null, {
      callback: (node) => {
        LightMixerSopNode.PARAM_CALLBACK_setup(node);
      }
    });
  }
}
const ParamsConfig = new LightMixerParamsConfig();
export class LightMixerSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._lightsByName = /* @__PURE__ */ new Map();
  }
  static type() {
    return "lightMixer";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(InputCloneMode.FROM_NODE);
  }
  cook(inputCoreGroups) {
    const coreGroup = inputCoreGroups[0];
    this._findLights(coreGroup);
    this._lightsByName.forEach((light, lightName) => {
      const intensityParam = this.params.get(intensityParamName(lightName));
      const colorParam = this.params.get(colorParamName(lightName));
      if (intensityParam && intensityParam instanceof FloatParam) {
        light.intensity = intensityParam.value;
      }
      if (colorParam && colorParam instanceof ColorParam) {
        light.color.copy(colorParam.value);
      }
    });
    this.setCoreGroup(coreGroup);
  }
  _findLights(coreGroup) {
    this._lightsByName.clear();
    const objects = coreGroup.threejsObjects();
    for (const object of objects) {
      object.traverse((child) => {
        if (child.isLight) {
          this._lightsByName.set(child.name, child);
        }
      });
    }
  }
  static PARAM_CALLBACK_setup(node) {
    node._paramCallbackSetup();
  }
  async _paramCallbackSetup() {
    this.states.error.clear();
    this.params.updateParams({ namesToDelete: this.params.spare.map((p) => p.name()) });
    const inputNode = this.io.inputs.input(0);
    if (!inputNode) {
      this.states.error.set("no input node");
      return;
    }
    const container = await inputNode.compute();
    const coreGroup = container.coreContent();
    if (!coreGroup) {
      this.states.error.set("failed to cook input node");
      return;
    }
    this._findLights(coreGroup);
    const paramsDataToAdd = [];
    this._lightsByName.forEach((light, lightName) => {
      const intensity = {
        name: intensityParamName(lightName),
        type: ParamType.FLOAT,
        initValue: light.intensity,
        rawInput: light.intensity,
        options: {
          range: [0, 2],
          rangeLocked: [true, false],
          spare: true
        }
      };
      const color = {
        name: colorParamName(lightName),
        type: ParamType.COLOR,
        initValue: light.color.toArray(),
        rawInput: light.color.toArray(),
        options: {
          separatorAfter: true,
          spare: true
        }
      };
      paramsDataToAdd.push(intensity);
      paramsDataToAdd.push(color);
    });
    this.params.updateParams({ toAdd: paramsDataToAdd });
  }
}
