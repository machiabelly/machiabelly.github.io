"use strict";
import { TypedSopNode } from "./_Base";
import { SphereSopOperation, SPHERE_TYPES, SPHERE_TYPE } from "../../operations/sop/Sphere";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = SphereSopOperation.DEFAULT_PARAMS;
const step = 1e-5;
class SphereSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param type of sphere (default sphere or isocahedron) */
    this.type = ParamConfig.INTEGER(DEFAULT.type, {
      menu: {
        entries: SPHERE_TYPES.map((name) => {
          return { name, value: SPHERE_TYPE[name] };
        })
      }
    });
    /** @param radius of the sphere when the type is default */
    this.radius = ParamConfig.FLOAT(DEFAULT.radius, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    /** @param resolution - number of segments in x and y */
    this.resolution = ParamConfig.VECTOR2(DEFAULT.resolution, { visibleIf: { type: SPHERE_TYPE.default } });
    /** @param if set to 1, you can then set the phiStart, phi_end, thetaStart and theta_end */
    this.open = ParamConfig.BOOLEAN(DEFAULT.open, { visibleIf: { type: SPHERE_TYPE.default } });
    /** @param start of phi angle */
    this.phiStart = ParamConfig.FLOAT(DEFAULT.phiStart, {
      range: [0, Math.PI * 2],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    /** @param length of phi opening */
    this.phiLength = ParamConfig.FLOAT("$PI*2", {
      range: [0, Math.PI * 2],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    /** @param start of theta angle */
    this.thetaStart = ParamConfig.FLOAT(DEFAULT.thetaStart, {
      range: [0, Math.PI],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    /** @param length of theta opening */
    this.thetaLength = ParamConfig.FLOAT("$PI", {
      range: [0, Math.PI],
      visibleIf: { type: SPHERE_TYPE.default, open: true },
      step
    });
    /** @param resolution of the sphere when the type is isocahedron */
    this.detail = ParamConfig.INTEGER(DEFAULT.detail, {
      range: [0, 5],
      rangeLocked: [true, false],
      visibleIf: { type: SPHERE_TYPE.isocahedron }
    });
    /** @param center of the sphere */
    this.center = ParamConfig.VECTOR3(DEFAULT.center);
    /** @param create lines instead of polygons */
    this.asLines = ParamConfig.BOOLEAN(DEFAULT.asLines);
  }
}
const ParamsConfig = new SphereSopParamsConfig();
export class SphereSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.SPHERE;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
    this.io.inputs.initInputsClonedState(SphereSopOperation.INPUT_CLONED_STATE);
  }
  cook(input_contents) {
    this._operation = this._operation || new SphereSopOperation(this.scene(), this.states, this);
    const core_group = this._operation.cook(input_contents, this.pv);
    this.setCoreGroup(core_group);
  }
}
