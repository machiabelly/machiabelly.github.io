"use strict";
import { ATTRIBUTE_TYPES, AttribType, AttribSize, ATTRIBUTE_SIZES } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
import { Vector2, Vector3, Vector4 } from "three";
import { ensureString } from "../../../../../core/Type";
export var ComparisonOperator = /* @__PURE__ */ ((ComparisonOperator2) => {
  ComparisonOperator2["EQUAL"] = "==";
  ComparisonOperator2["LESS_THAN"] = "<";
  ComparisonOperator2["EQUAL_OR_LESS_THAN"] = "<=";
  ComparisonOperator2["EQUAL_OR_GREATER_THAN"] = ">=";
  ComparisonOperator2["GREATER_THAN"] = ">";
  ComparisonOperator2["DIFFERENT"] = "!=";
  return ComparisonOperator2;
})(ComparisonOperator || {});
export const COMPARISON_OPERATORS = [
  "==" /* EQUAL */,
  "<" /* LESS_THAN */,
  "<=" /* EQUAL_OR_LESS_THAN */,
  ">=" /* EQUAL_OR_GREATER_THAN */,
  ">" /* GREATER_THAN */,
  "!=" /* DIFFERENT */
];
const COMPARE_METHOD_FLOAT = {
  ["==" /* EQUAL */]: (n1, n2) => {
    return n1 == n2;
  },
  ["<" /* LESS_THAN */]: (n1, n2) => {
    return n1 < n2;
  },
  ["<=" /* EQUAL_OR_LESS_THAN */]: (n1, n2) => {
    return n1 <= n2;
  },
  [">=" /* EQUAL_OR_GREATER_THAN */]: (n1, n2) => {
    return n1 >= n2;
  },
  [">" /* GREATER_THAN */]: (n1, n2) => {
    return n1 > n2;
  },
  ["!=" /* DIFFERENT */]: (n1, n2) => {
    return n1 != n2;
  }
};
export const ComparisonOperatorMenuEntries = COMPARISON_OPERATORS.map((name, value) => {
  return { name, value };
});
export class ByAttributeHelper {
  constructor(node) {
    this.node = node;
  }
  evalForEntities(entities) {
    const attribType = ATTRIBUTE_TYPES[this.node.pv.attribType];
    switch (attribType) {
      case AttribType.NUMERIC: {
        this._evalForNumeric(entities);
        return;
      }
      case AttribType.STRING: {
        this._evalForString(entities);
        return;
      }
    }
    TypeAssert.unreachable(attribType);
  }
  _evalForString(entities) {
    let value;
    for (const entity of entities) {
      value = entity.stringAttribValue(this.node.pv.attribName);
      if (value == ensureString(this.node.pv.attribString)) {
        this.node.entitySelectionHelper.select(entity);
      }
    }
  }
  _evalForNumeric(entities) {
    const attribSize = ATTRIBUTE_SIZES[this.node.pv.attribSize - 1];
    switch (attribSize) {
      case AttribSize.FLOAT: {
        return this._evalForPointsNumericFloat(entities);
      }
      case AttribSize.VECTOR2: {
        return this._evalForPointsNumericVector2(entities);
      }
      case AttribSize.VECTOR3: {
        return this._evalForPointsNumericVector3(entities);
      }
      case AttribSize.VECTOR4: {
        return this._evalForPointsNumericVector4(entities);
      }
    }
    TypeAssert.unreachable(attribSize);
  }
  _evalForPointsNumericFloat(entities) {
    let attribName = this.node.pv.attribName;
    const compared_value = this.node.pv.attribValue1;
    let value;
    const comparison_operator = COMPARISON_OPERATORS[this.node.pv.attribComparisonOperator];
    const compare_method = COMPARE_METHOD_FLOAT[comparison_operator];
    for (const entity of entities) {
      value = entity.attribValue(attribName);
      if (compare_method(value, compared_value)) {
        this.node.entitySelectionHelper.select(entity);
      }
    }
  }
  _evalForPointsNumericVector2(entities) {
    let attribName = this.node.pv.attribName;
    const compared_value = this.node.pv.attribValue2;
    let target = new Vector2();
    for (const entity of entities) {
      const value = entity.attribValue(attribName, target);
      if (compared_value.equals(value)) {
        this.node.entitySelectionHelper.select(entity);
      }
    }
  }
  _evalForPointsNumericVector3(entities) {
    let attribName = this.node.pv.attribName;
    const compared_value = this.node.pv.attribValue3;
    let target = new Vector3();
    for (const entity of entities) {
      const value = entity.attribValue(attribName, target);
      if (compared_value.equals(value)) {
        this.node.entitySelectionHelper.select(entity);
      }
    }
  }
  _evalForPointsNumericVector4(entities) {
    let attribName = this.node.pv.attribName;
    const compared_value = this.node.pv.attribValue4;
    let target = new Vector4();
    for (const entity of entities) {
      const value = entity.attribValue(attribName, target);
      if (compared_value.equals(value)) {
        this.node.entitySelectionHelper.select(entity);
      }
    }
  }
}
