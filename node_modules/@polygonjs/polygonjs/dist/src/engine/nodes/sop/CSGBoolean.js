"use strict";
import { CSGSopNode } from "./_BaseCSG";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { csgIsGeom2, csgIsGeom3 } from "../../../core/geometry/modules/csg/CsgCoreType";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { csgApplyTransform } from "../../../core/geometry/modules/csg/math/CsgMat4";
import { booleans } from "@jscad/modeling";
import { CsgObject } from "../../../core/geometry/modules/csg/CsgObject";
const { intersect, union, subtract } = booleans;
export var BooleanCsgOperationType = /* @__PURE__ */ ((BooleanCsgOperationType2) => {
  BooleanCsgOperationType2["INTERSECT"] = "intersect";
  BooleanCsgOperationType2["SUBTRACT"] = "subtract";
  BooleanCsgOperationType2["UNION"] = "union";
  return BooleanCsgOperationType2;
})(BooleanCsgOperationType || {});
export const BOOLEAN_CSG_OPERATION_TYPES = [
  "intersect" /* INTERSECT */,
  "subtract" /* SUBTRACT */,
  "union" /* UNION */
];
class CSGBooleanSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param operation */
    this.operation = ParamConfig.INTEGER(BOOLEAN_CSG_OPERATION_TYPES.indexOf("intersect" /* INTERSECT */), {
      menu: { entries: BOOLEAN_CSG_OPERATION_TYPES.map((name, value) => ({ name, value })) }
    });
  }
}
const ParamsConfig = new CSGBooleanSopParamsConfig();
export class CSGBooleanSopNode extends CSGSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CSG_BOOLEAN;
  }
  initializeNode() {
    this.io.inputs.setCount(2);
  }
  setOperation(operation) {
    this.p.operation.set(BOOLEAN_CSG_OPERATION_TYPES.indexOf(operation));
  }
  cook(inputCoreGroups) {
    const objects = [];
    const objects0 = inputCoreGroups[0].csgObjects();
    const objects1 = inputCoreGroups[1].csgObjects();
    if (objects0 && objects1) {
      const count = Math.min(objects0.length, objects1.length);
      for (let i = 0; i < count; i++) {
        const object0 = objects0[i];
        const object1 = objects1[i];
        const result = this._applyOperation(object0.csgGeometry(), object1.csgGeometry());
        if (result) {
          objects.push(new CsgObject(result));
        }
      }
    }
    this.setCSGObjects(objects);
  }
  _applyOperation(object0, object1) {
    const method = this._method();
    const bothAreGeom3 = csgIsGeom3(object0) && csgIsGeom3(object1);
    if (bothAreGeom3) {
      return method(object0, object1);
    }
    const bothAreGeom2 = csgIsGeom2(object0) && csgIsGeom2(object1);
    if (bothAreGeom2) {
      csgApplyTransform(object0);
      csgApplyTransform(object1);
      return method(object0, object1);
    }
  }
  _method() {
    const operation = BOOLEAN_CSG_OPERATION_TYPES[this.pv.operation];
    switch (operation) {
      case "intersect" /* INTERSECT */:
        return intersect;
      case "subtract" /* SUBTRACT */:
        return subtract;
      case "union" /* UNION */:
        return union;
    }
  }
}
