"use strict";
import { TypedSopNode } from "./_Base";
import { MergeSopOperation } from "../../operations/sop/Merge";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { NodeEvent } from "../../poly/NodeEvent";
import { SopType } from "../../poly/registers/nodes/types/Sop";
const DEFAULT = MergeSopOperation.DEFAULT_PARAMS;
const DEFAULT_INPUTS_COUNT = 4;
class MergeSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param When off, input objects remain separate. When on, they are merged together by type (mesh, points and lines). In order to merge them correctly, you'll have to make sure they have the same attributes */
    this.compact = ParamConfig.BOOLEAN(DEFAULT.compact);
    /** @param When off, objects with same type (mesh, points, lines) will be merged together, regardless of their material. When on, only objects with same type and same material will be merged */
    this.preserveMaterials = ParamConfig.BOOLEAN(DEFAULT.preserveMaterials, {
      visibleIf: {
        compact: true
      }
    });
    /** @param number of inputs that this node can merge geometries from */
    this.inputsCount = ParamConfig.INTEGER(DEFAULT_INPUTS_COUNT, {
      range: [1, 32],
      rangeLocked: [true, false],
      callback: (node) => {
        MergeSopNode.PARAM_CALLBACK_setInputsCount(node);
      }
    });
  }
}
const ParamsConfig = new MergeSopParamsConfig();
export class MergeSopNode extends TypedSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.MERGE;
  }
  setCompactMode(compact) {
    this.p.compact.set(compact);
  }
  initializeNode() {
    this.io.inputs.setCount(1, DEFAULT_INPUTS_COUNT);
    this.io.inputs.initInputsClonedState(MergeSopOperation.INPUT_CLONED_STATE);
    this.params.onParamsCreated("update inputs", () => {
      this._callbackUpdateInputsCount();
    });
  }
  cook(inputCoreGroups) {
    this._operation = this._operation || new MergeSopOperation(this.scene(), this.states, this);
    const coreGroup = this._operation.cook(inputCoreGroups, this.pv);
    this.setCoreGroup(coreGroup);
  }
  _callbackUpdateInputsCount() {
    this.io.inputs.setCount(1, this.pv.inputsCount);
    this.emit(NodeEvent.INPUTS_UPDATED);
  }
  static PARAM_CALLBACK_setInputsCount(node) {
    node._callbackUpdateInputsCount();
  }
}
