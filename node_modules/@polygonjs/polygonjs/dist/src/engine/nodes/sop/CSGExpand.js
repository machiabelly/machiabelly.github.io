"use strict";
import { CSGSopNode } from "./_BaseCSG";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { SopType } from "../../poly/registers/nodes/types/Sop";
import { CsgCorner, CSG_CORNERS } from "../../../core/geometry/modules/csg/operations/CsgCorner";
import { CsgGeometryType } from "../../../core/geometry/modules/csg/CsgCommon";
import { csgGeometryTypeFromGeometry } from "../../../core/geometry/modules/csg/CsgCoreType";
import { CoreType } from "../../../core/Type";
import { expansions, maths } from "@jscad/modeling";
const { expand } = expansions;
var ExpandMode = /* @__PURE__ */ ((ExpandMode2) => {
  ExpandMode2["_2D_ONLY"] = "2D Only";
  ExpandMode2["_2D_AND_3D_ONLY"] = "2D & 3D (Slow)";
  return ExpandMode2;
})(ExpandMode || {});
const EXPAND_MODES = ["2D Only" /* _2D_ONLY */, "2D & 3D (Slow)" /* _2D_AND_3D_ONLY */];
class CSGExpandSopParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = ParamConfig.INTEGER(EXPAND_MODES.indexOf("2D Only" /* _2D_ONLY */), {
      menu: { entries: EXPAND_MODES.map((name, value) => ({ name, value })) }
    });
    /** @param delta */
    this.delta = ParamConfig.FLOAT(0.1, {
      range: [1 * maths.constants.EPS, 1],
      rangeLocked: [true, false]
    });
    /** @param corners */
    this.corners = ParamConfig.INTEGER(CSG_CORNERS.indexOf(CsgCorner.ROUND), {
      menu: { entries: CSG_CORNERS.map((name, value) => ({ name, value })) }
    });
    /** @param segments */
    this.segments = ParamConfig.INTEGER(1, {
      range: [1, 8],
      rangeLocked: [true, false]
    });
    /** @param allow 3D expand (can be very slow) */
    this.allowExpand3D = ParamConfig.BOOLEAN(false, {
      // label: 'allow 3D geometries (slow)',
    });
  }
}
const ParamsConfig = new CSGExpandSopParamsConfig();
export class CSGExpandSopNode extends CSGSopNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return SopType.CSG_EXPAND;
  }
  initializeNode() {
    this.io.inputs.setCount(1);
  }
  setMode(mode) {
    this.p.mode.set(EXPAND_MODES.indexOf(mode));
  }
  cook(inputCoreGroups) {
    const inputObjects = inputCoreGroups[0].csgObjects();
    if (inputObjects && inputObjects.length != 0) {
      const minDelta = 1 * maths.constants.EPS;
      const delta = Math.max(this.pv.delta, minDelta);
      const options = {
        delta,
        corners: CSG_CORNERS[this.pv.corners],
        segments: this.pv.segments * 4
      };
      const mode = EXPAND_MODES[this.pv.mode];
      const newGeometries = [];
      for (const inputObject of inputObjects) {
        const inputGeometry = inputObject.csgGeometry();
        const type = csgGeometryTypeFromGeometry(inputGeometry);
        const is2D = type == CsgGeometryType.PATH2 || type == CsgGeometryType.GEOM2;
        if (is2D || mode == "2D & 3D (Slow)" /* _2D_AND_3D_ONLY */) {
          const result = expand(options, inputObject.csgGeometry());
          if (CoreType.isArray(result)) {
            newGeometries.push(...result);
          } else {
            newGeometries.push(result);
          }
        }
      }
      this.setCSGGeometries(newGeometries);
    } else {
      this.setCSGObjects([]);
    }
  }
}
