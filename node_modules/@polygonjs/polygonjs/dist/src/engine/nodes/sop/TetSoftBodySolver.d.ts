/**
 * Create a soft body solver
 *
 *
 */
import { Object3D, Vector3 } from 'three';
import { CoreGroup } from '../../../core/geometry/Group';
import { NodeParamsConfig } from '../utils/params/ParamsConfig';
import { NodeContext } from '../../poly/NodeContext';
import { SopType } from '../../poly/registers/nodes/types/Sop';
import { PolyScene } from '../../scene/PolyScene';
import { TetSopNode } from './_BaseTet';
import { SoftBodyPersistedConfig } from '../js/code/assemblers/softBody/SoftBodyPersistedConfig';
import { AssemblerName } from '../../poly/registers/assemblers/_BaseRegister';
import { JsAssemblerSoftBody } from '../js/code/assemblers/softBody/SoftBodyAssembler';
import { JsAssemblerController } from '../js/code/Controller';
import { NodeCreateOptions } from '../utils/hierarchy/ChildrenController';
import { JsNodeChildrenMap } from '../../poly/registers/nodes/Js';
import { Constructor, valueof } from '../../../types/GlobalTypes';
import { BaseJsNodeType } from '../js/_Base';
import { VelocityColliderFunctionData } from '../js/code/assemblers/_Base';
import { RegisterableVariable } from '../js/code/assemblers/_BaseJsPersistedConfigUtils';
import { VelocityFunction, SDFFunction } from '../../../core/softBody/SoftBody';
type FunctionArg = number | boolean | Function | RegisterableVariable;
type SoftBodyVelocityEvaluatorFunction = (...args: FunctionArg[]) => VelocityFunction;
type SoftBodyColliderEvaluatorFunction = (...args: FunctionArg[]) => SDFFunction;
export interface MultiFunctionPartial {
    velocity: SoftBodyVelocityEvaluatorFunction | undefined;
    collider: SoftBodyColliderEvaluatorFunction | undefined;
}
export interface MultiFunctionDefined {
    velocity: VelocityFunction;
    collider: SDFFunction;
}
export interface EvalArgsWithParamConfigs {
    velocity: FunctionArg[];
    collider: FunctionArg[];
}
declare class TetSoftBodySolverSopParamsConfig extends NodeParamsConfig {
}
export declare class TetSoftBodySolverSopNode extends TetSopNode<TetSoftBodySolverSopParamsConfig> {
    readonly paramsConfig: TetSoftBodySolverSopParamsConfig;
    static type(): SopType.TET_SOFT_BODY_SOLVER;
    private _nextId;
    private _tetEmbedByThreejsObjectEphemeralId;
    readonly persisted_config: SoftBodyPersistedConfig;
    assemblerController(): JsAssemblerController<JsAssemblerSoftBody> | undefined;
    usedAssembler(): Readonly<AssemblerName.JS_SOFT_BODY>;
    protected _assemblerController: JsAssemblerController<JsAssemblerSoftBody> | undefined;
    private _createAssemblerController;
    protected _childrenControllerContext: NodeContext;
    protected initializeNode(): void;
    createNode<S extends keyof JsNodeChildrenMap>(node_class: S, options?: NodeCreateOptions): JsNodeChildrenMap[S];
    createNode<K extends valueof<JsNodeChildrenMap>>(node_class: Constructor<K>, options?: NodeCreateOptions): K;
    children(): BaseJsNodeType[];
    nodesByType<K extends keyof JsNodeChildrenMap>(type: K): JsNodeChildrenMap[K][];
    childrenAllowed(): boolean;
    sceneReadonly(): boolean;
    cook(inputCoreGroups: CoreGroup[]): Promise<void>;
    private _highResObject;
    updateObjectOnAdd(object: Object3D, parent: Object3D): void;
    compileIfRequired(): void;
    private _evaluationGlobals;
    private _paramConfigs;
    private _functionData;
    private _functionCreationArgs;
    private _functionEvalArgs;
    private _function;
    private _functionArgsWithParams;
    updateSceneGlobals(stepsCount: number, dt: number): void;
    setPositionGlobals(position: Vector3): void;
    setPointGlobals(position: Vector3, velocity: Vector3): void;
    function(): MultiFunctionPartial;
    functionData(): VelocityColliderFunctionData | undefined;
    compile(): void;
    updateFromFunctionData(functionData: VelocityColliderFunctionData): void;
    functionEvalArgsWithParamConfigs(): EvalArgsWithParamConfigs;
}
export declare function getSoftBodyControllerNodeFromSolverObject(solverObject: Object3D, scene: PolyScene): TetSoftBodySolverSopNode | undefined;
export {};
