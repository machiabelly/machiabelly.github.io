"use strict";
import { InputCloneMode } from "../../../../poly/InputCloneMode";
import { TypeAssert } from "../../../../poly/Assert";
import { NodeEvent } from "../../../../poly/NodeEvent";
import { isArray } from "../../../../../core/Type";
export class ClonedStatesController {
  constructor(inputsController) {
    this.inputsController = inputsController;
    this._cloneRequiredStates = [];
    // private _cloneRequiredStatesMap: Map<number, boolean> = new Map();
    this._overridden = false;
    this.node = inputsController.node;
  }
  initInputsClonedState(states) {
    if (isArray(states)) {
      this._clonedStates = states;
    } else {
      this._clonedState = states;
    }
    this.updateCloneRequiredState();
  }
  overrideClonedStateAllowed() {
    if (this._clonedStates) {
      for (const state of this._clonedStates) {
        if (state == InputCloneMode.FROM_NODE) {
          return true;
        }
      }
    }
    if (this._clonedState) {
      return this._clonedState == InputCloneMode.FROM_NODE;
    }
    return false;
  }
  // private get inputs_clonable_state(): InputCloneMode[] {
  // 	return (this._inputs_clonable_states = this._inputs_clonable_states || this.init_inputs_clonable_state());
  // }
  cloneRequiredState(index) {
    const result = this._cloneRequiredStates[index];
    return result;
  }
  cloneRequiredStates() {
    return this._cloneRequiredStates;
  }
  // inputs_clonable_state_with_override(): boolean[] {
  // 	// const list = [];
  // 	// const states = this.inputs_clonable_state();
  // 	// for (let i = 0; i < states.length; i++) {
  // 	// 	list.push(this.input_clonable_state_with_override(i));
  // 	// }
  // 	// return list;
  // 	return this._inputs_cloned_state;
  // }
  _getCloneRequiredState(index) {
    const states = this._clonedStates;
    if (states) {
      const state = states[index];
      if (state != null) {
        return this._cloneRequiredFromState(state);
      }
    }
    if (this._clonedState) {
      return this._cloneRequiredFromState(this._clonedState);
    }
    return true;
  }
  _cloneRequiredFromState(state) {
    switch (state) {
      case InputCloneMode.ALWAYS:
        return true;
      case InputCloneMode.NEVER:
        return false;
      case InputCloneMode.FROM_NODE:
        return !this._overridden;
    }
    return TypeAssert.unreachable(state);
  }
  // private _default_inputs_clonale_state_values() {
  // 	const list = [];
  // 	for (let i = 0; i < this.inputs_controller.max_inputs_count; i++) {
  // 		list.push(InputCloneMode.ALWAYS);
  // 	}
  // 	return list;
  // }
  overrideClonedState(state) {
    this._overridden = state;
    this.updateCloneRequiredState();
  }
  overriden() {
    return this._overridden;
  }
  updateCloneRequiredState() {
    if (this._clonedStates) {
      const states = [];
      for (let i = 0; i < this._clonedStates.length; i++) {
        states[i] = this._getCloneRequiredState(i);
      }
      this._cloneRequiredStates = states;
    } else {
      if (this._clonedState) {
        const max_inputs = this.inputsController.maxInputsCount();
        const states = [];
        for (let i = 0; i < max_inputs; i++) {
          states[i] = this._getCloneRequiredState(i);
        }
        this._cloneRequiredStates = states;
      }
    }
    if (this.node.parent()) {
      this.node.emit(NodeEvent.OVERRIDE_CLONABLE_STATE_UPDATE);
      this.node.setDirty();
    }
  }
}
