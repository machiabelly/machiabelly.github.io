"use strict";
import { NodeEvent } from "../../../poly/NodeEvent";
import { CoreType } from "../../../../core/Type";
import { arrayUniq } from "../../../../core/ArrayUtils";
const _uniqOutputIndices = [];
const _usedOutputIndices = [];
export class OutputsController {
  constructor(node) {
    this.node = node;
    this._has_outputs = false;
    this._has_named_outputs = false;
    this._connections = [];
    this._onPlayingStateChangeBound = this._onPlayingStateChange.bind(this);
    this._outputIndexCache = /* @__PURE__ */ new Map();
    this.node.scene().timeController.onPlayingStateChange(this._onPlayingStateChangeBound);
  }
  _onPlayingStateChange() {
    this._clearCache();
  }
  _clearCache() {
    this._outputIndexCache.clear();
  }
  dispose() {
    this.node.scene().timeController.removeOnPlayingStateChange(this._onPlayingStateChangeBound);
    if (this._named_output_connection_points) {
      this._named_output_connection_points.splice(0, this._named_output_connection_points.length);
    }
  }
  setHasOneOutput() {
    this._has_outputs = true;
  }
  setHasNoOutput() {
    this._has_outputs = false;
  }
  hasOutputs() {
    return this._has_outputs;
  }
  hasNamedOutputs() {
    return this._has_named_outputs;
  }
  hasNamedOutput(name) {
    return this.getNamedOutputIndex(name) >= 0;
  }
  namedOutputConnectionPoints() {
    return this._named_output_connection_points;
  }
  namedOutputConnection(index) {
    if (this._named_output_connection_points) {
      return this._named_output_connection_points[index];
    }
  }
  getNamedOutputIndex(name) {
    if (this._named_output_connection_points) {
      let i = 0;
      for (const connectionPoint of this._named_output_connection_points) {
        if (connectionPoint && connectionPoint.name() == name) {
          return i;
        }
        i++;
      }
    }
    return -1;
  }
  getOutputIndex(output_index_or_name) {
    let currentCache = this._outputIndexCache.get(output_index_or_name);
    if (currentCache == null) {
      currentCache = this._getOutputIndex(output_index_or_name);
      this._outputIndexCache.set(output_index_or_name, currentCache);
    }
    return currentCache;
  }
  _getOutputIndex(output_index_or_name) {
    if (output_index_or_name != null) {
      if (CoreType.isString(output_index_or_name)) {
        if (this.hasNamedOutputs()) {
          return this.getNamedOutputIndex(output_index_or_name);
        } else {
          console.warn(`node ${this.node.path()} has no named outputs`);
          return -1;
        }
      } else {
        return output_index_or_name;
      }
    }
    return -1;
  }
  namedOutputConnectionPointsByName(name) {
    if (this._named_output_connection_points) {
      for (const connection_point of this._named_output_connection_points) {
        if ((connection_point == null ? void 0 : connection_point.name()) == name) {
          return connection_point;
        }
      }
    }
  }
  setNamedOutputConnectionPoints(connection_points, set_dirty = true) {
    this._has_named_outputs = true;
    this.node.io.connections.outputConnections(this._connections);
    for (const connection of this._connections) {
      if (connection) {
        if (connection.outputIndex() >= connection_points.length) {
          connection.disconnect({ setInput: true });
        }
      }
    }
    this._named_output_connection_points = connection_points;
    if (set_dirty && this.node.scene()) {
      this.node.setDirty(this.node);
    }
    this.node.emit(NodeEvent.NAMED_OUTPUTS_UPDATED);
  }
  used_output_names() {
    var _a;
    const target = [];
    const connectionsController = this.node.io.connections;
    if (connectionsController) {
      connectionsController.outputConnections(this._connections);
      arrayUniq(
        this._connections.map((connection) => connection ? connection.outputIndex() : null),
        _uniqOutputIndices
      );
      _usedOutputIndices.length = 0;
      for (const index of _uniqOutputIndices) {
        if (CoreType.isNumber(index)) {
          _usedOutputIndices.push(index);
        }
      }
      const connectionPoints = this.namedOutputConnectionPoints();
      if (connectionPoints) {
        for (const index of _usedOutputIndices) {
          const name = (_a = connectionPoints[index]) == null ? void 0 : _a.name();
          if (name) {
            target.push(name);
          }
        }
      }
    }
    return target;
  }
}
