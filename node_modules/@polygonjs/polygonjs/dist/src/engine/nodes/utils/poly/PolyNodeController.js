"use strict";
import { NodeEvent } from "./../../../poly/NodeEvent";
import { SceneJsonImporter } from "../../../io/json/import/Scene";
import { JsonExportDispatcher } from "../../../io/json/export/Dispatcher";
import { ParamTemplate } from "../params/ParamsConfig";
import { Poly } from "../../../Poly";
import { arrayCompact } from "../../../../core/ArrayUtils";
import { JsonImportDispatcher } from "../../../io/json/import/Dispatcher";
const _PolyNodeController = class {
  constructor(node, _definition) {
    this.node = node;
    this._definition = _definition;
    this._locked = true;
  }
  static registerCreatePolyNodeFunctionForContext(context, createPolyNodeFunction) {
    this._createPolyNodeFunctionByContext.set(context, createPolyNodeFunction);
  }
  initializeNode() {
    this._initInputs();
    this.node.lifecycle.onAfterCreated(() => {
      this.createChildNodesFromDefinition();
    });
  }
  locked() {
    return this._locked;
  }
  setLockedState(state) {
    if (state == this._locked) {
      return;
    }
    this._locked = state;
    this.node.emit(NodeEvent.POLY_NODE_LOCK_STATE_UPDATED);
  }
  _initInputs() {
    const inputsData = this._definition.inputs;
    if (!inputsData) {
      return;
    }
    const simpleData = inputsData.simple;
    if (simpleData) {
      this.node.io.inputs.setCount(simpleData.min, simpleData.max);
    }
  }
  // private _createParamsFromDefinition() {
  // 	const paramsData = this._definition.params;
  // 	if (!paramsData) {
  // 		return;
  // 	}
  // 	for (let paramData of paramsData) {
  // 		paramData.options = paramData.options || {};
  // 		paramData.options.spare = true;
  // 	}
  // 	this.node.params.updateParams({toAdd: paramsData});
  // }
  static setupParamsConfig(paramsConfig, data) {
    if (!data.params) {
      return;
    }
    for (const paramData of data.params) {
      const paramName = paramData.name;
      const paramType = paramData.type;
      const initValue = paramData.initValue;
      const options = paramData.options;
      paramsConfig[paramName] = new ParamTemplate(paramType, initValue, options);
    }
  }
  createChildNodesFromDefinition() {
    const childrenData = this._definition.nodes;
    if (!childrenData) {
      return;
    }
    const currentSceneLoadedState = this.node.scene().loadingController.loaded();
    if (currentSceneLoadedState) {
      this.node.scene().loadingController.markAsLoading();
    }
    const oldLockedState = this.locked();
    this.setLockedState(false);
    const sceneImporter = new SceneJsonImporter({});
    const dispatcher = new JsonImportDispatcher();
    const nodeImporter = dispatcher.dispatchNonPolyNode(this.node);
    const exporterData = {
      // ...this._definition,
      type: this.node.type(),
      polyNode: {
        locked: true
      }
    };
    nodeImporter.create_nodes(sceneImporter, childrenData, exporterData);
    const uiData = this._definition.ui;
    if (uiData) {
      nodeImporter.processNodesUiData(sceneImporter, uiData);
    }
    if (currentSceneLoadedState) {
      this.node.scene().loadingController.markAsLoaded();
    }
    this.setLockedState(oldLockedState);
  }
  static inputsData(node) {
    if (node.io.inputs.hasNamedInputs()) {
      const inputs = node.io.inputs;
      const connectionPoints = [];
      const namedInputConnectionPoints = inputs.namedInputConnectionPoints();
      if (namedInputConnectionPoints) {
        arrayCompact(namedInputConnectionPoints, connectionPoints);
      }
      return {
        typed: {
          types: connectionPoints.map((cp) => {
            return {
              name: cp.name(),
              type: cp.type()
            };
          })
        }
      };
    } else {
      return {
        simple: {
          min: node.io.inputs.minCount(),
          max: node.io.inputs.maxInputsCount(),
          names: node.displayedInputNames()
        }
      };
    }
  }
  static async polyNodeData(node, inputsData) {
    const dispatcher = new JsonExportDispatcher();
    const rootExporter = dispatcher.dispatchNode(node);
    const nodesData = await rootExporter.data({ showPolyNodesData: true });
    const uiData = rootExporter.uiData({ showPolyNodesData: true });
    const nodeInputsData = inputsData || this.inputsData(node);
    const data = {
      metadata: {
        version: {
          polygonjs: "1"
        },
        createdAt: 1
      },
      nodeContext: node.context(),
      inputs: nodeInputsData,
      params: node.params.non_spare.filter((p) => p.parentParam() == null).map((param) => {
        const paramData = {
          name: param.name(),
          type: param.type(),
          initValue: param.defaultValueSerialized(),
          rawInput: param.rawInputSerialized(),
          options: param.options.current()
        };
        return paramData;
      }),
      nodes: nodesData.nodes,
      ui: uiData.nodes
    };
    return data;
  }
  static _createNodeClass(nodeContext, nodeType, data) {
    const createFunction = this._createPolyNodeFunctionByContext.get(nodeContext);
    if (!createFunction) {
      return;
    }
    return createFunction(nodeType, data, _PolyNodeController);
  }
  static createNodeClassAndRegister(dataRegister) {
    const { node_context, node_type, data } = dataRegister;
    const nodeClass = this._createNodeClass(node_context, node_type, data);
    if (nodeClass) {
      let registerMapForContext = this._definitionRegister.get(node_context);
      if (!registerMapForContext) {
        registerMapForContext = /* @__PURE__ */ new Map();
        this._definitionRegister.set(node_context, registerMapForContext);
      }
      registerMapForContext.set(node_type, data);
      Poly.registerNode(nodeClass, "polyNodes", { polyNode: true });
    } else {
      console.warn("failed to create node from definition", node_context, node_type, data);
    }
  }
  static definition(context, type) {
    var _a;
    return (_a = this._definitionRegister.get(context)) == null ? void 0 : _a.get(type);
  }
  static register() {
    return this._definitionRegister;
  }
};
export let PolyNodeController = _PolyNodeController;
PolyNodeController._createPolyNodeFunctionByContext = /* @__PURE__ */ new Map();
PolyNodeController._definitionRegister = /* @__PURE__ */ new Map();
