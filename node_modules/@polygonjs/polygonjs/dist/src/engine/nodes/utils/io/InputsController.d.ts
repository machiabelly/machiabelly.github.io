import { CoreGraphNode } from '../../../../core/graph/CoreGraphNode';
import { BaseNodeByContextMap, NodeContext } from '../../../poly/NodeContext';
import { ConnectionPointTypeMap } from './connections/ConnectionMap';
import { TypedNode } from '../../_Base';
import { ContainerMap } from '../../../containers/utils/ContainerMap';
import { InputCloneMode } from '../../../poly/InputCloneMode';
type OnUpdateHook = () => void;
type OnEvalSingleInputListen = () => Promise<void>;
export interface SetInputsOptions {
    noExceptionOnInvalidInput?: boolean;
    ignoreLockedState?: boolean;
}
export declare class NodeInputsController<NC extends NodeContext> {
    node: TypedNode<NC, any>;
    private _graphNode;
    private _graphNodeInputs;
    private _inputs;
    private _has_named_inputs;
    private _named_input_connection_points;
    private _minInputsCount;
    private _maxInputsCount;
    private _maxInputsCountOnInput;
    private _depends_on_inputs;
    private _on_update_hooks;
    private _on_update_hook_names;
    dispose(): void;
    constructor(node: TypedNode<NC, any>);
    setDependsOnInputs(depends_on_inputs: boolean): void;
    private setMinCount;
    minCount(): number;
    private setMaxCount;
    private _singleInputIndexListenedTo;
    listenToSingleInputIndex(index: number): void;
    private _onEnsureListenToSingleInputIndexUpdatedCallback;
    onEnsureListenToSingleInputIndexUpdated(callback: OnEvalSingleInputListen): void;
    namedInputConnectionPointsByName(name: string): ConnectionPointTypeMap[NC] | undefined;
    setNamedInputConnectionPoints(newConnectionPoints: ConnectionPointTypeMap[NC][]): void;
    hasNamedInputs(): boolean;
    namedInputConnectionPoints(): ConnectionPointTypeMap[NC][] | undefined;
    private _initGraphNodeInputs;
    private _createGraphNodeInput;
    graphNode(): CoreGraphNode;
    private _createGraphNode;
    maxInputsCount(): number;
    maxInputsCountOverriden(): boolean;
    inputGraphNode(input_index: number): CoreGraphNode;
    setCount(min: number, max?: number): void;
    private _initConnectionControllerInputs;
    isGraphNodeDirty(): boolean;
    private _isAnyInputDirty;
    containersWithoutEvaluation(target: Array<ContainerMap[NC] | null>): (ContainerMap[NC] | null)[];
    private _existingInputIndices;
    evalRequiredInputs(target: Array<ContainerMap[NC] | null | undefined>): Promise<Array<ContainerMap[NC] | null | undefined>>;
    evalRequiredInput(inputIndex: number): Promise<ContainerMap[NC] | undefined>;
    getNamedInputIndex(name: string): number;
    getInputIndex(input_index_or_name: number | string): number;
    setInput(inputIndexOrName: number | string, node: BaseNodeByContextMap[NC] | null, outputIndexOrName?: number | string, options?: Readonly<SetInputsOptions>): void;
    input(input_index: number): BaseNodeByContextMap[NC] | null;
    named_input(input_name: string): BaseNodeByContextMap[NC] | null;
    named_input_connection_point(input_name: string): ConnectionPointTypeMap[NC] | undefined;
    has_named_input(name: string): boolean;
    hasInput(input_index: number): boolean;
    inputs(): (BaseNodeByContextMap[NC] | null)[];
    private _clonedStatesController;
    initInputsClonedState(states: InputCloneMode | InputCloneMode[]): void;
    overrideClonedStateAllowed(): boolean;
    overrideClonedState(state: boolean): void;
    clonedStateOverriden(): boolean;
    cloneRequired(index: number): boolean;
    cloneRequiredStates(): boolean | boolean[];
    private _updateCloneRequiredState;
    add_on_set_input_hook(name: string, hook: OnUpdateHook): void;
    private _run_on_set_input_hooks;
}
export {};
