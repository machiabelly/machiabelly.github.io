"use strict";
import { TypedAudioNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { NodeContext } from "../../poly/NodeContext";
class FetchAudioParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param which node to import */
    this.audioNode = ParamConfig.NODE_PATH("");
  }
}
const ParamsConfig = new FetchAudioParamsConfig();
export class FetchAudioNode extends TypedAudioNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "fetch";
  }
  initializeNode() {
    this.io.inputs.setCount(0);
  }
  async cook(inputContents) {
    const baseAudioNode = this.pv.audioNode.nodeWithContext(NodeContext.AUDIO);
    if (!baseAudioNode) {
      this.states.error.set("no audio node found");
      return;
    }
    const audioContainer = await baseAudioNode.compute();
    const audioBuilder = audioContainer.coreContentCloned();
    if (!audioBuilder) {
      this.states.error.set("invalid audio node");
      return;
    }
    this.setAudioBuilder(audioBuilder);
  }
}
