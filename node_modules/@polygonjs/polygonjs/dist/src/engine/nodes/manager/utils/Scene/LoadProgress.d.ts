import { Constructor } from '../../../../../types/GlobalTypes';
import { BaseNodeType } from '../../../_Base';
import { RootManagerNode } from '../../Root';
import { PolyScene } from '../../../../scene/PolyScene';
declare class NodeGroup {
    readonly nodes: BaseNodeType[];
    readonly totalCount: number;
    private _processed;
    private _remaining;
    constructor(nodes: BaseNodeType[]);
    markNodeAsProcessed(node: BaseNodeType): void;
    isNodeProcessed(node: BaseNodeType): boolean;
    processedCount(): number;
}
interface NodeGroups {
    toCook: NodeGroup;
    sopGroupToUpdate: NodeGroup;
}
export interface OnProgressArguments {
    scene: PolyScene;
    triggerNode?: BaseNodeType;
    groups: NodeGroups;
}
export type OnProgressUpdateCallback = (progressRatio: number, args: OnProgressArguments) => void;
export declare function RootLoadProgressParamConfig<TBase extends Constructor>(Base: TBase): {
    new (...args: any[]): {
        /** @param when the scene loads, nodes that match the mask will update the progress bar as they cook */
        nodesMask: import("../../../utils/params/ParamsConfig").ParamTemplate<import("../../../../index_all").ParamType.STRING>;
        /** @param prints which nodes match the mask in the console */
        printNodes: import("../../../utils/params/ParamsConfig").ParamTemplate<import("../../../../index_all").ParamType.BUTTON>;
    };
} & TBase;
export declare class RootLoadProgressController {
    protected node: RootManagerNode;
    constructor(node: RootManagerNode);
    static PARAM_CALLBACK_printResolve(node: RootManagerNode): Promise<void>;
    resolvedNodes(): Promise<BaseNodeType[]>;
    private _loadDisplayNodes;
    private _displayNodes;
    private _objectNodesWithDisplayNodeController;
    cameraCreatorNode(): Promise<BaseNodeType | null>;
    private _nodeGroups;
    private _onProgressUpdateCallback;
    private _runCallback;
    private _updateProgressAndRunCallback;
    watchNodesProgress(callback: OnProgressUpdateCallback): Promise<void>;
    private _watchNodesToCook;
    private _watchNodesWithSopGroup;
    protected static debugActive(): boolean;
    static debug(arg0: any): void;
    static debug2(arg0: any, arg1: any): void;
    protected _debug(arg0: any): void;
    protected _debug2(arg0: any, arg1: any): void;
}
export {};
