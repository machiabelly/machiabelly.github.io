"use strict";
import { ParamConfig } from "../../../utils/params/ParamsConfig";
import { PerspectiveCamera } from "three";
import { CoreWalker } from "../../../../../core/Walker";
import { CorePath } from "../../../../../core/geometry/CorePath";
let __defaultDummyPerspectiveCamera;
export function _defaultDummyPerspectiveCamera() {
  return __defaultDummyPerspectiveCamera = __defaultDummyPerspectiveCamera || new PerspectiveCamera();
}
export function RootMainCameraParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param path to the main camera object that will be used when the scene loads outside of the editor */
      this.mainCameraPath = ParamConfig.STRING("", {
        cook: false,
        separatorBefore: true,
        objectMask: true
      });
    }
  };
}
export class RootMainCameraController {
  constructor(node) {
    this.node = node;
  }
  setCamera(object) {
    const path = CorePath.objectPath(object);
    this.setCameraPath(path);
  }
  setCameraPath(path) {
    this.mainCameraPathParam().set(path);
  }
  mainCameraPathParam() {
    return this.node.p.mainCameraPath;
  }
  rawCameraPath() {
    return this.mainCameraPathParam().rawInput();
  }
  async cameraPath() {
    const param = this.mainCameraPathParam();
    if (param.isDirty()) {
      await param.compute();
    }
    return param.value;
  }
  _cameraPathSync() {
    const param = this.mainCameraPathParam();
    return param.value;
  }
  cameraSync() {
    const path = this._cameraPathSync();
    const object = this.node.scene().objectsController.findObjectByMask(path);
    return object;
  }
  dummyPerspectiveCamera() {
    return _defaultDummyPerspectiveCamera();
  }
  cameraSyncOrDummy() {
    return this.cameraSync();
  }
  async camera() {
    const path = await this.cameraPath();
    const object = this.node.scene().objectsController.findObjectByMask(path);
    return object;
  }
  async cameraCreatorNode() {
    const path = await this.cameraPath();
    const elements = path.split(CoreWalker.SEPARATOR);
    const nodeName = elements[1];
    const objNode = this.node.node(nodeName);
    if (objNode && elements.length != 2) {
      const displayNodeController = objNode.displayNodeController;
      if (displayNodeController) {
        return objNode.displayNodeController.displayNode() || objNode;
      }
    }
    return objNode;
  }
}
