"use strict";
import { ParamConfig } from "../../../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../../../core/BooleanValue";
import { NodeContext } from "../../../../poly/NodeContext";
const CallbackOptions = {
  cook: false,
  callback: (node) => {
    SceneEnvController.update(node);
  }
};
export function SceneEnvParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle on to use an environment map */
      this.useEnvironment = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions,
        separatorBefore: true
      });
      /** @param environment map */
      this.environment = ParamConfig.NODE_PATH("", {
        visibleIf: { useEnvironment: 1 },
        nodeSelection: {
          context: NodeContext.COP
        },
        // dependentOnFoundNode: false,
        ...CallbackOptions
      });
    }
  };
}
const CALLBACK_NAME = "SceneEnvController";
export class SceneEnvController {
  constructor(node) {
    this.node = node;
    this._updateBound = this.update.bind(this);
  }
  addHooks() {
    const p = this.node.p;
    const params = [p.useEnvironment, p.environment];
    for (const param of params) {
      param.addPostDirtyHook(CALLBACK_NAME, this._updateBound);
    }
  }
  async update() {
    const scene = this.node.object;
    const pv = this.node.pv;
    if (isBooleanTrue(pv.useEnvironment)) {
      const node = pv.environment.nodeWithContext(NodeContext.COP);
      if (node) {
        node.compute().then((container) => {
          scene.environment = container.texture();
        });
      } else {
        scene.environment = null;
        this.node.states.error.set("environment node not found");
      }
    } else {
      scene.environment = null;
    }
  }
  static async update(node) {
    node.sceneEnvController.update();
  }
}
