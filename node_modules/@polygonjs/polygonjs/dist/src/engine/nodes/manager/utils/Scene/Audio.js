"use strict";
import { ParamConfig } from "../../../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../../../core/Type";
const CallbackOptions = {
  computeOnDirty: false,
  callback: (node) => {
    RootAudioController.update(node);
  }
};
export function RootAudioParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      // audio
      /** @param set if a audio icon is shown in the viewer to toggle sound on/off */
      this.displayAudioIcon = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions,
        separatorBefore: true
      });
      /** @param icon color */
      this.audioIconColor = ParamConfig.COLOR([0, 0, 0], {
        ...CallbackOptions,
        visibleIf: { displayAudioIcon: 1 }
      });
      /** @param icon style properties */
      this.audioIconStyle = ParamConfig.STRING(
        "position: absolute; top: 10px; right: 10px; width: 24px; height: 24px; cursor: pointer",
        {
          ...CallbackOptions,
          visibleIf: { displayAudioIcon: 1 }
        }
      );
    }
  };
}
export class RootAudioController {
  constructor(node) {
    this.node = node;
    /*
     *
     * CALLBACKS
     *
     */
    this._callbacksByName = /* @__PURE__ */ new Map();
  }
  async toggleSound() {
    this.audioListeners().forEach((node) => {
      node.toggleSound();
    });
    this.update();
    this._runOnToggleSoundCallbacks();
  }
  soundOn() {
    const listener = this.audioListeners()[0];
    if (listener) {
      return isBooleanTrue(listener.pv.soundOn) || false;
    } else {
      return false;
    }
  }
  update() {
    this._updateViewers();
  }
  audioListeners() {
    return this.node.nodesByType("audioListener");
  }
  _updateViewers() {
    this.node.scene().viewersRegister.traverseViewers((viewer) => {
      viewer.audioController().update();
    });
  }
  static update(node) {
    node.audioController.update();
  }
  onToggleSound(callbackName, callback) {
    if (this._callbacksByName.get(callbackName)) {
      console.warn(`callback already registered ith name '${callbackName}'`);
      return;
    }
    this._callbacksByName.set(callbackName, callback);
  }
  _runOnToggleSoundCallbacks() {
    const soundOn = this.soundOn();
    this._callbacksByName.forEach((callback) => {
      callback(soundOn);
    });
  }
}
