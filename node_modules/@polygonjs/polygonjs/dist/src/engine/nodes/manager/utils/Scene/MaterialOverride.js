"use strict";
import { ParamConfig } from "../../../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../../../core/BooleanValue";
import { NodeContext } from "../../../../poly/NodeContext";
const CallbackOptions = {
  computeOnDirty: false,
  callback: (node) => {
    SceneMaterialOverrideController.update(node);
  }
};
export function SceneMaterialOverrideParamConfig(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      /** @param toggle on to override all materials */
      this.useOverrideMaterial = ParamConfig.BOOLEAN(0, {
        ...CallbackOptions,
        separatorBefore: true
      });
      /** @param material */
      this.overrideMaterial = ParamConfig.NODE_PATH("", {
        visibleIf: { useOverrideMaterial: 1 },
        nodeSelection: {
          context: NodeContext.MAT
        },
        dependentOnFoundNode: false,
        ...CallbackOptions
      });
    }
  };
}
export class SceneMaterialOverrideController {
  constructor(node) {
    this.node = node;
  }
  async update() {
    const scene = this.node.object;
    const pv = this.node.pv;
    if (isBooleanTrue(pv.useOverrideMaterial)) {
      const node = pv.overrideMaterial.nodeWithContext(NodeContext.MAT);
      if (node) {
        const container = await node.compute();
        scene.overrideMaterial = container.material();
      } else {
        scene.overrideMaterial = null;
        this.node.states.error.set("overrideMaterial node not found");
      }
    } else {
      scene.overrideMaterial = null;
    }
  }
  static async update(node) {
    node.sceneMaterialOverrideController.update();
  }
}
