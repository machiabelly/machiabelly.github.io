"use strict";
import { TypedAnimNode } from "./_Base";
import { TimelineBuilder } from "../../../core/animation/TimelineBuilder";
export var AnimTargetNodeTargetType = /* @__PURE__ */ ((AnimTargetNodeTargetType2) => {
  AnimTargetNodeTargetType2["SCENE_GRAPH"] = "scene graph";
  AnimTargetNodeTargetType2["NODE"] = "node";
  return AnimTargetNodeTargetType2;
})(AnimTargetNodeTargetType || {});
export const ANIM_TARGET_TYPES = [
  "scene graph" /* SCENE_GRAPH */,
  "node" /* NODE */
];
const TARGET_TYPE_SCENE_GRAPH = ANIM_TARGET_TYPES.indexOf("scene graph" /* SCENE_GRAPH */);
const TARGET_TYPE_NODE = ANIM_TARGET_TYPES.indexOf("node" /* NODE */);
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { TypeAssert } from "../../poly/Assert";
import { AnimPropertyTarget } from "../../../core/animation/PropertyTarget";
import { AnimationUpdateCallback } from "../../../core/animation/UpdateCallback";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { AnimType } from "../../poly/registers/nodes/types/Anim";
class TargetAnimParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param sets if the target is a Polygonjs node, or a THREE object */
    this.type = ParamConfig.INTEGER(TARGET_TYPE_SCENE_GRAPH, {
      menu: {
        entries: ANIM_TARGET_TYPES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param if set to a Polygonjs node, this is the node path */
    this.nodePath = ParamConfig.NODE_PATH("", {
      visibleIf: { type: TARGET_TYPE_NODE }
    });
    /** @param if set to a THREE object, this is a mask to find the objects */
    this.objectMask = ParamConfig.STRING("/geo*", {
      visibleIf: { type: TARGET_TYPE_SCENE_GRAPH },
      objectMask: true
    });
    /** @param sets if the matrix should be updated as the animation progresses */
    this.updateMatrix = ParamConfig.BOOLEAN(1, {
      visibleIf: { type: TARGET_TYPE_SCENE_GRAPH }
    });
    /** @param prints which objects are targeted by this node, for debugging */
    this.printResolve = ParamConfig.BUTTON(null, {
      callback: (node, param) => {
        TargetAnimNode.PARAM_CALLBACK_print_resolve(node);
      }
    });
  }
}
const ParamsConfig = new TargetAnimParamsConfig();
export class TargetAnimNode extends TypedAnimNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return AnimType.TARGET;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputCoreContents) {
    const timelineBuilder = inputCoreContents[0] || new TimelineBuilder();
    const target = this._create_target(timelineBuilder);
    timelineBuilder.setTarget(target);
    this._set_update_callback(timelineBuilder);
    this.setTimelineBuilder(timelineBuilder);
  }
  setTargetType(targetType) {
    this.p.type.set(ANIM_TARGET_TYPES.indexOf(targetType));
  }
  _create_target(timelineBuilder) {
    const type = ANIM_TARGET_TYPES[this.pv.type];
    switch (type) {
      case "node" /* NODE */: {
        return new AnimPropertyTarget(this.scene(), {
          node: {
            path: this.pv.nodePath.path(),
            relativeTo: this
          }
        });
      }
      case "scene graph" /* SCENE_GRAPH */: {
        return new AnimPropertyTarget(this.scene(), { object: { mask: this.pv.objectMask } });
      }
    }
    TypeAssert.unreachable(type);
  }
  _set_update_callback(timelineBuilder) {
    const type = ANIM_TARGET_TYPES[this.pv.type];
    let update_callback = timelineBuilder.updateCallback();
    switch (type) {
      case "node" /* NODE */: {
        return;
      }
      case "scene graph" /* SCENE_GRAPH */: {
        if (isBooleanTrue(this.pv.updateMatrix)) {
          update_callback = update_callback || new AnimationUpdateCallback();
          update_callback.setUpdateMatrix(this.pv.updateMatrix);
          timelineBuilder.setUpdateCallback(update_callback);
        }
        return;
      }
    }
    TypeAssert.unreachable(type);
  }
  static PARAM_CALLBACK_print_resolve(node) {
    node.print_resolve();
  }
  print_resolve() {
    const type = ANIM_TARGET_TYPES[this.pv.type];
    const timeline_builder = new TimelineBuilder();
    const target = this._create_target(timeline_builder);
    switch (type) {
      case "node" /* NODE */: {
        return console.log(target.node());
      }
      case "scene graph" /* SCENE_GRAPH */: {
        return console.log(target.objects());
      }
    }
  }
}
