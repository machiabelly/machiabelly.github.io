"use strict";
import { TypedAnimNode } from "./_Base";
import { TimelineBuilder } from "../../../core/animation/TimelineBuilder";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { Poly } from "../../Poly";
import { gsapTimeline } from "../../../core/thirdParty/gsap/gsapFactory";
class NullAnimParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param play the animations */
    this.play = ParamConfig.BUTTON(null, {
      callback: (node) => {
        NullAnimNode.PARAM_CALLBACK_play(node);
      },
      hidden: true
    });
    /** @param pause the animations */
    this.pause = ParamConfig.BUTTON(null, {
      callback: (node) => {
        NullAnimNode.PARAM_CALLBACK_pause(node);
      },
      hidden: true
    });
    /** @param sets if the animations created can be stopped when a new animation in generated on the same property */
    this.stoppable = ParamConfig.BOOLEAN(1);
    /** @param toggle to see debug infos printed in the console */
    this.debug = ParamConfig.BOOLEAN(0);
  }
}
const ParamsConfig = new NullAnimParamsConfig();
export class NullAnimNode extends TypedAnimNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "null";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  cook(inputContents) {
    const timelineBuilder = inputContents[0] || new TimelineBuilder();
    timelineBuilder.setDebug(isBooleanTrue(this.pv.debug));
    timelineBuilder.setStoppable(this.pv.stoppable);
    this.setTimelineBuilder(timelineBuilder);
  }
  async timelineBuilder() {
    const container = await this.compute();
    if (!container) {
      return;
    }
    const timelineBuilder = container.coreContent();
    if (!timelineBuilder) {
      return;
    }
    return timelineBuilder;
  }
  async play() {
    return new Promise(async (playResolve) => {
      if (isBooleanTrue(this.pv.debug)) {
        Poly.log(`play from '${this.path()}'`);
      }
      let resolved = false;
      function resolveOnce() {
        if (!resolved) {
          resolved = true;
          playResolve();
        }
      }
      const timelineBuilder = await this.timelineBuilder();
      if (!timelineBuilder) {
        return;
      }
      this._timeline = gsapTimeline({ onComplete: resolveOnce });
      if (!this._timeline) {
        return;
      }
      timelineBuilder.populate(this._timeline, { registerproperties: true });
    });
  }
  async pause() {
    if (this._timeline) {
      this._timeline.pause();
    }
  }
  static PARAM_CALLBACK_play(node) {
    node.play();
  }
  static PARAM_CALLBACK_pause(node) {
    node.pause();
  }
}
