"use strict";
import { TypedAnimNode } from "./_Base";
import { TimelineBuilder } from "../../../core/animation/TimelineBuilder";
import { CoreType } from "../../../core/Type";
import { TypeAssert } from "../../poly/Assert";
import { Quaternion } from "three";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../core/BooleanValue";
export var AnimPropertyValueNodeMode = /* @__PURE__ */ ((AnimPropertyValueNodeMode2) => {
  AnimPropertyValueNodeMode2["CUSTOM"] = "custom";
  AnimPropertyValueNodeMode2["FROM_SCENE_GRAPH"] = "from scene graph";
  AnimPropertyValueNodeMode2["FROM_NODE"] = "from node";
  return AnimPropertyValueNodeMode2;
})(AnimPropertyValueNodeMode || {});
const PROPERTY_VALUE_MODES = [
  "custom" /* CUSTOM */,
  "from scene graph" /* FROM_SCENE_GRAPH */,
  "from node" /* FROM_NODE */
];
const PROPERTY_VALUE_MODE_CUSTOM = PROPERTY_VALUE_MODES.indexOf("custom" /* CUSTOM */);
const PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH = PROPERTY_VALUE_MODES.indexOf("from scene graph" /* FROM_SCENE_GRAPH */);
const PROPERTY_VALUE_MODE_FROM_NODE = PROPERTY_VALUE_MODES.indexOf("from node" /* FROM_NODE */);
class PropertyValueAnimParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param mode */
    this.mode = ParamConfig.INTEGER(PROPERTY_VALUE_MODE_CUSTOM, {
      menu: {
        entries: PROPERTY_VALUE_MODES.map((name, value) => {
          return { name, value };
        })
      }
    });
    /** @param if set to a Polygonjs node, this is the node path */
    this.nodePath = ParamConfig.NODE_PATH("", {
      visibleIf: { mode: PROPERTY_VALUE_MODE_FROM_NODE }
    });
    /** @param if set to a THREE object, this is a mask to find the objects */
    this.objectMask = ParamConfig.STRING("*geo1", {
      visibleIf: { mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH }
    });
    /** @param print the object matching the objectMask, to help debugging */
    this.printResolve = ParamConfig.BUTTON(null, {
      visibleIf: { mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH },
      callback: (node) => {
        PropertyValueAnimNode.PARAM_CALLBACK_printResolve(node);
      }
    });
    this.overridePropertyName = ParamConfig.BOOLEAN(0, {
      visibleIf: [{ mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH }, { mode: PROPERTY_VALUE_MODE_FROM_NODE }]
    });
    this.propertyName = ParamConfig.STRING("", {
      visibleIf: [
        { overridePropertyName: true, mode: PROPERTY_VALUE_MODE_FROM_SCENE_GRAPH },
        { overridePropertyName: true, mode: PROPERTY_VALUE_MODE_FROM_NODE }
      ]
    });
    /** @param size of the parameter to animate */
    this.size = ParamConfig.INTEGER(3, {
      range: [1, 4],
      rangeLocked: [true, true],
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM },
      separatorAfter: true
    });
    /** @param value for a float */
    this.value1 = ParamConfig.FLOAT(0, {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 1 }
    });
    /** @param value for a vector2 */
    this.value2 = ParamConfig.VECTOR2([0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 2 }
    });
    /** @param value for a vector3 */
    this.value3 = ParamConfig.VECTOR3([0, 0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3, asColor: false }
    });
    /** @param value for a vector3 as color */
    this.color = ParamConfig.COLOR([0, 0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3, asColor: true }
    });
    /** @param value for a vector4 */
    this.value4 = ParamConfig.VECTOR4([0, 0, 0, 0], {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 4 }
    });
    /** @param when using vector3, use toggle on it should be a color */
    this.asColor = ParamConfig.BOOLEAN(0, {
      visibleIf: { mode: PROPERTY_VALUE_MODE_CUSTOM, size: 3 }
    });
  }
}
const ParamsConfig = new PropertyValueAnimParamsConfig();
export class PropertyValueAnimNode extends TypedAnimNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "propertyValue";
  }
  initializeNode() {
    this.io.inputs.setCount(0, 1);
  }
  async cook(inputContents) {
    const timelineBuilder = inputContents[0] || new TimelineBuilder();
    await this._prepareTimelineBuilder(timelineBuilder);
    this.setTimelineBuilder(timelineBuilder);
  }
  setMode(targetType) {
    this.p.mode.set(PROPERTY_VALUE_MODES.indexOf(targetType));
  }
  async _prepareTimelineBuilder(timelineBuilder) {
    const mode = PROPERTY_VALUE_MODES[this.pv.mode];
    switch (mode) {
      case "custom" /* CUSTOM */: {
        return this._prepareTimebuilderCustom(timelineBuilder);
      }
      case "from scene graph" /* FROM_SCENE_GRAPH */: {
        return this._prepareTimebuilderFromSceneGraph(timelineBuilder);
      }
      case "from node" /* FROM_NODE */: {
        return await this._prepareTimebuilderFromNode(timelineBuilder);
      }
    }
    TypeAssert.unreachable(mode);
  }
  _prepareTimebuilderCustom(timelineBuilder) {
    const size = this.pv.size;
    switch (size) {
      case 1: {
        return timelineBuilder.setPropertyValue(this.pv.value1);
      }
      case 2: {
        return timelineBuilder.setPropertyValue(this.pv.value2);
      }
      case 3: {
        if (isBooleanTrue(this.pv.asColor)) {
          return timelineBuilder.setPropertyValue(this.pv.color);
        } else {
          return timelineBuilder.setPropertyValue(this.pv.value3);
        }
      }
      case 4: {
        return timelineBuilder.setPropertyValue(this.pv.value4);
      }
    }
  }
  _prepareTimebuilderFromSceneGraph(timelineBuilder) {
    const propertyName = isBooleanTrue(this.pv.overridePropertyName) ? this.pv.propertyName : timelineBuilder.propertyName();
    if (!propertyName) {
      return;
    }
    const foundObject = this._foundObjectFromSceneGraph();
    if (foundObject) {
      const value = foundObject[propertyName];
      if (value) {
        if (CoreType.isNumber(value) || CoreType.isVector(value) || value instanceof Quaternion) {
          timelineBuilder.setPropertyValue(value);
        }
      }
    }
  }
  async _prepareTimebuilderFromNode(timelineBuilder) {
    const propertyName = isBooleanTrue(this.pv.overridePropertyName) ? this.pv.propertyName : timelineBuilder.propertyName();
    if (!propertyName) {
      return;
    }
    const node = this.pv.nodePath.node();
    if (!node) {
      return;
    }
    const param = node.params.get(propertyName);
    if (!param) {
      return;
    }
    if (param.isDirty()) {
      await param.compute();
    }
    const value = param.value;
    if (value) {
      if (CoreType.isNumber(value) || CoreType.isVector(value)) {
        timelineBuilder.setPropertyValue(value);
      }
    }
  }
  static PARAM_CALLBACK_printResolve(node) {
    node.printResolve();
  }
  _foundObjectFromSceneGraph() {
    return this.scene().findObjectByMask(this.pv.objectMask);
  }
  printResolve() {
    const foundObject = this._foundObjectFromSceneGraph();
    console.log(foundObject);
  }
}
