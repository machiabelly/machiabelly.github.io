"use strict";
import { TypedAnimNode } from "./_Base";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { NetworkNodeType, NodeContext } from "../../poly/NodeContext";
import { SubnetOutputAnimNode } from "./SubnetOutput";
class ParamLessSubnetAnimParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new ParamLessSubnetAnimParamsConfig();
export class BaseSubnetAnimNode extends TypedAnimNode {
  constructor() {
    super(...arguments);
    this._childrenControllerContext = NodeContext.ANIM;
  }
  initializeNode() {
    this.io.inputs.setCount(0, 4);
  }
  createNode(nodeClass, options) {
    return super.createNode(nodeClass, options);
  }
  children() {
    return super.children();
  }
  nodesByType(type) {
    return super.nodesByType(type);
  }
  async cook(inputContents) {
    const subnetOutput = this.nodesByType(SubnetOutputAnimNode.type())[0];
    if (!subnetOutput) {
      this.states.error.set("no output node found inside subnet");
      return this.cookController.endCook();
    }
    const container = await subnetOutput.compute();
    const timelineBuilder = container.coreContent();
    if (!timelineBuilder) {
      this.states.error.set("invalid subnetOutput");
      return this.cookController.endCook();
    }
    this.setTimelineBuilder(timelineBuilder);
  }
}
export class SubnetAnimNode extends BaseSubnetAnimNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return NetworkNodeType.SUBNET;
  }
}
