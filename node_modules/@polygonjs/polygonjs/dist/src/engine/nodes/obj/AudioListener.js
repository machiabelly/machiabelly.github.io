"use strict";
import { TypedObjNode } from "./_Base";
import { TransformedParamConfig, TransformController } from "./utils/TransformController";
import { FlagsControllerD } from "../utils/FlagsController";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { HierarchyController } from "./utils/HierarchyController";
import { ObjType } from "../../poly/registers/nodes/types/Obj";
import { isBooleanTrue } from "../../../core/Type";
import { CoreAudioListener } from "../../../core/audio/AudioListener";
import { AudioController } from "../../../core/audio/AudioController";
class AudioListenerParamConfig extends TransformedParamConfig(NodeParamsConfig) {
  constructor() {
    super(...arguments);
    this.audio = ParamConfig.FOLDER();
    /** @param soundOn */
    this.soundOn = ParamConfig.BOOLEAN(1, {
      cook: false,
      callback: (node) => {
        AudioListenerObjNode.PARAM_CALLBACK_update(node);
      }
    });
    /** @param volume */
    this.masterVolume = ParamConfig.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    /** @param ensures the transform of the audio listener is updated on very frame */
    this.listenerTransformAutoUpdate = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new AudioListenerParamConfig();
const _AudioListenerObjNode = class extends TypedObjNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this.hierarchyController = new HierarchyController(this);
    this.transformController = new TransformController(this);
    this.flags = new FlagsControllerD(this);
    this._boundEvents = {
      pointerdown: this._onpointerdown.bind(this),
      keypress: this._onkeypress.bind(this)
    };
  }
  static type() {
    return ObjType.AUDIO_LISTENER;
  }
  createObject() {
    const object = new CoreAudioListener();
    object.matrixAutoUpdate = false;
    return object;
  }
  initializeNode() {
    this.hierarchyController.initializeNode();
    this.transformController.initializeNode();
    this.lifecycle.onAfterAdded(() => {
      this._setPositionalAudioNodesDirty();
      this.addAudioActivationEvents();
      this.root().audioController.update();
    });
  }
  dispose() {
    super.dispose();
    this.object.dispose();
    this._setPositionalAudioNodesDirty();
    this.root().audioController.update();
  }
  toggleSound() {
    this.p.soundOn.set(!isBooleanTrue(this.pv.soundOn));
  }
  _setPositionalAudioNodesDirty() {
    this.root().nodesByType("positionalAudio").forEach((n) => n.setDirty());
  }
  cook() {
    this.transformController.update();
    this._validateUniq();
    this._updateListenerAndViewers();
    this.cookController.endCook();
  }
  _validateUniq() {
    const existingListeners = this.root().audioController.audioListeners();
    if (existingListeners.length > 1) {
      this.states.error.set("only 1 audioListener can exist in a scene");
    }
  }
  _updateAudioListener() {
    const volume = isBooleanTrue(this.pv.soundOn) ? this.pv.masterVolume : 0;
    this.object.setMasterVolume(volume);
    this.object.listenerTransformAutoUpdate = isBooleanTrue(this.pv.listenerTransformAutoUpdate);
  }
  _updateViewers() {
    this.root().audioController.update();
  }
  _updateListenerAndViewers() {
    this._updateAudioListener();
    this._updateViewers();
  }
  static PARAM_CALLBACK_update(node) {
    node._updateListenerAndViewers();
  }
  async _onpointerdown(event) {
    await this.activateSound();
  }
  async _onkeypress(event) {
    await this.activateSound();
  }
  static soundActivated() {
    return this._audioActivated;
  }
  soundActivated() {
    return _AudioListenerObjNode.soundActivated();
  }
  async activateSound() {
    if (!this.soundActivated()) {
      await AudioController.start();
      _AudioListenerObjNode._audioActivated = true;
    }
    this._removeAudioActivationEvents();
  }
  addAudioActivationEvents() {
    if (this.soundActivated()) {
      return;
    }
    if (_AudioListenerObjNode._eventsAdded) {
      return;
    }
    _AudioListenerObjNode._eventsAdded = true;
    document.body.addEventListener("pointerdown", this._boundEvents.pointerdown);
    document.body.addEventListener("keypress", this._boundEvents.keypress);
  }
  _removeAudioActivationEvents() {
    document.body.removeEventListener("pointerdown", this._boundEvents.pointerdown);
    document.body.removeEventListener("keypress", this._boundEvents.keypress);
  }
};
export let AudioListenerObjNode = _AudioListenerObjNode;
/*

	EVENTS TO ACTIVATE SOUND

	*/
AudioListenerObjNode._eventsAdded = false;
AudioListenerObjNode._audioActivated = false;
