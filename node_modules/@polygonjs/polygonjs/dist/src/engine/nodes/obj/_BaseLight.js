"use strict";
import { TypedObjNode, ObjNodeRenderOrder } from "./_Base";
import { FlagsControllerD } from "../utils/FlagsController";
import { isPromise } from "../../../core/Type";
export class TypedLightObjNode extends TypedObjNode {
  constructor() {
    super(...arguments);
    this.flags = new FlagsControllerD(this);
    this.renderOrder = ObjNodeRenderOrder.LIGHT;
    this._usedInScene = true;
    // TODO: I may be able to swap those methods to param callbacks for most params
    this._cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);
  }
  get light() {
    return this._light;
  }
  initializeBaseNode() {
    super.initializeBaseNode();
    this._light = this.createLight();
    this.object.add(this._light);
    this.flags.display.onUpdate(() => {
      this._updateLightAttachment();
    });
    this.dirtyController.addPostDirtyHook(
      "_cook_main_without_inputs_when_dirty",
      this._cook_main_without_inputs_when_dirty_bound
    );
  }
  async _cook_main_without_inputs_when_dirty() {
    await this.cookController.cookMainWithoutInputs();
  }
  set_object_name() {
    super.set_object_name();
    if (this._light) {
      this._light.name = `${this.path()}:light`;
    }
  }
  _updateLightAttachment() {
    if (this.flags.display.active()) {
      this.object.add(this.light);
      this._cook_main_without_inputs_when_dirty();
    } else {
      this.object.remove(this.light);
    }
  }
  async cook() {
    this.updateShadowParams();
    const result = this.updateLightParams();
    if (isPromise(result)) {
      await result;
    }
    this.cookController.endCook();
  }
  updateLightParams() {
  }
  updateShadowParams() {
  }
}
