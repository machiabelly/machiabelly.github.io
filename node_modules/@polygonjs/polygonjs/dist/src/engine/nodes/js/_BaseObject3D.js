"use strict";
import { wrapIfComputed } from "./_Base";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { Poly } from "../../Poly";
import { DecomposedPath } from "../../../core/DecomposedPath";
import { Attribute } from "../../../core/geometry/Attribute";
export function defaultObject(linesController) {
  return linesController.assembler().defaultObjectVariable();
}
function _defaultObject3DMaterial(linesController) {
  return linesController.assembler().defaultObject3DMaterialVariable();
}
export function defaultPrimitiveGraph(linesController) {
  return linesController.assembler().defaultPrimitiveGraph();
}
function _defaultPointIndex(node, linesController) {
  const func = Poly.namedFunctionsRegister.getFunction("getPointIndex", node, linesController);
  return func.asString(inputObject3D(node, linesController));
}
export function inputObject3D(node, linesController) {
  const inputObject3D2 = node.io.inputs.named_input(JsConnectionPointType.OBJECT_3D);
  const object3D = inputObject3D2 ? node.variableForInput(linesController, JsConnectionPointType.OBJECT_3D) : defaultObject(linesController);
  return object3D;
}
export function inputObject3DMaterial(node, linesController) {
  const inputMaterial = node.io.inputs.named_input(JsConnectionPointType.MATERIAL);
  const material = inputMaterial ? node.variableForInput(linesController, JsConnectionPointType.MATERIAL) : _defaultObject3DMaterial(linesController);
  return material;
}
export function inputPointIndex(node, linesController) {
  const inputPoint = node.io.inputs.named_input(Attribute.POINT_INDEX);
  const object3D = inputPoint ? node.variableForInput(linesController, Attribute.POINT_INDEX) : _defaultPointIndex(node, linesController);
  return object3D;
}
export function setObject3DMaterialOutputLine(node, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  if (!usedOutputNames.includes(JsConnectionPointType.MATERIAL)) {
    return;
  }
  const material = inputObject3DMaterial(node, linesController);
  const out = node.jsVarName(JsConnectionPointType.MATERIAL);
  linesController.addBodyOrComputed(node, [
    { dataType: JsConnectionPointType.OBJECT_3D, varName: out, value: material }
  ]);
}
export function setObject3DOutputLine(node, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  if (!usedOutputNames.includes(JsConnectionPointType.OBJECT_3D)) {
    return;
  }
  const object3D = inputObject3D(node, linesController);
  const out = node.jsVarName(JsConnectionPointType.OBJECT_3D);
  linesController.addBodyOrComputed(node, [
    { dataType: JsConnectionPointType.OBJECT_3D, varName: out, value: object3D }
  ]);
}
export function inputParam(node, linesController) {
  const inputParam2 = node.io.inputs.named_input(JsConnectionPointType.PARAM);
  const _getParam = (linesController2) => {
    const paramPathParam = node.params.get(JsConnectionPointType.PARAM);
    const decomposedPath = new DecomposedPath();
    paramPathParam.value.resolve(node, decomposedPath);
    const absolutePath = decomposedPath.toAbsolutePath();
    const out = node.jsVarName("getParamSinceNoInput");
    const func = Poly.namedFunctionsRegister.getFunction("getParam", node, linesController2);
    const bodyLine = func.asString(`'${absolutePath}'`);
    linesController2.addBodyOrComputed(node, [
      { dataType: JsConnectionPointType.PARAM, varName: out, value: bodyLine }
    ]);
    return wrapIfComputed(out, linesController2);
  };
  const param = inputParam2 ? node.variableForInput(linesController, JsConnectionPointType.PARAM) : _getParam(linesController);
  return param;
}
export function inputNode(jsNode, linesController) {
  const inputNode2 = jsNode.io.inputs.named_input(JsConnectionPointType.NODE);
  const _getNode = (linesController2) => {
    const nodePathParam = jsNode.params.get(JsConnectionPointType.NODE);
    const decomposedPath = new DecomposedPath();
    nodePathParam.value.resolve(jsNode, decomposedPath);
    const absolutePath = decomposedPath.toAbsolutePath();
    const out = jsNode.jsVarName("getNodeSinceNoInput");
    const func = Poly.namedFunctionsRegister.getFunction("getNode", jsNode, linesController2);
    const bodyLine = func.asString(`'${absolutePath}'`);
    linesController2.addBodyOrComputed(jsNode, [
      { dataType: JsConnectionPointType.NODE, varName: out, value: bodyLine }
    ]);
    return wrapIfComputed(out, linesController2);
  };
  const foundNode = inputNode2 ? jsNode.variableForInput(linesController, JsConnectionPointType.NODE) : _getNode(linesController);
  return foundNode;
}
export function vector2OutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.VECTOR2,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function vector2OutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.VECTOR2,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
export function vector3OutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.VECTOR3,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function vector3OutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.VECTOR3,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
export function vector4OutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.VECTOR4,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function vector4OutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.VECTOR4,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
export function floatOutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.FLOAT,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function floatOutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.FLOAT,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
export function integerOutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.INT,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function integerOutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.INT,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
export function stringOutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.STRING,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function stringOutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.STRING,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
export function booleanOutputFromParam(node, param, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = param.name();
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.BOOLEAN,
      varName: node.jsVarName(propertyName),
      value: node.variableForInputParam(linesController, param)
    }
  ]);
}
export function anyTypeOutputFromInput(node, inputName, linesController) {
  const usedOutputNames = node.io.outputs.used_output_names();
  const propertyName = inputName;
  if (!usedOutputNames.includes(propertyName)) {
    return;
  }
  linesController.addBodyOrComputed(node, [
    {
      dataType: JsConnectionPointType.FLOAT,
      varName: node.jsVarName(propertyName),
      value: node.variableForInput(linesController, inputName)
    }
  ]);
}
