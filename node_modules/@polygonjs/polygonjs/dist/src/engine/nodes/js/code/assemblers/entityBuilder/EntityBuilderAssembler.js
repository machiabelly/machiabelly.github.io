"use strict";
import { Vector3 } from "three";
import { JsAssemblerBaseEntityBuilder } from "./_BaseEntityBuilderAssembler";
import { JsShaderConfig } from "../../configs/ShaderConfig";
import { JsConnectionPointType, JsConnectionPoint } from "../../../../utils/io/connections/Js";
import { EntityBuilderAssemblerConstant, EntityVariable } from "./EntityBuilderAssemblerCommon";
import { JsFunctionName } from "../../../../utils/shaders/ShaderName";
import { AttributeJsNodeInput } from "../../../Attribute";
export class JsAssemblerEntityBuilder extends JsAssemblerBaseEntityBuilder {
  _evaluatorName() {
    return "CustomEntityBuilderEvaluator";
  }
  //
  //
  // CHILDREN NODES PARAMS
  //
  //
  add_output_inputs(output_child) {
    output_child.io.inputs.setNamedInputConnectionPoints([
      // new JsConnectionPoint(EntityVariable.POSITION, JsConnectionPointType.VECTOR3),
      // new JsConnectionPoint(EntityVariable.NORMAL, JsConnectionPointType.VECTOR3),
    ]);
  }
  add_globals_outputs(globals_node) {
    globals_node.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(EntityVariable.POSITION, JsConnectionPointType.VECTOR3),
      new JsConnectionPoint(EntityVariable.NORMAL, JsConnectionPointType.VECTOR3),
      new JsConnectionPoint(EntityVariable.INDEX, JsConnectionPointType.INT),
      new JsConnectionPoint(EntityVariable.OBJNUM, JsConnectionPointType.INT)
    ]);
  }
  //
  //
  // CONFIGS
  //
  //
  create_shader_configs() {
    return [
      new JsShaderConfig(
        JsFunctionName.MAIN,
        [
          EntityVariable.POSITION,
          EntityVariable.NORMAL,
          // attribute
          AttributeJsNodeInput.EXPORT
        ],
        []
      )
    ];
  }
  create_variable_configs() {
    return [
      // new VariableConfig(EntityVariable.POSITION, {
      // 	prefix: 'return ',
      // }),
      // new VariableConfig(EntityVariable.NORMAL, {
      // 	prefix: 'return ',
      // }),
    ];
  }
  //
  //
  // NODE LINES
  //
  //
  setNodeLinesOutput(outputNode, linesController) {
  }
  setNodeLinesGlobals(globalsNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const usedOutputNames = globalsNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = globalsNode.jsVarName(outputName);
      switch (outputName) {
        case EntityVariable.POSITION:
        case EntityVariable.NORMAL: {
          linesController.addVariable(globalsNode, new Vector3(), varName);
          bodyLines.push(`${varName}.copy(${EntityBuilderAssemblerConstant.ENTITY_CONTAINER}.${outputName})`);
          break;
        }
        case EntityVariable.OBJNUM:
        case EntityVariable.INDEX: {
          bodyLines.push(`${varName}= ${EntityBuilderAssemblerConstant.ENTITY_CONTAINER}.${outputName}`);
        }
      }
    }
    linesController._addBodyLines(globalsNode, bodyLines);
  }
}
