"use strict";
import { ParamType } from "../../../poly/ParamType";
import { setUnion, setToArray, setIntersection } from "../../../../core/SetUtils";
import { arrayToSet } from "../../../../core/ArrayUtils";
import { MapUtils } from "../../../../core/MapUtils";
const _currentParamNames = /* @__PURE__ */ new Set();
const _spareParamNamesToAdd = /* @__PURE__ */ new Set();
const _spareParamNamesToRemove = /* @__PURE__ */ new Set();
const _spareParamsWithSameNameAsParams = /* @__PURE__ */ new Set();
const _tmp = /* @__PURE__ */ new Set();
const DEBUG = false;
function _paramMatchesParamConfig(param, paramConfig) {
  if (param.type() != paramConfig.type()) {
    if (DEBUG) {
      console.log(`${param.name()}: type is different to paramConfig's`, param.type(), paramConfig.type());
    }
    return false;
  }
  if (param.name() != paramConfig.name()) {
    if (DEBUG) {
      console.log(`${param.name()}: name is different to paramConfig's`, param.name(), paramConfig.name());
    }
    return false;
  }
  if (!param.isDefaultValueEqual(paramConfig.defaultValue())) {
    if (DEBUG) {
      console.log(
        `${param.name()}: defaultValue is different to paramConfig's`,
        param.defaultValue(),
        paramConfig.defaultValue()
      );
    }
    return false;
  }
  return true;
}
export class JsAssemblerNodeSpareParamsController {
  constructor(_controller, _node) {
    this._controller = _controller;
    this._node = _node;
    // private _deletedParamsData: Map<string, ParamJsonExporterData<ParamType>> = new Map();
    // private _createdSpareParamNames: Set<string> = new Set();
    this._raw_input_serialized_by_param_name = /* @__PURE__ */ new Map();
    this._init_value_serialized_by_param_name = /* @__PURE__ */ new Map();
  }
  get assembler() {
    return this._controller.assembler;
  }
  // private _createdSpareParams(){
  // 	return this._node.params.spare;
  // }
  createSpareParameters() {
    const paramsUpdateOptions = {};
    const paramConfigs = this.assembler.param_configs();
    const paramConfigsByName = MapUtils.groupBy(paramConfigs, (c) => c.name());
    const assembler_param_names = paramConfigs.map((c) => c.name());
    arrayToSet(assembler_param_names, _spareParamNamesToAdd);
    const validation_result = this._validateNames(_spareParamNamesToAdd);
    if (validation_result == false) {
      return;
    }
    const currentSpareParams = this._node.params.spare;
    const currentSpareParamNames = currentSpareParams.map((p) => p.name());
    setUnion(arrayToSet(currentSpareParamNames, _tmp), _spareParamNamesToAdd, _spareParamNamesToRemove);
    for (const currentSpareParam of currentSpareParams) {
      const paramConfigsWithName = paramConfigsByName.get(currentSpareParam.name());
      if (paramConfigsWithName) {
        const firstParamConfig = paramConfigsWithName[0];
        if (firstParamConfig) {
          if (_paramMatchesParamConfig(currentSpareParam, firstParamConfig)) {
            _spareParamNamesToRemove.delete(currentSpareParam.name());
            _spareParamNamesToAdd.delete(currentSpareParam.name());
          }
        }
      }
    }
    _spareParamNamesToRemove.forEach((param_name) => {
      const param = this._node.params.get(param_name);
      if (param && !param.parentParam()) {
        this._raw_input_serialized_by_param_name.set(param.name(), param.rawInputSerialized());
        this._init_value_serialized_by_param_name.set(param.name(), param.defaultValueSerialized());
        paramsUpdateOptions.namesToDelete = paramsUpdateOptions.namesToDelete || [];
        paramsUpdateOptions.namesToDelete.push(param_name);
      }
    });
    for (const paramConfig of paramConfigs) {
      if (_spareParamNamesToAdd.has(paramConfig.name())) {
        const type = paramConfig.type();
        const options = this.assembler.spareParamsOptions({ type });
        let init_value = this._init_value_serialized_by_param_name.get(paramConfig.name());
        if (init_value == null) {
          init_value = paramConfig.defaultValue();
        }
        let raw_input = this._raw_input_serialized_by_param_name.get(paramConfig.name());
        if (raw_input == null) {
          raw_input = paramConfig.defaultValue();
        }
        if (type != ParamType.BUTTON) {
          paramsUpdateOptions.toAdd = paramsUpdateOptions.toAdd || [];
          paramsUpdateOptions.toAdd.push({
            name: paramConfig.name(),
            type,
            initValue: init_value,
            rawInput: raw_input,
            options
          });
        }
      }
    }
    this._node.params.updateParams(paramsUpdateOptions);
    for (const paramConfig of paramConfigs) {
      paramConfig.applyToNode(this._node);
    }
  }
  _validateNames(spareParamNamesToAdd) {
    arrayToSet(this._node.params.non_spare_names, _currentParamNames);
    setIntersection(spareParamNamesToAdd, _currentParamNames, _spareParamsWithSameNameAsParams);
    if (_spareParamsWithSameNameAsParams.size > 0) {
      const error_message = `${this._node.path()} attempts to create spare params called '${setToArray(
        _spareParamsWithSameNameAsParams,
        []
      ).join(", ")}' with same name as params`;
      this._node.states.error.set(error_message);
      return false;
    }
    return true;
  }
}
