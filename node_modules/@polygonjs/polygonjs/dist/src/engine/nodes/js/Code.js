"use strict";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF } from "../utils/io/connections/Js";
import { TRIGGER_CONNECTION_NAME, TypedJsNode } from "./_Base";
import { StringParamLanguage } from "../../params/utils/OptionsController";
import { TranspiledFilter } from "../utils/code/controllers/TranspiledFilter";
import { BaseCodeProcessor, buildCodeNodeFunction } from "../../../core/code/FunctionBuilderUtils";
import { JsLinesCollectionController } from "./code/utils/JsLinesCollectionController";
import { inputObject3D } from "./_BaseObject3D";
import { JsAssemblerActor } from "./code/assemblers/actor/ActorAssembler";
import { JsFunctionName } from "../utils/shaders/ShaderName";
import { JsType } from "../../poly/registers/nodes/types/Js";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
export const JS_CODE_DEFAULT_TS = `
export class CodeJsProcessor extends BaseCodeJsProcessor {
	override initializeProcessor(){
		this.io.inputs.setNamedInputConnectionPoints([
			new JsConnectionPoint('myBoolParam', JsConnectionPointType.BOOLEAN),
		]);
		this.io.outputs.setNamedOutputConnectionPoints([
			new JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER),
		]);
	}
	override setTriggerableLines(controller: JsLinesCollectionController) {
		const object3D = this.inputObject3D(this, controller);
		const myBoolParam = this.variableForInput(controller, 'myBoolParam');

		const bodyLines = [
			object3D + '.position.y += ' + myBoolParam + ' ? -1 : 1;',
			object3D + '.updateMatrix()'
		];
		this.addTriggerableLines(controller, bodyLines);
	}
}
`;
const DEFAULT_JS = JS_CODE_DEFAULT_TS.replace(/\:\sJsLinesCollectionController/g, "").replace(/override\s/g, "");
export class BaseCodeJsProcessor extends BaseCodeProcessor {
  constructor(node) {
    super(node);
    this.node = node;
  }
  get pv() {
    return this.node.pv;
  }
  get p() {
    return this.node.p;
  }
  get io() {
    return this.node.io;
  }
  initializeProcessor() {
  }
  setTriggerableLines(controller) {
  }
  inputObject3D(processor, controller) {
    return inputObject3D(this.node, controller);
  }
  variableForInput(controller, inputName) {
    return this.node.variableForInput(controller, inputName);
  }
  addTriggerableLines(controller, bodyLines) {
    return controller.addTriggerableLines(this.node, bodyLines);
  }
}
class CodeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    // compile = ParamConfig.BUTTON(null, {
    // 	callback: (node: BaseNodeType) => {
    // 		CodeJsNode.PARAM_CALLBACK_compile(node as CodeJsNode);
    // 	},
    // 	cook: false,
    // });
    this.codeTypescript = ParamConfig.STRING(JS_CODE_DEFAULT_TS, {
      hideLabel: true,
      language: StringParamLanguage.TYPESCRIPT,
      cook: false
    });
    this.codeJavascript = ParamConfig.STRING(DEFAULT_JS, {
      hidden: true,
      cook: false,
      callback: (node) => {
        CodeJsNode.PARAM_CALLBACK_requestCompile(node);
      }
    });
  }
}
const ParamsConfig = new CodeJsParamsConfig();
export class CodeJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._compilationSuccessful = false;
  }
  static type() {
    return JsType.CODE;
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["codeTypescript", "codeJavascript"]);
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER)
    ]);
    this.params.onParamsCreated("compile", () => {
      this.compile({ triggerFunctionNode: false });
    });
  }
  // override cook() {
  // 	// try {
  // 	// }catch(err){
  // 	// }
  // 	this.compile({triggerFunctionNode: false});
  // 	console.log('COOK: this.compiled()', this.compiled());
  // 	// if (this.compiled()) {
  // 	// } // else {
  // 	//	this.states.error.set(`cannot generate function`);
  // 	//}
  // 	this.cookController.endCook();
  // }
  setTriggerableLines(controller) {
    var _a;
    (_a = this._processor) == null ? void 0 : _a.setTriggerableLines(controller);
  }
  compiled() {
    return this._compilationSuccessful;
  }
  compile(options) {
    const content = TranspiledFilter.filter(this.pv.codeJavascript);
    if (this._lastCompiledCode == content) {
      return;
    }
    this._compilationSuccessful = false;
    this._lastCompiledCode = void 0;
    this._processor = void 0;
    this.states.error.clear();
    const _preventSelfCompilation = () => {
      this._setFunctionNodeToRecompileAllowed(false);
      this.setSelfDirtyForbidden(true);
      this.io.inputs.graphNode().setForbiddenTriggerNodes(this);
    };
    const _restore = () => {
      this._setFunctionNodeToRecompileAllowed(true);
      this.setSelfDirtyForbidden(false);
      this.io.inputs.graphNode().clearForbiddenTriggerNodes();
    };
    try {
      const functionBody = `try {
	${content}
} catch(e) {
		states.error.set(e);
}`;
      const ProcessorClass = buildCodeNodeFunction({
        BaseCodeProcessor: BaseCodeJsProcessor,
        BaseCodeProcessorName: "BaseCodeJsProcessor",
        node: this,
        functionBody,
        otherVariables: {
          ["JsConnectionPoint"]: JsConnectionPoint,
          ["JsConnectionPointType"]: JsConnectionPointType
        }
      });
      if (!ProcessorClass) {
        throw new Error(`cannot generate function`);
      }
      if (ProcessorClass) {
        this._processor = new ProcessorClass(this);
        _preventSelfCompilation();
        this._processor.initializeProcessor();
        const dummyAssembler = new JsAssemblerActor(this.functionNode());
        const dummyShadersCollectionController = new JsLinesCollectionController(
          [JsFunctionName.MAIN],
          JsFunctionName.MAIN,
          dummyAssembler
        );
        this._processor.setTriggerableLines(dummyShadersCollectionController);
        _restore();
        this._compilationSuccessful = true;
        this._lastCompiledCode = content;
        this.states.error.clear();
        if (options.triggerFunctionNode) {
          this._setFunctionNodeToRecompile();
        }
      }
    } catch (e) {
      _restore();
      this.states.error.set(`cannot generate function (${e})`);
      if (options.triggerFunctionNode) {
        this._setFunctionNodeToRecompile();
      }
    }
  }
  static PARAM_CALLBACK_requestCompile(node) {
    node.compile({ triggerFunctionNode: true });
  }
}
// adding BaseCodeJsProcessor seems necessary to have the bundled types include it
CodeJsNode.BaseCodeJsProcessor = BaseCodeJsProcessor;
