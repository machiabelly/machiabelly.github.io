"use strict";
import { TypedJsNode } from "./_Base";
import {
  PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES,
  JsConnectionPointType
} from "../utils/io/connections/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { Poly } from "../../Poly";
import { TypeAssert } from "../../poly/Assert";
var PreviousValueJsNodeInputName = /* @__PURE__ */ ((PreviousValueJsNodeInputName2) => {
  PreviousValueJsNodeInputName2["current"] = "current";
  PreviousValueJsNodeInputName2["offset"] = "offset";
  return PreviousValueJsNodeInputName2;
})(PreviousValueJsNodeInputName || {});
const DefaultValues = {
  ["current" /* current */]: 0,
  ["offset" /* offset */]: 1
};
class PreviousJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.offset = ParamConfig.INTEGER(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new PreviousJsParamsConfig();
const _PreviousValueJsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "previousValue";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  _expectedInputTypes() {
    let firstType = this.io.connection_points.first_input_connection_type();
    if (firstType == null || !PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.includes(firstType)) {
      firstType = JsConnectionPointType.FLOAT;
    }
    return [firstType, JsConnectionPointType.INT];
  }
  _expectedInputName(index) {
    return ["current" /* current */, "offset" /* offset */][index];
  }
  _expectedOutputName(index) {
    return _PreviousValueJsNode.OUTPUT_NAME;
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  setLines(shadersCollectionController) {
    const out = this.jsVarName(_PreviousValueJsNode.OUTPUT_NAME);
    const offset = this.variableForInputParam(shadersCollectionController, this.p.offset);
    const inputValue = this.variableForInput(shadersCollectionController, "current" /* current */);
    const _func = Poly.namedFunctionsRegister.getFunction(this._functionName(), this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType: this._expectedInputTypes()[0],
        varName: out,
        value: _func.asString(`'${this.path()}'`, offset, inputValue)
      }
    ]);
  }
  _functionName() {
    const type = this._expectedInputTypes()[0];
    switch (type) {
      case JsConnectionPointType.BOOLEAN:
      case JsConnectionPointType.FLOAT:
      case JsConnectionPointType.INT:
      case JsConnectionPointType.STRING: {
        return "previousValuePrimitive";
      }
      case JsConnectionPointType.COLOR: {
        return "previousValueColor";
      }
      case JsConnectionPointType.VECTOR2: {
        return "previousValueVector2";
      }
      case JsConnectionPointType.VECTOR3: {
        return "previousValueVector3";
      }
      case JsConnectionPointType.VECTOR4: {
        return "previousValueVector4";
      }
    }
    TypeAssert.unreachable(type);
  }
};
export let PreviousValueJsNode = _PreviousValueJsNode;
PreviousValueJsNode.OUTPUT_NAME = "prev";
