"use strict";
import { TRIGGER_CONNECTION_NAME, TypedJsNode } from "./_Base";
import { inputObject3D, setObject3DOutputLine } from "./_BaseObject3D";
import { Poly } from "../../Poly";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { ConstantJsDefinition } from "./utils/JsDefinition";
import { JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF } from "../utils/io/connections/Js";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
export var ClothSolverStepSimulationOutput = /* @__PURE__ */ ((ClothSolverStepSimulationOutput2) => {
  ClothSolverStepSimulationOutput2["TEXTURE_SIZE"] = "tSize";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION0"] = "tPosition0";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION1"] = "tPosition1";
  ClothSolverStepSimulationOutput2["TEXTURE_NORMAL"] = "tNormal";
  ClothSolverStepSimulationOutput2["TEXTURE_ORIGINAL_RT"] = "tOriginalRT";
  ClothSolverStepSimulationOutput2["TEXTURE_VISCOSITY_SPRING_T"] = "tViscositySpringT";
  ClothSolverStepSimulationOutput2["TEXTURE_PREVIOUS_RT0"] = "tPreviousRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_PREVIOUS_RT1"] = "tPreviousRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_TARGET_RT0"] = "targetRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_TARGET_RT1"] = "targetRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_NORMALS_RT"] = "tNormalsRT";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION_RT0"] = "tPositionRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_POSITION_RT1"] = "tPositionRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_ADJACENT_RT0"] = "tAdjacentsRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_ADJACENT_RT1"] = "tAdjacentsRT1";
  ClothSolverStepSimulationOutput2["TEXTURE_DISTANCE_RT0"] = "tDistanceRT0";
  ClothSolverStepSimulationOutput2["TEXTURE_DISTANCE_RT1"] = "tDistanceRT1";
  ClothSolverStepSimulationOutput2["MATERIAL_INTEGRATION"] = "integrationMat";
  return ClothSolverStepSimulationOutput2;
})(ClothSolverStepSimulationOutput || {});
class ClothSolverStepSimulationJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.stepsCount = ParamConfig.INTEGER(40, {
      range: [1, 100],
      rangeLocked: [true, false]
    });
    this.constraintInfluence = ParamConfig.FLOAT(0.1, {
      range: [0, 2],
      rangeLocked: [true, false]
    });
    this.viscosity = ParamConfig.FLOAT(0.1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
    this.spring = ParamConfig.FLOAT(1, {
      range: [0, 1],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new ClothSolverStepSimulationJsParamsConfig();
export class ClothSolverStepSimulationJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "clothSolverStepSimulation";
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER),
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D),
      new JsConnectionPoint("tSize" /* TEXTURE_SIZE */, JsConnectionPointType.VECTOR2),
      new JsConnectionPoint("tPosition0" /* TEXTURE_POSITION0 */, JsConnectionPointType.TEXTURE),
      new JsConnectionPoint("tPosition1" /* TEXTURE_POSITION1 */, JsConnectionPointType.TEXTURE),
      new JsConnectionPoint("tNormal" /* TEXTURE_NORMAL */, JsConnectionPointType.TEXTURE),
      new JsConnectionPoint("integrationMat" /* MATERIAL_INTEGRATION */, JsConnectionPointType.MATERIAL)
      //
      // ...ADDITIONAL_TEXTURE_OUTPUTS.map(
      // 	(outputName) => new JsConnectionPoint(outputName, JsConnectionPointType.TEXTURE)
      // ),
    ]);
  }
  setLines(linesController) {
    this._addRefs(linesController);
    setObject3DOutputLine(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = inputObject3D(this, linesController);
    const stepsCount = this.variableForInputParam(linesController, this.p.stepsCount);
    const constraintInfluence = this.variableForInputParam(linesController, this.p.constraintInfluence);
    const viscosity = this.variableForInputParam(linesController, this.p.viscosity);
    const spring = this.variableForInputParam(linesController, this.p.spring);
    const configRef = this._addRefs(linesController);
    const func = Poly.namedFunctionsRegister.getFunction("clothSolverStepSimulation", this, linesController);
    const bodyLine = func.asString(
      object3D,
      stepsCount,
      constraintInfluence,
      viscosity,
      spring,
      this._refToString(configRef)
    );
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _refToString(refs) {
    const keys = Object.keys(refs);
    const data = [];
    for (const key of keys) {
      data.push(`${key}:this.${refs[key]}`);
    }
    return `{${data.join(",")}}`;
  }
  _addRefs(linesController) {
    const tSize = this.jsVarName("tSize" /* TEXTURE_SIZE */);
    const tPosition0 = this.jsVarName("tPosition0" /* TEXTURE_POSITION0 */);
    const tPosition1 = this.jsVarName("tPosition1" /* TEXTURE_POSITION1 */);
    const tNormal = this.jsVarName("tNormal" /* TEXTURE_NORMAL */);
    const tOriginalRT = this.jsVarName("tOriginalRT" /* TEXTURE_ORIGINAL_RT */);
    const tViscositySpringT = this.jsVarName("tViscositySpringT" /* TEXTURE_VISCOSITY_SPRING_T */);
    const tPreviousRT0 = this.jsVarName("tPreviousRT0" /* TEXTURE_PREVIOUS_RT0 */);
    const tPreviousRT1 = this.jsVarName("tPreviousRT1" /* TEXTURE_PREVIOUS_RT1 */);
    const tTargetRT0 = this.jsVarName("targetRT0" /* TEXTURE_TARGET_RT0 */);
    const tTargetRT1 = this.jsVarName("targetRT1" /* TEXTURE_TARGET_RT1 */);
    const tNormalsRT = this.jsVarName("tNormalsRT" /* TEXTURE_NORMALS_RT */);
    const tPositionRT0 = this.jsVarName("tPositionRT0" /* TEXTURE_POSITION_RT0 */);
    const tPositionRT1 = this.jsVarName("tPositionRT1" /* TEXTURE_POSITION_RT1 */);
    const tAdjacentsRT0 = this.jsVarName("tAdjacentsRT0" /* TEXTURE_ADJACENT_RT0 */);
    const tAdjacentsRT1 = this.jsVarName("tAdjacentsRT1" /* TEXTURE_ADJACENT_RT1 */);
    const tDistanceRT0 = this.jsVarName("tDistanceRT0" /* TEXTURE_DISTANCE_RT0 */);
    const tDistanceRT1 = this.jsVarName("tDistanceRT1" /* TEXTURE_DISTANCE_RT1 */);
    const integrationMat = this.jsVarName("integrationMat" /* MATERIAL_INTEGRATION */);
    linesController.addDefinitions(this, [
      new ConstantJsDefinition(this, linesController, JsConnectionPointType.VECTOR2, tSize, `null`)
    ]);
    const textures = [
      tPosition0,
      tPosition1,
      tNormal,
      //
      tOriginalRT,
      tViscositySpringT,
      tPreviousRT0,
      tPreviousRT1,
      tTargetRT0,
      tTargetRT1,
      tNormalsRT,
      tPositionRT0,
      tPositionRT1,
      tAdjacentsRT0,
      tAdjacentsRT1,
      tDistanceRT0,
      tDistanceRT1
    ];
    const materials = [integrationMat];
    for (const texture of textures) {
      linesController.addDefinitions(this, [
        new ConstantJsDefinition(this, linesController, JsConnectionPointType.TEXTURE, texture, `null`)
      ]);
    }
    for (const material of materials) {
      linesController.addDefinitions(this, [
        new ConstantJsDefinition(this, linesController, JsConnectionPointType.MATERIAL, material, `null`)
      ]);
    }
    const ref = {
      tSize,
      tPosition0,
      tPosition1,
      tNormal,
      tOriginalRT,
      tViscositySpringT,
      tPreviousRT0,
      tPreviousRT1,
      tTargetRT0,
      tTargetRT1,
      tNormalsRT,
      tPositionRT0,
      tPositionRT1,
      tAdjacentsRT0,
      tAdjacentsRT1,
      tDistanceRT0,
      tDistanceRT1,
      integrationMat
    };
    return ref;
  }
}
