"use strict";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { ParamlessTypedJsNode } from "./_Base";
import { Poly } from "../../Poly";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
var MultScalarJsNodeInputName = /* @__PURE__ */ ((MultScalarJsNodeInputName2) => {
  MultScalarJsNodeInputName2["VALUE"] = "value";
  MultScalarJsNodeInputName2["MULT"] = "mult";
  return MultScalarJsNodeInputName2;
})(MultScalarJsNodeInputName || {});
const DefaultValues = {
  ["value" /* VALUE */]: 1,
  ["mult" /* MULT */]: 1
};
const OUTPUT_NAME = "val";
const ALLOWED_INPUT_TYPES = [
  JsConnectionPointType.COLOR,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
function functionNameByType(type) {
  switch (type) {
    case JsConnectionPointType.COLOR: {
      return "multScalarColor";
    }
    case JsConnectionPointType.VECTOR2: {
      return "multScalarVector2";
    }
    case JsConnectionPointType.VECTOR3: {
      return "multScalarVector3";
    }
    case JsConnectionPointType.VECTOR4: {
      return "multScalarVector4";
    }
  }
}
export class MultScalarJsNode extends ParamlessTypedJsNode {
  static type() {
    return "multScalar";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setLines(shadersCollectionController) {
    const input = this.variableForInput(shadersCollectionController, this._expectedInputName(0));
    const scalar = this.variableForInput(shadersCollectionController, this._expectedInputName(1));
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputType = this._expectedInputTypes()[0];
    const variable = createVariable(inputType);
    const tmpVarName = variable ? shadersCollectionController.addVariable(this, variable) : void 0;
    const functionName = functionNameByType(inputType);
    if (functionName && tmpVarName) {
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      shadersCollectionController.addBodyOrComputed(this, [
        { dataType: inputType, varName, value: func.asString(input, scalar, tmpVarName) }
      ]);
      return;
    }
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType && ALLOWED_INPUT_TYPES.includes(firstType) ? firstType : JsConnectionPointType.VECTOR3;
    return [type, JsConnectionPointType.FLOAT];
  }
  _expectedOutputTypes() {
    return [this._expectedInputTypes()[0]];
  }
  _expectedInputName(index) {
    return ["value" /* VALUE */, "mult" /* MULT */][index];
  }
  _expectedOutputName(index) {
    return OUTPUT_NAME;
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
}
