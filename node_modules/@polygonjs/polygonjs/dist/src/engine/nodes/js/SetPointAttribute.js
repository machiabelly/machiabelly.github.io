"use strict";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { Poly } from "../../Poly";
import {
  inputObject3D,
  inputPointIndex,
  vector3OutputFromInput,
  floatOutputFromInput,
  integerOutputFromInput,
  setObject3DOutputLine
} from "./_BaseObject3D";
import {
  JS_CONNECTION_POINT_IN_NODE_DEF,
  JsConnectionPoint,
  JsConnectionPointType,
  POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES
} from "../utils/io/connections/Js";
import { TypedJsNode } from "./_Base";
import { TypeAssert } from "../../poly/Assert";
export var SetPointAttributeInputName = /* @__PURE__ */ ((SetPointAttributeInputName2) => {
  SetPointAttributeInputName2["ptnum"] = "ptnum";
  SetPointAttributeInputName2["attribName"] = "attribName";
  SetPointAttributeInputName2["lerp"] = "lerp";
  SetPointAttributeInputName2["val"] = "val";
  return SetPointAttributeInputName2;
})(SetPointAttributeInputName || {});
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
class SetPointAttributeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param attribute type */
    this.type = ParamConfig.INTEGER(POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    /** @param attribName */
    this.attribName = ParamConfig.STRING("");
    /** @param point index */
    this.ptnum = ParamConfig.INTEGER(0);
    /** @param lerp factor */
    this.lerp = ParamConfig.FLOAT(1);
  }
}
const ParamsConfig = new SetPointAttributeJsParamsConfig();
export class SetPointAttributeJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.SET_POINT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),
      new JsConnectionPoint("ptnum" /* ptnum */, JsConnectionPointType.INT, CONNECTION_OPTIONS),
      new JsConnectionPoint(
        "attribName" /* attribName */,
        JsConnectionPointType.STRING,
        CONNECTION_OPTIONS
      ),
      new JsConnectionPoint("lerp", JsConnectionPointType.FLOAT, {
        ...CONNECTION_OPTIONS,
        init_value: 1
      })
    ]);
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputType.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
  }
  _expectedInputType() {
    return [this._currentConnectionType()];
  }
  _expectedOutputTypes() {
    return [
      JsConnectionPointType.TRIGGER,
      JsConnectionPointType.OBJECT_3D,
      JsConnectionPointType.INT,
      JsConnectionPointType.STRING,
      JsConnectionPointType.FLOAT,
      this._currentConnectionType()
    ];
  }
  _expectedInputName(index) {
    return "val" /* val */;
  }
  _expectedOutputName(index) {
    return [
      JsConnectionPointType.TRIGGER,
      JsConnectionPointType.OBJECT_3D,
      "ptnum" /* ptnum */,
      "attribName" /* attribName */,
      "lerp" /* lerp */,
      "val" /* val */
    ][index];
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const connectionType = POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES[this.pv.type];
    if (connectionType == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return connectionType || JsConnectionPointType.FLOAT;
  }
  setAttribType(type) {
    this.p.type.set(POINT_ATTRIBUTE_JS_CONNECTION_POINT_TYPES.indexOf(type));
  }
  setAttribName(attribName) {
    this.params.get("attribName" /* attribName */).set(attribName);
  }
  setLines(linesController) {
    setObject3DOutputLine(this, linesController);
    integerOutputFromInput(this, "ptnum" /* ptnum */, linesController);
    vector3OutputFromInput(this, "attribName" /* attribName */, linesController);
    floatOutputFromInput(this, "lerp" /* lerp */, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = inputObject3D(this, linesController);
    const ptnum = inputPointIndex(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const lerp = this.variableForInput(linesController, "lerp" /* lerp */);
    const newValue = this.variableForInput(linesController, "val" /* val */);
    const functionName = this._functionName();
    const func = Poly.namedFunctionsRegister.getFunction(functionName, this, linesController);
    const bodyLine = func.asString(object3D, attribName, ptnum, newValue, lerp);
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _functionName() {
    const type = this._currentConnectionType();
    switch (type) {
      case JsConnectionPointType.INT:
      case JsConnectionPointType.FLOAT:
        return "setPointAttributeNumber";
      case JsConnectionPointType.COLOR:
        return "setPointAttributeColor";
      case JsConnectionPointType.VECTOR2:
        return "setPointAttributeVector2";
      case JsConnectionPointType.VECTOR3:
        return "setPointAttributeVector3";
      case JsConnectionPointType.VECTOR4:
        return "setPointAttributeVector4";
    }
    TypeAssert.unreachable(type);
  }
}
