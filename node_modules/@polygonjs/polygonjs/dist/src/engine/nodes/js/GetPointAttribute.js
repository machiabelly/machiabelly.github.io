"use strict";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF } from "../utils/io/connections/Js";
import { Poly } from "../../Poly";
import { inputObject3D, inputPointIndex } from "./_BaseObject3D";
import { TypedJsNode } from "./_Base";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { TypeAssert } from "../../poly/Assert";
import { GetPointPropertyJsNodeInputName } from "../../../core/reactivity/PointPropertyReactivity";
import { Vector2, Vector3, Vector4 } from "three";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
export const AVAILABLE_TYPES = [
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.INT,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
function typedVisibleOptions(type, otherParamVal = {}) {
  const val = AVAILABLE_TYPES.indexOf(type);
  return { visibleIf: { type: val, ...otherParamVal } };
}
var GetPointAttributeInputName = /* @__PURE__ */ ((GetPointAttributeInputName2) => {
  GetPointAttributeInputName2["attribName"] = "attribName";
  return GetPointAttributeInputName2;
})(GetPointAttributeInputName || {});
var GetPointAttributeOutputName = /* @__PURE__ */ ((GetPointAttributeOutputName2) => {
  GetPointAttributeOutputName2["VALUE"] = "val";
  return GetPointAttributeOutputName2;
})(GetPointAttributeOutputName || {});
class GetObjectAttributeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    // attribName = ParamConfig.STRING('');
    this.type = ParamConfig.INTEGER(AVAILABLE_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: AVAILABLE_TYPES.map((name, value) => ({ name, value }))
      }
    });
    this.defaultFloat = ParamConfig.FLOAT(0, typedVisibleOptions(JsConnectionPointType.FLOAT));
    this.defaultInteger = ParamConfig.INTEGER(0, typedVisibleOptions(JsConnectionPointType.INT));
    this.defaultVector2 = ParamConfig.VECTOR2([0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR2));
    this.defaultVector3 = ParamConfig.VECTOR3([0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR3));
    this.defaultVector4 = ParamConfig.VECTOR4([0, 0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR4));
  }
}
const ParamsConfig = new GetObjectAttributeJsParamsConfig();
export class GetPointAttributeJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return JsType.GET_POINT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS),
      new JsConnectionPoint(GetPointPropertyJsNodeInputName.ptnum, JsConnectionPointType.INT, CONNECTION_OPTIONS),
      new JsConnectionPoint(
        "attribName" /* attribName */,
        JsConnectionPointType.STRING,
        CONNECTION_OPTIONS
      )
    ]);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [
      JsConnectionPointType.INT,
      this._currentConnectionType()
    ]);
    this.io.connection_points.set_output_name_function(
      (index) => [GetPointPropertyJsNodeInputName.ptnum, "val" /* VALUE */][index]
    );
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const type = this.attribType();
    if (type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return type;
  }
  defaultValueParam() {
    const type = this.attribType();
    switch (type) {
      case JsConnectionPointType.FLOAT: {
        return this.p.defaultFloat;
      }
      case JsConnectionPointType.INT: {
        return this.p.defaultInteger;
      }
      case JsConnectionPointType.VECTOR2: {
        return this.p.defaultVector2;
      }
      case JsConnectionPointType.VECTOR3: {
        return this.p.defaultVector3;
      }
      case JsConnectionPointType.VECTOR4: {
        return this.p.defaultVector4;
      }
    }
    TypeAssert.unreachable(type);
  }
  _bodyLine(linesController) {
    const object3D = inputObject3D(this, linesController);
    const ptnum = inputPointIndex(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const defaultParam = this.defaultValueParam();
    const defaultValue = this.variableForInputParam(linesController, defaultParam);
    const type = this.attribType();
    switch (type) {
      case JsConnectionPointType.FLOAT:
      case JsConnectionPointType.INT: {
        const func = Poly.namedFunctionsRegister.getFunction("getPointAttributeNumber", this, linesController);
        return func.asString(object3D, ptnum, attribName, defaultValue);
      }
      case JsConnectionPointType.VECTOR2:
      case JsConnectionPointType.VECTOR3:
      case JsConnectionPointType.VECTOR4: {
        const functionName = type == JsConnectionPointType.VECTOR2 ? "getPointAttributeVector2" : type == JsConnectionPointType.VECTOR3 ? "getPointAttributeVector3" : "getPointAttributeVector4";
        const tmpVar = type == JsConnectionPointType.VECTOR2 ? new Vector2() : type == JsConnectionPointType.VECTOR3 ? new Vector3() : new Vector4();
        const tmpVarName = linesController.addVariable(this, tmpVar);
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, linesController);
        return func.asString(object3D, ptnum, attribName, defaultValue, tmpVarName);
      }
    }
    TypeAssert.unreachable(type);
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(AVAILABLE_TYPES.indexOf(type));
  }
  attribType() {
    const type = AVAILABLE_TYPES[this.pv.type];
    return type;
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(linesController) {
    const out = this.jsVarName("val" /* VALUE */);
    const dataType = AVAILABLE_TYPES[this.pv.type];
    const bodyLine = this._bodyLine(linesController);
    linesController.addBodyOrComputed(this, [{ dataType, varName: out, value: bodyLine }]);
  }
}
