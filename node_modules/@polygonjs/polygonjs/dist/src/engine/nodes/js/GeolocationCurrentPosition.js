"use strict";
import { ParamlessTypedJsNode } from "./_Base";
import { JsConnectionPoint, JsConnectionPointType, JS_CONNECTION_POINT_IN_NODE_DEF } from "../utils/io/connections/Js";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { Poly } from "../../Poly";
import { WatchedValueJsDefinition } from "./utils/JsDefinition";
import { nodeMethodName } from "./code/assemblers/actor/ActorAssemblerUtils";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
var GeolocationCurrentPositionOutput = /* @__PURE__ */ ((GeolocationCurrentPositionOutput2) => {
  GeolocationCurrentPositionOutput2["LAT"] = "lat";
  GeolocationCurrentPositionOutput2["LNG"] = "lng";
  return GeolocationCurrentPositionOutput2;
})(GeolocationCurrentPositionOutput || {});
export class GeolocationCurrentPositionJsNode extends ParamlessTypedJsNode {
  static type() {
    return JsType.GEOLOCATION_CURRENT_POSITION;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS)
    ]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.TRIGGER, JsConnectionPointType.TRIGGER, CONNECTION_OPTIONS),
      new JsConnectionPoint(
        "lat" /* LAT */,
        JsConnectionPointType.FLOAT,
        CONNECTION_OPTIONS
      ),
      new JsConnectionPoint(
        "lng" /* LNG */,
        JsConnectionPointType.FLOAT,
        CONNECTION_OPTIONS
      )
    ]);
  }
  setLines(linesController) {
    const usedOutputNames = this.io.outputs.used_output_names();
    const _val = (propertyName, functionName, type) => {
      if (!usedOutputNames.includes(propertyName)) {
        return;
      }
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, linesController);
      const varName = this.jsVarName(propertyName);
      linesController.addBodyOrComputed(this, [
        {
          dataType: type,
          varName,
          value: func.asString()
        }
      ]);
    };
    _val("lat" /* LAT */, "geolocationLatitude", JsConnectionPointType.FLOAT);
    _val("lng" /* LNG */, "geolocationLongitude", JsConnectionPointType.FLOAT);
  }
  setTriggeringLines(linesController, triggeredMethods) {
    const geolocationCurrentPositionRef = Poly.namedFunctionsRegister.getFunction(
      "geolocationCurrentPositionRef",
      this,
      linesController
    );
    linesController.addDefinitions(this, [
      new WatchedValueJsDefinition(
        this,
        linesController,
        JsConnectionPointType.VECTOR2,
        geolocationCurrentPositionRef.asString(),
        `this.${nodeMethodName(this)}()`,
        {
          deep: true
        }
      )
    ]);
    linesController.addTriggeringLines(this, [triggeredMethods], {
      gatherable: false
    });
  }
  setTriggerableLines(linesController) {
    const func = Poly.namedFunctionsRegister.getFunction("geolocationGetCurrentPosition", this, linesController);
    const bodyLine = func.asString();
    linesController.addTriggerableLines(this, [bodyLine]);
  }
}
