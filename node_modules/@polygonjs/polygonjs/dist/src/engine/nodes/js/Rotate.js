"use strict";
import { TypedJsNode } from "./_Base";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { ParamConfig, NodeParamsConfig } from "../utils/params/ParamsConfig";
import { Vector3 } from "three";
import { Poly } from "../../Poly";
export var JsRotateMode = /* @__PURE__ */ ((JsRotateMode2) => {
  JsRotateMode2[JsRotateMode2["AXIS"] = 0] = "AXIS";
  JsRotateMode2[JsRotateMode2["QUAT"] = 1] = "QUAT";
  return JsRotateMode2;
})(JsRotateMode || {});
const Modes = [0 /* AXIS */, 1 /* QUAT */];
export var JsRotateInputNameAxisMode = /* @__PURE__ */ ((JsRotateInputNameAxisMode2) => {
  JsRotateInputNameAxisMode2["AXIS"] = "axis";
  JsRotateInputNameAxisMode2["ANGLE"] = "angle";
  return JsRotateInputNameAxisMode2;
})(JsRotateInputNameAxisMode || {});
const LabelByMode = {
  [0 /* AXIS */]: "from axis + angle",
  [1 /* QUAT */]: "from quaternion"
};
const InputNamesByMode = {
  [0 /* AXIS */]: [
    JsConnectionPointType.VECTOR3,
    "axis" /* AXIS */,
    "angle" /* ANGLE */
  ],
  [1 /* QUAT */]: [JsConnectionPointType.VECTOR3, JsConnectionPointType.QUATERNION]
};
const MethodNameByMode = {
  [0 /* AXIS */]: "rotateWithAxisAngle",
  [1 /* QUAT */]: "rotateWithQuat"
};
const InputTypesByMode = {
  [0 /* AXIS */]: [JsConnectionPointType.VECTOR3, JsConnectionPointType.VECTOR3, JsConnectionPointType.FLOAT],
  [1 /* QUAT */]: [JsConnectionPointType.VECTOR3, JsConnectionPointType.QUATERNION]
};
const DefaultValues = {
  vector: [0, 0, 1],
  axis: [0, 1, 0]
};
class RotateParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.mode = ParamConfig.INTEGER(0 /* AXIS */, {
      menu: {
        entries: Modes.map((mode, i) => {
          const label = LabelByMode[mode];
          return { name: label, value: i };
        })
      }
    });
  }
}
const ParamsConfig = new RotateParamsConfig();
export class RotateJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "rotate";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  setMode(mode) {
    const index = Modes.indexOf(mode);
    this.p.mode.set(index);
  }
  mode() {
    return Modes[this.pv.mode] || 0 /* AXIS */;
  }
  _expectedInputName(index) {
    return InputNamesByMode[this.mode()][index];
  }
  _expectedOutputName(index) {
    return JsConnectionPointType.VECTOR3;
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  functionName() {
    return MethodNameByMode[this.mode()];
  }
  _expectedInputTypes() {
    return InputTypesByMode[this.mode()];
  }
  _expectedOutputTypes() {
    return [JsConnectionPointType.VECTOR3];
  }
  setLines(linesController) {
    const mode = this.mode();
    switch (mode) {
      case 0 /* AXIS */:
        this._setLinesForAxisAngle(linesController);
        break;
      case 1 /* QUAT */:
        this._setLinesForQuat(linesController);
        break;
    }
  }
  _setLinesForAxisAngle(linesController) {
    const inputNames = InputNamesByMode[0 /* AXIS */];
    const vector = this.variableForInput(linesController, inputNames[0]);
    const axis = this.variableForInput(linesController, inputNames[1]);
    const angle = this.variableForInput(linesController, inputNames[2]);
    const varName = this.jsVarName(JsConnectionPointType.VECTOR3);
    const tmpVarName = linesController.addVariable(this, new Vector3());
    const func = Poly.namedFunctionsRegister.getFunction("rotateWithAxisAngle", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: JsConnectionPointType.EULER,
        varName,
        value: func.asString(vector, axis, angle, tmpVarName)
      }
    ]);
  }
  _setLinesForQuat(linesController) {
    const inputNames = InputNamesByMode[1 /* QUAT */];
    const vector = this.variableForInput(linesController, inputNames[0]);
    const quat = this.variableForInput(linesController, inputNames[1]);
    const varName = this.jsVarName(JsConnectionPointType.VECTOR3);
    const tmpVarName = linesController.addVariable(this, new Vector3());
    const func = Poly.namedFunctionsRegister.getFunction("rotateWithQuaternion", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType: JsConnectionPointType.EULER,
        varName,
        value: func.asString(vector, quat, tmpVarName)
      }
    ]);
  }
}
