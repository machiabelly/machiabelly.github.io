"use strict";
import { TypedJsNode } from "./_Base";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { Poly } from "../../Poly";
import { defaultObject } from "./_BaseObject3D";
export const ATTRIBUTE_NODE_AVAILABLE_JS_TYPES = [
  JsConnectionPointType.COLOR,
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.INT,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
export var ImportAttributeJsNodeInput = /* @__PURE__ */ ((ImportAttributeJsNodeInput2) => {
  ImportAttributeJsNodeInput2["INDEX"] = "index";
  return ImportAttributeJsNodeInput2;
})(ImportAttributeJsNodeInput || {});
export var ImportAttributeJsNodeOutput = /* @__PURE__ */ ((ImportAttributeJsNodeOutput2) => {
  ImportAttributeJsNodeOutput2["VAL"] = "val";
  return ImportAttributeJsNodeOutput2;
})(ImportAttributeJsNodeOutput || {});
class ImportAttributeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.name = ParamConfig.STRING("");
    this.type = ParamConfig.INTEGER(0, {
      menu: {
        entries: ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    /** @param entity index */
    this.index = ParamConfig.INTEGER(0);
  }
}
const ParamsConfig = new ImportAttributeJsParamsConfig();
export class ImportAttributeJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.IMPORT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(() => this._expectedInputTypes());
    this.io.connection_points.set_input_name_function((index) => this.inputName());
    this.io.connection_points.set_expected_output_types_function(() => [this._expectedOutputType()]);
  }
  _expectedInputTypes() {
    return [JsConnectionPointType.INT];
  }
  _expectedOutputType() {
    return ATTRIBUTE_NODE_AVAILABLE_JS_TYPES[this.pv.type];
  }
  inputName() {
    return "index" /* INDEX */;
  }
  outputName() {
    return "val" /* VAL */;
  }
  attribData() {
    return {
      attribName: this.attributeName(),
      attribType: this.jsType()
    };
  }
  attributeName() {
    return this.pv.name.trim();
  }
  jsType() {
    const connectionPoints = this.io.outputs.namedOutputConnectionPoints();
    if (!connectionPoints) {
      return JsConnectionPointType.FLOAT;
    }
    return connectionPoints[0].type();
  }
  setJsType(type) {
    this.p.type.set(ATTRIBUTE_NODE_AVAILABLE_JS_TYPES.indexOf(type));
  }
  setLines(linesController) {
    const primitiveGraph = defaultObject(linesController);
    const index = this.variableForInputParam(linesController, this.p.index);
    const attribName = this.variableForInputParam(linesController, this.p.name);
    const out = this.jsVarName("val" /* VAL */);
    const func = Poly.namedFunctionsRegister.getFunction("importPrimitiveAttributeNumber", this, linesController);
    const bodyLine = func.asString(primitiveGraph, attribName, index);
    linesController.addBodyOrComputed(this, [{ dataType: JsConnectionPointType.INT, varName: out, value: bodyLine }]);
  }
}
