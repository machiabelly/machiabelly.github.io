"use strict";
import { TypedJsNode } from "./_Base";
import {
  JsConnectionPoint,
  JsConnectionPointType,
  JS_CONNECTION_POINT_TYPES,
  JS_CONNECTION_POINT_IN_NODE_DEF
} from "../utils/io/connections/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { inputObject3D } from "./_BaseObject3D";
import { Poly } from "../../Poly";
import { JsType } from "../../poly/registers/nodes/types/Js";
const CONNECTION_OPTIONS = JS_CONNECTION_POINT_IN_NODE_DEF;
class GetObjectUserDataJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.type = ParamConfig.INTEGER(JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: JS_CONNECTION_POINT_TYPES.map((name, i) => {
          return { name, value: i };
        })
      }
    });
    this.name = ParamConfig.STRING("");
  }
}
const ParamsConfig = new GetObjectUserDataJsParamsConfig();
const _GetObjectUserDataJsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return JsType.GET_OBJECT_USER_DATA;
  }
  initializeNode() {
    this.io.inputs.setNamedInputConnectionPoints([
      new JsConnectionPoint(JsConnectionPointType.OBJECT_3D, JsConnectionPointType.OBJECT_3D, CONNECTION_OPTIONS)
    ]);
    this.io.connection_points.set_output_name_function((index) => _GetObjectUserDataJsNode.OUTPUT_NAME);
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(() => [this._currentConnectionType()]);
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} actor node type not valid`);
    }
    const connectionType = JS_CONNECTION_POINT_TYPES[this.pv.type];
    if (connectionType == null) {
      console.warn(`${this.type()} actor node type not valid`);
    }
    return connectionType;
  }
  setUserDataType(type) {
    this.p.type.set(JS_CONNECTION_POINT_TYPES.indexOf(type));
  }
  setLines(shadersCollectionController) {
    const object3D = inputObject3D(this, shadersCollectionController);
    const userDataName = this.variableForInputParam(shadersCollectionController, this.p.name);
    const dataType = this._currentConnectionType();
    const varName = this.jsVarName(_GetObjectUserDataJsNode.OUTPUT_NAME);
    const func = Poly.namedFunctionsRegister.getFunction("getObjectUserData", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(object3D, userDataName)
      }
    ]);
  }
  // public override outputValue(
  // 	context: JsNodeTriggerContext,
  // 	outputName: string
  // ): ReturnValueTypeByJsConnectionPointType[JsConnectionPointType] | undefined {
  // 	const Object3D =
  // 		this._inputValue<JsConnectionPointType.OBJECT_3D>(JsConnectionPointType.OBJECT_3D, context) ||
  // 		context.Object3D;
  // 	return Object3D.userData[this.pv.name];
  // }
};
export let GetObjectUserDataJsNode = _GetObjectUserDataJsNode;
GetObjectUserDataJsNode.OUTPUT_NAME = "val";
