"use strict";
import { BaseMathFunctionJsNode } from "./_BaseMathFunction";
import {
  JsConnectionPointType,
  isJsConnectionPointPrimitive,
  JsConnectionPointTypeToArrayTypeMap,
  isJsConnectionPointArray,
  JsConnectionPointTypeFromArrayTypeMap
} from "../utils/io/connections/Js";
import { Poly } from "../../Poly";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
import {
  _vectorFunctionName_1,
  _vectorFunctionName_2,
  _vectorFunctionName_3,
  _vectorFunctionName_4,
  _vectorFunctionName_5
} from "../../functions/_MathGeneric";
export const PRIMITIVE_ALLOWED_TYPES = [
  JsConnectionPointType.INT,
  JsConnectionPointType.COLOR,
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
const ARRAY_ALLOWED_TYPES = PRIMITIVE_ALLOWED_TYPES.map((type) => JsConnectionPointTypeToArrayTypeMap[type]);
export const DEFAULT_ALLOWED_TYPES = [...PRIMITIVE_ALLOWED_TYPES, ...ARRAY_ALLOWED_TYPES];
export const FUNC_ARG_NAME = "_mathFunc";
export function MathFunctionArgXOperationFactory(type, options) {
  const inputPrefix = options.inputPrefix || type;
  const outputName = options.out || "val";
  const allowed_in_types = options.allowed_in_types || DEFAULT_ALLOWED_TYPES;
  return class Node extends BaseMathFunctionJsNode {
    static type() {
      return type;
    }
    initializeNode() {
      super.initializeNode();
      this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
      this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
      this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
      this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    }
    setLines(shadersCollectionController) {
      const varName = this.jsVarName(this._expectedOutputName(0));
      const inputType = this._expectedInputTypes()[0];
      const variable = createVariable(inputType);
      const tmpVarName = variable != null ? shadersCollectionController.addVariable(this, variable) : void 0;
      const mainFunction = this._mainFunction(shadersCollectionController, tmpVarName);
      if (!mainFunction) {
        return;
      }
      shadersCollectionController.addBodyOrComputed(this, [{ dataType: inputType, varName, value: mainFunction }]);
    }
    _mainFunction(shadersCollectionController, tmpVarName) {
      const functionData = this._functionData();
      const { vectorFunctionNameFunction, mathFloat, mathPrimArray, mathVectorArray } = functionData;
      const args = this._inputArgs(shadersCollectionController);
      const inputType = this._expectedInputTypes()[0];
      const isPrimitive = isJsConnectionPointPrimitive(inputType);
      const coreFunction = this._coreFunction(shadersCollectionController);
      if (isPrimitive) {
        return Poly.namedFunctionsRegister.getFunction(mathFloat, this, shadersCollectionController).asString(...[coreFunction, ...args]);
      }
      if (!tmpVarName) {
        return;
      }
      const vectorFunctionName = vectorFunctionNameFunction(inputType);
      if (vectorFunctionName) {
        return Poly.namedFunctionsRegister.getFunction(vectorFunctionName, this, shadersCollectionController).asString(...[coreFunction, ...args, tmpVarName]);
      }
      if (isJsConnectionPointArray(inputType)) {
        const elementInputType = JsConnectionPointTypeFromArrayTypeMap[inputType];
        const vectorElementInputFunctionName = vectorFunctionNameFunction(elementInputType);
        if (vectorElementInputFunctionName) {
          Poly.namedFunctionsRegister.getFunction(vectorElementInputFunctionName, this, shadersCollectionController).asString("", "", "");
          return Poly.namedFunctionsRegister.getFunction(mathVectorArray, this, shadersCollectionController).asString(...[coreFunction, vectorElementInputFunctionName, ...args, tmpVarName]);
        } else {
          return Poly.namedFunctionsRegister.getFunction(mathPrimArray, this, shadersCollectionController).asString(...[coreFunction, ...args, tmpVarName]);
        }
      }
    }
    _coreFunction(shadersCollectionController) {
      return `Math.${type}`;
    }
    _functionData() {
      return {
        vectorFunctionNameFunction: _vectorFunctionName_1,
        mathFloat: "mathFloat_1",
        mathPrimArray: "mathPrimArray_1",
        mathVectorArray: "mathVectorArray_1"
      };
    }
    _inputValuesCount() {
      const inputTypes = this._expectedInputTypes();
      const inputValuesCount = inputTypes.length;
      return inputValuesCount;
    }
    _inputArgs(shadersCollectionController) {
      const inputValuesCount = this._inputValuesCount();
      const inputArgs = [];
      for (let i = 0; i < inputValuesCount; i++) {
        const arg = this.variableForInput(shadersCollectionController, this._expectedInputName(i));
        inputArgs.push(arg);
      }
      return inputArgs;
    }
    _expectedInputName(index) {
      return inputPrefix;
    }
    _expectedOutputName(index) {
      return outputName;
    }
    _expectedInputTypes() {
      let first_input_type = this.io.connection_points.first_input_connection_type();
      const connectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (first_input_type && connectionPoints) {
        if (!allowed_in_types.includes(first_input_type)) {
          const first_connection = connectionPoints[0];
          if (first_connection) {
            first_input_type = first_connection.type();
          }
        }
      }
      const type2 = first_input_type || JsConnectionPointType.FLOAT;
      return [type2];
    }
    _expectedOutputTypes() {
      return [this._expectedInputTypes()[0]];
    }
  };
}
export function MathFunctionArg1OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
  };
}
export function MathFunctionArg2OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _vectorFunctionName_2,
        mathFloat: "mathFloat_2",
        mathPrimArray: "mathPrimArray_2",
        mathVectorArray: "mathVectorArray_2"
      };
    }
  };
}
export function MathFunctionArg3OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _vectorFunctionName_3,
        mathFloat: "mathFloat_3",
        mathPrimArray: "mathPrimArray_3",
        mathVectorArray: "mathVectorArray_3"
      };
    }
  };
}
export function MathFunctionArg4OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _vectorFunctionName_4,
        mathFloat: "mathFloat_4",
        mathPrimArray: "mathPrimArray_4",
        mathVectorArray: "mathVectorArray_4"
      };
    }
  };
}
export function MathFunctionArg5OperationFactory(type, options) {
  return class Node extends MathFunctionArgXOperationFactory(type, options) {
    // TODO: this should ideally be inherited from the class created by MathFunctionArgXOperationFactory
    // and would therefore require an override statement,
    // and would then automatically have the return type FunctionData<MathVectorFunction2>
    _functionData() {
      return {
        vectorFunctionNameFunction: _vectorFunctionName_5,
        mathFloat: "mathFloat_5",
        mathPrimArray: "mathPrimArray_5",
        mathVectorArray: "mathVectorArray_5"
      };
    }
  };
}
