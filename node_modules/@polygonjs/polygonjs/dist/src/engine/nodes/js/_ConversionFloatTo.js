"use strict";
import { TypedJsNode } from "./_Base";
import { JsConnectionPointType, JsConnectionPoint } from "../utils/io/connections/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { Color, Vector2, Vector3, Vector4 } from "three";
import { Poly } from "../../Poly";
class FloatToColorJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.r = ParamConfig.FLOAT(0);
    this.g = ParamConfig.FLOAT(0);
    this.b = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig_Color = new FloatToColorJsParamsConfig();
export class FloatToColorJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Color;
  }
  static type() {
    return "floatToColor";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(FloatToVec3JsNode.OUTPUT_NAME, JsConnectionPointType.COLOR)
    ]);
  }
  setLines(shadersCollectionController) {
    const r = this.variableForInputParam(shadersCollectionController, this.p.r);
    const g = this.variableForInputParam(shadersCollectionController, this.p.g);
    const b = this.variableForInputParam(shadersCollectionController, this.p.b);
    const out = this.jsVarName(FloatToVec3JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new Color());
    const func = Poly.namedFunctionsRegister.getFunction("floatToColor", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: JsConnectionPointType.VECTOR3, varName: out, value: func.asString(r, g, b, tmpVarName) }
    ]);
  }
}
FloatToColorJsNode.OUTPUT_NAME = "Color";
class FloatToVec2JsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.x = ParamConfig.FLOAT(0);
    this.y = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig_Vector2 = new FloatToVec2JsParamsConfig();
const _FloatToVec2JsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vector2;
  }
  static type() {
    return "floatToVec2";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(_FloatToVec2JsNode.OUTPUT_NAME, JsConnectionPointType.VECTOR2)
    ]);
  }
  setLines(shadersCollectionController) {
    const x = this.variableForInputParam(shadersCollectionController, this.p.x);
    const y = this.variableForInputParam(shadersCollectionController, this.p.y);
    const varName = this.jsVarName(_FloatToVec2JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new Vector2());
    const func = Poly.namedFunctionsRegister.getFunction("floatToVec2", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: JsConnectionPointType.VECTOR3, varName, value: func.asString(x, y, tmpVarName) }
    ]);
  }
};
export let FloatToVec2JsNode = _FloatToVec2JsNode;
FloatToVec2JsNode.OUTPUT_NAME = "vec2";
class FloatToVec3JsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.x = ParamConfig.FLOAT(0);
    this.y = ParamConfig.FLOAT(0);
    this.z = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig_Vector3 = new FloatToVec3JsParamsConfig();
const _FloatToVec3JsNode = class extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vector3;
  }
  static type() {
    return "floatToVec3";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(_FloatToVec3JsNode.OUTPUT_NAME, JsConnectionPointType.VECTOR3)
    ]);
  }
  setLines(shadersCollectionController) {
    const x = this.variableForInputParam(shadersCollectionController, this.p.x);
    const y = this.variableForInputParam(shadersCollectionController, this.p.y);
    const z = this.variableForInputParam(shadersCollectionController, this.p.z);
    const out = this.jsVarName(_FloatToVec3JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new Vector3());
    const func = Poly.namedFunctionsRegister.getFunction("floatToVec3", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: JsConnectionPointType.VECTOR3, varName: out, value: func.asString(x, y, z, tmpVarName) }
    ]);
  }
};
export let FloatToVec3JsNode = _FloatToVec3JsNode;
FloatToVec3JsNode.OUTPUT_NAME = "vec3";
class FloatToVec4JsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.x = ParamConfig.FLOAT(0);
    this.y = ParamConfig.FLOAT(0);
    this.z = ParamConfig.FLOAT(0);
    this.w = ParamConfig.FLOAT(0);
  }
}
const ParamsConfig_Vector4 = new FloatToVec4JsParamsConfig();
export class FloatToVec4JsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig_Vector4;
  }
  static type() {
    return "floatToVec4";
  }
  initializeNode() {
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(FloatToVec3JsNode.OUTPUT_NAME, JsConnectionPointType.VECTOR4)
    ]);
  }
  setLines(shadersCollectionController) {
    const x = this.variableForInputParam(shadersCollectionController, this.p.x);
    const y = this.variableForInputParam(shadersCollectionController, this.p.y);
    const z = this.variableForInputParam(shadersCollectionController, this.p.z);
    const w = this.variableForInputParam(shadersCollectionController, this.p.w);
    const varName = this.jsVarName(FloatToVec3JsNode.OUTPUT_NAME);
    const tmpVarName = shadersCollectionController.addVariable(this, new Vector4());
    const func = Poly.namedFunctionsRegister.getFunction("floatToVec4", this, shadersCollectionController);
    shadersCollectionController.addBodyOrComputed(this, [
      { dataType: JsConnectionPointType.VECTOR3, varName, value: func.asString(x, y, z, w, tmpVarName) }
    ]);
  }
}
FloatToVec4JsNode.OUTPUT_NAME = "vec4";
