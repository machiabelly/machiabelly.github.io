"use strict";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { ParamlessTypedJsNode } from "./_Base";
import { ThreeToJs } from "../../../core/ThreeToJs";
const INPUT_TYPES_ALLOWING_NON_CONNECTED_INPUT = /* @__PURE__ */ new Set([
  JsConnectionPointType.BOOLEAN,
  JsConnectionPointType.COLOR,
  JsConnectionPointType.INT,
  JsConnectionPointType.STRING,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
]);
const _SwitchJsNode = class extends ParamlessTypedJsNode {
  static type() {
    return "switch";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputName(index) {
    if (index == 0) {
      return _SwitchJsNode.INPUT_INDEX_NAME;
    } else {
      return `in${index - 1}`;
    }
  }
  _expectedOutputName() {
    return _SwitchJsNode.OUTPUT_NAME;
  }
  _expectedInputTypes() {
    const secondInputType = this.io.connection_points.input_connection_type(1);
    const type = secondInputType || JsConnectionPointType.FLOAT;
    const currentConnections = this.io.connections.inputConnections() || [];
    let lastValidConnectionIndex = 1;
    let i = 0;
    for (const connection of currentConnections) {
      if (connection) {
        lastValidConnectionIndex = i;
      }
      i++;
    }
    const expectedCount = Math.max(lastValidConnectionIndex + 1, 2);
    const expectedInputTypes = [JsConnectionPointType.INT];
    for (let i2 = 0; i2 < expectedCount; i2++) {
      expectedInputTypes.push(type);
    }
    return expectedInputTypes;
  }
  _expectedOutputTypes() {
    const inputTypes = this._expectedInputTypes();
    const type = inputTypes[1] || JsConnectionPointType.FLOAT;
    return [type];
  }
  setLines(shadersCollectionController) {
    const inputIndex = ThreeToJs.integer(
      this.variableForInput(shadersCollectionController, _SwitchJsNode.INPUT_INDEX_NAME)
    );
    const inputTypes = this._expectedInputTypes();
    const inputValuesCount = this._expectedInputTypes().length - 1;
    const inputArgs = [];
    for (let i = 0; i <= inputValuesCount; i++) {
      const inputIndex2 = i + 1;
      const inputType = inputTypes[inputIndex2];
      if (this.io.connections.inputConnection(inputIndex2) || INPUT_TYPES_ALLOWING_NON_CONNECTED_INPUT.has(inputType)) {
        const inputArg = ThreeToJs.valueWrap(
          this.variableForInput(shadersCollectionController, this._expectedInputName(inputIndex2))
        );
        inputArgs.push(inputArg);
      }
    }
    const arrayElement = `[${inputArgs.join(", ")}][${inputIndex}]`;
    const value = shadersCollectionController.assembler().computedVariablesAllowed() ? `${arrayElement}.value` : arrayElement;
    const varName = this.jsVarName(_SwitchJsNode.OUTPUT_NAME);
    const dataType = this._expectedOutputTypes()[0];
    shadersCollectionController.addBodyOrComputed(this, [{ dataType, varName, value }]);
  }
};
export let SwitchJsNode = _SwitchJsNode;
SwitchJsNode.INPUT_INDEX_NAME = "index";
SwitchJsNode.OUTPUT_NAME = "val";
