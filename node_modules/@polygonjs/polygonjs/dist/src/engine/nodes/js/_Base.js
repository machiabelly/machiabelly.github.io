"use strict";
import { TypedNode } from "../_Base";
import { NodeContext } from "../../poly/NodeContext";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { ParamType } from "../../poly/ParamType";
import { Vector2Param } from "../../params/Vector2";
import { Vector3Param } from "../../params/Vector3";
import { Vector4Param } from "../../params/Vector4";
import { ColorParam } from "../../params/Color";
import { ThreeToJs } from "../../../core/ThreeToJs";
import { ParamsEditableStateController } from "../utils/io/ParamsEditableStateController";
import { Color, Quaternion, Vector2, Vector3, Vector4 } from "three";
import { sanitizeName } from "../../../core/String";
import { sanitizeJsVarName } from "./code/assemblers/JsTypeUtils";
import { Poly } from "../../Poly";
export const TRIGGER_CONNECTION_NAME = "trigger";
function wrapComputed(varName) {
  return `this.${varName}.value`;
}
export function wrapIfComputed(varName, linesController) {
  if (linesController.registeredAsComputed(varName)) {
    return wrapComputed(varName);
  } else {
    return varName;
  }
}
export function variableFromParamRequired(param) {
  return param instanceof ColorParam || param instanceof Vector2Param || param instanceof Vector3Param || param instanceof Vector4Param;
}
export function createVariableFromParam(param) {
  if (param instanceof ColorParam) {
    return new Color();
  }
  if (param instanceof Vector2Param) {
    return new Vector2();
  }
  if (param instanceof Vector3Param) {
    return new Vector3();
  }
  if (param instanceof Vector4Param) {
    if (param.options.asQuaternion()) {
      return new Quaternion();
    } else {
      return new Vector4();
    }
  }
  return new Vector4();
}
export class TypedJsNode extends TypedNode {
  constructor() {
    super(...arguments);
    // protected _assembler: BaseJsFunctionAssembler | undefined;
    this._paramsEditableStatesController = new ParamsEditableStateController(this);
    this.__setFunctionNodeToRecompileAllowed = true;
  }
  static context() {
    return NodeContext.JS;
  }
  eventData() {
    return void 0;
  }
  isTriggering() {
    return false;
  }
  initializeBaseNode() {
    this.uiData.setLayoutHorizontal();
    this.io.connections.initInputs();
    this.io.connection_points.spare_params.initializeNode();
    this._paramsEditableStatesController.initializeNode();
    this.addPostDirtyHook("_setMatToRecompile", this._setFunctionNodeToRecompile.bind(this));
    this.lifecycle.onBeforeDeleted(this._setFunctionNodeToRecompile.bind(this));
  }
  cook() {
    this.cookController.endCook();
  }
  _setFunctionNodeToRecompileAllowed(state) {
    this.__setFunctionNodeToRecompileAllowed = state;
  }
  _setFunctionNodeToRecompile() {
    var _a, _b;
    if (this.__setFunctionNodeToRecompileAllowed == false) {
      return;
    }
    (_b = (_a = this.functionNode()) == null ? void 0 : _a.assemblerController()) == null ? void 0 : _b.setCompilationRequiredAndDirty(this);
  }
  functionNode() {
    const parent = this.parent();
    if (parent) {
      if (parent.context() == NodeContext.JS) {
        return parent == null ? void 0 : parent.functionNode();
      } else {
        return parent;
      }
    }
  }
  // //
  // //
  // // VARIABLES
  // //
  // //
  jsVarName(name) {
    const functionNode = this.functionNode();
    const fullPathWithFunctionNodeRemoved = (_functionNode) => {
      const functionNodePath = _functionNode.path();
      const path = this.path();
      return path.slice(functionNodePath.length + 1);
    };
    const baseName = functionNode ? fullPathWithFunctionNodeRemoved(functionNode) : this.name();
    return sanitizeJsVarName(`v_POLY_${baseName}_${name}`);
  }
  inputVarName(inputName) {
    return TypedJsNode.inputVarName(this, inputName);
  }
  static inputVarName(node, inputName) {
    var _a;
    const sanitizedNodePath = sanitizeName(node.path().replace(((_a = node.functionNode()) == null ? void 0 : _a.path()) || "", ""));
    const varName = `${sanitizedNodePath}_${inputName}`;
    return varName;
  }
  variableForInputParam(shadersCollectionController, param) {
    return this.variableForInput(shadersCollectionController, param.name());
  }
  variableForInput(shadersCollectionController, inputName) {
    const varName = this._variableForInput(shadersCollectionController, inputName);
    return wrapIfComputed(varName, shadersCollectionController);
  }
  _variableForInput(shadersCollectionController, inputName) {
    var _a;
    const inputIndex = this.io.inputs.getInputIndex(inputName);
    const connection = this.io.connections.inputConnection(inputIndex);
    let outputJsVarName;
    if (connection) {
      const inputNode = connection.nodeSrc();
      const connectionPoints = inputNode.io.outputs.namedOutputConnectionPoints();
      if (connectionPoints) {
        const outputConnectionPoint = connectionPoints[connection.outputIndex()];
        if (outputConnectionPoint) {
          const outputName = outputConnectionPoint.name();
          outputJsVarName = inputNode.jsVarName(outputName);
        } else {
          console.warn(`no output called '${inputName}' for js node ${inputNode.path()}`);
          throw "variable_for_input ERROR";
        }
      }
    }
    if (this.params.has(inputName)) {
      const param = this.params.get(inputName);
      if (param) {
        if (param.type() == ParamType.STRING) {
          return outputJsVarName != null ? outputJsVarName : `'${param.value}'`;
        }
        if (variableFromParamRequired(param)) {
          const varName = `VAR_` + this.inputVarName(inputName);
          shadersCollectionController.addVariable(this, createVariableFromParam(param), varName);
          const _copy = (_outputJsVarName) => {
            return `${varName}.copy(${wrapIfComputed(_outputJsVarName, shadersCollectionController)})`;
          };
          const _set = () => {
            if (param.type() == ParamType.COLOR) {
              const func = Poly.namedFunctionsRegister.getFunction(
                "colorSetRGB",
                this,
                shadersCollectionController
              );
              const { r, g, b } = param.value;
              return func.asString(varName, `${r}`, `${g}`, `${b}`);
            } else {
              return `${varName}.set(${param.value.toArray().join(", ")})`;
            }
          };
          return outputJsVarName ? _copy(outputJsVarName) : _set();
        }
      }
      return outputJsVarName || ThreeToJs.any((_a = this.params.get(inputName)) == null ? void 0 : _a.value);
    } else {
      if (outputJsVarName != null) {
        return outputJsVarName;
      }
      const connectionPoints = this.io.inputs.namedInputConnectionPoints();
      if (connectionPoints) {
        const connectionPoint = connectionPoints[inputIndex];
        if (!connectionPoint) {
          console.warn(
            `connectionPoint not created for index ${inputIndex} (inputName: '${inputName}', node: ${this.path()})`
          );
        }
        return outputJsVarName || connectionPoint ? ThreeToJs.any(connectionPoint.init_value) : "0";
      }
      throw "variable_for_input ERROR";
    }
  }
  // variableForInput(name: string): string {
  // 	const input_index = this.io.inputs.getInputIndex(name);
  // 	const connection = this.io.connections.inputConnection(input_index);
  // 	if (connection) {
  // 		const input_node = (<unknown>connection.node_src) as BaseJsNodeType;
  // 		const output_connection_point =
  // 			input_node.io.outputs.namedOutputConnectionPoints()[connection.output_index];
  // 		if (output_connection_point) {
  // 			const output_name = output_connection_point.name();
  // 			return input_node.js_var_name(output_name);
  // 		} else {
  // 			console.warn(`no output called '${name}' for gl node ${input_node.path()}`);
  // 			throw 'variable_for_input ERROR';
  // 		}
  // 	} else {
  // 		return 'to debug...'; //ThreeToGl.any(this.params.get(name)?.value);
  // 	}
  // }
  // //
  // //
  // // ADDED LINES
  // //
  // //
  setLines(shadersCollectionController) {
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    console.warn(`setTriggeringLines not defined for node '${this.path()}'`);
  }
  setTriggerableLines(shadersCollectionController) {
  }
  // addConstructorInitFunctionLines(shadersCollectionController: ShadersCollectionController): void {}
  // wrappedBodyLinesMethodName() {
  // 	return this.type();
  // }
  // wrappedBodyLines(
  // 	shadersCollectionController: ShadersCollectionController,
  // 	bodyLines: string[],
  // 	existingMethodNames: Set<string>
  // ): WrappedBodyLines | undefined {
  // 	const methodName = this.wrappedBodyLinesMethodName();
  // 	if (existingMethodNames.has(methodName)) {
  // 		return;
  // 	}
  // 	const wrappedLines = `${methodName}(){
  // 		${bodyLines.join('\n')}
  // 	}`;
  // 	return {
  // 		methodNames: [methodName],
  // 		wrappedLines,
  // 	};
  // }
  reset_code() {
    var _a;
    (_a = this._param_configs_controller) == null ? void 0 : _a.reset();
  }
  // //
  // //
  // // PARAM CONFIGS
  // //
  // //
  paramsGenerating() {
    return false;
  }
  setParamConfigs() {
  }
  param_configs() {
    var _a;
    return (_a = this._param_configs_controller) == null ? void 0 : _a.list();
  }
  // //
  // //
  // // INPUT
  // //
  // //
  // js_input_default_value(name: string): ParamInitValueSerialized {
  // 	return null;
  // }
}
export class BaseJsNodeClass extends TypedJsNode {
}
class ParamlessJsParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new ParamlessJsParamsConfig();
export class ParamlessTypedJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
}
