"use strict";
import {
  JsConnectionPointType,
  JsConnectionPointTypeFromArrayTypeMap
} from "../utils/io/connections/Js";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { createVariable } from "./code/assemblers/_BaseJsPersistedConfigUtils";
import { Poly } from "../../Poly";
import { BaseArrayElementJsNode, ALLOWED_INPUT_TYPES } from "./_BaseArrayToElement";
var IndexInput = /* @__PURE__ */ ((IndexInput2) => {
  IndexInput2["index"] = "index";
  return IndexInput2;
})(IndexInput || {});
class ArrayElementJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.index = ParamConfig.INTEGER(0, {
      range: [0, 9],
      rangeLocked: [true, false]
    });
  }
}
const ParamsConfig = new ArrayElementJsParamsConfig();
export class ArrayElementJsNode extends BaseArrayElementJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "arrayElement";
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type();
    const type = firstType != null && ALLOWED_INPUT_TYPES.has(firstType) ? firstType : JsConnectionPointType.FLOAT_ARRAY;
    return [type, JsConnectionPointType.INT];
  }
  _expectedInputName(index) {
    const type = this._expectedInputTypes()[0];
    return [`${type}`, "index" /* index */][index];
  }
  _setLinesAsPrimitive(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const index = this.variableForInputParam(linesController, this.p.index);
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const func = Poly.namedFunctionsRegister.getFunction("arrayElementPrimitive", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array, index)
      }
    ]);
  }
  _setLinesAsVector(linesController) {
    const array = this.variableForInput(linesController, this._expectedInputName(0));
    const index = this.variableForInputParam(linesController, this.p.index);
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const elementType = JsConnectionPointTypeFromArrayTypeMap[dataType];
    const tmpVarName = linesController.addVariable(this, createVariable(elementType));
    const func = Poly.namedFunctionsRegister.getFunction("arrayElementVector", this, linesController);
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: func.asString(array, index, tmpVarName)
      }
    ]);
  }
  // private _setLinesAsObject(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
  // private _setLinesAsIntersection(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
  // private _setLinesAsTexture(linesController: JsLinesCollectionController) {
  // 	console.warn('not implemented');
  // }
}
