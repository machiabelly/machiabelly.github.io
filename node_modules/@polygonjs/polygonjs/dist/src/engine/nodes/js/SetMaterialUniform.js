"use strict";
import { TRIGGER_CONNECTION_NAME, TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { Poly } from "../../Poly";
import {
  floatOutputFromInput,
  stringOutputFromInput,
  anyTypeOutputFromInput,
  inputObject3DMaterial,
  setObject3DMaterialOutputLine
} from "./_BaseObject3D";
export const JS_CONNECTION_POINT_TYPES = [
  JsConnectionPointType.COLOR,
  JsConnectionPointType.FLOAT,
  JsConnectionPointType.INT,
  JsConnectionPointType.TEXTURE,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
];
const NUMBER_TYPES = /* @__PURE__ */ new Set([JsConnectionPointType.FLOAT, JsConnectionPointType.INT]);
const VECTOR_COLOR_TYPES = /* @__PURE__ */ new Set([
  JsConnectionPointType.COLOR,
  JsConnectionPointType.VECTOR2,
  JsConnectionPointType.VECTOR3,
  JsConnectionPointType.VECTOR4
]);
const DEFAULT_PARAM_VALUES = { lerp: 1, addPrefix: 1 };
var SetMaterialUniformJsNodeInputName = /* @__PURE__ */ ((SetMaterialUniformJsNodeInputName2) => {
  SetMaterialUniformJsNodeInputName2["uniformName"] = "uniformName";
  SetMaterialUniformJsNodeInputName2["lerp"] = "lerp";
  return SetMaterialUniformJsNodeInputName2;
})(SetMaterialUniformJsNodeInputName || {});
class SetMaterialUniformJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param printWarnings */
    this.printWarnings = ParamConfig.BOOLEAN(1);
    /** @param add prefix */
    this.addPrefix = ParamConfig.BOOLEAN(1);
    /** @param uniform type */
    this.type = ParamConfig.INTEGER(JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: JS_CONNECTION_POINT_TYPES.map((name, i) => {
          return { name, value: i };
        })
      },
      separatorBefore: true
    });
  }
}
const ParamsConfig = new SetMaterialUniformJsParamsConfig();
export class SetMaterialUniformJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "setMaterialUniform";
  }
  initializeNode() {
    this.io.connection_points.spare_params.setInputlessParamNames(["type"]);
    this.io.connection_points.set_input_name_function(this._expectedInputNames.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputType.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedInputNames.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedInputType.bind(this));
  }
  _expectedInputNames(index) {
    const list = [
      TRIGGER_CONNECTION_NAME,
      JsConnectionPointType.MATERIAL,
      this.uniformType(),
      "uniformName" /* uniformName */
    ];
    if (this._lerpAllowed()) {
      list.push("lerp" /* lerp */);
    }
    return list[index];
  }
  _expectedInputType() {
    const list = [
      JsConnectionPointType.TRIGGER,
      JsConnectionPointType.MATERIAL,
      this.uniformType(),
      JsConnectionPointType.STRING
    ];
    if (this._lerpAllowed()) {
      list.push(JsConnectionPointType.FLOAT);
    }
    return list;
  }
  paramDefaultValue(name) {
    return DEFAULT_PARAM_VALUES[name];
  }
  uniformType() {
    return JS_CONNECTION_POINT_TYPES[this.pv.type] || JsConnectionPointType.FLOAT;
  }
  setUniformType(type) {
    this.p.type.set(JS_CONNECTION_POINT_TYPES.indexOf(type));
  }
  setLines(linesController) {
    setObject3DMaterialOutputLine(this, linesController);
    anyTypeOutputFromInput(this, this.uniformType(), linesController);
    floatOutputFromInput(this, "lerp" /* lerp */, linesController);
    stringOutputFromInput(this, "uniformName" /* uniformName */, linesController);
  }
  setTriggerableLines(shadersCollectionController) {
    const material = inputObject3DMaterial(this, shadersCollectionController);
    const uniformName = this.variableForInput(
      shadersCollectionController,
      "uniformName" /* uniformName */
    );
    const uniformValue = this.variableForInput(shadersCollectionController, this.uniformType());
    const printWarnings = this.pv.printWarnings ? "true" : "false";
    const addPrefix = this.pv.addPrefix ? "true" : "false";
    if (this._isUniformNumber() || this._isUniformVectorColor()) {
      const lerp = this.variableForInput(shadersCollectionController, "lerp" /* lerp */);
      if (this._isUniformNumber()) {
        const functionName = "setMaterialUniformNumber";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const bodyLine = func.asString(material, uniformName, uniformValue, lerp, addPrefix, printWarnings);
        shadersCollectionController.addTriggerableLines(this, [bodyLine]);
        return;
      }
      if (this._isUniformVectorColor()) {
        const functionName = "setMaterialUniformVectorColor";
        const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
        const bodyLine = func.asString(material, uniformName, uniformValue, lerp, addPrefix, printWarnings);
        shadersCollectionController.addTriggerableLines(this, [bodyLine]);
        return;
      }
    } else {
      const functionName = "setMaterialUniformTexture";
      const func = Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController);
      const bodyLine = func.asString(material, uniformName, uniformValue, addPrefix, printWarnings);
      shadersCollectionController.addTriggerableLines(this, [bodyLine]);
      return;
    }
  }
  _isUniformNumber() {
    return NUMBER_TYPES.has(this.uniformType());
  }
  _isUniformVectorColor() {
    return VECTOR_COLOR_TYPES.has(this.uniformType());
  }
  _lerpAllowed() {
    return this._isUniformNumber() || this._isUniformVectorColor();
  }
}
