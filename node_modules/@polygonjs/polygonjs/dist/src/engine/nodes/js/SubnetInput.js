"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig } from "../utils/params/ParamsConfig";
import { NetworkChildNodeType } from "../../poly/NodeContext";
class SubnetInputJsParamsConfig extends NodeParamsConfig {
}
const ParamsConfig = new SubnetInputJsParamsConfig();
export class SubnetInputJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return NetworkChildNodeType.INPUT;
  }
  initializeNode() {
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
    this.io.connection_points.set_expected_input_types_function(() => []);
    this.io.connection_points.set_expected_output_types_function(this.expectedOutputTypes.bind(this));
  }
  parent() {
    return super.parent();
  }
  _expectedOutputNames(index) {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedInputConnectionPointName(index)) || `out${index}`;
  }
  expectedOutputTypes() {
    const parent = this.parent();
    return (parent == null ? void 0 : parent.childExpectedInputConnectionPointTypes()) || [];
  }
  setLines(shadersCollectionController) {
    const parent = this.parent();
    parent == null ? void 0 : parent.setSubnetInputLines(shadersCollectionController, this);
  }
  // public override outputValue(context: JsNodeTriggerContext, outputName: string) {
  // 	return this.parent()?.inputValueForSubnetInput(context, outputName);
  // }
}
