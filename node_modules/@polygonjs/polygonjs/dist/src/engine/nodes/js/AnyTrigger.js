"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPointType } from "../utils/io/connections/Js";
class AnyTriggerJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param audio node */
    this.condition = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new AnyTriggerJsParamsConfig();
export class AnyTriggerJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "anyTrigger";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const current_connections = this.io.connections.existingInputConnections();
    const expected_count = current_connections ? Math.max(current_connections.length + 1, 2) : 2;
    return new Array(expected_count).fill(JsConnectionPointType.TRIGGER);
  }
  _expectedOutputTypes() {
    return [JsConnectionPointType.TRIGGER];
  }
  _expectedInputName(index) {
    return `${JsConnectionPointType.TRIGGER}${index}`;
  }
  _expectedOutputName(index) {
    return JsConnectionPointType.TRIGGER;
  }
  setTriggerableLines(shadersCollectionController) {
    shadersCollectionController.addTriggerableLines(this, []);
  }
}
