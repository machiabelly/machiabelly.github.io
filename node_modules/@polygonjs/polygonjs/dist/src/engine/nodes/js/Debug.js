"use strict";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { Poly } from "../../Poly";
import { inputObject3D } from "./_BaseObject3D";
class DebugJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    this.displayValue = ParamConfig.BOOLEAN(1);
    this.displayFrame = ParamConfig.BOOLEAN(1);
    this.displayTime = ParamConfig.BOOLEAN(0);
    this.displayNodePath = ParamConfig.BOOLEAN(1);
    this.message = ParamConfig.STRING("");
    this.bundleByObject = ParamConfig.BOOLEAN(1);
  }
}
const ParamsConfig = new DebugJsParamsConfig();
export class DebugJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "debug";
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["displayValue"]);
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _expectedInputTypes() {
    const firstType = this.io.connection_points.first_input_connection_type() || JsConnectionPointType.FLOAT;
    return [firstType];
  }
  _expectedInputName(index) {
    return [`in`][index];
  }
  _expectedOutputName(index) {
    const type = this._expectedOutputTypes()[0];
    return `${type}`;
  }
  _expectedOutputTypes() {
    return this._expectedInputTypes();
  }
  setLines(linesController) {
    const dataType = this._expectedInputTypes()[0];
    const varName = this.jsVarName(this._expectedOutputName(0));
    const inputValue = this.variableForInput(linesController, this._expectedInputName(0));
    linesController.addBodyOrComputed(this, [
      {
        dataType,
        varName,
        value: this._function({
          linesController,
          inputValue
        })
      }
    ]);
  }
  setTriggerableLines(linesController) {
    const bodyLine = this._function({
      linesController
    });
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _function(options) {
    const { linesController, inputValue } = options;
    const object3D = inputObject3D(this, linesController);
    const nodePath = `'${this.path()}'`;
    const debugOptions = {
      displayValue: this.pv.displayValue,
      displayFrame: this.pv.displayFrame,
      displayTime: this.pv.displayTime,
      displayNodePath: this.pv.displayNodePath,
      message: this.pv.message,
      bundleByObject: this.pv.bundleByObject
    };
    const func = Poly.namedFunctionsRegister.getFunction("debug", this, linesController);
    return func.asString(object3D, nodePath, inputValue || `''`, JSON.stringify(debugOptions));
  }
}
