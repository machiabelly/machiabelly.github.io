"use strict";
import { TypedJsNode } from "./_Base";
import { inputObject3D, setObject3DOutputLine } from "./_BaseObject3D";
import { Poly } from "../../Poly";
import { ParamConfig } from "../utils/params/ParamsConfig";
import { PolyNodeParamsConfig } from "../utils/poly/PolyNodeParamsConfig";
import { JsConnectionPointType } from "../utils/io/connections/Js";
import { ConstantJsDefinition } from "./utils/JsDefinition";
import { rangeStartEnd } from "../../../core/ArrayUtils";
import { TEXTURE_ALLOCATION_PREFIX } from "../gl/code/utils/TextureAllocation";
function visibleIfTexturessCountAtLeast(index) {
  return {
    visibleIf: rangeStartEnd(index + 1, 10).map((i) => ({ texturesCount: i }))
  };
}
function textureNameParam(index) {
  return ParamConfig.STRING("", {
    ...visibleIfTexturessCountAtLeast(index)
  });
}
class ParticlesSystemStepSimulationJsParamsConfig extends PolyNodeParamsConfig {
  constructor() {
    super(...arguments);
    this.texturesCount = ParamConfig.INTEGER(1, {
      range: [0, 10],
      rangeLocked: [true, false]
    });
    this.textureName0 = textureNameParam(0);
    this.textureName1 = textureNameParam(1);
    this.textureName2 = textureNameParam(2);
    this.textureName3 = textureNameParam(3);
    this.textureName4 = textureNameParam(4);
    this.textureName5 = textureNameParam(5);
    this.textureName6 = textureNameParam(6);
    this.textureName7 = textureNameParam(7);
    this.textureName8 = textureNameParam(8);
    this.textureName9 = textureNameParam(9);
  }
}
const ParamsConfig = new ParticlesSystemStepSimulationJsParamsConfig();
export class ParticlesSystemStepSimulationJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "particlesSystemStepSimulation";
  }
  initializeNode() {
    this.io.connection_points.set_input_name_function(this._expectedInputName.bind(this));
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputName.bind(this));
  }
  _textureNameParams() {
    return [
      this.p.textureName0,
      this.p.textureName1,
      this.p.textureName2,
      this.p.textureName3,
      this.p.textureName4,
      this.p.textureName5,
      this.p.textureName6,
      this.p.textureName7,
      this.p.textureName8,
      this.p.textureName9
    ];
  }
  setTextureName(index, textureName) {
    const param = this._textureNameParams()[index];
    if (!param) {
      return;
    }
    param.set(textureName);
  }
  _expectedInputTypes() {
    return [JsConnectionPointType.TRIGGER, JsConnectionPointType.OBJECT_3D];
  }
  _expectedInputName(index) {
    return this._expectedInputTypes()[index];
  }
  _expectedOutputTypes() {
    const count = this.pv.texturesCount;
    return this._expectedInputTypes().concat(
      rangeStartEnd(0, count).map((value, i) => JsConnectionPointType.TEXTURE)
    );
  }
  _expectedOutputName(index) {
    if (index <= 1) {
      return this._expectedInputName(index);
    } else {
      return this._textureNameParams()[index - 2].value;
    }
  }
  setLines(linesController) {
    this._addRefs(linesController);
    setObject3DOutputLine(this, linesController);
  }
  setTriggerableLines(linesController) {
    const object3D = inputObject3D(this, linesController);
    const configRef = this._addRefs(linesController);
    const func = Poly.namedFunctionsRegister.getFunction("particlesSystemStepSimulation", this, linesController);
    const bodyLine = func.asString(object3D, this._refToString(configRef));
    linesController.addTriggerableLines(this, [bodyLine]);
  }
  _refToString(refs) {
    const keys = Object.keys(refs);
    const data = [];
    for (const key of keys) {
      data.push(`${key}:this.${refs[key]}`);
    }
    return `{${data.join(",")}}`;
  }
  _addRefs(linesController) {
    const count = this.pv.texturesCount;
    const textureParams = this._textureNameParams();
    const textureNames = rangeStartEnd(0, count).map((value, i) => `${textureParams[i].value}`);
    const varNames = textureNames.map((textureName) => this.jsVarName(textureName));
    for (const texture of varNames) {
      linesController.addDefinitions(this, [
        new ConstantJsDefinition(this, linesController, JsConnectionPointType.TEXTURE, texture, `null`)
      ]);
    }
    const ref = {};
    for (let i = 0; i < count; i++) {
      const textureName = textureNames[i];
      const textureNameWithPrefix = `${TEXTURE_ALLOCATION_PREFIX}${textureName}`;
      const varName = varNames[i];
      ref[textureNameWithPrefix] = varName;
    }
    return ref;
  }
}
