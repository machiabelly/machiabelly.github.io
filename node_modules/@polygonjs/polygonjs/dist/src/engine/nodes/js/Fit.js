"use strict";
import { Poly } from "../../Poly";
import { JsConnectionPointType, JsConnectionPointTypeFromArrayTypeMap } from "../utils/io/connections/Js";
import { MathFunctionArg5OperationFactory, DEFAULT_ALLOWED_TYPES } from "./_Math_Arg1Operation";
var FitInput = /* @__PURE__ */ ((FitInput2) => {
  FitInput2["VALUE"] = "val";
  FitInput2["SRC_MIN"] = "srcMin";
  FitInput2["SRC_MAX"] = "srcMax";
  FitInput2["DEST_MIN"] = "destMin";
  FitInput2["DEST_MAX"] = "destMax";
  FitInput2["CLAMP_TO_DEST_RANGE"] = "clampToDestRange";
  return FitInput2;
})(FitInput || {});
const DefaultValues = {
  ["val" /* VALUE */]: 0,
  ["srcMin" /* SRC_MIN */]: 0,
  ["srcMax" /* SRC_MAX */]: 1,
  ["destMin" /* DEST_MIN */]: 0,
  ["destMax" /* DEST_MAX */]: 1,
  ["clampToDestRange" /* CLAMP_TO_DEST_RANGE */]: 0
};
const FUNCTION_NAME_FIT = "fit";
const FUNCTION_NAME_FIT_CLAMP = "fitClamp";
const FUNCTION_NAMES = [FUNCTION_NAME_FIT, FUNCTION_NAME_FIT_CLAMP];
export class FitJsNode extends MathFunctionArg5OperationFactory("fit", {
  inputPrefix: "in",
  out: "val"
}) {
  _coreFunction(shadersCollectionController) {
    FUNCTION_NAMES.forEach((functionName) => {
      Poly.namedFunctionsRegister.getFunction(functionName, this, shadersCollectionController).asString("", "", "", "", "");
    });
    const doClamp = this.variableForInput(shadersCollectionController, "clampToDestRange" /* CLAMP_TO_DEST_RANGE */);
    return `${doClamp} ? ${FUNCTION_NAME_FIT_CLAMP}: ${FUNCTION_NAME_FIT}`;
  }
  _inputValuesCount() {
    const inputTypes = this._expectedInputTypes();
    const inputValuesCount = inputTypes.length;
    return inputValuesCount - 1;
  }
  paramDefaultValue(name) {
    return DefaultValues[name];
  }
  _expectedInputName(index) {
    return [
      "val" /* VALUE */,
      "srcMin" /* SRC_MIN */,
      "srcMax" /* SRC_MAX */,
      "destMin" /* DEST_MIN */,
      "destMax" /* DEST_MAX */,
      "clampToDestRange" /* CLAMP_TO_DEST_RANGE */
    ][index];
  }
  _expectedInputTypes() {
    let first_input_type = this.io.connection_points.first_input_connection_type();
    const connectionPoints = this.io.inputs.namedInputConnectionPoints();
    if (first_input_type && connectionPoints) {
      if (!DEFAULT_ALLOWED_TYPES.includes(first_input_type)) {
        const first_connection = connectionPoints[0];
        if (first_connection) {
          first_input_type = first_connection.type();
        }
      }
    }
    const type = first_input_type || JsConnectionPointType.FLOAT;
    const boundType = JsConnectionPointTypeFromArrayTypeMap[type];
    return [type, boundType, boundType, boundType, boundType, JsConnectionPointType.BOOLEAN];
  }
}
