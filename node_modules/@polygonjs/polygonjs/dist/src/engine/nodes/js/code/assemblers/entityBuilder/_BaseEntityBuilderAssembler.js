"use strict";
import {
  BaseJsShaderAssembler,
  INSERT_DEFINE_AFTER,
  INSERT_BODY_AFTER,
  INSERT_MEMBERS_AFTER,
  INSERT_CONSTRUCTOR_AFTER
} from "../_Base";
import { JsFunctionName } from "../../../../utils/shaders/ShaderName";
import { AttributeJsNodeInput } from "../../../Attribute";
import { NodeContext } from "../../../../../poly/NodeContext";
import { JsType } from "../../../../../poly/registers/nodes/types/Js";
import { PrettierController } from "../../../../../../core/code/PrettierController";
import { EntityBuilderAssemblerConstant } from "./EntityBuilderAssemblerCommon";
const TEMPLATE = `
${INSERT_DEFINE_AFTER}
${INSERT_MEMBERS_AFTER}
${INSERT_CONSTRUCTOR_AFTER}
const __EVALUATOR_NAME___ = function(){
	${INSERT_BODY_AFTER}
`;
const CLOSE_CLASS_DEFINITION = `};
return __EVALUATOR_NAME___;`;
export class JsAssemblerBaseEntityBuilder extends BaseJsShaderAssembler {
  makeFunctionNodeDirtyOnChange() {
    return true;
  }
  templateShader() {
    return {
      main: TEMPLATE.replace(/__EVALUATOR_NAME___/g, this._evaluatorName())
    };
  }
  _closeClassDefinition() {
    return CLOSE_CLASS_DEFINITION.replace(/__EVALUATOR_NAME___/g, this._evaluatorName());
  }
  _evaluatorName() {
    return "BaseEntityBuilderEvaluator";
  }
  spareParamsOptions(options) {
    const _options = {
      spare: true,
      // computeOnDirty: true, // not needed if cook option is not set
      // cook: false, // for SDFBuilder, the node needs to recook
      // important for texture nodes
      // that compute after being found by the nodepath param
      dependentOnFoundNode: true
    };
    return _options;
  }
  defaultObjectVariable() {
    return EntityBuilderAssemblerConstant.OBJECT;
  }
  defaultObject3DMaterialVariable() {
    return EntityBuilderAssemblerConstant.MATERIAL;
  }
  defaultPrimitiveGraph() {
    return EntityBuilderAssemblerConstant.PRIMITIVE_GRAPH;
  }
  functionData() {
    var _a;
    const _buildFunctionBody = () => {
      const bodyLines = this._shaders_by_name.get(JsFunctionName.MAIN) || TEMPLATE;
      const functionBodyElements = [
        bodyLines,
        // triggerableFunctionLines.join('\n'),
        // triggerFunctionLines.join('\n'),
        this._closeClassDefinition()
      ];
      const functionBody2 = PrettierController.formatJs(functionBodyElements.join("\n"));
      return functionBody2;
    };
    const functionBody = _buildFunctionBody();
    if (!functionBody) {
      return;
    }
    const variableNames = [];
    const functionNames = [];
    const variablesByName = {};
    const functionsByName = {};
    this.traverseRegisteredVariables((variable, varName) => {
      variableNames.push(varName);
      variablesByName[varName] = variable;
    });
    this.traverseRegisteredFunctions((namedFunction) => {
      functionNames.push(namedFunction.type());
      functionsByName[namedFunction.type()] = namedFunction.func.bind(namedFunction);
    });
    const attribNodes = [];
    (_a = this.currentJsParentNode().childrenController) == null ? void 0 : _a.traverseChildren((child) => {
      if (child.context() == NodeContext.JS && child.type() == JsType.ATTRIBUTE) {
        attribNodes.push(child);
      }
    });
    const attributesRead = attribNodes.filter((n) => n.isImporting()).map((attribNode) => attribNode.attribData());
    const attributesWrite = attribNodes.filter((n) => n.isExporting()).map((attribNode) => attribNode.attribData());
    const paramConfigs = this.param_configs();
    return {
      functionBody,
      variableNames,
      variablesByName,
      functionNames,
      functionsByName,
      paramConfigs: [...paramConfigs],
      attributesData: {
        read: attributesRead,
        write: attributesWrite
      }
    };
  }
  updateFunction() {
    super.updateFunction();
    this._lines = /* @__PURE__ */ new Map();
    this._shaders_by_name = /* @__PURE__ */ new Map();
    const shaderNames = this.shaderNames();
    if (this._root_nodes.length > 0) {
      this.buildCodeFromNodes(this._root_nodes);
      this._buildLines();
    }
    for (const shaderName of shaderNames) {
      const lines = this._lines.get(shaderName);
      if (lines) {
        this._shaders_by_name.set(shaderName, lines.join("\n"));
      }
    }
  }
  setNodeLinesAttribute(attributeNode, linesController) {
    const shaderName = linesController.currentShaderName();
    const shaderConfig = this.shader_config(shaderName);
    if (!shaderConfig) {
      return;
    }
    const bodyLines = [];
    const attribName = attributeNode.attributeName();
    if (attributeNode.isExporting()) {
      const exportedValue = attributeNode.variableForInput(linesController, AttributeJsNodeInput.EXPORT);
      const bodyLine = `${EntityBuilderAssemblerConstant.ATTRIBUTES_DICT}.set('${attribName}', ${exportedValue})`;
      bodyLines.push(bodyLine);
    }
    const usedOutputNames = attributeNode.io.outputs.used_output_names();
    for (const outputName of usedOutputNames) {
      const varName = attributeNode.jsVarName(outputName);
      const bodyLine = `${varName} = ${EntityBuilderAssemblerConstant.ATTRIBUTES_DICT}.get('${attribName}')`;
      bodyLines.push(bodyLine);
    }
    linesController._addBodyLines(attributeNode, bodyLines);
  }
}
