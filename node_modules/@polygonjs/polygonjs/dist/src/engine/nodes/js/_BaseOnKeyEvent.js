"use strict";
import { TRIGGER_CONNECTION_NAME } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { JsConnectionPoint, JsConnectionPointType } from "../utils/io/connections/Js";
import { BaseUserInputJsNode } from "./_BaseUserInput";
import { CoreEventEmitter, EVENT_EMITTERS, EVENT_EMITTER_PARAM_MENU_OPTIONS } from "../../../core/event/CoreEventEmitter";
import { Poly } from "../../Poly";
import { KeyModifierRequirement, KEY_MODIFIER_REQUIREMENTS } from "../../functions/_KeyboardEventMatchesConfig";
const KEY_MENU_ENTRIES = { menu: { entries: KEY_MODIFIER_REQUIREMENTS.map((name, value) => ({ name, value })) } };
const OPTIONAL_ENTRY = KEY_MODIFIER_REQUIREMENTS.indexOf(KeyModifierRequirement.OPTIONAL);
class BaseOnKeyEventJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param set which element triggers the event */
    this.element = ParamConfig.INTEGER(EVENT_EMITTERS.indexOf(CoreEventEmitter.CANVAS), {
      ...EVENT_EMITTER_PARAM_MENU_OPTIONS,
      separatorAfter: true
    });
    /** @param space separated list of accepted key codes. If this is empty then any key is accepted. */
    this.keyCodes = ParamConfig.STRING("Digit1 KeyE ArrowDown");
    /** @param requires ctrlKey */
    this.ctrlKey = ParamConfig.INTEGER(OPTIONAL_ENTRY, KEY_MENU_ENTRIES);
    /** @param requires altKey */
    this.altKey = ParamConfig.INTEGER(OPTIONAL_ENTRY, KEY_MENU_ENTRIES);
    /** @param requires shiftKey */
    this.shiftKey = ParamConfig.INTEGER(OPTIONAL_ENTRY, KEY_MENU_ENTRIES);
    /** @param requires metaKey */
    this.metaKey = ParamConfig.INTEGER(OPTIONAL_ENTRY, KEY_MENU_ENTRIES);
  }
}
const ParamsConfig = new BaseOnKeyEventJsParamsConfig();
export class BaseOnKeyEventJsNode extends BaseUserInputJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  isTriggering() {
    return true;
  }
  initializeNode() {
    super.initializeNode();
    this.io.connection_points.spare_params.setInputlessParamNames(["element"]);
    this.io.outputs.setNamedOutputConnectionPoints([
      new JsConnectionPoint(TRIGGER_CONNECTION_NAME, JsConnectionPointType.TRIGGER)
    ]);
  }
  eventEmitter() {
    return EVENT_EMITTERS[this.pv.element];
  }
  setEventEmitter(emitter) {
    this.p.element.set(EVENT_EMITTERS.indexOf(emitter));
  }
  setTriggeringLines(shadersCollectionController, triggeredMethods) {
    const keyCodes = this.variableForInputParam(shadersCollectionController, this.p.keyCodes);
    const ctrlKey = this.variableForInputParam(shadersCollectionController, this.p.ctrlKey);
    const altKey = this.variableForInputParam(shadersCollectionController, this.p.altKey);
    const shiftKey = this.variableForInputParam(shadersCollectionController, this.p.shiftKey);
    const metaKey = this.variableForInputParam(shadersCollectionController, this.p.metaKey);
    const func = Poly.namedFunctionsRegister.getFunction(
      "keyboardEventMatchesConfig",
      this,
      shadersCollectionController
    );
    const condition = func.asString(keyCodes, ctrlKey, altKey, shiftKey, metaKey);
    const bodyLines = [`if( ${condition}==false ){return}`, triggeredMethods];
    shadersCollectionController.addTriggeringLines(this, bodyLines, {
      gatherable: true
    });
  }
}
