"use strict";
import { TypedJsNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import {
  JsConnectionPointType,
  PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES
} from "../utils/io/connections/Js";
import { inputObject3D } from "./_BaseObject3D";
import { Poly } from "../../Poly";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { TypeAssert } from "../../poly/Assert";
var GetObjectAttributeInputName = /* @__PURE__ */ ((GetObjectAttributeInputName2) => {
  GetObjectAttributeInputName2["attribName"] = "attribName";
  return GetObjectAttributeInputName2;
})(GetObjectAttributeInputName || {});
var GetObjectAttributeOutputName = /* @__PURE__ */ ((GetObjectAttributeOutputName2) => {
  GetObjectAttributeOutputName2["VALUE"] = "val";
  return GetObjectAttributeOutputName2;
})(GetObjectAttributeOutputName || {});
class GetObjectAttributeJsParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    // attribName = ParamConfig.STRING('');
    this.type = ParamConfig.INTEGER(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(JsConnectionPointType.FLOAT), {
      menu: {
        entries: PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.map((name, value) => ({ name, value }))
      }
    });
  }
  // defaultBoolean = ParamConfig.BOOLEAN(0, typedVisibleOptions(JsConnectionPointType.BOOLEAN));
  // defaultColor = ParamConfig.COLOR([0, 0, 0], typedVisibleOptions(JsConnectionPointType.COLOR));
  // defaultFloat = ParamConfig.FLOAT(0, typedVisibleOptions(JsConnectionPointType.FLOAT));
  // defaultInteger = ParamConfig.INTEGER(0, typedVisibleOptions(JsConnectionPointType.INT));
  // defaultString = ParamConfig.STRING('', typedVisibleOptions(JsConnectionPointType.STRING));
  // defaultVector2 = ParamConfig.VECTOR2([0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR2));
  // defaultVector3 = ParamConfig.VECTOR3([0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR3));
  // defaultVector4 = ParamConfig.VECTOR4([0, 0, 0, 0], typedVisibleOptions(JsConnectionPointType.VECTOR4));
}
const ParamsConfig = new GetObjectAttributeJsParamsConfig();
export class GetObjectAttributeJsNode extends TypedJsNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
    this._nextAttribName = "";
  }
  static type() {
    return JsType.GET_OBJECT_ATTRIBUTE;
  }
  initializeNode() {
    this.io.connection_points.set_expected_input_types_function(this._expectedInputTypes.bind(this));
    this.io.connection_points.set_input_name_function(this._expectedInputNames.bind(this));
    this.io.connection_points.set_expected_output_types_function(this._expectedOutputTypes.bind(this));
    this.io.connection_points.set_output_name_function(this._expectedOutputNames.bind(this));
  }
  _expectedInputTypes() {
    return [JsConnectionPointType.OBJECT_3D, JsConnectionPointType.STRING, this._currentConnectionType()];
  }
  _expectedInputNames(index) {
    return [JsConnectionPointType.OBJECT_3D, "attribName" /* attribName */, this.defaultValueName()][index];
  }
  _expectedOutputTypes() {
    return [this._currentConnectionType()];
  }
  _expectedOutputNames(index) {
    return ["val" /* VALUE */][index];
  }
  _currentConnectionType() {
    if (this.pv.type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    const connection_type = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];
    if (connection_type == null) {
      console.warn(`${this.type()} js node type not valid`);
    }
    return connection_type;
  }
  // defaultValueParam() {
  // 	const type = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type] as ParamConvertibleJsType;
  // 	switch (type) {
  // 		case JsConnectionPointType.BOOLEAN: {
  // 			return this.p.defaultBoolean;
  // 		}
  // 		case JsConnectionPointType.COLOR: {
  // 			return this.p.defaultColor;
  // 		}
  // 		case JsConnectionPointType.FLOAT: {
  // 			return this.p.defaultFloat;
  // 		}
  // 		case JsConnectionPointType.INT: {
  // 			return this.p.defaultInteger;
  // 		}
  // 		case JsConnectionPointType.STRING: {
  // 			return this.p.defaultString;
  // 		}
  // 		case JsConnectionPointType.VECTOR2: {
  // 			return this.p.defaultVector2;
  // 		}
  // 		case JsConnectionPointType.VECTOR3: {
  // 			return this.p.defaultVector3;
  // 		}
  // 		case JsConnectionPointType.VECTOR4: {
  // 			return this.p.defaultVector4;
  // 		}
  // 	}
  // 	TypeAssert.unreachable(type);
  // }
  defaultValueName() {
    const type = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];
    switch (type) {
      case JsConnectionPointType.BOOLEAN: {
        return "defaultBoolean";
      }
      case JsConnectionPointType.COLOR: {
        return "defaultColor";
      }
      case JsConnectionPointType.FLOAT: {
        return "defaultFloat";
      }
      case JsConnectionPointType.INT: {
        return "defaultInteger";
      }
      case JsConnectionPointType.STRING: {
        return "defaultString";
      }
      case JsConnectionPointType.VECTOR2: {
        return "defaultVector2";
      }
      case JsConnectionPointType.VECTOR3: {
        return "defaultVector3";
      }
      case JsConnectionPointType.VECTOR4: {
        return "defaultVector4";
      }
    }
    TypeAssert.unreachable(type);
  }
  paramDefaultValue(name) {
    return {
      ["attribName" /* attribName */]: this._nextAttribName
    }[name];
  }
  setAttribType(type) {
    this.p.type.set(PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES.indexOf(type));
  }
  setAttribName(attribName) {
    const param = this.params.get("attribName" /* attribName */);
    if (param) {
      param.set(attribName);
    } else {
      this._nextAttribName = attribName;
    }
  }
  attributeName() {
    return this.params.get("attribName" /* attribName */).value;
  }
  setLines(linesController) {
    const object3D = inputObject3D(this, linesController);
    const attribName = this.variableForInput(linesController, "attribName" /* attribName */);
    const defaultValue = this.variableForInput(linesController, this.defaultValueName());
    const out = this.jsVarName("val" /* VALUE */);
    const dataType = PARAM_CONVERTIBLE_JS_CONNECTION_POINT_TYPES[this.pv.type];
    const func = Poly.namedFunctionsRegister.getFunction("getObjectAttribute", this, linesController);
    const bodyLine = func.asString(object3D, attribName, `'${dataType}'`, defaultValue);
    linesController.addBodyOrComputed(this, [{ dataType, varName: out, value: bodyLine }]);
  }
}
