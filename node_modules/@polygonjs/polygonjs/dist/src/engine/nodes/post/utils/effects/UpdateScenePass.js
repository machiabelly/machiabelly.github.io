"use strict";
import { CopyPass } from "postprocessing";
import { isBooleanTrue } from "../../../../../core/Type";
export class UpdateScenePass extends CopyPass {
  // public objectsMask: string;
  // public invertMask: boolean;
  // public setMatteMaterial: boolean;
  // public setVisible: boolean;
  // public visible: boolean;
  constructor(options) {
    super();
    this.reset = options.reset;
    this.node = options.node;
    this.nodeToReset = options.nodeToReset;
  }
  // private _onRenderBound = this._onRender.bind(this)
  // private _onRender(){
  // }
  render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest) {
    if (isBooleanTrue(this.reset)) {
      if (this.nodeToReset) {
        this.nodeToReset.resetChanges();
      } else {
        console.warn("reset is true, but no passToReset is given");
      }
    } else {
      this.node.applyChanges();
    }
    super.render(renderer, inputBuffer, outputBuffer, deltaTime, stencilTest);
  }
  // override update(renderer: WebGLRenderer, inputBuffer: WebGLRenderTarget, deltaTime: number) {
  // 	if (isBooleanTrue(this.reset)) {
  // 		if (this.nodeToReset) {
  // 			this.nodeToReset.resetChanges();
  // 		} else {
  // 			console.warn('reset is true, but no passToReset is given');
  // 		}
  // 	} else {
  // 		this.node.applyChanges();
  // 	}
  // 	// console.warn(deltaTime, this);
  // 	super.update(renderer, inputBuffer, deltaTime);
  // }
  // private _updateObjectBound = this._updateObject.bind(this);
  // private _updateObject(obj: Object3D) {
  // 	this._objectsList.push(obj);
  // 	if (isBooleanTrue(this.setMatteMaterial)) {
  // 		const mesh = obj as Mesh;
  // 		if (mesh.material) {
  // 			this._materialByMesh.set(mesh, mesh.material);
  // 			mesh.material = MATTE_MATERIAL;
  // 		}
  // 	}
  // 	if (isBooleanTrue(this.setVisible)) {
  // 		if (obj.visible != this.visible) {
  // 			this._visibleByObject.set(obj, obj.visible);
  // 			obj.visible = this.visible;
  // 			console.log(obj, obj.visible);
  // 		}
  // 	}
  // }
}
