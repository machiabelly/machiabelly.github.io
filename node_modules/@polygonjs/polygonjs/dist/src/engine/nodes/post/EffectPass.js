"use strict";
import { TypedPostNode } from "./_Base";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { EffectPass } from "postprocessing";
import { rangeWithEnd, arrayCompact } from "../../../core/ArrayUtils";
import { NodeEvent } from "../../poly/NodeEvent";
import { PostType } from "../../poly/registers/nodes/types/Post";
const POSSIBLE_COMBINED_PASSES_COUNT = 5;
export const RANGE = rangeWithEnd(POSSIBLE_COMBINED_PASSES_COUNT);
const DEFAULT_INPUTS_COUNT = POSSIBLE_COMBINED_PASSES_COUNT + 1;
class EffectPassPostParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param number of inputs that this node can merge geometries from */
    this.inputsCount = ParamConfig.INTEGER(DEFAULT_INPUTS_COUNT, {
      range: [1, 32],
      rangeLocked: [true, false],
      callback: (node) => {
        EffectPassPostNode.PARAM_CALLBACK_setInputsCount(node);
      }
    });
  }
}
const ParamsConfig = new EffectPassPostParamsConfig();
export class EffectPassPostNode extends TypedPostNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return PostType.EFFECT_PASS;
  }
  initializeNode() {
    super.initializeNode();
    this.io.inputs.setCount(DEFAULT_INPUTS_COUNT);
    this.params.onParamsCreated("update inputs", () => {
      this._callbackUpdateInputsCount();
    });
  }
  _setupComposerIfActive(context) {
    const inputIndices = RANGE.map((i) => i + 1);
    const passesToCombine = [];
    arrayCompact(
      inputIndices.map((index) => {
        const input = this.io.inputs.input(index);
        if (input) {
          if (!input.flags.bypass.active()) {
            return input.createPassForContext(context);
          }
        }
      }),
      passesToCombine
    ).flat();
    const effectLists = [];
    arrayCompact(
      passesToCombine.map((pass2) => {
        return pass2.effects;
      }),
      effectLists
    );
    const effects = effectLists.flat();
    const pass = new EffectPass(context.camera, ...effects);
    context.composerController.addPassByNodeInBuildPassesProcess(this, pass, context.composer);
  }
  updatePass(pass) {
  }
  _callbackUpdateInputsCount() {
    this.io.inputs.setCount(1, this.pv.inputsCount);
    this.emit(NodeEvent.INPUTS_UPDATED);
  }
  static PARAM_CALLBACK_setInputsCount(node) {
    node._callbackUpdateInputsCount();
  }
}
