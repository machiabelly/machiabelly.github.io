"use strict";
import { UnsignedByteType, HalfFloatType, FloatType } from "three";
import { EffectComposer, RenderPass } from "postprocessing";
import { NodeParamsConfig, ParamConfig } from "../../utils/params/ParamsConfig";
import { isBooleanTrue } from "../../../../core/BooleanValue";
const RENDER_TARGET_TEXTURE_TYPE_OPTIONS = {
  UnsignedByteType,
  HalfFloatType,
  FloatType
};
const RENDER_TARGET_TEXTURE_TYPE_MENU_ENTRIES = Object.keys(RENDER_TARGET_TEXTURE_TYPE_OPTIONS).map((name) => {
  return {
    name,
    value: RENDER_TARGET_TEXTURE_TYPE_OPTIONS[name]
  };
});
export function postProcessTextureTypeLabel(value) {
  for (const entry of RENDER_TARGET_TEXTURE_TYPE_MENU_ENTRIES) {
    if (entry.value == value) {
      return entry.name;
    }
  }
}
export function PostProcessNetworkParamsConfigMixin(Base) {
  return class Mixin extends Base {
    constructor() {
      super(...arguments);
      this.prependRenderPass = ParamConfig.BOOLEAN(1, {
        separatorAfter: true
      });
      this.depthBuffer = ParamConfig.BOOLEAN(1);
      this.stencilBuffer = ParamConfig.BOOLEAN(0);
      this.sampling = ParamConfig.INTEGER(0, {
        range: [0, 4],
        rangeLocked: [true, false]
      });
      this.tTextureType = ParamConfig.BOOLEAN(0);
      this.textureType = ParamConfig.INTEGER(UnsignedByteType, {
        visibleIf: { tTextureType: 1 },
        menu: {
          entries: RENDER_TARGET_TEXTURE_TYPE_MENU_ENTRIES
        }
      });
    }
  };
}
export class PostProcessNetworkParamsConfig extends PostProcessNetworkParamsConfigMixin(NodeParamsConfig) {
}
export class EffectComposerController {
  constructor(node) {
    this.node = node;
    this._composerAndOptionsByCamera = /* @__PURE__ */ new Map();
    this._nextId = 0;
    this._passByNodeInBuildPassesProcess = /* @__PURE__ */ new Map();
    this.node.dirtyController.addPostDirtyHook("EffectComposerController", () => {
      this._updateComposers();
    });
  }
  displayNodeControllerCallbacks() {
    return {
      onDisplayNodeRemove: () => {
      },
      onDisplayNodeSet: () => {
        this.node.setDirty();
      },
      onDisplayNodeUpdate: () => {
        this.node.setDirty();
      }
    };
  }
  createEffectsComposer(options) {
    const renderer = options.renderer;
    const pv = this.node.pv;
    const composer = new EffectComposer(renderer, {
      depthBuffer: isBooleanTrue(pv.depthBuffer),
      stencilBuffer: isBooleanTrue(pv.stencilBuffer),
      multisampling: pv.sampling,
      frameBufferType: isBooleanTrue(pv.tTextureType) ? pv.textureType : void 0
    });
    composer._polygonId = this._nextId++;
    return composer;
  }
  createEffectsComposerAndBuildPasses(options) {
    const composer = this.createEffectsComposer(options);
    this._composerAndOptionsByCamera.set(options.camera, { composer, options });
    this._buildPasses(composer, options);
    return composer;
  }
  _updateComposers() {
    this._composerAndOptionsByCamera.forEach(({ composer, options }) => {
      this._buildPasses(composer, options);
    });
  }
  addPassByNodeInBuildPassesProcess(node, pass, composer) {
    this._passByNodeInBuildPassesProcess.set(node, pass);
    composer.addPass(pass);
  }
  // passByNodeInBuildPassesProcess(node: BaseNodeType) {
  // 	return this._passByNodeInBuildPassesProcess.get(node);
  // }
  _buildPasses(composer, options) {
    this._passByNodeInBuildPassesProcess.clear();
    composer.removeAllPasses();
    if (isBooleanTrue(this.node.pv.prependRenderPass)) {
      const renderPass = new RenderPass(options.scene, options.camera);
      composer.addPass(renderPass);
    }
    const postNode = this.node.displayNodeController.displayNode();
    if (postNode) {
      postNode.setupComposer({
        composerController: this,
        composer,
        camera: options.camera,
        renderer: options.renderer,
        // resolution: options.resolution,
        scene: options.scene,
        // requester: options.requester,
        viewer: options.viewer
      });
    } else {
      console.warn(`no displayNode found inside '${this.node.path()}'`);
    }
    this._passByNodeInBuildPassesProcess.clear();
  }
}
