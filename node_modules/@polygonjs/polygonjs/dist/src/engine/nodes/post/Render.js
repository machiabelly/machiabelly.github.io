"use strict";
import { TypedPostNode, PostParamOptions } from "./_Base";
import { RenderPass } from "postprocessing";
import { NodeParamsConfig, ParamConfig } from "../utils/params/ParamsConfig";
import { NodeContext } from "../../poly/NodeContext";
import { SceneObjNode } from "../obj/Scene";
import { isBooleanTrue } from "../../../core/BooleanValue";
class RenderPassWithContext extends RenderPass {
  constructor(scene, camera) {
    super(scene, camera);
    this.scene = scene;
    this.camera = camera;
    this.context = { scene, camera };
  }
}
class RenderPostParamsConfig extends NodeParamsConfig {
  constructor() {
    super(...arguments);
    /** @param overrideScene */
    this.overrideScene = ParamConfig.BOOLEAN(0, PostParamOptions);
    /** @param scene */
    this.scene = ParamConfig.NODE_PATH("", {
      visibleIf: { overrideScene: 1 },
      nodeSelection: {
        context: NodeContext.OBJ,
        types: [SceneObjNode.type()]
      },
      ...PostParamOptions
    });
    /** @param overrideCamera */
    this.overrideCamera = ParamConfig.BOOLEAN(0, PostParamOptions);
    /** @param camera */
    this.camera = ParamConfig.STRING("", {
      visibleIf: { overrideCamera: 1 },
      // nodeSelection: {
      // 	context: NodeContext.OBJ,
      // 	types: CAMERA_TYPES,
      // },
      // cook: false,
      // separatorBefore: true,
      objectMask: true,
      ...PostParamOptions
    });
  }
  // clear_color = ParamConfig.COLOR([0, 0, 0]);
  // clear_alpha = ParamConfig.FLOAT(0);
  // clear_depth = ParamConfig.BOOLEAN(0);
}
const ParamsConfig = new RenderPostParamsConfig();
export class RenderPostNode extends TypedPostNode {
  constructor() {
    super(...arguments);
    this.paramsConfig = ParamsConfig;
  }
  static type() {
    return "render";
  }
  createPass(context) {
    const pass = new RenderPass(context.scene, context.camera);
    pass.context = {
      camera: context.camera,
      scene: context.scene
    };
    this.updatePass(pass);
    return pass;
  }
  updatePass(pass) {
    this._updateCamera(pass);
    this._updateScene(pass);
  }
  async _updateCamera(pass) {
    if (isBooleanTrue(this.pv.overrideCamera)) {
      if (this.p.camera.isDirty()) {
        await this.p.camera.compute();
      }
      const path = this.pv.camera;
      const object = this.scene().objectsController.findObjectByMask(path);
      if (object) {
        pass.camera = object;
      }
    } else {
      pass.camera = pass.context.camera;
    }
  }
  async _updateScene(pass) {
    if (isBooleanTrue(this.pv.overrideScene)) {
      if (this.p.scene.isDirty()) {
        await this.p.scene.compute();
      }
      const objNode = this.pv.scene.nodeWithContext(NodeContext.OBJ);
      if (objNode) {
        if (objNode.type() == SceneObjNode.type()) {
          const scene = objNode.object;
          pass.scene = scene;
        }
      }
    } else {
      pass.scene = pass.context.scene;
    }
  }
}
