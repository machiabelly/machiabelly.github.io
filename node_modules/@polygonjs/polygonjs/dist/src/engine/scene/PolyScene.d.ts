import { ActorsManager } from './utils/ActorsManager';
import { SceneCamerasController } from './utils/SceneCamerasController';
import { Cooker } from './utils/Cooker';
import { SceneCookController } from './utils/CookController';
import { CoreGraph } from '../../core/graph/CoreGraph';
import { CorePerformance } from '../../core/performance/CorePerformance';
import { DispatchController } from './utils/DispatchController';
import { SceneExpressionsController } from './utils/SceneExpressionsController';
import { SceneLifeCycleController } from './utils/LifeCycleController';
import { LoadingController } from './utils/LoadingController';
import { MissingReferencesController } from './utils/missingReferences/MissingReferencesController';
import { GraphNodesController } from './utils/GraphNodesController';
import { NodesController } from './utils/NodesController';
import { SceneEventsDispatcher } from './utils/events/EventsDispatcher';
import { ObjectsController } from './utils/ObjectsController';
import { ScenePerformanceMonitor } from './utils/ScenePerformanceMonitor';
import { ReferencesController } from './utils/ReferencesController';
import { onTimeTickHook, TimeController, TimeControllerUpdateTimeOptions } from './utils/TimeController';
import { UniformsController } from './utils/UniformsController';
import { ViewersRegister } from './utils/ViewersRegister';
import { SceneWebGLController } from './utils/WebGLController';
import { WindowController } from './utils/WindowController';
import { SceneAssetsController } from './utils/AssetsController';
import { SceneTraverserController } from './utils/SceneTraverser';
import { BaseNodeType } from '../nodes/_Base';
import { ObjNodeChildrenMap } from '../poly/registers/nodes/Obj';
import { Constructor, valueof } from '../../types/GlobalTypes';
import { Raycaster, Scene, WebGLRenderer } from 'three';
import { SceneRenderersRegister, RegisterRendererOptions } from './utils/SceneRenderersRegister';
import { NodeCreateOptions } from '../nodes/utils/hierarchy/ChildrenController';
import { SceneWebXRController } from './utils/WebXREventsController';
import { CoreObjectType, ObjectContent } from '../../core/geometry/ObjectContent';
import { CoreParamSerializer } from '../params/utils/CoreParamSerializer';
import type { ParamType } from '../poly/ParamType';
interface PolySceneCreateOptions {
    root: NodeCreateOptions;
    paramsSerializerClass?: typeof CoreParamSerializer<ParamType>;
}
type SceneBatchUpdateCallback = () => void | Promise<void>;
interface UpdateState {
    scene: Scene;
}
/**
 *
 *
 * PolyScene contains all nodes within a scene.
 *
 */
export declare class PolyScene {
    /**
     * Returns the THREE.Scene.
     *
     * @remarks
     *
     * Read more about how to use a THREE.Scene on [THREE's documentation](https://threejs.org/docs/?q=scene#api/en/scenes/Scene)
     *
     */
    threejsScene(): Scene;
    private _uuid;
    setUuid(uuid: string): string;
    get uuid(): string;
    private _name;
    setName(newName: string): string;
    static sanitizeName(newName: string): string;
    name(): string | undefined;
    protected _camerasController: SceneCamerasController | undefined;
    get camerasController(): SceneCamerasController;
    /**
     * Returns the camera object that has been set as main
     *
     */
    mainCamera(): Promise<import("three").Camera | null>;
    private _cooker;
    get cooker(): Cooker;
    private _actorsManager;
    get actorsManager(): ActorsManager;
    private _assetsController;
    get assets(): SceneAssetsController;
    readonly cookController: SceneCookController;
    /**
     * Returns a promise to wait for all nodes to have cooked when loading a scene.
     *
     */
    waitForCooksCompleted(): Promise<void>;
    private _dispatchController;
    get dispatchController(): DispatchController;
    private _eventsDispatcher;
    get eventsDispatcher(): SceneEventsDispatcher;
    private _webXRController;
    get webXR(): SceneWebXRController;
    /**
     * When using Polygonjs viewers, a raycaster is created to use mouse events and detect if there are any object under the cursor.
     * But if no viewer is created, such as when [importing a scene in react three fiber](/docs/integrations/react_three_fiber),
     * It is then useful to give a raycaster.
     *
     */
    setRaycaster(raycaster: Raycaster): void;
    private _graph;
    get graph(): CoreGraph;
    readonly lifecycleController: SceneLifeCycleController;
    readonly loadingController: LoadingController;
    readonly missingExpressionReferencesController: MissingReferencesController;
    readonly expressionsController: SceneExpressionsController;
    readonly nodesController: NodesController;
    readonly graphNodesController: GraphNodesController;
    readonly renderersRegister: SceneRenderersRegister;
    /**
     * Creates a new node.
     *
     * nodeClass can be either a string or a node class. Both examples below work:
     *
     * - polyScene.createNode('box'): returns a BoxSopNode
     * - polyScene.createNode(boxSopNode): returns a BoxSopNode
     *
     */
    createNode<S extends keyof ObjNodeChildrenMap>(nodeClass: S, options?: NodeCreateOptions): ObjNodeChildrenMap[S];
    createNode<K extends valueof<ObjNodeChildrenMap>>(nodeClass: Constructor<K>, options?: NodeCreateOptions): K;
    /**
     * returns all nodes with a given type
     *
     * - polyScene.nodesByType('box'): returns all BoxSopNodes
     */
    nodesByType(type: string): BaseNodeType[];
    protected _objectsController: ObjectsController;
    get objectsController(): ObjectsController;
    /**
     * returns a THREE.Object3D whose name matches the mask
     *
     */
    findObjectByMask<T extends CoreObjectType>(mask: string): ObjectContent<T> | undefined;
    /**
     * returns a list THREE.Object3Ds whose names matche the mask
     *
     */
    objectsByMask<T extends CoreObjectType>(mask: string, parent?: ObjectContent<T>): ObjectContent<T>[];
    protected _referencesController: ReferencesController;
    get referencesController(): ReferencesController;
    protected _performance: CorePerformance | undefined;
    get performance(): CorePerformance;
    readonly perfMonitor: ScenePerformanceMonitor;
    protected _viewersRegister: ViewersRegister | undefined;
    get viewersRegister(): ViewersRegister;
    readonly sceneTraverser: SceneTraverserController;
    /**
     * updates Polygonjs scene internals. This is called automatically when using Polygonjs viewers,
     * but you would need to call it yourself in the render loop when adding your scene to threejs or react-three-fiber.
     * See [https://polygonjs.com/docs/integrations](https://polygonjs.com/docs/integrations)
     *
     */
    update(delta: number, state?: UpdateState): void;
    readonly timeController: TimeController;
    /**
     * sets the current frame
     *
     */
    setFrame(frame: number): void;
    setFrameToStart(): void;
    /**
     * returns the current frame
     *
     */
    frame(): number;
    /**
     * returns the current time
     *
     */
    time(): number;
    maxFrame(): number;
    /**
     * starts playing the scene
     *
     */
    play(): void;
    /**
     * pauses the scene
     *
     */
    pause(): void;
    /**
     * increments the time
     *
     */
    incrementTime(options?: TimeControllerUpdateTimeOptions): void;
    /**
     * increments the time if the scene is playing()
     *
     */
    incrementTimeIfPlaying(options?: TimeControllerUpdateTimeOptions): void;
    /**
     * registers a renderer
     *
     */
    registerRenderer(renderer: WebGLRenderer, options?: RegisterRendererOptions): void;
    private _uniformsController;
    get uniformsController(): UniformsController;
    private _webglController;
    get webglController(): SceneWebGLController;
    private _windowController;
    get windowController(): WindowController;
    constructor(options?: PolySceneCreateOptions);
    private _disposed;
    dispose(): void;
    disposed(): boolean;
    private _paramSerializerClass?;
    paramSerializerClass(): {
        new (param: import("../params/_Base").TypedParam<ParamType>): CoreParamSerializer<ParamType>;
    } | undefined;
    /**
     * batchUpdates can be useful to set multiple parameter values without triggering a recook for each update.
     *
     */
    batchUpdates(callback: SceneBatchUpdateCallback): Promise<void>;
    /**
     * returns a node based on its path
     *
     * - polyScene.node('/geo1')
     *
     */
    node(path: string): BaseNodeType | import("../nodes/manager/Root").RootManagerNode | null;
    /**
     * returns the root node
     *
     */
    root(): import("../nodes/manager/Root").RootManagerNode;
    /**
     * traverse all nodes and runs a callback for each
     *
     */
    traverseNodes(callback: (node: BaseNodeType) => void): void;
    /**
     * registers a BeforeTick callback. BeforeTick callbacks are run before updating the frame (and therefore before any time dependent node has changed)
     *
     */
    registerOnBeforeTick(callbackName: string, callback: onTimeTickHook): void;
    /**
     * unregisters BeforeTick callback
     *
     */
    unRegisterOnBeforeTick(callbackName: string): void;
    /**
     * Returns the list registered BeforeTick callback names
     *
     */
    registeredBeforeTickCallbacks(): Map<string, onTimeTickHook>;
    /**
     * return true if a callback is registered with that name
     *
     */
    hasBeforeTickCallback(callbackName: string): boolean;
    /**
     * registers AfterTick callback. AfterTick callbacks are run after updating the frame (and therefore after any time dependent node has changed)
     *
     */
    registerOnAfterTick(callbackName: string, callback: onTimeTickHook): void;
    /**
     * unregisters AfterTick callback
     *
     */
    unRegisterOnAfterTick(callbackName: string): void;
    /**
     * Returns the list registered AfterTick callback names
     *
     */
    registeredAfterTickCallbacks(): Map<string, onTimeTickHook>;
    /**
     * return true if a callback is registered with that name
     *
     */
    hasAfterTickCallback(callbackName: string): boolean;
}
export {};
