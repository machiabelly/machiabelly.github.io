import { PolyDictionary } from '../../../types/GlobalTypes';
import { PolyScene } from '../PolyScene';
import { RootManagerNode } from '../../nodes/manager/Root';
import { BaseNodeType } from '../../nodes/_Base';
import { NodeContext } from '../../poly/NodeContext';
import { NodeChildrenMapByContext } from '../../poly/registers/nodes/All';
import { CoreGraphNodeId } from '../../../core/graph/CoreGraph';
import { NodeCreateOptions } from '../../nodes/utils/hierarchy/ChildrenController';
type NodeByNodeId = Map<CoreGraphNodeId, BaseNodeType>;
type NodeMapByType<NC extends NodeContext> = Map<keyof NodeChildrenMapByContext[NC], NodeByNodeId>;
export declare class NodesController {
    private scene;
    constructor(scene: PolyScene);
    _root: RootManagerNode;
    _nodeContextSignatures: PolyDictionary<boolean>;
    _instanciatedNodesByContextAndType: Map<NodeContext, NodeMapByType<NodeContext>>;
    createRoot(options?: NodeCreateOptions): void;
    root(): RootManagerNode;
    private _traverseNode;
    traverseNodes(callback: (node: BaseNodeType) => void): void;
    clear(): void;
    node(path: string): BaseNodeType | RootManagerNode | null;
    allNodes(): BaseNodeType[];
    nodesFromMask(mask: string): BaseNodeType[];
    resetNodeContextSignatures(): void;
    registerNodeContextSignature(node: BaseNodeType): void;
    nodeContextSignatures(): string[];
    addToInstanciatedNode<NC extends NodeContext>(node: BaseNodeType): void;
    removeFromInstanciatedNode<NC extends NodeContext>(node: BaseNodeType): void;
    nodesByType(type: string): BaseNodeType[];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ANIM]>(context: NodeContext.ANIM, node_type: T): NodeChildrenMapByContext[NodeContext.ANIM][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.AUDIO]>(context: NodeContext.AUDIO, node_type: T): NodeChildrenMapByContext[NodeContext.AUDIO][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.COP]>(context: NodeContext.COP, node_type: T): NodeChildrenMapByContext[NodeContext.COP][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.EVENT]>(context: NodeContext.EVENT, node_type: T): NodeChildrenMapByContext[NodeContext.EVENT][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.GL]>(context: NodeContext.GL, node_type: T): NodeChildrenMapByContext[NodeContext.GL][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.JS]>(context: NodeContext.JS, node_type: T): NodeChildrenMapByContext[NodeContext.JS][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.MAT]>(context: NodeContext.MAT, node_type: T): NodeChildrenMapByContext[NodeContext.MAT][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.OBJ]>(context: NodeContext.OBJ, node_type: T): NodeChildrenMapByContext[NodeContext.OBJ][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.POST]>(context: NodeContext.POST, node_type: T): NodeChildrenMapByContext[NodeContext.POST][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.ROP]>(context: NodeContext.ROP, node_type: T): NodeChildrenMapByContext[NodeContext.ROP][T][];
    nodesByContextAndType<T extends keyof NodeChildrenMapByContext[NodeContext.SOP]>(context: NodeContext.SOP, node_type: T): NodeChildrenMapByContext[NodeContext.SOP][T][];
    hasNodesByContextAndType<NC extends NodeContext>(context: NC, nodeType: string): boolean;
}
export {};
