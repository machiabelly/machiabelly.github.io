"use strict";
import { ActorManualTriggersController } from "./actors/ManualTriggersController";
import { ActorKeyboardEventsController } from "./actors/ActorsKeyboardEventsController";
import { JsType } from "../../poly/registers/nodes/types/Js";
import { EVALUATOR_METHOD_NAMES } from "../../nodes/js/code/assemblers/actor/ActorEvaluator";
import { AssemblerControllerNode } from "../../nodes/js/code/Controller";
import { hierarchyTraverse } from "../../../core/geometry/util/HierarchyTraverse";
import { Poly } from "../../Poly";
import { RayObjectIntersectionsHoverController } from "./actors/rayObjectIntersection/RayObjectIntersectionsHoverController";
import { RayObjectIntersectionsPointerdownController } from "./actors/rayObjectIntersection/RayObjectIntersectionsPointerdownController";
import { RayObjectIntersectionsPointerupController } from "./actors/rayObjectIntersection/RayObjectIntersectionsPointerupController";
import { RayObjectIntersectionsClickController } from "./actors/rayObjectIntersection/RayObjectIntersectionsClickController";
import { RayObjectIntersectionsMouseClickController } from "./actors/rayObjectIntersection/RayObjectIntersectionsMouseClickController";
import { RayObjectIntersectionsContextmenuController } from "./actors/rayObjectIntersection/RayObjectIntersectionsContextmenuController";
import { RayObjectIntersectionsLongPressController } from "./actors/rayObjectIntersection/RayObjectIntersectionsLongPressController";
import { RayObjectIntersectionsSwipeController } from "./actors/rayObjectIntersection/RayObjectIntersectionsSwipeController";
import { PointerdownController } from "./actors/rayObjectIntersection/PointerdownController";
import { PointerupController } from "./actors/rayObjectIntersection/PointerupController";
const ACTOR_BUILDER_NODE_IDS_KEY = "actorBuilderNodeIds";
var EventHandlerType = /* @__PURE__ */ ((EventHandlerType2) => {
  EventHandlerType2["instant"] = "instant";
  EventHandlerType2["onTick"] = "onTick";
  return EventHandlerType2;
})(EventHandlerType || {});
const EVENT_MAP_LOGIC = {
  [JsType.ON_KEY]: "onTick" /* onTick */,
  [JsType.ON_KEYDOWN]: "onTick" /* onTick */,
  [JsType.ON_KEYPRESS]: "onTick" /* onTick */,
  [JsType.ON_KEYUP]: "onTick" /* onTick */,
  // [JsType.ON_MANUAL_TRIGGER]: EventHandlerType.instant,
  [JsType.ON_MAPBOX_CAMERA_MOVE]: "onTick" /* onTick */,
  [JsType.ON_MAPBOX_CAMERA_MOVE_START]: "onTick" /* onTick */,
  [JsType.ON_MAPBOX_CAMERA_MOVE_END]: "onTick" /* onTick */,
  [JsType.ON_OBJECT_ATTRIBUTE_UPDATE]: "onTick" /* onTick */,
  // ['onClick']: EventHandlerType.onTick,
  ["onContextMenu"]: "onTick" /* onTick */,
  [JsType.ON_OBJECT_DISPATCH_EVENT]: "instant" /* instant */,
  // TODO
  ["onPointermove"]: "onTick" /* onTick */,
  // [JsType.ON_OBJECT_POINTERDOWN]: EventHandlerType.onTick,
  // [JsType.ON_OBJECT_POINTERUP]: EventHandlerType.onTick,
  [JsType.ON_PERFORMANCE_CHANGE]: "instant" /* instant */,
  [JsType.ON_POINTERDOWN]: "onTick" /* onTick */,
  [JsType.ON_POINTERUP]: "onTick" /* onTick */,
  [JsType.ON_SCENE_PAUSE]: "instant" /* instant */,
  [JsType.ON_SCENE_PLAY]: "instant" /* instant */,
  [JsType.ON_SCENE_RESET]: "instant" /* instant */,
  [JsType.ON_TICK]: "onTick" /* onTick */,
  [JsType.ON_VIDEO_EVENT]: "onTick" /* onTick */,
  [JsType.ON_WEBXR_CONTROLLER_EVENT]: "onTick" /* onTick */
  // TODO
};
const ON_TICK_METHOD_NAMES = new Set(
  EVALUATOR_METHOD_NAMES.filter((methodName) => EVENT_MAP_LOGIC[methodName] == "onTick" /* onTick */)
);
const INSTANT_METHOD_NAMES = new Set(
  EVALUATOR_METHOD_NAMES.filter((methodName) => EVENT_MAP_LOGIC[methodName] == "instant" /* instant */)
);
if (0 + 0) {
  console.log({ ON_TICK_METHOD_NAMES, INSTANT_METHOD_NAMES });
}
export class ActorBuilderNode extends AssemblerControllerNode {
}
export class ActorsManager {
  constructor(scene) {
    this.scene = scene;
    this.rayObjectIntersectionClick = new RayObjectIntersectionsClickController(this);
    this.rayObjectIntersectionMouseClick = new RayObjectIntersectionsMouseClickController(this);
    this.rayObjectIntersectionContextmenu = new RayObjectIntersectionsContextmenuController(this);
    this.rayObjectIntersectionHover = new RayObjectIntersectionsHoverController(this);
    this.rayObjectIntersectionLongPress = new RayObjectIntersectionsLongPressController(this);
    this.rayObjectIntersectionPointerdown = new RayObjectIntersectionsPointerdownController(this);
    this.rayObjectIntersectionPointerup = new RayObjectIntersectionsPointerupController(this);
    this.rayObjectIntersectionSwipe = new RayObjectIntersectionsSwipeController(this);
    this.pointerdown = new PointerdownController(this);
    this.pointerup = new PointerupController(this);
    /*
     *
     * PRIVATE METHODS
     *
     */
    // tick
    this._onEventTickBound = this._onEventTick.bind(this);
    // reset
    this._onEventSceneResetBound = this._onEventSceneReset.bind(this);
    // play
    this._onEventScenePlayBound = this._onEventScenePlay.bind(this);
    // pause
    this._onEventScenePauseBound = this._onEventScenePause.bind(this);
    // performanceChange
    this._onEventPerformanceChangeBound = this._onEventPerformanceChange.bind(this);
  }
  registerEvaluatorGenerator(evaluatorGenerator) {
    this.scene.eventsDispatcher.registerEvaluatorGenerator(evaluatorGenerator);
  }
  unregisterEvaluatorGenerator(evaluatorGenerator) {
    this.scene.eventsDispatcher.unregisterEvaluatorGenerator(evaluatorGenerator);
  }
  assignActorBuilder(object, node) {
    let ids = this.objectActorNodeIds(object);
    if (!ids) {
      ids = [];
      object.userData[ACTOR_BUILDER_NODE_IDS_KEY] = ids;
    }
    const id = node.graphNodeId();
    if (!ids.includes(id)) {
      ids.push(id);
    }
    Poly.onObjectsAddRemoveHooks.assignOnRemoveHookHandler(object, node);
  }
  objectActorNodeIds(object) {
    return object.userData[ACTOR_BUILDER_NODE_IDS_KEY];
  }
  /*
   *
   * EVENTS
   *
   */
  get keyboardEventsController() {
    return this._keyboardEventsController = this._keyboardEventsController || new ActorKeyboardEventsController(this);
  }
  get manualTriggerController() {
    return this._manualTriggerController = this._manualTriggerController || new ActorManualTriggersController(this);
  }
  /*
   *
   * PUBLIC METHODS
   *
   */
  tick() {
    var _a;
    this.rayObjectIntersectionHover.process();
    (_a = this._keyboardEventsController) == null ? void 0 : _a.runTriggers();
    hierarchyTraverse(this.scene.threejsScene(), (object) => {
      this.triggerEventNodes(object, "onPointermove");
      this._onEventTickBound(object);
    });
  }
  runOnEventSceneReset() {
    this._onEventSceneResetTraverse();
  }
  runOnEventScenePlay() {
    this._onEventScenePlayTraverse();
  }
  runOnEventScenePause() {
    this._onEventScenePauseTraverse();
  }
  runOnEventPerformanceChange() {
    this._onEventPerformanceChangeTraverse();
  }
  _onEventTick(object) {
    this.triggerEventNodes(object, JsType.ON_TICK);
  }
  _onEventSceneReset(object) {
    this.triggerEventNodes(object, JsType.ON_SCENE_RESET);
  }
  _onEventSceneResetTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventSceneResetBound);
  }
  _onEventScenePlay(object) {
    this.triggerEventNodes(object, JsType.ON_SCENE_PLAY);
  }
  _onEventScenePlayTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventScenePlayBound);
  }
  _onEventScenePause(object) {
    this.triggerEventNodes(object, JsType.ON_SCENE_PAUSE);
  }
  _onEventScenePauseTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventScenePauseBound);
  }
  _onEventPerformanceChange(object) {
    this.triggerEventNodes(object, JsType.ON_PERFORMANCE_CHANGE);
  }
  _onEventPerformanceChangeTraverse() {
    hierarchyTraverse(this.scene.threejsScene(), this._onEventPerformanceChangeBound);
  }
  //
  triggerEventNodes(object, methodName) {
    const nodeIds = this.objectActorNodeIds(object);
    if (!nodeIds) {
      return;
    }
    for (const nodeId of nodeIds) {
      if (object.parent == null) {
        return;
      }
      const node = this.scene.graph.nodeFromId(nodeId);
      if (node) {
        this.triggerEventNode(node, object, methodName);
      }
    }
  }
  triggerEventNode(node, object, methodName) {
    const evaluatorGenerator = node.compilationController.evaluatorGenerator();
    this._triggerEvaluatorGenerator(evaluatorGenerator, object, methodName);
  }
  _triggerEvaluatorGenerator(evaluatorGenerator, object, methodName) {
    const evaluator = evaluatorGenerator.findOrCreateEvaluator(object);
    if (evaluator[methodName]) {
      evaluator[methodName]();
    }
  }
}
