"use strict";
import { BaseSceneEventsController } from "./_BaseEventsController";
import { Vector2 } from "three";
import { MouseEventType } from "../../../../core/event/MouseEventType";
import { ACCEPTED_POINTER_EVENT_TYPES, PointerEventType } from "../../../../core/event/PointerEventType";
import { TouchEventType } from "../../../../core/event/TouchEventType";
import { ref } from "../../../../core/reactivity/CoreReactivity";
import { CursorHelper } from "../../../nodes/event/utils/CursorHelper";
import { createRaycaster } from "../../../../core/RaycastHelper";
import { isTouchDevice } from "../../../../core/UserAgent";
export class PointerEventsController extends BaseSceneEventsController {
  constructor(dispatcher) {
    super(dispatcher);
    this._requireCanvasEventListeners = true;
    this._cursorHelper = new CursorHelper();
    // init to a large value so we don't get a fake intersect
    // if there was no interaction
    this._cursor0 = ref(new Vector2(-1e3, -1e3));
    // protected _camera: Camera | undefined;
    this._raycaster0 = ref(createRaycaster());
  }
  type() {
    return "pointer";
  }
  acceptedEventTypes() {
    return /* @__PURE__ */ new Set([...ACCEPTED_POINTER_EVENT_TYPES]);
  }
  setRaycaster(raycaster) {
    this._raycaster0.value = raycaster;
  }
  processEvent(eventContext) {
    this._cursorHelper.setCursorForCPU(eventContext, this._cursor0.value);
    super.processEvent(eventContext);
    const { viewer, event } = eventContext;
    if (!(event && viewer)) {
      console.log("either event or viewer missing");
      return;
    }
    viewer.raycastersController.setCursor0(this._cursor0.value);
    viewer.raycastersController.updateRaycasters();
    const eventType = event.type;
    if (eventType == PointerEventType.pointermove) {
      return;
    }
    const mapForEvent = this._actorEvaluatorsByEventNames.get(eventType);
    if (!mapForEvent) {
      return;
    }
    const eventEmitter = eventContext.emitter;
    if (!eventEmitter) {
      return;
    }
    const evaluatorGenerators = mapForEvent.get(eventEmitter);
    if (!evaluatorGenerators) {
      return;
    }
    if (eventContext.event) {
      const actorsManager = this.dispatcher.scene.actorsManager;
      switch (eventType) {
        case MouseEventType.mousedown: {
          actorsManager.rayObjectIntersectionMouseClick.onMousedown(eventContext.event);
          return;
        }
        case PointerEventType.pointerdown: {
          actorsManager.rayObjectIntersectionClick.onPointerdown(eventContext.event);
          actorsManager.rayObjectIntersectionLongPress.onPointerdown(eventContext.event);
          actorsManager.rayObjectIntersectionPointerdown.onPointerdown(eventContext.event);
          actorsManager.pointerdown.onPointerdown(eventContext.event);
          actorsManager.rayObjectIntersectionSwipe.onPointerdown(eventContext.event);
          return;
        }
        case PointerEventType.pointerup: {
          if (!isTouchDevice()) {
            actorsManager.rayObjectIntersectionPointerup.onPointerup(eventContext.event);
            actorsManager.pointerup.onPointerup(eventContext.event);
            return;
          }
        }
        case PointerEventType.contextmenu: {
          actorsManager.rayObjectIntersectionContextmenu.onContextmenu(eventContext.event);
          return;
        }
        case TouchEventType.touchend: {
          if (isTouchDevice()) {
            actorsManager.rayObjectIntersectionPointerup.onPointerup(eventContext.event);
            actorsManager.pointerup.onPointerup(eventContext.event);
            return;
          }
        }
      }
    }
  }
  raycaster() {
    return this._raycaster0;
  }
  cursor() {
    return this._cursor0;
  }
  // camera() {
  // 	return this._camera;
  // }
  updateRaycast(options) {
    const pointsParam = this._raycaster0.value.params.Points;
    if (pointsParam) {
      pointsParam.threshold = options.pointsThreshold;
    }
    const lineParam = this._raycaster0.value.params.Line;
    if (lineParam) {
      lineParam.threshold = options.lineThreshold;
    }
  }
}
