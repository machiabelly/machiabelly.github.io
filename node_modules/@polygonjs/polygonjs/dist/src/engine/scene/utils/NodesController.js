"use strict";
import { RootManagerNode, ROOT_NODE_NAME } from "../../nodes/manager/Root";
import { stringMatchMask } from "../../../core/String";
export class NodesController {
  constructor(scene) {
    this.scene = scene;
    this._nodeContextSignatures = {};
    this._instanciatedNodesByContextAndType = /* @__PURE__ */ new Map();
  }
  createRoot(options) {
    this._root = new RootManagerNode(this.scene, ROOT_NODE_NAME, options);
    this._root.initializeBaseAndNode();
    this._root.params.init();
  }
  root() {
    return this._root;
  }
  _traverseNode(parent, callback) {
    const nodes = parent.children();
    if (!nodes || nodes.length == 0) {
      return;
    }
    for (const node of nodes) {
      if (node.childrenController) {
        this._traverseNode(node, callback);
      }
      callback(node);
    }
  }
  traverseNodes(callback) {
    this._traverseNode(this._root, callback);
  }
  // objectsFromMask(mask: string): Object3D[] {
  // 	const masks = mask.split(' ');
  // 	const child_nodes = this.root.children() as BaseObjNodeType[];
  // 	const objects: Object3D[] = [];
  // 	for (let child_node of child_nodes) {
  // 		if (CoreString.matchesOneMask(child_node.name, masks)) {
  // 			if (child_node.object) {
  // 				objects.push(child_node.object);
  // 			}
  // 		}
  // 	}
  // 	return objects;
  // }
  clear() {
    var _a;
    const children = this.root().children();
    for (const child of children) {
      (_a = this.root().childrenController) == null ? void 0 : _a.removeNode(child);
    }
  }
  node(path) {
    if (path === "/") {
      return this.root();
    } else {
      return this.root().node(path);
    }
  }
  allNodes() {
    let nodes = [this.root()];
    let current_parents = [this.root()];
    let cmptr = 0;
    while (current_parents.length > 0 && cmptr < 10) {
      const children = current_parents.map((current_parent) => {
        if (current_parent.childrenAllowed()) {
          return current_parent.children();
        } else {
          return [];
        }
      }).flat();
      nodes = nodes.concat(children);
      current_parents = children;
      cmptr += 1;
    }
    return nodes.flat();
  }
  nodesFromMask(mask) {
    const nodes = this.allNodes();
    const matching_nodes = [];
    for (const node of nodes) {
      const path = node.path();
      if (stringMatchMask(path, mask)) {
        matching_nodes.push(node);
      }
    }
    return matching_nodes;
  }
  resetNodeContextSignatures() {
    this._nodeContextSignatures = {};
  }
  registerNodeContextSignature(node) {
    if (node.childrenAllowed() && node.childrenController) {
      this._nodeContextSignatures[node.childrenController.nodeContextSignature()] = true;
    }
  }
  nodeContextSignatures() {
    return Object.keys(this._nodeContextSignatures).sort().map((s) => s.toLowerCase());
  }
  addToInstanciatedNode(node) {
    const context = node.context();
    const nodeType = node.type();
    let mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (!mapForContext) {
      mapForContext = /* @__PURE__ */ new Map();
      this._instanciatedNodesByContextAndType.set(context, mapForContext);
    }
    let mapForType = mapForContext.get(nodeType);
    if (!mapForType) {
      mapForType = /* @__PURE__ */ new Map();
      mapForContext.set(nodeType, mapForType);
    }
    mapForType.set(node.graphNodeId(), node);
  }
  removeFromInstanciatedNode(node) {
    const context = node.context();
    const nodeType = node.type();
    const mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (!mapForContext) {
      return;
    }
    const mapForType = mapForContext.get(nodeType);
    if (!mapForType) {
      return;
    }
    mapForType.delete(node.graphNodeId());
  }
  nodesByType(type) {
    const list = [];
    this._traverseNode(this.scene.root(), (node) => {
      if (node.type() == type) {
        list.push(node);
      }
    });
    return list;
  }
  nodesByContextAndType(context, nodeType) {
    const nodes = [];
    const mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (mapForContext) {
      const mapForType = mapForContext.get(nodeType);
      if (mapForType) {
        mapForType.forEach((node) => {
          nodes.push(node);
        });
      }
    }
    return nodes;
  }
  hasNodesByContextAndType(context, nodeType) {
    const mapForContext = this._instanciatedNodesByContextAndType.get(context);
    if (!mapForContext) {
      return false;
    }
    const mapForType = mapForContext.get(nodeType);
    if (!mapForType) {
      return false;
    }
    return mapForType.size != 0;
  }
}
