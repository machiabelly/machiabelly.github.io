"use strict";
import { MissingReference } from "./MissingReference";
import { addToSetAtEntry, mapValuesToArray } from "../../../../core/MapUtils";
import { CoreWalker } from "../../../../core/Walker";
import { setToArray } from "../../../../core/SetUtils";
const _resolvedReferences = [];
const _missingReferences = [];
const _missingReferencesSet = [];
export class MissingReferencesController {
  constructor(scene) {
    this.scene = scene;
    this.references = /* @__PURE__ */ new Map();
    this._toIgnore = /* @__PURE__ */ new WeakMap();
  }
  register(param, path, jsepNode) {
    if (jsepNode && this._toIgnore.get(jsepNode) == true) {
      return;
    }
    const missingReference = new MissingReference(param, path);
    addToSetAtEntry(this.references, param.graphNodeId(), missingReference);
    return missingReference;
  }
  deregisterParam(param) {
    this.references.delete(param.graphNodeId());
  }
  registerToIgnore(jsepNode) {
    this._toIgnore.set(jsepNode, true);
  }
  //
  //
  // MISSING REFERENCES
  //
  //
  resolveMissingReferences() {
    _resolvedReferences.length = 0;
    this.references.forEach((references) => {
      references.forEach((reference) => {
        if (this._isReferenceResolvable(reference)) {
          _resolvedReferences.push(reference);
        }
      });
    });
    for (const reference of _resolvedReferences) {
      reference.resolveMissingDependencies();
    }
  }
  _isReferenceResolvable(reference) {
    const absolutePath = reference.absolutePath();
    if (absolutePath) {
      const node = this.scene.node(absolutePath);
      if (node) {
        return true;
      } else {
        const paths = CoreWalker.splitParentChild(absolutePath);
        if (paths.child) {
          const parentNode = this.scene.node(paths.parent);
          if (parentNode) {
            const param = parentNode.params.get(paths.child);
            if (param) {
              return true;
            }
          }
        }
      }
    }
  }
  // call this from node.create and node.rename
  checkForMissingNodeReferences(node) {
    if (!node.scene().loadingController.loaded()) {
      return;
    }
    this._checkForMissingReferencesForNode(node);
    for (const param of node.params.all) {
      this._checkForMissingReferencesForParam(param);
    }
  }
  // call this from spare params update
  checkForMissingParamReferences(param) {
    if (!param.scene().loadingController.loaded()) {
      return;
    }
    this._checkForMissingReferencesForParam(param);
  }
  _checkForMissingReferencesForNode(node) {
    const id = node.graphNodeId();
    mapValuesToArray(this.references, _missingReferencesSet);
    for (const missingReferenceSet of _missingReferencesSet) {
      let matchFound = false;
      setToArray(missingReferenceSet, _missingReferences);
      for (const ref of _missingReferences) {
        if (ref.matchesPath(node.path())) {
          matchFound = true;
          ref.resolveMissingDependencies();
        }
      }
      if (matchFound) {
        this.references.delete(id);
      }
    }
  }
  _checkForMissingReferencesForParam(param) {
    const id = param.graphNodeId();
    mapValuesToArray(this.references, _missingReferencesSet);
    for (const missingReferenceSet of _missingReferencesSet) {
      let matchFound = false;
      setToArray(missingReferenceSet, _missingReferences);
      for (const ref of _missingReferences) {
        if (ref.matchesPath(param.path())) {
          matchFound = true;
          ref.resolveMissingDependencies();
        }
      }
      if (matchFound) {
        this.references.delete(id);
      }
    }
  }
}
