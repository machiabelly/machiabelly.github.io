"use strict";
import { MapUtils } from "../../../core/MapUtils";
import { ParamType } from "../../poly/ParamType";
import { arrayShallowClone } from "../../../core/ArrayUtils";
import { NodePathParam } from "../../params/NodePath";
const _pathParams = [];
const _nodes = [];
export class ReferencesController {
  constructor(scene) {
    this.scene = scene;
    this._referenced_nodes_by_src_param_id = /* @__PURE__ */ new Map();
    this._referencing_params_by_referenced_node_id = /* @__PURE__ */ new Map();
    this._referencing_params_by_all_named_node_ids = /* @__PURE__ */ new Map();
  }
  setReferenceFromParam(src_param, referencedGraphNode) {
    this._referenced_nodes_by_src_param_id.set(src_param.graphNodeId(), referencedGraphNode);
    MapUtils.pushOnArrayAtEntry(
      this._referencing_params_by_referenced_node_id,
      referencedGraphNode.graphNodeId(),
      src_param
    );
  }
  setNamedNodesFromParam(src_param) {
    src_param.decomposedPath.namedNodes(_nodes);
    for (const namedNode of _nodes) {
      MapUtils.pushOnArrayAtEntry(
        this._referencing_params_by_all_named_node_ids,
        namedNode.graphNodeId(),
        src_param
      );
    }
  }
  resetReferenceFromParam(src_param) {
    const referenced_node = this._referenced_nodes_by_src_param_id.get(src_param.graphNodeId());
    if (referenced_node) {
      MapUtils.popFromArrayAtEntry(
        this._referencing_params_by_referenced_node_id,
        referenced_node.graphNodeId(),
        src_param
      );
      src_param.decomposedPath.namedNodes(_nodes);
      for (const namedNode of _nodes) {
        MapUtils.popFromArrayAtEntry(
          this._referencing_params_by_all_named_node_ids,
          namedNode.graphNodeId(),
          src_param
        );
      }
      this._referenced_nodes_by_src_param_id.delete(src_param.graphNodeId());
    }
  }
  referencing_params(node) {
    return this._referencing_params_by_referenced_node_id.get(node.graphNodeId());
  }
  referencingNodes(node, target) {
    const params = this._referencing_params_by_referenced_node_id.get(node.graphNodeId());
    target.length = 0;
    if (params) {
      const node_by_node_id = /* @__PURE__ */ new Map();
      for (const param of params) {
        const node2 = param.node;
        node_by_node_id.set(node2.graphNodeId(), node2);
      }
      node_by_node_id.forEach((node2) => {
        target.push(node2);
      });
    }
    return target;
  }
  nodesReferencedBy(node, target) {
    const path_param_types = /* @__PURE__ */ new Set([ParamType.NODE_PATH]);
    _pathParams.length = 0;
    for (const param of node.params.all) {
      if (path_param_types.has(param.type())) {
        _pathParams.push(param);
      }
    }
    const nodes_by_id = /* @__PURE__ */ new Map();
    const params = [];
    for (const pathParam of _pathParams) {
      this._check_param(pathParam, nodes_by_id, params);
    }
    for (const param of params) {
      nodes_by_id.set(param.node.graphNodeId(), param.node);
    }
    target.length = 0;
    nodes_by_id.forEach((node2) => {
      target.push(node2);
    });
    return target;
  }
  _check_param(param, nodes_by_id, params) {
    if (param instanceof NodePathParam) {
      const found_node = param.value.node();
      if (found_node) {
        nodes_by_id.set(found_node.graphNodeId(), found_node);
      }
      return;
    }
  }
  //
  //
  // TRACK NAME CHANGES
  //
  //
  notifyNameUpdated(node) {
    const referencingParams = this._referencing_params_by_all_named_node_ids.get(node.graphNodeId());
    if (referencingParams) {
      const referencingParamsCloned = arrayShallowClone(referencingParams);
      for (const referencingParam of referencingParamsCloned) {
        referencingParam.notifyPathRebuildRequired(node);
      }
    }
  }
  //
  //
  // TRACK NODE DELETIONS/ADDITIONS
  //
  //
  //
  //
  // TRACK PARAM DELETIONS/ADDITIONS
  //
  //
  notifyParamsUpdated(node) {
    const referencingParams = this._referencing_params_by_all_named_node_ids.get(node.graphNodeId());
    if (referencingParams) {
      const referencingParamsCloned = arrayShallowClone(referencingParams);
      for (const referencingParam of referencingParamsCloned) {
        if (referencingParam.options.isSelectingParam()) {
          referencingParam.notifyTargetParamOwnerParamsUpdated(node);
        }
      }
    }
  }
}
