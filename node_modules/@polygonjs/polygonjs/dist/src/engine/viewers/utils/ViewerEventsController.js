"use strict";
import { EVENT_EMITTERS } from "../../../core/event/CoreEventEmitter";
import { ACCEPTED_KEYBOARD_EVENT_TYPES } from "../../../core/event/KeyboardEventType";
import { allowCanvasKeyEventsListener } from "../../../core/event/CanvasKeyFocus";
import { getEventEmitter } from "../../../core/event/EventEmitter";
const DEBUG = false;
export class ViewerEventsController {
  constructor(viewer) {
    this.viewer = viewer;
    this._boundListenerMapByEventControllerType = /* @__PURE__ */ new Map();
  }
  updateEvents(eventsController) {
    if (DEBUG) {
      console.log("------------ updateEvents START:", eventsController);
    }
    const canvas = this.canvas();
    if (!canvas) {
      console.warn("no canvas found");
      return;
    }
    const controllerType = eventsController.type();
    let map = this._boundListenerMapByEventControllerType.get(controllerType);
    if (!map) {
      map = /* @__PURE__ */ new Map();
      this._boundListenerMapByEventControllerType.set(controllerType, map);
    }
    map.forEach((listenerWithData, eventType) => {
      for (let emitter of EVENT_EMITTERS) {
        const eventEmitter = getEventEmitter({ emitter, type: eventType }, canvas);
        eventEmitter.removeEventListener(eventType, listenerWithData.listener);
      }
    });
    map.clear();
    for (let eventData of eventsController.activeEventDatas()) {
      const eventEmitter = getEventEmitter(eventData, canvas);
      const eventType = eventData.type;
      const _processEvent = (event, controller) => {
        const eventContext = {
          viewer: this.viewer,
          event,
          emitter: eventData.emitter
          // camera: this.camera(),
        };
        controller.processEvent(eventContext);
      };
      const listener = (event) => {
        _processEvent(
          event,
          eventsController
          /*, canvas*/
        );
      };
      if (DEBUG) {
        console.log("- add event:", eventType, eventEmitter);
      }
      eventEmitter.addEventListener(eventType, listener, { passive: true });
      if (eventEmitter != document) {
        if (ACCEPTED_KEYBOARD_EVENT_TYPES.includes(eventData.type)) {
          allowCanvasKeyEventsListener(eventEmitter);
        }
      }
      map.set(eventData.type, { listener, data: eventData });
    }
    if (DEBUG) {
      console.log("------------ updateEvents DONE:");
    }
  }
  camera() {
    return this.viewer.camera();
  }
  canvas() {
    return this.viewer.canvas();
  }
  init() {
    if (!this.canvas()) {
      console.warn("no canvas found for eventsController");
      return;
    }
    this.viewer.scene().eventsDispatcher.traverseControllers((controller) => {
      this.updateEvents(controller);
    });
  }
  registeredEventTypes() {
    const list = [];
    this._boundListenerMapByEventControllerType.forEach((map) => {
      map.forEach((listener, eventType) => {
        list.push(eventType);
      });
    });
    return list;
  }
  dispose() {
    const canvas = this.canvas();
    this._boundListenerMapByEventControllerType.forEach((map) => {
      if (canvas) {
        map.forEach((listenerWithData, eventType) => {
          const eventOwner = getEventEmitter(listenerWithData.data, canvas);
          eventOwner.removeEventListener(eventType, listenerWithData.listener);
        });
      }
    });
  }
}
