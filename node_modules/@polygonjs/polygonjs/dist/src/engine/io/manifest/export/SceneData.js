"use strict";
import { SceneJsonExporter } from "../../json/export/Scene";
export class SceneDataManifestExporter {
  constructor(scene) {
    this.scene = scene;
    this._manifestContent = {
      properties: "",
      root: "",
      nodes: {},
      shaders: {},
      jsFunctionBodies: {}
    };
    this._data = {
      properties: {
        frame: 0,
        maxFrame: 100,
        maxFrameLocked: false,
        realtimeState: true,
        mainCameraNodePath: "/"
      },
      root: { type: "root" },
      nodes: {}
    };
  }
  async data() {
    const now = `${Date.now()}`;
    this._manifestContent = {
      properties: now,
      root: now,
      nodes: {},
      shaders: {},
      jsFunctionBodies: {}
    };
    const exporter = new SceneJsonExporter(this.scene);
    const sceneData = await exporter.data({ versions: { polygonjs: "ENGINE_VERSION" }, withPersistedConfig: true });
    this._data = {
      properties: sceneData.properties,
      root: { type: "root" },
      nodes: {}
    };
    const rootData = sceneData.root;
    if (rootData) {
      this._saveNodeData({
        nodeName: "root",
        nodeData: rootData,
        // parentFullPath: '',
        now
      });
    }
    const rootInNode = this._data.nodes["root"];
    if (rootInNode) {
      throw "root should not be in node";
    }
    return { sceneData: this._data, manifest: this._manifestContent };
  }
  _saveNodeData(options) {
    const { nodeName, nodeData, parentFullPath, now } = options;
    const nodeFullPath = parentFullPath ? `${parentFullPath}/${nodeName}` : nodeName;
    const manifestPath = parentFullPath ? nodeFullPath.substring(5) : nodeFullPath;
    const children = nodeData.nodes;
    if (!children) {
      return;
    }
    const childrenDataToWriteSeparately = [];
    const childrenNames = Object.keys(children);
    for (let childName of childrenNames) {
      const childData = children[childName];
      if (childData.nodes) {
        delete children[childName];
        childrenDataToWriteSeparately.push({
          childName,
          childData,
          nodeFullPath
        });
      }
    }
    if (parentFullPath) {
      this._manifestContent.nodes[manifestPath] = now;
      this._data.nodes[`${nodeFullPath}.json`] = nodeData;
    } else {
      this._data.root = nodeData;
    }
    for (let childDataContainer of childrenDataToWriteSeparately) {
      const { childName, childData, nodeFullPath: nodeFullPath2 } = childDataContainer;
      this._saveNodeData({
        nodeName: childName,
        nodeData: childData,
        parentFullPath: nodeFullPath2,
        now
      });
    }
  }
}
