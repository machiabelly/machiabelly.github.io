"use strict";
import { CoreFeaturesController } from "./../../../../core/FeaturesController";
import { PolyNodeController } from "./../../../nodes/utils/poly/PolyNodeController";
import { PolyScene } from "../../../scene/PolyScene";
import { JsonImportDispatcher } from "./Dispatcher";
import { ImportReport } from "./ImportReport";
import { TimeController } from "../../../scene/utils/TimeController";
import { ParamJsonImporter } from "./Param";
import { ROOT_NODE_NAME } from "../../../nodes/manager/Root";
export class SceneJsonImporter {
  constructor(_data, _options) {
    this._data = _data;
    this._options = _options;
    this.report = new ImportReport(this);
  }
  static async loadData(data, options) {
    const importer = new SceneJsonImporter(data, options);
    return await importer.scene(options == null ? void 0 : options.serializers);
  }
  setMigrateHelper(migrateHelper) {
    this._migrateHelper = migrateHelper;
  }
  migrateHelper() {
    return this._migrateHelper;
  }
  oldPolygonjsSceneVersion() {
    var _a;
    const properties = this._data["properties"];
    if (properties) {
      return (_a = properties.versions) == null ? void 0 : _a.polygonjs;
    }
  }
  scene(options) {
    if (this._migrateHelper) {
      this._data = this._migrateHelper.migrateData(this._data);
    }
    if (CoreFeaturesController.debugLoadProgress()) {
      console.log(`polygonjs version:${this.oldPolygonjsSceneVersion()}`);
    }
    const rootData = this._data["root"];
    const paramsInitValueOverrides = ParamJsonImporter.non_spare_params_data_value(rootData["params"]);
    const nodeCreateOptions = {
      paramsInitValueOverrides,
      nodeName: ROOT_NODE_NAME,
      serializerClass: options == null ? void 0 : options.nodeSerializerClass
    };
    const embeddedPolyNodes = this._data.embeddedPolyNodes;
    if (embeddedPolyNodes) {
      const keys = Object.keys(embeddedPolyNodes);
      for (let key of keys) {
        const elements = key.split("/");
        const nodeContext = elements[0];
        const nodeType = elements[1];
        const data = embeddedPolyNodes[key];
        PolyNodeController.createNodeClassAndRegister({
          node_context: nodeContext,
          node_type: nodeType,
          data
        });
      }
    }
    const scene = new PolyScene({ root: nodeCreateOptions, paramsSerializerClass: options == null ? void 0 : options.paramsSerializerClass });
    if (this._options) {
      if (this._options.sceneName) {
        scene.setName(this._options.sceneName);
      }
      if (this._options.measurePerformanceOnLoad == true) {
        scene.performance.start();
      }
    }
    scene.loadingController.markAsLoading();
    const properties = this._data["properties"];
    if (properties) {
      const maxFrame = properties["maxFrame"] || 600;
      scene.timeController.setMaxFrame(maxFrame);
      const maxFrameLocked = properties["maxFrameLocked"];
      if (maxFrameLocked) {
        scene.timeController.setMaxFrameLocked(maxFrameLocked);
      }
      const realtimeState = properties["realtimeState"];
      if (realtimeState != null) {
        scene.timeController.setRealtimeState(realtimeState);
      }
      scene.setFrame(properties["frame"] || TimeController.START_FRAME);
      const mainCameraPath = properties["mainCameraNodePath"] || properties["mainCameraPath"];
      if (mainCameraPath) {
        scene.camerasController.setMainCameraPath(mainCameraPath);
      }
    }
    scene.cooker.block();
    this._base_operations_composer_nodes_with_resolve_required = void 0;
    const dispatcher = new JsonImportDispatcher();
    const importer = dispatcher.dispatchNode(scene.root());
    if (rootData) {
      importer.process_data(this, rootData);
    }
    const uiData = this._data["ui"];
    if (uiData) {
      importer.process_ui_data(this, uiData);
    }
    this._resolve_operation_containers_with_path_param_resolve();
    if (this._options) {
      if (this._options.nodeCookWatcher) {
        this._options.nodeCookWatcher(scene);
      }
      if (this._options.configureScene) {
        this._options.configureScene(scene);
      }
    }
    scene.loadingController.markAsLoaded();
    scene.cooker.unblock();
    return scene;
  }
  shadersData() {
    return this._data["shaders"];
  }
  jsFunctionBodiesData() {
    return this._data["jsFunctionBodies"];
  }
  //
  //
  // OPERATION CONTAINER RESOLVE
  //
  //
  add_operations_composer_node_with_path_param_resolve_required(operations_composer_node) {
    if (!this._base_operations_composer_nodes_with_resolve_required) {
      this._base_operations_composer_nodes_with_resolve_required = [];
    }
    this._base_operations_composer_nodes_with_resolve_required.push(operations_composer_node);
  }
  _resolve_operation_containers_with_path_param_resolve() {
    if (!this._base_operations_composer_nodes_with_resolve_required) {
      return;
    }
    for (let operations_composer_node of this._base_operations_composer_nodes_with_resolve_required) {
      operations_composer_node.resolveOperationContainersPathParams();
    }
  }
}
