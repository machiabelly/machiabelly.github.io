"use strict";
import { Vector2 } from "three";
import { Poly } from "../../../Poly";
import { CoreType, isString } from "../../../../core/Type";
const COMPLEX_PARAM_DATA_KEYS = ["overriden_options", "type"];
export class NodeJsonImporter {
  constructor(_node, dispatcher, nodesImporter) {
    this._node = _node;
    this.dispatcher = dispatcher;
    this.nodesImporter = nodesImporter;
  }
  process_data(scene_importer, data) {
    if (this._node.sceneReadonly()) {
      scene_importer.report.markAsLoadedWithoutAssemblers();
    }
    this.set_connection_points(data["connection_points"]);
    if (this._node.childrenAllowed()) {
      this.create_nodes(scene_importer, data["nodes"], data);
    }
    if (this._node.io.inputs.overrideClonedStateAllowed()) {
      const override = data["cloned_state_overriden"];
      if (override) {
        this._node.io.inputs.overrideClonedState(override);
      }
    }
    this.set_flags(data);
    this.set_params(data);
    if (data.persisted_config) {
      const shadersData = scene_importer.shadersData();
      const jsFunctionBodiesData = scene_importer.jsFunctionBodiesData();
      if (shadersData) {
        let shaders = shadersData[this._node.path()];
        if (!shaders) {
          shaders = {};
        }
        data.persisted_config.shaders = shaders;
      }
      if (jsFunctionBodiesData) {
        const jsFunctionBodyData = jsFunctionBodiesData[this._node.path()];
        if (jsFunctionBodyData) {
          if (isString(jsFunctionBodyData)) {
            data.persisted_config.functionBody = jsFunctionBodyData;
          } else {
            data.persisted_config.functionBody = jsFunctionBodyData;
          }
        }
      }
      this.set_persisted_config(data.persisted_config);
    }
    this.setCustomData(data);
  }
  process_inputs_data(scene_importer, data) {
    const maxInputsCount = data.maxInputsCount;
    if (maxInputsCount != null) {
      const minCount = this._node.io.inputs.minCount();
      this._node.io.inputs.setCount(minCount, maxInputsCount);
    }
    try {
      this.setInputs(data["inputs"]);
    } catch (err) {
      const message = err.message || `failed connecting inputs of node ${data["type"]}`;
      scene_importer.report.addWarning(message);
      console.warn(data["inputs"]);
    }
  }
  process_ui_data(scene_importer, data) {
    if (!data) {
      return;
    }
    if (Poly.playerMode()) {
      return;
    }
    const ui_data = this._node.uiData;
    const pos = data["pos"];
    if (pos) {
      const vector = new Vector2().fromArray(pos);
      ui_data.setPosition(vector);
    }
    const comment = data["comment"];
    if (comment) {
      ui_data.setComment(comment);
    }
    const selection = data["selection"];
    if (selection) {
      this.set_selection(selection);
    }
    if (this._node.childrenAllowed()) {
      const nodesData = data["nodes"];
      if (nodesData) {
        this.processNodesUiData(scene_importer, nodesData);
      }
    }
  }
  create_nodes(scene_importer, data, nodeData) {
    if (!data) {
      return;
    }
    this.nodesImporter.process_data(scene_importer, data);
  }
  set_selection(data) {
    if (this._node.childrenAllowed() && this._node.childrenController) {
      if (data && data.length > 0) {
        const selected_nodes = [];
        data.forEach((node_name) => {
          const node = this._node.node(node_name);
          if (node) {
            selected_nodes.push(node);
          }
        });
        this._node.childrenController.selection.set(selected_nodes);
      }
    }
  }
  set_flags(data) {
    var _a, _b, _c, _d, _e, _f;
    const flags = data["flags"];
    if (flags) {
      const bypass = flags["bypass"];
      if (bypass != null) {
        (_b = (_a = this._node.flags) == null ? void 0 : _a.bypass) == null ? void 0 : _b.set(bypass);
      }
      const display = flags["display"];
      if (display != null) {
        (_d = (_c = this._node.flags) == null ? void 0 : _c.display) == null ? void 0 : _d.set(display);
      }
      const optimize = flags["optimize"];
      if (optimize != null) {
        (_f = (_e = this._node.flags) == null ? void 0 : _e.optimize) == null ? void 0 : _f.set(optimize);
      }
    }
  }
  set_connection_points(connection_points_data) {
    if (!connection_points_data) {
      return;
    }
    if (connection_points_data["in"]) {
      this._node.io.saved_connection_points_data.set_in(connection_points_data["in"]);
    }
    if (connection_points_data["out"]) {
      this._node.io.saved_connection_points_data.set_out(connection_points_data["out"]);
    }
    if (this._node.io.has_connection_points_controller) {
      this._node.io.connection_points.update_signature_if_required();
    }
  }
  setInputs(inputsData) {
    if (!inputsData) {
      return;
    }
    let inputData;
    for (let i = 0; i < inputsData.length; i++) {
      inputData = inputsData[i];
      if (inputData && this._node.parent()) {
        if (CoreType.isString(inputData)) {
          const inputNodeName = inputData;
          const inputNode = this._node.nodeSibling(inputNodeName);
          this._node.setInput(i, inputNode);
        } else {
          const inputNode = this._node.nodeSibling(inputData["node"]);
          let inputIndex = inputData["index"];
          const inputName = inputData["inputName"];
          let outputName = inputData["output"];
          if (inputName != null) {
            const connectionPoints = this._node.io.inputs.namedInputConnectionPoints();
            if (connectionPoints) {
              const connectionPointIndex = connectionPoints.map((point) => point == null ? void 0 : point.name().toLowerCase()).indexOf(inputName.toLowerCase());
              if (connectionPointIndex >= 0) {
                inputIndex = connectionPointIndex;
              }
            }
          }
          if (inputNode != null && outputName != null) {
            const connectionPoints = inputNode.io.outputs.namedOutputConnectionPoints();
            if (connectionPoints) {
              for (let connectionPoint of connectionPoints) {
                if (connectionPoint) {
                  if (connectionPoint.name().toLowerCase() == outputName.toLowerCase()) {
                    outputName = connectionPoint.name();
                  }
                }
              }
            }
          }
          if (inputIndex != null) {
            this._node.setInput(inputIndex, inputNode, outputName);
          }
        }
      }
    }
  }
  processNodesUiData(scene_importer, data) {
    if (!data) {
      return;
    }
    if (Poly.playerMode()) {
      return;
    }
    const node_names = Object.keys(data);
    for (let node_name of node_names) {
      const node = this._node.node(node_name);
      if (node) {
        const node_data = data[node_name];
        this.dispatcher.dispatchNode(node).process_ui_data(scene_importer, node_data);
      }
    }
  }
  //
  //
  // PARAMS
  //
  //
  set_params(nodeData) {
    const data = nodeData["params"];
    if (!data) {
      return;
    }
    const param_names = Object.keys(data);
    const params_update_options = {};
    for (let param_name of param_names) {
      const param_data = data[param_name];
      if (param_data != null) {
        const options = param_data["options"];
        let param_type = param_data["type"];
        const has_param = this._node.params.has_param(param_name);
        let has_param_and_same_type = false;
        let param;
        if (has_param) {
          param = this._node.params.get(param_name);
          if (param && param.type() == param_type || param_type == null) {
            has_param_and_same_type = true;
          }
        }
        if (has_param_and_same_type) {
          if (this._is_param_data_complex(param_data)) {
            this._process_param_data_complex(param_name, param_data);
          } else {
            this._process_param_data_simple(
              param_name,
              param_data
            );
          }
        } else {
          params_update_options.namesToDelete = params_update_options.namesToDelete || [];
          params_update_options.namesToDelete.push(param_name);
          params_update_options.toAdd = params_update_options.toAdd || [];
          params_update_options.toAdd.push({
            name: param_name,
            type: param_type,
            initValue: param_data["default_value"],
            rawInput: param_data["raw_input"],
            options
          });
        }
      }
    }
    const params_delete_required = params_update_options.namesToDelete && params_update_options.namesToDelete.length > 0;
    const params_add_required = params_update_options.toAdd && params_update_options.toAdd.length > 0;
    if (params_delete_required || params_add_required) {
      this._node.params.updateParams(params_update_options);
      for (let spare_param of this._node.params.spare) {
        const param_data = data[spare_param.name()];
        if (!spare_param.parentParam() && param_data) {
          if (this._is_param_data_complex(param_data)) {
            this._process_param_data_complex(spare_param.name(), param_data);
          } else {
            this._process_param_data_simple(
              spare_param.name(),
              param_data
            );
          }
        }
      }
    }
    this._node.params.runOnSceneLoadHooks();
  }
  _process_param_data_simple(param_name, param_data) {
    var _a;
    (_a = this._node.params.get(param_name)) == null ? void 0 : _a.set(param_data);
  }
  _process_param_data_complex(param_name, param_data) {
    const param = this._node.params.get(param_name);
    if (param) {
      this.dispatcher.dispatchParam(param).process_data(param_data);
    }
  }
  _is_param_data_complex(param_data) {
    if (CoreType.isString(param_data) || CoreType.isNumber(param_data) || CoreType.isArray(param_data) || CoreType.isBoolean(param_data)) {
      return false;
    }
    if (CoreType.isObject(param_data)) {
      const keys = Object.keys(param_data);
      for (let complex_key of COMPLEX_PARAM_DATA_KEYS) {
        if (keys.includes(complex_key)) {
          return true;
        }
      }
    }
    return false;
  }
  set_persisted_config(persisted_config_data) {
    if (this._node.persisted_config) {
      this._node.persisted_config.load(persisted_config_data);
    }
  }
  setCustomData(data) {
  }
}
