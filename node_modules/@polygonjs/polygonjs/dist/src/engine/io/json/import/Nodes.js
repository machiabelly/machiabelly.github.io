"use strict";
import { NodeContext } from "../../../poly/NodeContext";
import { ParamJsonImporter } from "./Param";
import { OptimizedNodesJsonImporter } from "./OptimizedNodes";
import { Poly } from "../../../Poly";
import { CoreString } from "../../../../core/String";
export class NodesJsonImporter {
  constructor(_node, dispatcher) {
    this._node = _node;
    this.dispatcher = dispatcher;
  }
  process_data(sceneImporter, data) {
    var _a;
    if (!data) {
      return;
    }
    if (!(this._node.childrenAllowed() && this._node.childrenController)) {
      return;
    }
    const { optimized_names, non_optimized_names } = OptimizedNodesJsonImporter.child_names_by_optimized_state(data);
    const nonOptimizedNodes = [];
    const migrateHelper = sceneImporter.migrateHelper();
    for (let nodeName of non_optimized_names) {
      const node_data = data[nodeName];
      const nodeType = migrateHelper ? migrateHelper.migrateNodeType(this._node, node_data) : node_data.type;
      migrateHelper == null ? void 0 : migrateHelper.migrateParams(this._node, node_data);
      const paramsInitValueOverrides = ParamJsonImporter.non_spare_params_data_value(node_data["params"]);
      const nodeCreateOptions = {
        paramsInitValueOverrides,
        nodeName
      };
      const loadNodeAttempt = (nodeType2, nodeCreateOptions2) => {
        try {
          const node2 = this._node.createNode(nodeType2, nodeCreateOptions2);
          if (node2) {
            return node2;
          }
        } catch (e) {
          console.error(`error importing node: cannot create with type ${nodeType2}`, e);
        }
      };
      let node = loadNodeAttempt(nodeType, nodeCreateOptions);
      if (!node) {
        const nodeTypeCamelCase = CoreString.camelCase(nodeType);
        node = loadNodeAttempt(nodeTypeCamelCase, nodeCreateOptions);
      }
      if (!node) {
        const nodeTypeWithNetwork = `${nodeType}Network`;
        node = loadNodeAttempt(nodeTypeWithNetwork, nodeCreateOptions);
      }
      if (node) {
        nonOptimizedNodes.push(node);
      } else {
        const message = `failed to create node with type '${nodeType}' (in '${this._node.path()}')`;
        sceneImporter.report.addWarning(message);
        Poly.warn(message);
      }
    }
    if (optimized_names.length > 0) {
      const optimized_nodes_importer = new OptimizedNodesJsonImporter(this._node);
      optimized_nodes_importer.process_data(sceneImporter, data);
      if (this._node.childrenController.context == NodeContext.SOP) {
        const nodeNames = Object.keys(data);
        let nodeNameWithDisplayFlag = void 0;
        for (let nodeName of nodeNames) {
          const nodeData = data[nodeName];
          if ((_a = nodeData.flags) == null ? void 0 : _a.display) {
            nodeNameWithDisplayFlag = nodeName;
          }
        }
        if (nodeNameWithDisplayFlag) {
          const existingNodeNames = nonOptimizedNodes.map((n) => n.name());
          const optimizedNodes = optimized_nodes_importer.nodes();
          for (let optimizedNode of optimizedNodes) {
            existingNodeNames.push(optimizedNode.name());
          }
          if (!existingNodeNames.includes(nodeNameWithDisplayFlag)) {
            const parentFullPath = this._node.path();
            const nodeFullPath = `${parentFullPath}/${nodeNameWithDisplayFlag}`;
            const message = `node '${nodeFullPath}' with display flag has been optimized and does not exist in player mode`;
            console.error(message);
          }
        }
      }
    }
    const importers_by_node_name = /* @__PURE__ */ new Map();
    for (let node of nonOptimizedNodes) {
      const child_data = data[node.name()];
      if (child_data) {
        const importer = this.dispatcher.dispatchNode(node);
        importers_by_node_name.set(node.name(), importer);
        importer.process_data(sceneImporter, data[node.name()]);
      } else {
        Poly.warn(`possible import error for node ${node.name()}`);
        Poly.log("available names are", Object.keys(data).sort(), data);
      }
    }
    for (let node of nonOptimizedNodes) {
      const importer = importers_by_node_name.get(node.name());
      if (importer) {
        importer.process_inputs_data(sceneImporter, data[node.name()]);
      }
    }
  }
}
