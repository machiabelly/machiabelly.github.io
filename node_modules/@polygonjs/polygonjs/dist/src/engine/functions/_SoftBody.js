"use strict";
import { Vector3 } from "three";
import { getSoftBodyControllerNodeFromSolverObject } from "../nodes/sop/TetSoftBodySolver";
import {
  ObjectNamedFunction0,
  ObjectNamedFunction2,
  ObjectNamedFunction1,
  ObjectNamedFunction3,
  NamedFunction5,
  ObjectNamedFunction4
} from "./_Base";
import {
  softBodySolverStepSimulation as _softBodySolverStepSimulation,
  softBodySetPosition as _softBodySetPosition,
  softBodyMultiplyVelocity as _softBodyMultiplyVelocity,
  softBodyConstraintCreate as _softBodyConstraintCreate,
  softBodyConstraintSetPosition as _softBodyConstraintSetPosition,
  softBodyConstraintDelete as _softBodyConstraintDelete
} from "../../core/softBody/SoftBodySolver";
const _v3 = new Vector3();
export class softBodySolverReset extends ObjectNamedFunction0 {
  static type() {
    return "softBodySolverReset";
  }
  func(object3D) {
    const softBodySolverNode = getSoftBodyControllerNodeFromSolverObject(object3D, this.scene);
    if (!softBodySolverNode) {
      return;
    }
    softBodySolverNode.setDirty();
  }
}
export class softBodySolverStepSimulation extends ObjectNamedFunction4 {
  static type() {
    return "softBodySolverStepSimulation";
  }
  func(object3D, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions) {
    _softBodySolverStepSimulation(object3D, stepsCount, edgeCompliance, volumeCompliance, preciseCollisions);
  }
}
export class computeVelocity extends NamedFunction5 {
  static type() {
    return "computeVelocity";
  }
  func(velocity, forces, dt, drag, target) {
    _v3.copy(forces).multiplyScalar(dt);
    target.copy(velocity).multiplyScalar(drag).add(_v3);
    return target;
  }
}
export class softBodySetPosition extends ObjectNamedFunction2 {
  static type() {
    return "softBodySetPosition";
  }
  func(object3D, position, lerp) {
    _softBodySetPosition(object3D, position, lerp);
  }
}
export class softBodyMultiplyVelocity extends ObjectNamedFunction1 {
  static type() {
    return "softBodyMultiplyVelocity";
  }
  func(object3D, mult) {
    _softBodyMultiplyVelocity(object3D, mult);
  }
}
export class softBodyConstraintCreate extends ObjectNamedFunction2 {
  static type() {
    return "softBodyConstraintCreate";
  }
  func(object3D, index, constraintIdRef) {
    const constraint = _softBodyConstraintCreate(object3D, index);
    if (constraint) {
      constraintIdRef.value = constraint.id;
    }
  }
}
export class softBodyConstraintSetPosition extends ObjectNamedFunction3 {
  static type() {
    return "softBodyConstraintSetPosition";
  }
  func(object3D, constraintId, position, lerp) {
    const delta = this.scene.timeController.delta();
    _softBodyConstraintSetPosition(object3D, constraintId, position, lerp, delta);
  }
}
export class softBodyConstraintDelete extends ObjectNamedFunction1 {
  static type() {
    return "softBodyConstraintDelete";
  }
  func(object3D, constraintId) {
    _softBodyConstraintDelete(object3D, constraintId);
  }
}
