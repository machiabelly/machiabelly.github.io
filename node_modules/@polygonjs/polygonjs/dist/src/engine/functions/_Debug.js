"use strict";
import { ObjectNamedFunction3 } from "./_Base";
import { Object3D } from "three";
import { isVector, isColor, isBoolean, isNumber, isString, isArray, isQuaternion } from "../../core/Type";
import { ref } from "../../core/reactivity/CoreReactivity";
const options = {
  object3D: new Object3D(),
  nodePath: "",
  message: "",
  value: 0
};
const _debugDataController = {
  lastProcessedFrameByNodePath: /* @__PURE__ */ new Map(),
  debugContentByFrameByNodePath: ref({})
  // arrayByNodePath: new Map(),
};
function _displayableValue(value) {
  try {
    if (isBoolean(value) || isString(value)) {
      return `${value}`;
    }
    if (isNumber(value)) {
      return `${value.toFixed(6)}`;
    }
    if (isColor(value)) {
      return value.toArray().map((e) => e.toFixed(4)).join(", ");
    }
    if (isVector(value) || isQuaternion(value)) {
      return value.toArray().map((e) => e.toFixed(4)).join(", ");
    }
    if (isArray(value)) {
      const firstElement = value[0];
      const firstElementAsString = _displayableValue(firstElement);
      return `[${firstElementAsString},...] (length: ${value.length})`;
    }
    return "value not displayabled, see dev console";
  } catch (err) {
    console.warn("error trying to display value:", value);
    return "";
  }
}
export function tableContent(debugLines) {
  const entries = debugLines.map((debugLine, i) => {
    return {
      objectName: debugLine.objectName,
      value: isVector(debugLine.value) || isColor(debugLine.value) ? debugLine.value.toArray() : debugLine.value
    };
  });
  return entries;
}
function logBlue(message) {
  console.log("%c" + message, "color:blue; font-weight:bold;");
}
function _flushDebugNode(nodePath, debugLines) {
  logBlue("------------");
  console.log(`${nodePath}:`);
  console.table(tableContent(debugLines));
  logBlue("------------");
}
function optionsToDebugLines(scene, options2, debugDataController) {
  const { object3D, nodePath, value } = options2;
  const displayableValue = _displayableValue(value);
  const objectName = object3D.name || "no name";
  const currentFrame = scene.frame();
  let currentValue = debugDataController.debugContentByFrameByNodePath.value[nodePath];
  if (!currentValue) {
    currentValue = [];
    debugDataController.debugContentByFrameByNodePath.value[nodePath] = currentValue;
  }
  currentValue.push({
    objectName,
    value,
    displayableValue
  });
  const lastProcessedFrame = debugDataController.lastProcessedFrameByNodePath.get(nodePath) || -1;
  if (!lastProcessedFrame) {
    debugDataController.lastProcessedFrameByNodePath.set(nodePath, lastProcessedFrame);
  }
  if (currentFrame != lastProcessedFrame) {
    _flushDebugNode(nodePath, currentValue);
    if (scene.dispatchController.emitAllowed()) {
      scene.dispatchController.actorEvaluatorDebug({ nodePath, debugLines: currentValue });
    }
    currentValue.length = 0;
    debugDataController.lastProcessedFrameByNodePath.set(nodePath, currentFrame);
  }
  return currentValue;
}
function _optionsToDebugLines(scene, options2) {
  return optionsToDebugLines(scene, options2, _debugDataController);
}
export class debug extends ObjectNamedFunction3 {
  static type() {
    return "debug";
  }
  func(object3D, nodePath, input, debugOptions) {
    const messageElements = [];
    if (debugOptions.displayFrame) {
      messageElements.push(`${this.scene.frame()}`);
    }
    if (debugOptions.displayTime) {
      messageElements.push(`${this.scene.time()}`);
    }
    if (debugOptions.message) {
      messageElements.push(debugOptions.message);
    }
    if (debugOptions.displayNodePath) {
      messageElements.push(nodePath);
    }
    const message = messageElements.join(" ");
    if (debugOptions.bundleByObject) {
      options.object3D = object3D;
      options.nodePath = nodePath;
      options.message = message;
      options.value = input;
      _optionsToDebugLines(this.scene, options);
    } else {
      if (debugOptions.displayValue) {
        messageElements.push(input);
      }
      console.log(...messageElements);
    }
    return input;
  }
}
