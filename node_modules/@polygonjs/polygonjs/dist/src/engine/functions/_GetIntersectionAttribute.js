"use strict";
import { Triangle, Color, Vector2, Vector3, Vector4 } from "three";
import { NamedFunction2, NamedFunction3, NamedFunction4 } from "./_Base";
import { corePointClassFactory } from "../../core/geometry/CoreObjectFactory";
const positionA = new Vector3();
const positionB = new Vector3();
const positionC = new Vector3();
const _ca = new Color();
const _cb = new Color();
const _cc = new Color();
const _v2a = new Vector2();
const _v2b = new Vector2();
const _v2c = new Vector2();
const _v3a = new Vector3();
const _v3b = new Vector3();
const _v3c = new Vector3();
const _v4a = new Vector4();
const _v4b = new Vector4();
const _v4c = new Vector4();
const _v3 = new Vector3();
const _tmpColorA = new Color();
const _tmpColorB = new Color();
const _tmpColorC = new Color();
function triangleGetInterpolatedNumber(point, p1, p2, p3, va, vb, vc) {
  Triangle.getBarycoord(point, p1, p2, p3, _v3);
  return va * _v3.x + vb * _v3.y + vc * _v3.z;
}
function triangleGetInterpolatedColor(point, p1, p2, p3, va, vb, vc, target) {
  Triangle.getBarycoord(point, p1, p2, p3, _v3);
  target.r = 0;
  target.g = 0;
  target.b = 0;
  _tmpColorA.copy(va).multiplyScalar(_v3.x);
  _tmpColorB.copy(vb).multiplyScalar(_v3.y);
  _tmpColorC.copy(vc).multiplyScalar(_v3.z);
  target.add(_tmpColorA).add(_tmpColorB).add(_tmpColorC);
  return target;
}
function triangleGetInterpolatedVector2(point, p1, p2, p3, va, vb, vc, target) {
  Triangle.getBarycoord(point, p1, p2, p3, _v3);
  target.set(0, 0);
  target.addScaledVector(va, _v3.x);
  target.addScaledVector(vb, _v3.y);
  target.addScaledVector(vc, _v3.z);
  return target;
}
function triangleGetInterpolatedVector3(point, p1, p2, p3, va, vb, vc, target) {
  Triangle.getBarycoord(point, p1, p2, p3, _v3);
  target.set(0, 0, 0);
  target.addScaledVector(va, _v3.x);
  target.addScaledVector(vb, _v3.y);
  target.addScaledVector(vc, _v3.z);
  return target;
}
function triangleGetInterpolatedVector4(point, p1, p2, p3, va, vb, vc, target) {
  Triangle.getBarycoord(point, p1, p2, p3, _v3);
  target.set(0, 0, 0, 0);
  target.addScaledVector(va, _v3.x);
  target.addScaledVector(vb, _v3.y);
  target.addScaledVector(vc, _v3.z);
  return target;
}
function nearestFaceVertexIndex(intersection, positionAttribute, face) {
  const intersectionPos = intersection.point;
  positionA.fromBufferAttribute(positionAttribute, face.a);
  positionB.fromBufferAttribute(positionAttribute, face.b);
  positionC.fromBufferAttribute(positionAttribute, face.c);
  const distanceA = positionA.distanceTo(intersectionPos);
  const distanceB = positionB.distanceTo(intersectionPos);
  const distanceC = positionC.distanceTo(intersectionPos);
  if (distanceA < distanceB && distanceA < distanceC) {
    return face.a;
  }
  if (distanceB < distanceA && distanceB < distanceC) {
    return face.b;
  }
  return face.c;
}
function nonInterpolatedVertexIndex(intersection) {
  if (!intersection) {
    return;
  }
  const geometry = intersection.object.geometry;
  if (!geometry) {
    return;
  }
  const positionAttribute = geometry.getAttribute("position");
  if (!positionAttribute) {
    return;
  }
  const face = intersection.face;
  if (!face) {
    return;
  }
  return nearestFaceVertexIndex(intersection, positionAttribute, face);
}
export class getIntersectionAttributeNumberNearest extends NamedFunction3 {
  static type() {
    return "getIntersectionAttributeNumberNearest";
  }
  func(intersection, attribName, notFoundValue) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const value = attribute.array[vertexIndex];
    return value;
  }
}
export class getIntersectionAttributeNumberInterpolated extends NamedFunction3 {
  static type() {
    return "getIntersectionAttributeNumberInterpolated";
  }
  func(intersection, attribName, notFoundValue) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    const va = attribute.array[face.a];
    const vb = attribute.array[face.b];
    const vc = attribute.array[face.c];
    return triangleGetInterpolatedNumber(intersectionPos, positionA, positionB, positionC, va, vb, vc);
  }
}
export class getIntersectionAttributeColorNearest extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeColorNearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
export class getIntersectionAttributeColorInterpolated extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeColorInterpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _ca.fromBufferAttribute(attribute, face.a);
    _cb.fromBufferAttribute(attribute, face.b);
    _cc.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedColor(intersectionPos, positionA, positionB, positionC, _ca, _cb, _cc, target);
  }
}
const notFoundValueStr = "";
export class getIntersectionAttributeStringNearest extends NamedFunction2 {
  static type() {
    return "getIntersectionAttributeStringNearest";
  }
  func(intersection, attribName) {
    if (!intersection) {
      return notFoundValueStr;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValueStr;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValueStr;
    }
    const corePointClass = corePointClassFactory(intersection.object);
    const result = corePointClass.stringAttribValue(intersection.object, vertexIndex, attribName);
    if (result == null) {
      return notFoundValueStr;
    }
    return result;
  }
}
export class getIntersectionAttributeVector2Nearest extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeVector2Nearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
export class getIntersectionAttributeVector2Interpolated extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeVector2Interpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _v2a.fromBufferAttribute(attribute, face.a);
    _v2b.fromBufferAttribute(attribute, face.b);
    _v2c.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedVector2(
      intersectionPos,
      positionA,
      positionB,
      positionC,
      _v2a,
      _v2b,
      _v2c,
      target
    );
  }
}
export class getIntersectionAttributeVector3Nearest extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeVector3Nearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
export class getIntersectionAttributeVector3Interpolated extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeVector3Interpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _v3a.fromBufferAttribute(attribute, face.a);
    _v3b.fromBufferAttribute(attribute, face.b);
    _v3c.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedVector3(
      intersectionPos,
      positionA,
      positionB,
      positionC,
      _v3a,
      _v3b,
      _v3c,
      target
    );
  }
}
export class getIntersectionAttributeVector4Nearest extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeVector4Nearest";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    return target.fromBufferAttribute(attribute, vertexIndex);
  }
}
export class getIntersectionAttributeVector4Interpolated extends NamedFunction4 {
  static type() {
    return "getIntersectionAttributeVector4Interpolated";
  }
  func(intersection, attribName, notFoundValue, target) {
    if (!intersection) {
      return notFoundValue;
    }
    const face = intersection.face;
    if (!face) {
      return notFoundValue;
    }
    const geometry = intersection.object.geometry;
    if (!geometry) {
      return notFoundValue;
    }
    const vertexIndex = nonInterpolatedVertexIndex(intersection);
    if (vertexIndex == null) {
      return notFoundValue;
    }
    const attribute = geometry.getAttribute(attribName);
    if (!attribute) {
      return notFoundValue;
    }
    const positionAttribute = geometry.getAttribute("position");
    if (!positionAttribute) {
      return notFoundValue;
    }
    const intersectionPos = intersection.point;
    positionA.fromBufferAttribute(positionAttribute, face.a);
    positionB.fromBufferAttribute(positionAttribute, face.b);
    positionC.fromBufferAttribute(positionAttribute, face.c);
    _v4a.fromBufferAttribute(attribute, face.a);
    _v4b.fromBufferAttribute(attribute, face.b);
    _v4c.fromBufferAttribute(attribute, face.c);
    return triangleGetInterpolatedVector4(
      intersectionPos,
      positionA,
      positionB,
      positionC,
      _v4a,
      _v4b,
      _v4c,
      target
    );
  }
}
