"use strict";
import { BaseOperation } from "../_Base";
import { BaseOperationContainer } from "./_Base";
import { NodeContext } from "../../../engine/poly/NodeContext";
export class BaseCopOperation extends BaseOperation {
  static context() {
    return NodeContext.COP;
  }
  cook(input_contents, params) {
  }
}
export class CopOperationContainer extends BaseOperationContainer {
  constructor(operation, name, init_params) {
    super(operation, name, init_params);
    this.operation = operation;
    this.name = name;
    this.init_params = init_params;
    // TODO: there may a better to overload add_input
    this._inputs = [];
    this._currentInputIndex = 0;
  }
  addInput(input) {
    super.setInput(this._currentInputIndex, input);
    this.incrementInputIndex();
  }
  incrementInputIndex() {
    this._currentInputIndex++;
  }
  currentInputIndex() {
    return this._currentInputIndex;
  }
  async compute(input_contents, operation_inputs_map) {
    const operation_input_contents = [];
    const node_inputs_map = operation_inputs_map.get(this);
    if (node_inputs_map) {
      node_inputs_map.forEach((node_input_index, operation_input_index) => {
        operation_input_contents[operation_input_index] = input_contents[node_input_index];
      });
    }
    for (let i = 0; i < this._inputs.length; i++) {
      const input_operation = this._inputs[i];
      const result = await input_operation.compute(input_contents, operation_inputs_map);
      if (result) {
        operation_input_contents[i] = result;
      }
    }
    return this.operation.cook(operation_input_contents, this.params);
  }
}
