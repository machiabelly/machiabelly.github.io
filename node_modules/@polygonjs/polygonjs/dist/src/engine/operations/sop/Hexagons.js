"use strict";
import { CoreGeometryOperationHexagon } from "./../../../core/geometry/operation/Hexagon";
import { BaseSopOperation } from "./_Base";
import { Vector2, Vector3, Quaternion, BoxGeometry, Box3 } from "three";
import { rotateGeometry } from "../../../core/Transform";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { ObjectType } from "../../../core/geometry/Constant";
const tmpBox = new Box3();
const tmpBoxPreRotation = new Box3();
const tmpSize = new Vector3();
const tmpCenter = new Vector3();
const DEFAULT_UP = new Vector3(0, 0, 1);
const q = new Quaternion();
export class HexagonsSopOperation extends BaseSopOperation {
  static type() {
    return "hexagons";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    if (coreGroup) {
      return this._cookWithInput(coreGroup, params);
    } else {
      return this._cookWithoutInput(params);
    }
  }
  _cookWithoutInput(params) {
    if (params.hexagonRadius > 0) {
      const geometry = this._createHexagons(params.size, params);
      rotateGeometry(geometry, DEFAULT_UP, params.direction);
      return this.createCoreGroupFromObjects([this._createHexagonsObjects(geometry, params)]);
    } else {
      return this.createCoreGroupFromObjects([]);
    }
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBoxPreRotation);
    tmpBoxPreRotation.getCenter(tmpCenter);
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    const boxGeometry = new BoxGeometry(tmpSize.x, tmpSize.y, tmpSize.z, 1, 1, 1);
    function _applyInputQuaternion(_q) {
      boxGeometry.applyQuaternion(_q);
      boxGeometry.computeBoundingBox();
    }
    function _setInputRotation() {
      q.setFromUnitVectors(DEFAULT_UP, params.direction);
      _applyInputQuaternion(q);
    }
    _setInputRotation();
    const bboxPostRotation = boxGeometry.boundingBox;
    bboxPostRotation.getSize(tmpSize);
    const size2d = new Vector2(tmpSize.x, tmpSize.y);
    const geometry = this._createHexagons(size2d, params);
    rotateGeometry(geometry, DEFAULT_UP, params.direction);
    geometry.translate(tmpCenter.x, tmpCenter.y, tmpCenter.z);
    const object = this._createHexagonsObjects(geometry, params);
    return this.createCoreGroupFromObjects([object]);
  }
  _createHexagonsObjects(geometry, params) {
    if (isBooleanTrue(params.pointsOnly)) {
      return this.createObject(geometry, ObjectType.POINTS);
    } else {
      return this.createObject(geometry, ObjectType.MESH);
    }
  }
  _createHexagons(size, params) {
    const operation = new CoreGeometryOperationHexagon(size, params.hexagonRadius, params.pointsOnly);
    const geometry = operation.process();
    return geometry;
  }
}
HexagonsSopOperation.DEFAULT_PARAMS = {
  size: new Vector2(1, 1),
  hexagonRadius: 0.1,
  direction: new Vector3(0, 1, 0),
  pointsOnly: false
};
HexagonsSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
