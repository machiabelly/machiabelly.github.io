"use strict";
import { LightUserDataRaymarching } from "./../../../core/lights/Common";
import { BaseSopOperation } from "./_Base";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { Group, PointLight } from "three";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { CorePointLightHelper, DEFAULT_POINT_LIGHT_PARAMS } from "../../../core/lights/PointLight";
import { ObjectType, registerObjectType } from "../../../core/geometry/Constant";
export class PointLightSopOperation extends BaseSopOperation {
  static type() {
    return "pointLight";
  }
  cook(input_contents, params) {
    const light = this.createLight();
    light.name = params.name;
    this.updateLightParams(light, params);
    this.updateShadowParams(light, params);
    if (isBooleanTrue(params.showHelper)) {
      const group = new Group();
      group.name = `PointLightGroup_${light.name}`;
      group.add(light);
      const helper = this._createHelper(light, params);
      if (helper) {
        group.add(helper);
        helper.name = `PointLightHelper_${light.name}`;
      }
      return this.createCoreGroupFromObjects([group]);
    } else {
      return this.createCoreGroupFromObjects([light]);
    }
  }
  _createHelper(light, params) {
    this._helper = this._helper || new CorePointLightHelper();
    return this._helper.createAndBuildObject({ helperSize: params.helperSize, light });
  }
  createLight() {
    var _a;
    registerObjectType({
      type: ObjectType.POINT_LIGHT,
      checkFunc: (obj) => {
        if (obj.isPointLight) {
          return ObjectType.POINT_LIGHT;
        }
      },
      ctor: PointLight,
      humanName: "PointLight"
    });
    const light = new PointLight();
    const nodeName = (_a = this._node) == null ? void 0 : _a.name();
    if (nodeName) {
      light.name = `PointLight_${nodeName}`;
    }
    light.matrixAutoUpdate = false;
    light.castShadow = true;
    light.shadow.bias = -1e-3;
    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;
    light.shadow.camera.near = 0.1;
    return light;
  }
  updateLightParams(light, params) {
    light.color = params.color;
    light.intensity = params.intensity;
    light.decay = params.decay;
    light.distance = params.distance;
    light.userData[LightUserDataRaymarching.PENUMBRA] = params.raymarchingPenumbra;
    light.userData[LightUserDataRaymarching.SHADOW_BIAS_ANGLE] = params.raymarchingShadowBiasAngle;
    light.userData[LightUserDataRaymarching.SHADOW_BIAS_DISTANCE] = params.raymarchingShadowBiasDistance;
  }
  updateShadowParams(light, params) {
    light.castShadow = isBooleanTrue(params.castShadow);
    light.shadow.autoUpdate = isBooleanTrue(params.shadowAutoUpdate);
    light.shadow.needsUpdate = light.shadow.autoUpdate || isBooleanTrue(params.shadowUpdateOnNextRender);
    light.shadow.mapSize.copy(params.shadowRes);
    light.shadow.camera.near = params.shadowNear;
    light.shadow.camera.far = params.shadowFar;
    light.shadow.bias = params.shadowBias;
    light.shadow.camera.updateProjectionMatrix();
  }
  // private __debugShadowMesh: Mesh<PlaneGeometry, MeshBasicMaterial> | undefined;
  // private _debugShadowMesh(light: PointLight) {
  // 	return (this.__debugShadowMesh = this.__debugShadowMesh || this._createDebugShadowMesh(light));
  // }
  // private _createDebugShadowMesh(light: PointLight) {
  // 	const material = new MeshBasicMaterial({
  // 		color: new Color(1, 1, 1),
  // 		map: light.shadow.map.texture,
  // 		side: DoubleSide,
  // 	});
  // 	const mesh = new Mesh(new PlaneGeometry(5, 5, 2, 2), material);
  // 	mesh.position.z = 1;
  // 	mesh.castShadow = false;
  // 	mesh.receiveShadow = false;
  // 	return mesh;
  // }
}
PointLightSopOperation.DEFAULT_PARAMS = DEFAULT_POINT_LIGHT_PARAMS;
PointLightSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
