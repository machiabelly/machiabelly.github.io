"use strict";
import { BaseSopOperation } from "./_Base";
import { Vector3, Box3 } from "three";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { BoxLineGeometry } from "three/examples/jsm/geometries/BoxLineGeometry";
import { ObjectType } from "../../../core/geometry/Constant";
const tmpBox = new Box3();
const tmpSize = new Vector3();
const tmpCenter = new Vector3();
const _BoxLinesSopOperation = class extends BaseSopOperation {
  static type() {
    return "boxLines";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const object = inputCoreGroup ? this._cookWithInput(inputCoreGroup, params) : this._cookWithoutInput(params);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _cookWithoutInput(params) {
    return _BoxLinesSopOperation.createLines(params);
  }
  _cookWithInput(coreGroup, params) {
    coreGroup.boundingBox(tmpBox);
    tmpBox.getSize(tmpSize);
    tmpBox.getCenter(tmpCenter);
    return _BoxLinesSopOperation.createLines({
      size: 1,
      sizes: tmpSize,
      divisions: params.divisions,
      center: tmpCenter
    });
  }
  static createLines(params) {
    const geometry = new BoxLineGeometry(
      params.sizes.x * params.size,
      params.sizes.y * params.size,
      params.sizes.z * params.size,
      Math.max(1, Math.floor(params.divisions.x)),
      Math.max(1, Math.floor(params.divisions.y)),
      Math.max(1, Math.floor(params.divisions.z))
    );
    geometry.translate(params.center.x, params.center.y, params.center.z);
    return this.createObject(geometry, ObjectType.LINE_SEGMENTS);
  }
};
export let BoxLinesSopOperation = _BoxLinesSopOperation;
BoxLinesSopOperation.DEFAULT_PARAMS = {
  size: 1,
  sizes: new Vector3(1, 1, 1),
  divisions: new Vector3(1, 1, 1),
  center: new Vector3(0, 0, 0)
};
BoxLinesSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
