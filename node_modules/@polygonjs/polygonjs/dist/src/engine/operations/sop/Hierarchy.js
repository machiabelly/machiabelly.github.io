"use strict";
import { BaseSopOperation } from "./_Base";
import { Group } from "three";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { TypeAssert } from "../../../engine/poly/Assert";
import { CorePath } from "../../../core/geometry/CorePath";
export var HierarchyMode = /* @__PURE__ */ ((HierarchyMode2) => {
  HierarchyMode2["ADD_PARENT"] = "add parent";
  HierarchyMode2["REMOVE_PARENT"] = "remove parent";
  HierarchyMode2["ADD_CHILD"] = "add child";
  return HierarchyMode2;
})(HierarchyMode || {});
export const HIERARCHY_MODES = [
  "add parent" /* ADD_PARENT */,
  "remove parent" /* REMOVE_PARENT */,
  "add child" /* ADD_CHILD */
];
export var AddChildMode = /* @__PURE__ */ ((AddChildMode2) => {
  AddChildMode2["ONE_CHILD_PER_PARENT"] = "one child per parent";
  AddChildMode2["ALL_CHILDREN_UNDER_FIRST_PARENT"] = "all children under first parent";
  AddChildMode2["ALL_CHILDREN_UNDER_ALL_PARENTS"] = "all children under all parents";
  return AddChildMode2;
})(AddChildMode || {});
export const ADD_CHILD_MODES = [
  "one child per parent" /* ONE_CHILD_PER_PARENT */,
  "all children under first parent" /* ALL_CHILDREN_UNDER_FIRST_PARENT */,
  "all children under all parents" /* ALL_CHILDREN_UNDER_ALL_PARENTS */
];
export class HierarchySopOperation extends BaseSopOperation {
  static type() {
    return "hierarchy";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const mode = HIERARCHY_MODES[params.mode];
    switch (mode) {
      case "add parent" /* ADD_PARENT */: {
        const objects = addParentToCoreGroup(coreGroup, inputCoreGroups[1], params);
        return this.createCoreGroupFromObjects(objects);
      }
      case "remove parent" /* REMOVE_PARENT */: {
        const objects = _removeParentFromCoreGroup(coreGroup, params);
        return this.createCoreGroupFromObjects(objects);
      }
      case "add child" /* ADD_CHILD */: {
        const objects = _addChildrenToCoreGroup(coreGroup, inputCoreGroups[1], params, this, this.states);
        return this.createCoreGroupFromObjects(objects);
      }
    }
    TypeAssert.unreachable(mode);
  }
}
HierarchySopOperation.DEFAULT_PARAMS = {
  mode: HIERARCHY_MODES.indexOf("add parent" /* ADD_PARENT */),
  levels: 1,
  objectMask: "",
  addChildMode: ADD_CHILD_MODES.indexOf("all children under first parent" /* ALL_CHILDREN_UNDER_FIRST_PARENT */)
};
HierarchySopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
function addParentToCoreGroup(coreGroup, parentCoreGroup, params) {
  function _addParentToObject(objects) {
    function _createNewParent() {
      const newParent2 = new Group();
      newParent2.matrixAutoUpdate = false;
      return newParent2;
    }
    let newParent;
    if (parentCoreGroup) {
      newParent = parentCoreGroup == null ? void 0 : parentCoreGroup.threejsObjects()[0];
    }
    newParent = newParent || _createNewParent();
    for (let object of objects) {
      newParent.add(object);
    }
    if (params.levels > 1) {
      let _addNewParent2 = function(object, params2) {
        const newParent2 = _createNewParent();
        newParent2.add(object);
        return newParent2;
      };
      var _addNewParent = _addNewParent2;
      for (let i = 1; i < params.levels; i++) {
        newParent = _addNewParent2(newParent, params);
      }
    }
    return newParent;
  }
  if (params.levels == 0) {
    return coreGroup.threejsObjects();
  } else {
    const newObject = _addParentToObject(coreGroup.threejsObjects());
    return [newObject];
  }
}
function _removeParentFromCoreGroup(coreGroup, params) {
  function _removeParentFromObject(object, params2) {
    function _getChildrenFromObjects(objects) {
      let object2;
      const children = [];
      while (object2 = objects.pop()) {
        if (object2.children) {
          for (let child of object2.children) {
            children.push(child);
          }
        }
      }
      return children;
    }
    let current_children = object.children;
    for (let i = 0; i < params2.levels - 1; i++) {
      current_children = _getChildrenFromObjects(current_children);
    }
    return current_children;
  }
  if (params.levels == 0) {
    return coreGroup.threejsObjects();
  } else {
    const newObjects = [];
    const threejsObjects = coreGroup.threejsObjects();
    for (let object of threejsObjects) {
      const newChildren = _removeParentFromObject(object, params);
      for (let newChild of newChildren) {
        newObjects.push(newChild);
      }
    }
    return newObjects;
  }
}
function _addChildrenToCoreGroup(coreGroup, childCoreGroup, params, operation, states) {
  const objects = coreGroup.threejsObjects();
  if (!childCoreGroup) {
    states == null ? void 0 : states.error.set("input 1 is invalid");
    return [];
  }
  function _findObjectsByMaskFromObjects(mask, objects2) {
    const list = [];
    for (let object of objects2) {
      CorePath.objectsByMaskInObject(mask, object, list);
    }
    return list;
  }
  function _getParentObjects() {
    const mask = params.objectMask.trim();
    const maskValid = mask != "";
    const parentObjects2 = maskValid ? _findObjectsByMaskFromObjects(mask, objects) : objects;
    return parentObjects2;
  }
  const parentObjects = _getParentObjects();
  const childObjects = childCoreGroup.threejsObjects();
  function _addOneChildPerParent() {
    for (let i = 0; i < parentObjects.length; i++) {
      const parentObject = parentObjects[i];
      const childObject = childObjects[i] || childObjects[0];
      if (!childObject) {
        states == null ? void 0 : states.error.set("no objects found in input 1");
        return [];
      }
      parentObject.add(childObject);
    }
    return objects;
  }
  function _addAllChildrenUnderFirstParent() {
    const parentObject = parentObjects[0];
    for (let childObject of childObjects) {
      parentObject.add(childObject);
    }
    return objects;
  }
  function _addAllChildrenUnderAllParents() {
    for (let parentObject of parentObjects) {
      for (let childObject of childObjects) {
        parentObject.add(childObject.clone());
      }
    }
    return objects;
  }
  const addChildMode = ADD_CHILD_MODES[params.addChildMode];
  switch (addChildMode) {
    case "one child per parent" /* ONE_CHILD_PER_PARENT */: {
      return _addOneChildPerParent();
    }
    case "all children under first parent" /* ALL_CHILDREN_UNDER_FIRST_PARENT */: {
      return _addAllChildrenUnderFirstParent();
    }
    case "all children under all parents" /* ALL_CHILDREN_UNDER_ALL_PARENTS */: {
      return _addAllChildrenUnderAllParents();
    }
  }
  TypeAssert.unreachable(addChildMode);
}
