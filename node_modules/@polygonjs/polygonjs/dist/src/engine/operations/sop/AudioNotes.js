"use strict";
import { BaseSopOperation } from "./_Base";
import { InputCloneMode } from "../../poly/InputCloneMode";
import { AttribClass, ATTRIBUTE_CLASSES } from "../../../core/geometry/Constant";
import { TypeAssert } from "../../poly/Assert";
import { NotesBuilder } from "../../../core/audio/NotesBuilder";
import { CoreAttribute } from "../../../core/geometry/Attribute";
import { isBooleanTrue } from "../../../core/Type";
import { pointsFromObject } from "../../../core/geometry/entities/point/CorePointUtils";
import { corePointClassFactory } from "../../../core/geometry/CoreObjectFactory";
var OutOfRangeBehavior = /* @__PURE__ */ ((OutOfRangeBehavior2) => {
  OutOfRangeBehavior2["RESTART"] = "restart";
  OutOfRangeBehavior2["BOUNCE"] = "bounce";
  return OutOfRangeBehavior2;
})(OutOfRangeBehavior || {});
export const OUT_OF_RANGE_BEHAVIOR = ["restart" /* RESTART */, "bounce" /* BOUNCE */];
const _points = [];
export class AudioNotesSopOperation extends BaseSopOperation {
  static type() {
    return "AudioNotes";
  }
  cook(inputCoreGroups, params) {
    const inputCoreGroup = inputCoreGroups[0];
    const attribClass = ATTRIBUTE_CLASSES[params.class];
    this._addAttribute(attribClass, inputCoreGroup, params);
    return inputCoreGroup;
  }
  async _addAttribute(attribClass, coreGroup, params) {
    var _a, _b;
    switch (attribClass) {
      case AttribClass.POINT:
        return this._addPointAttribute(coreGroup, params);
      case AttribClass.VERTEX: {
        (_a = this.states) == null ? void 0 : _a.error.set("vertex not supported yet");
        return;
      }
      case AttribClass.PRIMITIVE: {
        (_b = this.states) == null ? void 0 : _b.error.set("primitive not supported yet");
        return;
      }
      case AttribClass.OBJECT:
        return this._addObjectAttribute(coreGroup, params);
      case AttribClass.CORE_GROUP:
        return this._addCoreGroupAttribute(coreGroup, params);
    }
    TypeAssert.unreachable(attribClass);
  }
  _addPointAttribute(coreGroup, params) {
    const objects = coreGroup.allObjects();
    for (let object of objects) {
      pointsFromObject(object, _points);
      const corePointClass = corePointClassFactory(object);
      const values = this._values(_points, params);
      const notesIndexData = CoreAttribute.arrayToIndexedArrays(values.map((v) => v.note));
      corePointClass.setIndexedAttribute(object, params.name, notesIndexData.values, notesIndexData.indices);
      if (isBooleanTrue(params.toctave)) {
        const octavesArray = values.map((v) => v.octave);
        if (!corePointClass.hasAttribute(object, params.octaveName)) {
          corePointClass.addNumericAttribute(object, params.octaveName, 1, 1);
        }
        let i = 0;
        for (let corePoint of _points) {
          corePoint.setAttribValue(params.octaveName, octavesArray[i]);
          i++;
        }
      }
    }
  }
  _addObjectAttribute(coreGroup, params) {
    const coreObjects = coreGroup.allCoreObjects();
    const values = this._values(coreObjects, params);
    for (let i = 0; i < coreObjects.length; i++) {
      const coreObject = coreObjects[i];
      coreObject.addAttribute(params.name, values[i].note);
      if (isBooleanTrue(params.toctave)) {
        coreObject.addAttribute(params.octaveName, values[i].octave);
      }
    }
  }
  _addCoreGroupAttribute(coreGroup, params) {
    const values = this._values([coreGroup], params);
    coreGroup.addAttribute(params.name, values[0].note);
    if (isBooleanTrue(params.toctave)) {
      coreGroup.addAttribute(params.octaveName, values[0].octave);
    }
  }
  _values(entities, params) {
    let increment = 1;
    let i = 0;
    const behavior = OUT_OF_RANGE_BEHAVIOR[params.outOfRangeBehavior];
    const noteHolders = NotesBuilder.list(params.startOctave, params.endOctave);
    const values = [];
    for (let k = 0; k < entities.length; k++) {
      if (i >= noteHolders.length) {
        switch (behavior) {
          case "bounce" /* BOUNCE */: {
            increment = -1;
            i = noteHolders.length - 2;
            break;
          }
          case "restart" /* RESTART */: {
            i = 0;
            break;
          }
        }
      }
      if (behavior == "bounce" /* BOUNCE */) {
        if (i == 0 && increment < 0) {
          increment = 1;
          i = 1;
        }
      }
      const note = noteHolders[i];
      values.push(note);
      i += increment;
    }
    return values;
  }
}
AudioNotesSopOperation.DEFAULT_PARAMS = {
  class: ATTRIBUTE_CLASSES.indexOf(AttribClass.OBJECT),
  name: "note",
  toctave: false,
  octaveName: "octave",
  startOctave: 2,
  endOctave: 4,
  outOfRangeBehavior: OUT_OF_RANGE_BEHAVIOR.indexOf("bounce" /* BOUNCE */)
};
AudioNotesSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
