"use strict";
import { BaseSopOperation } from "./_Base";
import { Vector3, BufferAttribute, BufferGeometry } from "three";
import { ObjectType } from "../../../core/geometry/Constant";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { Attribute } from "../../../core/geometry/Attribute";
import { TypeAssert } from "../../poly/Assert";
const _geoCenter = new Vector3();
export var CenterMode = /* @__PURE__ */ ((CenterMode2) => {
  CenterMode2["OBJECT_ORIGIN"] = "object origin";
  CenterMode2["GEOMETRY_CENTER"] = "geometry center";
  return CenterMode2;
})(CenterMode || {});
export const CENTER_MODES = ["object origin" /* OBJECT_ORIGIN */, "geometry center" /* GEOMETRY_CENTER */];
export class CenterSopOperation extends BaseSopOperation {
  static type() {
    return "center";
  }
  cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const srcObjects = coreGroup.threejsObjectsWithGeo();
    const mode = CENTER_MODES[params.mode];
    const positions = new Array(srcObjects.length * 3);
    positions.fill(0);
    for (let i = 0; i < srcObjects.length; i++) {
      const srcObject = srcObjects[i];
      this._applyCenter(mode, srcObject, positions, i);
    }
    const geometry = new BufferGeometry();
    geometry.setAttribute(Attribute.POSITION, new BufferAttribute(new Float32Array(positions), 3));
    const object = this.createObject(geometry, ObjectType.POINTS);
    if (this._node) {
      object.name = this._node.name();
    }
    return this.createCoreGroupFromObjects([object]);
  }
  _applyCenter(mode, object, positions, i) {
    var _a;
    object.updateMatrixWorld();
    switch (mode) {
      case "object origin" /* OBJECT_ORIGIN */: {
        object.getWorldPosition(_geoCenter);
        _geoCenter.toArray(positions, i * 3);
        return;
      }
      case "geometry center" /* GEOMETRY_CENTER */: {
        const srcGeometry = object.geometry;
        srcGeometry.computeBoundingBox();
        if (srcGeometry.boundingBox) {
          (_a = srcGeometry.boundingBox) == null ? void 0 : _a.getCenter(_geoCenter);
          _geoCenter.applyMatrix4(object.matrixWorld);
          _geoCenter.toArray(positions, i * 3);
        }
        return;
      }
    }
    TypeAssert.unreachable(mode);
  }
}
CenterSopOperation.DEFAULT_PARAMS = {
  mode: CENTER_MODES.indexOf("object origin" /* OBJECT_ORIGIN */)
};
CenterSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
