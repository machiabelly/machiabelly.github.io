"use strict";
import { CoreAttribute } from "../../../../../core/geometry/Attribute";
import { AttribType } from "../../../../../core/geometry/Constant";
import { TypeAssert } from "../../../../poly/Assert";
import {
  verticesFromObject,
  verticesFromObjectFromGroup
} from "../../../../../core/geometry/entities/vertex/CoreVertexUtils";
import { coreVertexClassFactory } from "../../../../../core/geometry/CoreObjectFactory";
export function addVertexAttribute(attribType, coreGroup, params) {
  const objects = coreGroup.allObjects();
  switch (attribType) {
    case AttribType.NUMERIC: {
      for (let object of objects) {
        _addAttributeToVertices(object, params, false);
      }
      return;
    }
    case AttribType.STRING: {
      for (let object of objects) {
        _addAttributeToVertices(object, params, true);
      }
      return;
    }
  }
  TypeAssert.unreachable(attribType);
}
const _vertices = [];
function _addAttributeToVertices(object, params, isString) {
  const value = isString ? params.string : [params.value1, params.value2, params.value3, params.value4][params.size - 1];
  const attribName = CoreAttribute.remapName(params.name);
  const vertexClass = coreVertexClassFactory(object);
  let attribute = vertexClass.attribute(object, attribName);
  if (!attribute) {
    const verticesCount = vertexClass.entitiesCount(object);
    const values = new Array(verticesCount * params.size).fill(value);
    attribute = { array: values, itemSize: params.size, isString };
    vertexClass.addAttribute(object, attribName, attribute);
  }
  if (params.group) {
    verticesFromObjectFromGroup(object, params.group, _vertices);
    for (let vertex of _vertices) {
      vertex.setAttribValue(attribName, value);
    }
  } else {
    verticesFromObject(object, _vertices);
    for (let vertex of _vertices) {
      vertex.setAttribValue(attribName, value);
    }
  }
}
