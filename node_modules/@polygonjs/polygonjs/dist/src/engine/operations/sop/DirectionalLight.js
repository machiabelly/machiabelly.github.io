"use strict";
import { LightUserDataRaymarching } from "./../../../core/lights/Common";
import { BaseSopOperation } from "./_Base";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { isBooleanTrue } from "../../../core/BooleanValue";
import {
  DEFAULT_DIRECTIONAL_LIGHT_PARAMS,
  DirectionalLightContainer
} from "../../../core/lights/DirectionalLight";
export class DirectionalLightSopOperation extends BaseSopOperation {
  static type() {
    return "directionalLight";
  }
  cook(_, params) {
    const container = this.createLight(params);
    if (!container) {
      return this.createCoreGroupFromObjects([]);
    }
    container.light().name = params.name;
    this.updateLightParams(container, params);
    this.updateShadowParams(container, params);
    return this.createCoreGroupFromObjects([container]);
  }
  createLight(params) {
    var _a;
    const nodeName = (_a = this._node) == null ? void 0 : _a.name();
    const container = new DirectionalLightContainer({ showHelper: params.showHelper }, nodeName || "");
    const light = container.light();
    light.matrixAutoUpdate = false;
    light.castShadow = true;
    light.shadow.bias = -1e-3;
    light.shadow.mapSize.x = 1024;
    light.shadow.mapSize.y = 1024;
    light.shadow.camera.near = 0.1;
    return container;
  }
  updateLightParams(container, params) {
    const light = container.light();
    light.color = params.color;
    light.intensity = params.intensity;
    light.shadow.camera.far = params.distance;
    light.userData[LightUserDataRaymarching.PENUMBRA] = params.raymarchingPenumbra;
    light.userData[LightUserDataRaymarching.SHADOW_BIAS_ANGLE] = params.raymarchingShadowBiasAngle;
    light.userData[LightUserDataRaymarching.SHADOW_BIAS_DISTANCE] = params.raymarchingShadowBiasDistance;
  }
  updateShadowParams(container, params) {
    const light = container.light();
    light.shadow.autoUpdate = isBooleanTrue(params.shadowAutoUpdate);
    light.shadow.needsUpdate = isBooleanTrue(params.shadowUpdateOnNextRender);
    light.castShadow = isBooleanTrue(params.castShadow);
    light.shadow.mapSize.copy(params.shadowRes);
    light.shadow.bias = params.shadowBias;
    light.shadow.radius = params.shadowRadius;
    const shadowCamera = light.shadow.camera;
    const shadowSize = params.shadowSize;
    shadowCamera.left = -shadowSize.x * 0.5;
    shadowCamera.right = shadowSize.x * 0.5;
    shadowCamera.top = shadowSize.y * 0.5;
    shadowCamera.bottom = -shadowSize.y * 0.5;
    shadowCamera.updateProjectionMatrix();
    container.updateHelper();
  }
  // private __debugShadowMesh: Mesh<PlaneGeometry, MeshBasicMaterial> | undefined;
  // private _debugShadowMesh(light: DirectionalLight) {
  // 	return (this.__debugShadowMesh = this.__debugShadowMesh || this._createDebugShadowMesh(light));
  // }
  // private _createDebugShadowMesh(light: DirectionalLight) {
  // 	const material = new MeshBasicMaterial({
  // 		color: new Color(1, 1, 1),
  // 		map: light.shadow.map.texture,
  // 		side: DoubleSide,
  // 	});
  // 	const mesh = new Mesh(new PlaneGeometry(5, 5, 2, 2), material);
  // 	mesh.position.z = 1;
  // 	mesh.castShadow = false;
  // 	mesh.receiveShadow = false;
  // 	return mesh;
  // }
}
DirectionalLightSopOperation.DEFAULT_PARAMS = DEFAULT_DIRECTIONAL_LIGHT_PARAMS;
DirectionalLightSopOperation.INPUT_CLONED_STATE = InputCloneMode.NEVER;
