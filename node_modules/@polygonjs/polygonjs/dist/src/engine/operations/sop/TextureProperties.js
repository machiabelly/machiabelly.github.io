"use strict";
import { BaseSopOperation } from "./_Base";
import {
  NoColorSpace,
  UVMapping,
  RepeatWrapping
} from "three";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
import { MAG_FILTER_DEFAULT_VALUE, MIN_FILTER_DEFAULT_VALUE } from "../../../core/cop/Filter";
import { isBooleanTrue } from "../../../core/BooleanValue";
import { filterThreejsObjects } from "../../../core/geometry/Mask";
export class TexturePropertiesSopOperation extends BaseSopOperation {
  static type() {
    return "textureProperties";
  }
  async cook(inputCoreGroups, params) {
    const coreGroup = inputCoreGroups[0];
    const objects = filterThreejsObjects(coreGroup, params);
    const promises = objects.map((object) => this._updateObject(object, params));
    await Promise.all(promises);
    return coreGroup;
  }
  async _updateObject(object, params) {
    const material = object.material;
    if (!material) {
      return;
    }
    await this._updateMaterial(material, params);
  }
  async _updateMaterial(material, params) {
    let texture = material.map;
    if (texture) {
      await this._updateTexture(texture, params);
    }
  }
  async _updateTexture(texture, params) {
    this._updateColorSpace(texture, params);
    this._updateMapping(texture, params);
    this._updateWrap(texture, params);
    await this._updateAnisotropy(texture, params);
    this._updateFilter(texture, params);
  }
  _updateColorSpace(texture, pv) {
    if (!isBooleanTrue(pv.tcolorSpace)) {
      return;
    }
    texture.colorSpace = pv.colorSpace;
    texture.needsUpdate = true;
  }
  _updateMapping(texture, pv) {
    if (isBooleanTrue(pv.tmapping)) {
      texture.mapping = pv.mapping;
    }
  }
  _updateWrap(texture, pv) {
    if (isBooleanTrue(pv.twrap)) {
      texture.wrapS = pv.wrapS;
      texture.wrapT = pv.wrapT;
    }
  }
  async _updateAnisotropy(texture, params) {
    var _a;
    if (!isBooleanTrue(params.tanisotropy)) {
      return;
    }
    if (isBooleanTrue(params.useRendererMaxAnisotropy)) {
      const renderer = (_a = this._node) == null ? void 0 : _a.scene().renderersRegister.lastRegisteredRenderer();
      if (!renderer) {
        console.warn("no renderer found");
        return;
      }
      texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    } else {
      texture.anisotropy = params.anisotropy;
    }
  }
  _updateFilter(texture, params) {
    if (isBooleanTrue(params.tminFilter)) {
      texture.minFilter = params.minFilter;
    }
    if (isBooleanTrue(params.tmagFilter)) {
      texture.magFilter = params.magFilter;
    }
  }
}
TexturePropertiesSopOperation.DEFAULT_PARAMS = {
  group: "",
  // anisotropy
  tcolorSpace: false,
  colorSpace: NoColorSpace,
  // mapping
  tmapping: false,
  mapping: UVMapping,
  // wrap
  twrap: false,
  wrapS: RepeatWrapping,
  wrapT: RepeatWrapping,
  // anisotropy
  tanisotropy: false,
  useRendererMaxAnisotropy: false,
  anisotropy: 2,
  // filters
  tminFilter: false,
  minFilter: MIN_FILTER_DEFAULT_VALUE,
  tmagFilter: false,
  magFilter: MAG_FILTER_DEFAULT_VALUE
};
TexturePropertiesSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
