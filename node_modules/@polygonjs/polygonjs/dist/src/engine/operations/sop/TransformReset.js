"use strict";
import { BaseSopOperation } from "./_Base";
import { TypeAssert } from "../../poly/Assert";
import { Vector3 } from "three";
import { Matrix4 } from "three";
import { CoreTransform } from "../../../core/Transform";
import { InputCloneMode } from "../../../engine/poly/InputCloneMode";
export var TransformResetMode = /* @__PURE__ */ ((TransformResetMode2) => {
  TransformResetMode2["RESET_OBJECT"] = "reset objects transform";
  TransformResetMode2["CENTER_GEO"] = "center geometries";
  TransformResetMode2["CENTER_GEO_RESET_OBJECT"] = "center geometry and reset object";
  return TransformResetMode2;
})(TransformResetMode || {});
export const TRANSFORM_RESET_MODES = [
  "reset objects transform" /* RESET_OBJECT */,
  "center geometries" /* CENTER_GEO */,
  "center geometry and reset object" /* CENTER_GEO_RESET_OBJECT */
];
const bboxCenter = new Vector3();
const translateMatrix = new Matrix4();
const _TransformResetSopOperation = class extends BaseSopOperation {
  static type() {
    return "transformReset";
  }
  cook(inputCoreGroups, params) {
    const mode = TRANSFORM_RESET_MODES[params.mode];
    return this._selectMode(mode, inputCoreGroups);
  }
  _selectMode(mode, coreGroups) {
    switch (mode) {
      case "reset objects transform" /* RESET_OBJECT */: {
        return this._resetObjects(coreGroups[0]);
      }
      case "center geometries" /* CENTER_GEO */: {
        return _TransformResetSopOperation.centerCoreGroup(coreGroups[0], {
          applyMatrixToObject: false,
          refCoreGroup: coreGroups[1]
        });
      }
      case "center geometry and reset object" /* CENTER_GEO_RESET_OBJECT */: {
        return _TransformResetSopOperation.centerCoreGroup(coreGroups[0], {
          applyMatrixToObject: true,
          refCoreGroup: coreGroups[1]
        });
      }
    }
    TypeAssert.unreachable(mode);
  }
  _resetObjects(coreGroup) {
    const objects = coreGroup.threejsObjects();
    for (let object of objects) {
      object.matrix.identity();
      CoreTransform.decomposeMatrix(object);
    }
    return coreGroup;
  }
  static centerCoreGroup(coreGroup, options) {
    const objects = coreGroup.threejsObjects();
    let refObjects = objects;
    if (options.refCoreGroup) {
      refObjects = options.refCoreGroup.threejsObjectsWithGeo();
    }
    for (let i = 0; i < objects.length; i++) {
      const object = objects[i];
      const refObject = refObjects[i] || refObjects[refObjects.length - 1];
      _TransformResetSopOperation.centerObject(object, {
        applyMatrixToObject: options.applyMatrixToObject,
        refObject
      });
    }
    return coreGroup;
  }
  static centerObject(object, options) {
    const refObject = options.refObject || object;
    const geometry = object.geometry;
    const refGeometry = refObject.geometry;
    if (geometry && refGeometry) {
      refGeometry.computeBoundingBox();
      const bbox = refGeometry.boundingBox;
      if (bbox) {
        bbox.getCenter(bboxCenter);
        refObject.updateMatrixWorld();
        bboxCenter.applyMatrix4(refObject.matrixWorld);
        if (options.applyMatrixToObject) {
          translateMatrix.identity();
          translateMatrix.makeTranslation(bboxCenter.x, bboxCenter.y, bboxCenter.z);
          object.matrix.multiply(translateMatrix);
          CoreTransform.decomposeMatrix(object);
          object.updateWorldMatrix(false, false);
        }
        translateMatrix.identity();
        translateMatrix.makeTranslation(-bboxCenter.x, -bboxCenter.y, -bboxCenter.z);
        geometry.applyMatrix4(translateMatrix);
      }
    }
  }
};
export let TransformResetSopOperation = _TransformResetSopOperation;
TransformResetSopOperation.DEFAULT_PARAMS = {
  mode: 0
};
TransformResetSopOperation.INPUT_CLONED_STATE = InputCloneMode.FROM_NODE;
