(self["webpackChunk_polygonjs_polygonjs"] = self["webpackChunk_polygonjs_polygonjs"] || []).push([[113],{

/***/ 68168:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "N": () => (/* binding */ sanitizeUrl)
/* harmony export */ });
function sanitizeUrl(url) {
    return url.replace(/([^:]\/)\/+/g, '$1').replace(/^\/+/, '/');
}


/***/ }),

/***/ 22033:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "l": () => (/* reexport safe */ _io_manifest_import_SceneData__WEBPACK_IMPORTED_MODULE_0__.l)
/* harmony export */ });
/* harmony import */ var _io_manifest_import_SceneData__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(97581);




/***/ }),

/***/ 68535:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "q": () => (/* binding */ PolyEventsDispatcher)
/* harmony export */ });
/* harmony import */ var _poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28687);

class PolyEventsDispatcher {
    static dispatchProgressEvent(progress, sceneName) {
        const createEvent = (eventName) => {
            return new CustomEvent(eventName, {
                detail: {
                    progress,
                },
            });
        };
        document.dispatchEvent(createEvent(_poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_0__/* .PolyEventName.POLY_PROGRESS */ .X.POLY_PROGRESS));
        document.dispatchEvent(createEvent(`${_poly_utils_PolyEventName__WEBPACK_IMPORTED_MODULE_0__/* .PolyEventName.POLY_PROGRESS */ .X.POLY_PROGRESS}-${sceneName}`));
    }
}


/***/ }),

/***/ 50620:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ PROGRESS_RATIO)
/* harmony export */ });
const PROGRESS_RATIO = {
    sceneData: { start: 0, mult: 0.25 },
    assets: { start: 0.25, mult: 0.0 },
    nodes: { start: 0.25, mult: 0.75 },
};


/***/ }),

/***/ 97581:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {


// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "l": () => (/* binding */ SceneDataManifestImporter)
});

// EXTERNAL MODULE: ./src/core/UrlHelper.ts
var UrlHelper = __webpack_require__(68168);
// EXTERNAL MODULE: ./src/engine/io/common/EventsDispatcher.ts
var EventsDispatcher = __webpack_require__(68535);
// EXTERNAL MODULE: ./src/engine/io/common/Progress.ts
var Progress = __webpack_require__(50620);
;// CONCATENATED MODULE: ./src/engine/io/self_contained/Common.ts
var SelfContainedFileName;
(function (SelfContainedFileName) {
    SelfContainedFileName["EXPORT_MANIFEST"] = "scene/export_manifest.json";
    // SCENE_MANIFEST = 'scene/scene_manifest.json',
    SelfContainedFileName["CODE_PREFIX"] = "scene/code";
    SelfContainedFileName["PROPERTIES"] = "scene/code/properties.json";
    SelfContainedFileName["EDITOR"] = "scene/editor.json";
    SelfContainedFileName["ASSETS"] = "scene/assets.json";
    SelfContainedFileName["POLYGONJS"] = "js/all.js";
    SelfContainedFileName["SCENE_DATA_LOADER"] = "js/sceneDataLoader.js";
    SelfContainedFileName["POLY_CONFIG"] = "js/polyConfig.js";
    SelfContainedFileName["JS_FILES"] = "scene/js_files.json";
    SelfContainedFileName["POSTER"] = "images/poster.png";
})(SelfContainedFileName || (SelfContainedFileName = {}));

;// CONCATENATED MODULE: ./src/engine/io/manifest/import/SceneData.ts




function _shaderUrl(options) {
    const { urlPrefix, nodePath, shaderName, timestamp } = options;
    return `${urlPrefix}/root/${nodePath}.${shaderName}.glsl?t=${timestamp}`;
}
function _jsFunctionBodyUrl(options) {
    const { urlPrefix, nodePath, timestamp } = options;
    return `${urlPrefix}/root/${nodePath}.txt?t=${timestamp}`;
}
function _iterateShaders(manifest, callback) {
    const shaderNodePaths = Object.keys(manifest.shaders);
    for (let nodePath of shaderNodePaths) {
        const nodeShaders = manifest.shaders[nodePath];
        const nodeShaderNames = Object.keys(nodeShaders);
        for (let shaderName of nodeShaderNames) {
            const timestamp = nodeShaders[shaderName];
            callback({ nodePath, shaderName, timestamp });
        }
    }
}
function _iterateFunctionBodies(manifest, callback) {
    const nodePaths = Object.keys(manifest.jsFunctionBodies);
    for (let nodePath of nodePaths) {
        const timestamp = manifest.jsFunctionBodies[nodePath];
        callback({ nodePath, timestamp });
    }
}
class SceneDataManifestImporter {
    static async importSceneData(importData) {
        if (importData.editorMode == null) {
            importData.editorMode = false;
        }
        const manifest = importData.manifest;
        const urlPrefix = importData.urlPrefix || SelfContainedFileName.CODE_PREFIX;
        const nodePaths = Object.keys(manifest.nodes);
        const nodeUrls = [];
        for (let node_path of nodePaths) {
            const timestamp = manifest.nodes[node_path];
            const url = `${urlPrefix}/root/${node_path}.json?t=${timestamp}`;
            nodeUrls.push(url);
        }
        const root_url = `${urlPrefix}/root.json?t=${manifest.root}`;
        const properties_url = `${urlPrefix}/properties.json?t=${manifest.properties}`;
        const allUrls = [root_url, properties_url];
        // add editor urls if needed
        if (importData.editorMode) {
            const now = Date.now();
            allUrls.push(`${urlPrefix}/ui.json?t=${now}`);
            //all_urls.push(`${url_prefix}/editor.json?t=${now}`);
        }
        // add all nodes
        for (let nodeUrl of nodeUrls) {
            allUrls.push(nodeUrl);
        }
        // add all shaders
        const shaderUrls = [];
        _iterateShaders(manifest, (options) => {
            const shaderUrl = _shaderUrl({ urlPrefix, ...options });
            allUrls.push(shaderUrl);
            shaderUrls.push(shaderUrl);
        });
        // add all function bodies
        const jsFunctionBodiesUrls = [];
        _iterateFunctionBodies(manifest, (options) => {
            const jsFunctionBodyUrl = _jsFunctionBodyUrl({ urlPrefix, ...options });
            allUrls.push(jsFunctionBodyUrl);
            jsFunctionBodiesUrls.push(jsFunctionBodyUrl);
        });
        let count = 0;
        const jsonPayloadsCount = allUrls.length - (shaderUrls.length + jsFunctionBodiesUrls.length);
        const total = allUrls.length;
        function _incrementCount() {
            count++;
            const ratio = count / total;
            const progressRatio = Progress/* PROGRESS_RATIO.sceneData */.X.sceneData;
            const progress = progressRatio.start + progressRatio.mult * ratio;
            if (importData.onProgress) {
                importData.onProgress(progress);
            }
            EventsDispatcher/* PolyEventsDispatcher.dispatchProgressEvent */.q.dispatchProgressEvent(progress, importData.sceneName);
        }
        const sanitizedUrls = allUrls.map((url) => (0,UrlHelper/* sanitizeUrl */.N)(url));
        const promises = sanitizedUrls.map((url) => fetch(url));
        const responses = await Promise.all(promises);
        const jsonResponses = responses.slice(0, jsonPayloadsCount);
        const textResponses = responses.slice(jsonPayloadsCount);
        const results = await Promise.all([
            ...jsonResponses.map((response) => {
                _incrementCount();
                return response.json();
            }),
            ...textResponses.map((response) => {
                _incrementCount();
                return response.text();
            }),
        ]);
        const jsons = results.slice(0, jsonPayloadsCount);
        const texts = results.slice(jsonPayloadsCount);
        let textIndex = 0;
        const shadersData = {};
        _iterateShaders(manifest, (options) => {
            const text = texts[textIndex];
            const { nodePath, shaderName } = options;
            shadersData[nodePath] = shadersData[nodePath] || {};
            shadersData[nodePath][shaderName] = text;
            textIndex++;
        });
        const jsFunctionBodiesData = {};
        _iterateFunctionBodies(manifest, (options) => {
            const text = texts[textIndex];
            const { nodePath } = options;
            jsFunctionBodiesData[nodePath] = text;
            textIndex++;
        });
        const assembleData = {
            root: jsons[0],
            properties: jsons[1],
            shaders: shadersData,
            jsFunctionBodies: jsFunctionBodiesData,
        };
        let responseOffset = 2;
        if (importData.editorMode) {
            assembleData['ui'] = jsons[2];
            responseOffset += 1;
        }
        const jsonByName = {};
        const manifestNodes = Object.keys(manifest.nodes);
        for (let i = 0; i < manifestNodes.length; i++) {
            const manifestName = manifestNodes[i];
            const json = jsons[i + responseOffset];
            jsonByName[manifestName] = json;
        }
        return this.assemble(assembleData, manifestNodes, jsonByName);
    }
    static async assemble(assembleData, manifestNodes, jsonByName) {
        const sceneData = {
            root: assembleData.root,
            properties: assembleData.properties,
            ui: assembleData.ui,
            shaders: assembleData.shaders,
            jsFunctionBodies: assembleData.jsFunctionBodies,
        };
        for (let i = 0; i < manifestNodes.length; i++) {
            const manifestName = manifestNodes[i];
            const json = jsonByName[manifestName];
            this._insertChildData(sceneData.root, manifestName, json);
        }
        return sceneData;
    }
    static _insertChildData(data, path, json) {
        const elements = path.split('/');
        if (elements.length == 1) {
            if (!data.nodes) {
                data.nodes = {};
            }
            data.nodes[path] = json;
        }
        else {
            const parentName = elements.shift();
            const pathWithoutParent = elements.join('/');
            const parentData = data.nodes[parentName];
            this._insertChildData(parentData, pathWithoutParent, json);
        }
    }
}


/***/ }),

/***/ 28687:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "X": () => (/* binding */ PolyEventName)
/* harmony export */ });
var PolyEventName;
(function (PolyEventName) {
    PolyEventName["POLY_PROGRESS"] = "POLYProgress";
    // scene
    PolyEventName["SCENE_CREATED"] = "POLYSceneCreated";
    PolyEventName["SCENE_READY"] = "POLYSceneReady";
    PolyEventName["SCENE_PLAY"] = "POLYScenePlay";
    PolyEventName["SCENE_PAUSE"] = "POLYScenePause";
    // viewer
    PolyEventName["VIEWER_MOUNTED"] = "POLYViewerMounted";
    PolyEventName["VIEWER_READY"] = "POLYViewerReady";
})(PolyEventName || (PolyEventName = {}));


/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ var __webpack_exports__ = (__webpack_exec__(22033));
/******/ var __webpack_exports__SceneDataManifestImporter = __webpack_exports__.l;
/******/ export { __webpack_exports__SceneDataManifestImporter as SceneDataManifestImporter };
/******/ }
])
//# sourceMappingURL=sceneDataLoader.js.map